This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-05T03:05:30.093Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
CONVERSION_SUMMARY.md
eslint.config.js
GITNEXUS_README.md
index.html
package.json
project_guide.md
public/vite.svg
README.md
src/ai/cypher-generator.ts
src/ai/index.ts
src/ai/langchain-orchestrator.ts
src/ai/llm-service.ts
src/ai/orchestrator.ts
src/App.css
src/App.tsx
src/assets/react.svg
src/core/graph/types.ts
src/core/ingestion/call-processor.ts
src/core/ingestion/parsing-processor.ts
src/core/ingestion/pipeline.ts
src/core/ingestion/structure-processor.ts
src/core/tree-sitter/parser-loader.ts
src/index.css
src/lib/export.ts
src/lib/polyfills.ts
src/lib/preload.ts
src/lib/utils.ts
src/lib/workerUtils.ts
src/main.tsx
src/services/github.ts
src/services/ingestion.service.ts
src/services/zip.ts
src/ui/components/chat/ChatInterface.tsx
src/ui/components/chat/CodeAssistant.tsx
src/ui/components/chat/index.ts
src/ui/components/ErrorBoundary.tsx
src/ui/components/graph/GraphExplorer.tsx
src/ui/components/graph/index.ts
src/ui/components/graph/SourceViewer.tsx
src/ui/components/graph/Visualization.tsx
src/ui/components/index.ts
src/ui/index.ts
src/ui/pages/HomePage.tsx
src/ui/pages/index.ts
src/vite-env.d.ts
src/workers/ingestion.worker.ts
tsconfig.app.json
tsconfig.app.tsbuildinfo
tsconfig.json
tsconfig.node.json
tsconfig.node.tsbuildinfo
vite.config.ts

================================================================
Files
================================================================

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: CONVERSION_SUMMARY.md
================
# Deno to Node.js Conversion Summary

## Overview
Successfully converted the GitNexus repository from Deno to Node.js while maintaining all functionality.

## Changes Made

### 1. Configuration Files
- **Removed**: `deno.json`, `deno.lock`
- **Updated**: `package.json` with all dependencies from `deno.json`
  - Added all npm dependencies: jszip, axios, cytoscape, web-tree-sitter, langchain packages, etc.
  - Updated version to 1.0.0
  - Kept existing build scripts (Vite-based)

### 2. Import Statements
- **Removed**: All `npm:` prefixes from import statements
- **Removed**: All `@ts-expect-error` comments related to npm: imports
- **Files affected**: 13+ TypeScript files across the codebase

### 3. Dependencies Successfully Converted
- `react` & `react-dom` (already present)
- `jszip` for ZIP file processing
- `axios` for HTTP requests
- `cytoscape` & `cytoscape-dagre` for graph visualization
- `web-tree-sitter` for code parsing
- `comlink` for web workers
- `@langchain/*` packages for AI functionality
- `zod` for schema validation

### 4. Build System
- **Unchanged**: Vite configuration remains the same
- **Unchanged**: TypeScript configuration
- **Working**: Development server starts successfully on port 5173
- **Note**: Some TypeScript errors remain but don't prevent the dev server from running

## Current Status
‚úÖ **Development server running** - The application starts and runs on Node.js
‚úÖ **All dependencies installed** - npm install completed successfully  
‚úÖ **Import statements fixed** - All Deno-style imports converted to Node.js style
‚ö†Ô∏è **TypeScript errors** - Some type errors remain but don't block functionality

## Next Steps (Optional)
The conversion is complete and functional, but to achieve a clean build:
1. Fix TypeScript errors in langchain imports
2. Update type definitions for cytoscape
3. Fix unused variable warnings
4. Address JSZip type compatibility issues

## Files Modified
- `package.json` - Added all dependencies
- 13+ TypeScript files - Removed npm: prefixes and Deno comments
- Removed `deno.json` and `deno.lock`

The repository is now fully converted to Node.js and ready for development!

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: GITNEXUS_README.md
================
# üîç CodeNexus - Edge Knowledge Graph Creator with Graph RAG

**Transform any codebase into an interactive knowledge graph in your browser. No servers, no setup - just instant Graph RAG-powered code intelligence.**

CodeNexus is a client-side knowledge graph creator that runs entirely in your browser. Drop in a GitHub repo or ZIP file, and get an interactive knowledge graph with AI-powered chat interface. Perfect for code exploration, documentation, and understanding complex codebases through Graph RAG (Retrieval-Augmented Generation).

## ‚ú® Features

### üìä **Code Analysis & Visualization**
- **GitHub Integration**: Analyze any public GitHub repository directly from URL
- **ZIP File Support**: Upload and analyze local code archives
- **Interactive Knowledge Graph**: Visualize code structure with Cytoscape.js
- **Multi-language Support**: Currently optimized for Python with extensible architecture
- **Smart Filtering**: Directory and file pattern filters to focus analysis scope
- **Performance Optimization**: Configurable file limits with confirmation dialogs for large repositories

### ü§ñ **AI-Powered Chat Interface**
- **Multiple LLM Providers**: OpenAI, Anthropic (Claude), Google Gemini
- **ReAct Agent Pattern**: Uses proper LangChain ReAct implementation for reasoning
- **Tool-Augmented Responses**: Graph queries, code retrieval, file search
- **Context-Aware**: Maintains conversation history with configurable memory

### üîß **Advanced Processing Pipeline**
- **3-Pass Ingestion Strategy**:
  1. **Structure Analysis**: Project hierarchy and file organization
  2. **Code Parsing**: AST-based extraction using Tree-sitter
  3. **Call Resolution**: Function/method call relationship mapping
- **Web Worker Processing**: Non-blocking UI with progress tracking
- **Intelligent Caching**: AST and processing result optimization
- **Error Resilience**: Comprehensive error boundaries and recovery mechanisms

### üé® **Modern UI/UX**
- **Responsive Design**: Adaptive layout for different screen sizes
- **Real-time Progress**: Live updates during repository processing
- **Interactive Graph**: Node selection, zooming, panning
- **Split-Panel Layout**: Graph visualization + AI chat interface
- **Settings Management**: Persistent configuration for API keys and preferences
- **Export Functionality**: Download knowledge graphs as JSON with metadata
- **Performance Controls**: File limits, filtering, and optimization settings

### üõ°Ô∏è **Reliability & Performance**
- **Error Boundaries**: Graceful error handling with user-friendly recovery options
- **Performance Monitoring**: Real-time processing statistics and export size calculation
- **Memory Management**: Efficient handling of large repositories with configurable limits
- **Progress Tracking**: Detailed progress indicators with phase-specific messaging
- **Confirmation Dialogs**: Smart warnings for potentially expensive operations

## üèóÔ∏è Architecture

### **Frontend Stack**
- **React 18** with TypeScript
- **Vite** for fast development and building
- **Cytoscape.js** for graph visualization
- **Custom CSS** with modern design patterns
- **Error Boundaries** for robust error handling

### **Processing Engine**
- **Deno Runtime** for TypeScript execution
- **Tree-sitter WASM** for syntax parsing
- **Web Workers** for background processing
- **Comlink** for worker communication

### **AI Integration**
- **LangChain.js** with proper ReAct agent implementation
- **Multiple LLM Support**: OpenAI, Anthropic, Gemini
- **Tool-based Architecture**: Graph queries, code retrieval, file search
- **Cypher Query Generation**: Natural language to graph queries

### **Services Layer**
```
src/
‚îú‚îÄ‚îÄ services/           # External API integrations
‚îÇ   ‚îú‚îÄ‚îÄ github.ts      # GitHub REST API client
‚îÇ   ‚îî‚îÄ‚îÄ zip.ts         # ZIP file processing
‚îú‚îÄ‚îÄ core/              # Core processing logic
‚îÇ   ‚îú‚îÄ‚îÄ graph/         # Knowledge graph types
‚îÇ   ‚îú‚îÄ‚îÄ ingestion/     # 3-pass processing pipeline
‚îÇ   ‚îî‚îÄ‚îÄ tree-sitter/   # Syntax parsing infrastructure
‚îú‚îÄ‚îÄ ai/                # AI and RAG components
‚îÇ   ‚îú‚îÄ‚îÄ llm-service.ts # Multi-provider LLM client
‚îÇ   ‚îú‚îÄ‚îÄ cypher-generator.ts # NL to Cypher translation
‚îÇ   ‚îú‚îÄ‚îÄ orchestrator.ts     # Custom ReAct implementation
‚îÇ   ‚îî‚îÄ‚îÄ langchain-orchestrator.ts # Standard LangChain ReAct
‚îú‚îÄ‚îÄ workers/           # Web Worker implementations
‚îú‚îÄ‚îÄ ui/                # React components and pages
‚îÇ   ‚îú‚îÄ‚îÄ components/    # Reusable UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorBoundary.tsx # Error handling component
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ graph/     # Graph visualization components
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chat/      # Chat interface components
‚îÇ   ‚îî‚îÄ‚îÄ pages/         # Application pages
‚îú‚îÄ‚îÄ lib/               # Shared utilities
‚îÇ   ‚îî‚îÄ‚îÄ export.ts      # Graph export functionality
‚îî‚îÄ‚îÄ App.tsx            # Main application entry point
```

## üöÄ Getting Started

### Prerequisites
- **Node.js 18+** and **npm/yarn**
- **Deno 1.40+** for development
- **API Keys** for AI features (OpenAI, Anthropic, or Gemini)

### Installation

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd gitnexus
   ```

2. **Install dependencies**
   ```bash
   npm install
   ```

3. **Start development server**
   ```bash
   npm run dev
   ```

4. **Open in browser**
   ```
   http://localhost:5173
   ```

### Configuration

1. **GitHub Token (Optional)**
   - Increases rate limit from 60 to 5,000 requests/hour
   - Generate at: https://github.com/settings/tokens
   - Requires no special permissions for public repos

2. **AI API Keys**
   - **OpenAI**: Get from https://platform.openai.com/api-keys
   - **Anthropic**: Get from https://console.anthropic.com/
   - **Gemini**: Get from https://makersuite.google.com/app/apikey

3. **Performance Settings**
   - **File Limit**: Configure maximum files to process (default: 500)
   - **Directory Filters**: Focus on specific directories (e.g., "src", "lib")
   - **File Patterns**: Filter by file types (e.g., "*.py", "*.js", "*.ts")

## üí° Usage

### Analyzing a Repository

1. **GitHub Repository**
   ```
   1. Enter GitHub URL: https://github.com/owner/repo
   2. Optional: Set directory/file filters to focus analysis
   3. Click "Analyze"
   4. For large repos: Confirm processing or adjust filters
   5. Wait for processing (structure ‚Üí parsing ‚Üí call resolution)
   6. Explore the interactive graph
   ```

2. **ZIP File Upload**
   ```
   1. Click "Choose File" and select a .zip file
   2. Optional: Configure filters before processing
   3. Click "Analyze"
   4. Processing will extract and analyze text files
   5. Explore results in the graph visualization
   ```

### Performance Optimization

1. **Directory Filtering**
   ```
   - Enter directory names: "src", "lib", "components"
   - Focuses analysis on specific parts of the codebase
   - Reduces processing time and memory usage
   ```

2. **File Pattern Filtering**
   ```
   - Use patterns: "*.py", "*.js", "*.ts"
   - Supports wildcards: "test*.py", "*util*"
   - Comma-separated: "*.py,*.js,*.ts"
   ```

3. **File Limits**
   ```
   - Default limit: 500 files
   - Configurable in settings (50-2000 files)
   - Large repositories show confirmation dialog
   - Automatic truncation to limit if confirmed
   ```

### Using the AI Chat

1. **Configure API Key**
   ```
   1. Click the ‚öôÔ∏è settings button
   2. Choose your preferred LLM provider
   3. Enter your API key
   4. Select model (e.g., gpt-4o-mini, claude-3-haiku)
   ```

2. **Ask Questions**
   ```
   - "What functions are in the main.py file?"
   - "Show me all classes that inherit from BaseClass"
   - "How does the authentication system work?"
   - "Find all functions that call the database"
   ```

### Exporting Data

1. **Export Knowledge Graph**
   ```
   1. Click the üì• Export button after processing
   2. Downloads JSON file with graph data and metadata
   3. Includes processing statistics and timestamps
   4. File size shown in UI before export
   ```

2. **Export Format**
   ```json
   {
     "metadata": {
       "exportedAt": "2024-01-01T12:00:00.000Z",
       "version": "1.0.0",
       "nodeCount": 150,
       "relationshipCount": 200,
       "fileCount": 25,
       "processingDuration": 5000
     },
     "graph": {
       "nodes": [...],
       "relationships": [...]
     },
     "fileContents": {...}
   }
   ```

### Graph Interaction

- **Node Selection**: Click any node to highlight and view details
- **Zoom & Pan**: Mouse wheel to zoom, drag to pan
- **Node Types**: Different colors/shapes for files, functions, classes, etc.
- **Relationships**: Arrows show CONTAINS, CALLS, INHERITS relationships

## üîß Development

### Project Structure
```
GitNexus/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ services/          # External integrations
‚îÇ   ‚îú‚îÄ‚îÄ core/             # Processing pipeline
‚îÇ   ‚îú‚îÄ‚îÄ ai/               # AI and RAG systems
‚îÇ   ‚îú‚îÄ‚îÄ workers/          # Web Workers
‚îÇ   ‚îú‚îÄ‚îÄ ui/               # React components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/   # Reusable components
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorBoundary.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ graph/    # Graph components
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chat/     # Chat components
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pages/        # Application pages
‚îÇ   ‚îú‚îÄ‚îÄ lib/              # Utilities
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ export.ts     # Export functionality
‚îÇ   ‚îî‚îÄ‚îÄ App.tsx           # Main application
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îî‚îÄ‚îÄ wasm/             # Tree-sitter WASM files
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ vite.config.ts
‚îî‚îÄ‚îÄ tsconfig.json
```

### Key Components

#### **Error Handling**
```typescript
// ErrorBoundary component with recovery options
<ErrorBoundary
  onError={(error, errorInfo) => {
    console.error('Application error:', error);
  }}
>
  <App />
</ErrorBoundary>
```

#### **Performance Optimization**
```typescript
// File filtering and limits
const filterFiles = (files: any[]) => {
  return files
    .filter(file => matchesDirectoryFilter(file))
    .filter(file => matchesPatternFilter(file))
    .slice(0, maxFiles);
};
```

#### **Export Functionality**
```typescript
// Export with metadata
exportAndDownloadGraph(graph, {
  projectName: 'my-project',
  includeMetadata: true,
  prettyPrint: true
}, fileContents, { duration: 5000 });
```

#### **Processing Pipeline**
```typescript
// 3-pass ingestion strategy with progress tracking
const pipeline = new GraphPipeline();
const result = await pipeline.run({
  projectRoot: '/',
  projectName: 'MyProject',
  filePaths: ['src/main.py', 'src/utils.py'],
  fileContents: new Map([
    ['src/main.py', 'def main(): pass'],
    ['src/utils.py', 'def helper(): pass']
  ])
});
```

#### **AI Integration**
```typescript
// LangChain ReAct agent with error handling
const orchestrator = new LangChainRAGOrchestrator(llmService, cypherGenerator);
await orchestrator.setContext({ graph, fileContents }, llmConfig);
const response = await orchestrator.answerQuestion("How does auth work?");
```

#### **Graph Visualization**
```typescript
// Interactive graph component with error boundaries
<ErrorBoundary>
  <GraphExplorer
    graph={knowledgeGraph}
    onNodeSelect={(nodeId) => setSelectedNode(nodeId)}
  />
</ErrorBoundary>
```

### Adding New Features

1. **New Language Support**
   ```typescript
   // Add parser in core/tree-sitter/
   export const loadJavaScriptParser = async () => {
     // Load JS Tree-sitter grammar
   };
   ```

2. **Custom AI Tools**
   ```typescript
   // Add tools in ai/langchain-orchestrator.ts
   const customTool = tool(
     async (input: { query: string }) => {
       // Tool implementation
     },
     {
       name: "custom_tool",
       description: "Custom functionality",
       schema: z.object({ query: z.string() })
     }
   );
   ```

3. **Export Formats**
   ```typescript
   // Add new export formats in lib/export.ts
   export function exportToCSV(graph: KnowledgeGraph): string {
     // CSV export implementation
   }
   ```

## üß™ Testing & Quality Assurance

### Error Handling
- **Error Boundaries**: Catch and display JavaScript errors gracefully
- **User Recovery**: Allow users to reset component state after errors
- **Detailed Logging**: Console logging for debugging and error reporting
- **Fallback UI**: User-friendly error messages with recovery options

### Performance Testing
1. **Large Repository Handling**
   - Test with repositories containing 1000+ files
   - Verify confirmation dialogs for file limits
   - Monitor memory usage during processing
   - Test filtering effectiveness

2. **UI Responsiveness**
   - Ensure non-blocking processing with Web Workers
   - Verify progress indicators update correctly
   - Test error recovery mechanisms
   - Validate export functionality with large graphs

3. **Error Scenarios**
   - Network failures during GitHub API calls
   - Corrupted ZIP files
   - Invalid API keys
   - Memory exhaustion scenarios

### Manual Testing Checklist
- [ ] GitHub repository analysis with various sizes
- [ ] ZIP file upload and extraction
- [ ] Directory and file pattern filtering
- [ ] Large repository confirmation dialog
- [ ] Export functionality with different options
- [ ] Error boundary activation and recovery
- [ ] API key validation for all providers
- [ ] Settings persistence across sessions
- [ ] Graph visualization interactions
- [ ] Chat interface with different LLM providers

## üöÄ Deployment

### Production Build
```bash
npm run build
npm run preview
```

### Environment Variables
```env
# Optional: Pre-configure API keys
VITE_OPENAI_API_KEY=sk-...
VITE_ANTHROPIC_API_KEY=sk-ant-...
VITE_GEMINI_API_KEY=...

# Performance settings
VITE_DEFAULT_MAX_FILES=500
VITE_ENABLE_DEBUG_LOGGING=false
```

### Docker Deployment
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "run", "preview", "--", "--host", "0.0.0.0"]
```

### Performance Monitoring
```javascript
// Add performance monitoring
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.entryType === 'measure') {
      console.log(`${entry.name}: ${entry.duration}ms`);
    }
  }
});
observer.observe({ entryTypes: ['measure'] });
```

## üîí Security & Privacy

- **Client-Side Processing**: All analysis happens in your browser
- **API Keys**: Stored locally, never transmitted to our servers
- **GitHub Access**: Uses public API, respects repository permissions
- **Data Privacy**: No code or analysis results are stored remotely
- **Error Logging**: Sensitive data excluded from error reports
- **Export Security**: User-controlled data export with no server interaction

## ü§ù Contributing

### Development Setup
1. Fork the repository
2. Create feature branch: `git checkout -b feature/amazing-feature`
3. Make changes and test thoroughly
4. Run the testing checklist above
5. Commit: `git commit -m 'Add amazing feature'`
6. Push: `git push origin feature/amazing-feature`
7. Open a Pull Request

### Code Style
- **TypeScript**: Strict mode enabled
- **ESLint**: Follow configured rules
- **Prettier**: Auto-formatting
- **Comments**: Minimal, only when necessary
- **Error Handling**: Comprehensive error boundaries and recovery
- **Performance**: Consider memory usage and processing time

### Testing Guidelines
- Test error scenarios and edge cases
- Verify performance with large datasets
- Ensure graceful degradation
- Test all export functionality
- Validate error boundary behavior

## üìö Technical Details

### Knowledge Graph Schema
```typescript
interface KnowledgeGraph {
  nodes: GraphNode[];        // Code entities
  relationships: GraphRelationship[]; // Connections
}

// Node types: Project, Folder, File, Module, Class, Function, Method, Variable
// Relationship types: CONTAINS, CALLS, INHERITS, OVERRIDES, IMPORTS
```

### Export Format
```typescript
interface ExportedGraph {
  metadata: {
    exportedAt: string;
    version: string;
    nodeCount: number;
    relationshipCount: number;
    fileCount?: number;
    processingDuration?: number;
  };
  graph: KnowledgeGraph;
  fileContents?: Record<string, string>;
}
```

### Error Boundary Implementation
- **Component-Level**: Individual components wrapped for isolation
- **Application-Level**: Top-level boundary for catastrophic failures
- **Recovery Options**: Reset state, reload page, or continue with fallback
- **Error Reporting**: Detailed technical information for developers

### Performance Optimizations
- **Web Workers**: Non-blocking processing
- **AST Caching**: Reuse parsed syntax trees
- **Progressive Loading**: Stream results as available
- **Memory Management**: Efficient data structures
- **File Filtering**: Reduce processing scope
- **Confirmation Dialogs**: Prevent accidental expensive operations

### ReAct Agent Implementation
- **Standard LangChain**: Uses `createReactAgent` from `@langchain/langgraph/prebuilt`
- **Custom Implementation**: Manual ReAct loop for educational purposes
- **Tools**: Graph queries, code retrieval, file search
- **Memory**: Conversation persistence with thread management
- **Error Recovery**: Graceful handling of API failures

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- **Tree-sitter**: Syntax parsing infrastructure
- **LangChain.js**: AI agent framework
- **Cytoscape.js**: Graph visualization
- **React**: UI framework with error boundaries
- **Vite**: Build tool and dev server

---

**CodeNexus** - Edge Knowledge Graph Creator with instant Graph RAG. Zero setup, maximum insight. üöÄ

*Browser-native code intelligence that runs anywhere, anytime - no servers required.*

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitNexus - Code Knowledge Graph Explorer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      
      #root {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "gitnexus",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@langchain/anthropic": "^0.1.21",
    "@langchain/core": "^0.3.66",
    "@langchain/google-genai": "^0.2.16",
    "@langchain/langgraph": "^0.0.26",
    "@langchain/openai": "^0.0.28",
    "@types/d3": "^7.4.3",
    "axios": "^1.6.0",
    "comlink": "^4.4.1",
    "d3": "^7.9.0",
    "jszip": "^3.10.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "uuid": "^11.1.0",
    "web-tree-sitter": "^0.20.8",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/js": "^9.11.1",
    "@types/react": "^18.3.10",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.2",
    "eslint": "^9.11.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.12",
    "globals": "^15.9.0",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.7.0",
    "vite": "^5.4.8"
  }
}

================
File: project_guide.md
================
# GitNexus: Edge-Based Code Knowledge Graph Generator for Deno - Step-by-Step Implementation Guide

This guide will walk you through building a fully edge-based code knowledge graph generator from scratch using Deno. I'll explain each concept before showing the implementation, so you understand **why** we're doing something, not just **how** to do it.

## Phase 1: Project Setup & Core Infrastructure

### Step 1: Project Structure and Tooling Setup

**Why this matters:** Before writing any code, we need to set up our development environment properly. A well-structured project makes it easier to add features later and keeps everything organized.

**Key concepts:**

- We're using Vite (a modern build tool) with React and TypeScript
- We need special configuration for WebAssembly (WASM) files
- A clear directory structure helps us scale to multiple languages later

**Implementation Steps:**

1. **Create the base project:**

```bash
# Create project root
mkdir GitNexus
cd GitNexus

# Initialize Vite project with React and TypeScript
npm create vite@latest . -- --template react-ts

# Initialize Deno project
deno init
```

2. **Create the application directory structure:**

```bash
# Create directories for our core components
mkdir -p src/{core,core/tree-sitter,core/graph,core/ingestion,services,ai,ai/agents,ai/prompts,ui,ui/components,ui/components/graph,ui/components/chat,ui/hooks,workers,lib,config,store}
```

**Why this structure?**

- `core/`: Contains the engine that builds the knowledge graph
- `services/`: Handles external interactions (GitHub API, ZIP processing)
- `ai/`: Contains the RAG and chat functionality
- `ui/`: All user interface components
- `workers/`: Web Workers for heavy processing (keeps UI responsive)
- `lib/`: Utility functions used throughout the app

### Step 2: Configure Build Tools for WASM

**Why this matters:** WebAssembly (WASM) is how we'll run the Tree-sitter parsers in the browser. We need special configuration to handle these binary files correctly.

**Key concepts:**

- WASM files are binary files that run at near-native speed in browsers
- Vite needs special configuration to handle them properly
- We want to avoid inlining large WASM files in our JavaScript bundles

**Implementation:**

1. **Update `vite.config.ts`:**

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
export default defineConfig({
  plugins: [react()],
  worker: {
    format: 'es'
  },
  assetsInclude: ['**/*.wasm'],
  build: {
    target: 'esnext',
    assetsInlineLimit: 0 // Don't inline WASM files
  }
})
```

**What this does:**

- `assetsInclude: ['**/*.wasm']` tells Vite to treat WASM files as assets
- `assetsInlineLimit: 0` ensures WASM files aren't inlined into JavaScript (they're too large)
- `worker: { format: 'es' }` configures Web Workers to use ES modules

2. **Configure TypeScript** with a `tsconfig.json` that has strict settings for better code quality.

**Why strict settings?** They help catch errors early and make the code more maintainable as the project grows.

### Step 3: Set Up WASM Parser Infrastructure

**Why this matters:** Tree-sitter is the engine that parses code into ASTs (Abstract Syntax Trees). We need to get these parsers working in the browser via WASM.

**Key concepts:**

- Tree-sitter parsers for different languages are written in C
- We compile them to WASM so they can run in browsers
- We need to load these parsers on demand

**Implementation:**

1. **Create a public directory for WASM files:**

```bash
mkdir -p public/wasm/python
```

2. **Download the Tree-sitter Python parser:**
   - Get `tree-sitter-python.wasm` from [tree-sitter-python releases](https://github.com/tree-sitter/tree-sitter-python/releases)
   - Place it in `public/wasm/python/`

**Why host WASM files separately?** Browsers can't access the user's file system directly for security reasons. We need to serve the WASM files from a URL.

3. **Create a loader for Tree-sitter parsers:**

```typescript
import WebTreeSitter from 'web-tree-sitter';
let parserInstance: WebTreeSitter | null = null;
const parserCache = new Map<string, WebTreeSitter.Language>();

export async function initTreeSitter() {
  if (parserInstance) return parserInstance;
  parserInstance = await WebTreeSitter.init();
  return parserInstance;
}

export async function loadPythonParser(): Promise<WebTreeSitter.Language> {
  if (parserCache.has('python')) {
    return parserCache.get('python')!;
  }
  const Parser = await initTreeSitter();
  const pythonLang = await Parser.Language.load(
    '/wasm/python/tree-sitter-python.wasm'
  );
  parserCache.set('python', pythonLang);
  return pythonLang;
}
```

**How this works:**

1. `initTreeSitter()` initializes the WebAssembly module once
2. `loadPythonParser()` loads the Python parser from the WASM file
3. We cache parsers to avoid reloading them multiple times

**Why cache parsers?** Loading WASM files is relatively slow, so we want to do it once and reuse the parsers.

## Phase 2: Code Acquisition Module

### Step 4: Implement GitHub API Integration

**Why this matters:** Users will want to analyze public GitHub repositories, so we need a way to fetch code from GitHub.

**Key concepts:**

- GitHub has a REST API for accessing repository contents
- We need to handle rate limits (GitHub limits how many requests you can make)
- We'll let users provide their own API tokens for higher limits

**Implementation:**

```typescript
export class GitHubService {
  private token: string | null = null;
  
  setToken(token: string) {
    this.token = token;
  }
  
  async getRepoContents(owner: string, repo: string, path = '') {
    const headers: HeadersInit = {
      'Accept': 'application/vnd.github.v3+json'
    };
    if (this.token) {
      headers['Authorization'] = `token ${this.token}`;
    }
  
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${path}`,
      { headers }
    );
  
    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status}`);
    }
  
    return response.json();
  }
}
```

**How this works:**

- `getRepoContents()` fetches the directory structure of a repository
- It uses the GitHub API with proper headers
- It handles authentication via a token

**Important note:** GitHub API has rate limits. For unauthenticated requests, it's about 60 requests/hour. With a token, it's 5,000/hour.

### Step 5: Implement ZIP Processing

**Why this matters:** Not all code is on GitHub. Users might want to analyze local code or private repositories by uploading a ZIP file.

**Key concepts:**

- JSZip is a library for handling ZIP files in JavaScript
- We need to extract files and their contents from the ZIP
- We'll use a Map to store file paths and contents

**Implementation:**

```typescript
import JSZip from 'jszip';

export class ZipService {
  async processZip(file: File): Promise<Map<string, string>> {
    const zip = await JSZip.loadAsync(file);
    const files = new Map<string, string>();
  
    for (const [filePath, zipEntry] of Object.entries(zip.files)) {
      if (!zipEntry.dir) {
        const content = await zipEntry.async('text');
        files.set(filePath, content);
      }
    }
  
    return files;
  }
}
```

**How this works:**

1. `JSZip.loadAsync(file)` loads the ZIP file
2. We iterate through all entries in the ZIP
3. For each file (not directory), we extract its content as text
4. We store the file path and content in a Map

**Why use a Map?** It provides O(1) lookups by file path, which is important when we need to find files during graph construction.

## Phase 3: Graph Construction Pipeline

### Step 6: Define Graph Data Structures

**Why this matters:** Before we can build a graph, we need to define what nodes and relationships look like.

**Key concepts:**

- A knowledge graph consists of nodes and relationships
- Nodes represent code elements (functions, classes, etc.)
- Relationships represent connections between elements (calls, contains, etc.)

**Implementation:**

```typescript
export type NodeLabel = 
  | 'Project' 
  | 'Package' 
  | 'Module' 
  | 'Folder' 
  | 'File' 
  | 'Class' 
  | 'Function' 
  | 'Method' 
  | 'Variable';

export interface GraphNode {
  id: string;
  label: NodeLabel;
  properties: Record<string, any>;
}

export type RelationshipType = 
  | 'CONTAINS'
  | 'CALLS'
  | 'INHERITS'
  | 'OVERRIDES'
  | 'IMPORTS';

export interface GraphRelationship {
  id: string;
  type: RelationshipType;
  source: string;
  target: string;
  properties?: Record<string, any>;
}

export interface KnowledgeGraph {
  nodes: GraphNode[];
  relationships: GraphRelationship[];
}
```

**Why these specific types?**

- `NodeLabel` defines all possible types of code elements we'll track
- `RelationshipType` defines how code elements connect to each other
- `KnowledgeGraph` is the complete structure we'll build

**Important relationships:**

- `CONTAINS`: A folder contains files, a file contains functions
- `CALLS`: A function calls another function
- `IMPORTS`: One module imports from another

### Step 7: Implement the 3-Pass Ingestion Pipeline

**Why this matters:** Building a complete knowledge graph requires multiple passes to handle cross-file references properly.

**Key concepts:**

- **Pass 1**: Identify the overall structure (folders, modules)
- **Pass 2**: Parse individual files and cache ASTs
- **Pass 3**: Process function calls across files (the hardest part)

This three-pass approach solves the "island problem" - where functions in different files appear disconnected.

#### Pass 1: Structure Identification

```typescript
export class StructureProcessor {
  private graph: KnowledgeGraph;
  private projectRoot: string;
  private projectName: string;
  
  constructor(graph: KnowledgeGraph, projectRoot: string, projectName: string) {
    this.graph = graph;
    this.projectRoot = projectRoot;
    this.projectName = projectName;
  }
  
  identifyStructure(filePaths: string[]): void {
    // Add Project node
    this.graph.nodes.push({
      id: `project:${this.projectName}`,
      label: 'Project',
      properties: { name: this.projectName }
    });
  
    // Track directory structure
    const directories = new Set<string>();
    for (const filePath of filePaths) {
      const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
      if (dirPath && !directories.has(dirPath)) {
        directories.add(dirPath);
        // Create Folder node
        this.graph.nodes.push({
          id: `folder:${dirPath}`,
          label: 'Folder',
          properties: { path: dirPath }
        });
      
        // Create CONTAINS relationship with parent
        if (dirPath.includes('/')) {
          const parentPath = dirPath.substring(0, dirPath.lastIndexOf('/'));
          this.graph.relationships.push({
            id: `rel:folder:${dirPath}:parent`,
            type: 'CONTAINS',
            source: `folder:${parentPath}`,
            target: `folder:${dirPath}`
          });
        } else {
          // Root folder connects to project
          this.graph.relationships.push({
            id: `rel:folder:${dirPath}:project`,
            type: 'CONTAINS',
            source: `project:${this.projectName}`,
            target: `folder:${dirPath}`
          });
        }
      }
    }
  }
}
```

**How this works:**

1. Creates a root Project node
2. Walks through all file paths to identify directories
3. Creates Folder nodes and CONTAINS relationships

**Why identify structure first?** We need to know the overall organization before parsing individual files.

#### Pass 2: File Parsing

```typescript
export class ParsingProcessor {
  private graph: KnowledgeGraph;
  private astCache = new Map<string, any>();
  
  constructor(graph: KnowledgeGraph) {
    this.graph = graph;
  }
  
  async parseFiles(filePaths: string[], fileContents: Map<string, string>): Promise<Map<string, any>> {
    for (const [filePath, content] of fileContents) {
      if (filePath.endsWith('.py')) {
        await this.parsePythonFile(filePath, content);
      }
    }
    return this.astCache;
  }
  
  private async parsePythonFile(filePath: string, content: string): Promise<void> {
    const parser = await loadPythonParser();
    const tree = parser.parse(content);
    // Cache the AST
    this.astCache.set(filePath, tree);
    // Extract definitions from the AST
    this.extractDefinitions(filePath, tree, content);
  }
  
  private extractDefinitions(filePath: string, tree: any, content: string): void {
    // Extract modules
    this.graph.nodes.push({
      id: `module:${filePath}`,
      label: 'Module',
      properties: { 
        path: filePath,
        name: filePath.split('/').pop()!.replace('.py', ''),
        extension: '.py'
      }
    });
  
    // Extract functions from the AST
    const rootNode = tree.rootNode;
    const functionDefs = rootNode.descendantsOfType('function_definition');
    for (const funcNode of functionDefs) {
      const nameNode = funcNode.childForFieldName('name');
      const name = nameNode ? nameNode.text : 'unknown';
    
      // Calculate position
      const startLine = funcNode.startPosition.row + 1;
    
      // Create function node
      this.graph.nodes.push({
        id: `function:${filePath}:${name}`,
        label: 'Function',
        properties: {
          name,
          qualified_name: `${this.getModuleName(filePath)}.${name}`,
          path: filePath,
          start_line: startLine
        }
      });
    
      // Create CONTAINS relationship with module
      this.graph.relationships.push({
        id: `rel:function:${filePath}:${name}:module`,
        type: 'CONTAINS',
        source: `module:${filePath}`,
        target: `function:${filePath}:${name}`
      });
    }
  }
}
```

**How this works:**

1. Parses each file with the appropriate Tree-sitter parser
2. Caches the AST for later use
3. Extracts definitions (functions, classes) from the AST
4. Creates nodes and relationships in the graph

**Why cache ASTs?** We need them in Pass 3 to resolve cross-file function calls.

#### Pass 3: Call Resolution

```typescript
export class CallProcessor {
  private graph: KnowledgeGraph;
  private astCache: Map<string, any>;
  private projectRoot: string;
  private projectName: string;
  
  constructor(
    graph: KnowledgeGraph,
    astCache: Map<string, any>,
    projectRoot: string,
    projectName: string
  ) {
    this.graph = graph;
    this.astCache = astCache;
    this.projectRoot = projectRoot;
    this.projectName = projectName;
  }
  
  processCalls(): void {
    for (const [filePath, tree] of this.astCache) {
      if (filePath.endsWith('.py')) {
        this.processPythonCalls(filePath, tree);
      }
    }
  }
  
  private processPythonCalls(filePath: string, tree: any): void {
    const rootNode = tree.rootNode;
    // Find all call expressions
    const callExpressions = rootNode.descendantsOfType('call');
    for (const callNode of callExpressions) {
      const functionNameNode = callNode.childForFieldName('function');
      if (!functionNameNode) continue;
    
      // Handle different types of function references
      let targetFunctionName = '';
      if (functionNameNode.type === 'identifier') {
        targetFunctionName = functionNameNode.text;
      } else if (functionNameNode.type === 'attribute') {
        // Handle method calls like obj.method()
        const attrNode = functionNameNode;
        const objectNode = attrNode.childForFieldName('object');
        const attrNameNode = attrNode.childForFieldName('attribute');
        if (objectNode && attrNameNode) {
          const objectName = objectNode.text;
          const methodName = attrNameNode.text;
          targetFunctionName = `${objectName}.${methodName}`;
        }
      }
    
      if (!targetFunctionName) continue;
    
      // Try to resolve the target function
      const targetNode = this.resolveTargetFunction(targetFunctionName, filePath);
      if (targetNode) {
        // Create CALLS relationship
        const callerId = this.getCallerId(callNode, filePath);
        this.graph.relationships.push({
          id: `rel:call:${callerId}:${targetNode.id}`,
          type: 'CALLS',
          source: callerId,
          target: targetNode.id
        });
      }
    }
  }
  
  private resolveTargetFunction(targetName: string, currentFilePath: string): { id: string; type: string } | null {
    // 1. Check if it's a built-in function
    if (this.isBuiltInFunction(targetName)) {
      return {
        id: `builtin:${targetName}`,
        type: 'builtin'
      };
    }
  
    // 2. Check if it's an imported function
    const importInfo = this.findImportForFunction(targetName, currentFilePath);
    if (importInfo) {
      const targetId = `function:${importInfo.sourceFile}:${importInfo.targetName}`;
      return {
        id: targetId,
        type: 'imported'
      };
    }
  
    // 3. Check if it's defined in the current file
    for (const node of this.graph.nodes) {
      if (node.label === 'Function' && 
          node.properties.name === targetName &&
          node.properties.path === currentFilePath) {
        return {
          id: node.id,
          type: 'local'
        };
      }
    }
  
    return null;
  }
}
```

**How this works:**

1. Finds all function calls in the AST
2. Determines what function is being called
3. Resolves the target function across files using imports
4. Creates CALLS relationships in the graph

**Why is this the hardest part?** Resolving cross-file references requires understanding:

- How imports work in the language
- How to map a simple name to a fully qualified name
- Handling edge cases like aliases (`import helper as h`)

### Step 8: Implement Web Workers for Performance

**Why this matters:** Parsing code and building graphs can be CPU-intensive. Web Workers keep the UI responsive.

**Key concepts:**

- Web Workers run JavaScript in background threads
- They can't access the DOM directly
- We use Comlink to simplify communication

**Implementation:**

```typescript
// src/workers/ingestion.worker.ts
import { expose } from 'comlink';
import { GraphPipeline } from '../core/ingestion/pipeline';

class IngestionWorker {
  async processRepository(
    projectRoot: string,
    projectName: string,
    filePaths: string[],
    fileContents: Record<string, string>
  ) {
    const pipeline = new GraphPipeline(projectRoot, projectName);
    return pipeline.run(filePaths, new Map(Object.entries(fileContents)));
  }
}

expose(new IngestionWorker());
```

**How this works:**

1. The worker runs the heavy processing in a background thread
2. We expose methods via Comlink to call them from the main thread
3. The main thread can call these methods without blocking the UI

**Why use Web Workers?** Without them, large repositories would freeze the browser tab while processing.

## Phase 4: Graph Visualization

### Step 9: Implement Graph Visualization Components

**Why this matters:** A knowledge graph is useless if users can't see and interact with it.

**Key concepts:**

- Cytoscape.js is a powerful graph visualization library
- We need to convert our graph data to Cytoscape's format
- Users need controls to filter and navigate the graph

**Implementation:**

```tsx
import React, { useEffect, useRef } from 'react';
import cytoscape from 'cytoscape';
import dagre from 'cytoscape-dagre';
import { KnowledgeGraph } from '@/core/graph/types';

cytoscape.use(dagre);

interface GraphVisualizationProps {
  graph: KnowledgeGraph;
  onNodeClick?: (nodeId: string) => void;
  filter?: (node: any) => boolean;
}

export const GraphVisualization: React.FC<GraphVisualizationProps> = ({ 
  graph, 
  onNodeClick,
  filter 
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const cyRef = useRef<cytoscape.Core | null>(null);
  
  useEffect(() => {
    if (!containerRef.current) return;
  
    // Clean up previous instance
    if (cyRef.current) {
      cyRef.current.destroy();
    }
  
    // Convert our graph to Cytoscape format
    const cyElements = convertToCytoscapeElements(graph, filter);
  
    const cy = cytoscape({
      container: containerRef.current,
      elements: cyElements,
      style: [
        {
          selector: 'node',
          style: {
            'label': 'data(label)',
            'width': 'mapData(size, 0, 100, 20, 80)',
            'height': 'mapData(size, 0, 100, 20, 80)',
            'background-color': 'data(color)',
            'text-valign': 'center',
            'text-halign': 'center',
            'font-size': '8px'
          }
        },
        {
          selector: 'edge',
          style: {
            'width': 2,
            'line-color': '#ccc',
            'target-arrow-color': '#ccc',
            'target-arrow-shape': 'triangle'
          }
        }
      ],
      layout: {
        name: 'dagre',
        rankDir: 'TB',
        padding: 20
      }
    });
  
    // Add interactions
    cy.on('tap', 'node', (event) => {
      const node = event.target;
      const nodeId = node.data('id');
      if (onNodeClick) {
        onNodeClick(nodeId);
      }
    });
  
    cyRef.current = cy;
  
    return () => {
      if (cyRef.current) {
        cyRef.current.destroy();
        cyRef.current = null;
      }
    };
  }, [graph, filter]);
  
  return (
    <div 
      ref={containerRef} 
      className="w-full h-full bg-white rounded-lg border border-gray-200"
    />
  );
};

function convertToCytoscapeElements(
  graph: KnowledgeGraph, 
  filter?: (node: any) => boolean
) {
  const elements: any[] = [];
  
  // Add nodes
  for (const node of graph.nodes) {
    if (filter && !filter(node)) continue;
    elements.push({
      data: {
        id: node.id,
        label: getNodeLabel(node),
        type: node.label,
        color: getNodeColor(node.label),
        size: getNodeSize(node)
      }
    });
  }
  
  // Add edges
  for (const rel of graph.relationships) {
    elements.push({
      data: {
        id: rel.id,
        source: rel.source,
        target: rel.target,
        label: rel.type
      }
    });
  }
  
  return elements;
}
```

**How this works:**

1. Converts our graph data to Cytoscape's format
2. Sets up visual styles based on node type
3. Applies a hierarchical layout (dagre)
4. Adds interaction handlers for node clicks

**Why use Cytoscape.js?** It's specifically designed for graph visualization with:

- Multiple layout algorithms
- Good performance for medium-sized graphs
- Extensive customization options

### Step 10: Create Source Code Viewer

**Why this matters:** Seeing the graph isn't enough - users need to see the actual code behind the nodes.

**Implementation:**

```tsx
import React, { useState, useEffect } from 'react';
import { KnowledgeGraph } from '@/core/graph/types';

interface SourceViewerProps {
  graph: KnowledgeGraph;
  selectedNodeId: string | null;
}

export const SourceViewer: React.FC<SourceViewerProps> = ({ graph, selectedNodeId }) => {
  const [sourceCode, setSourceCode] = useState<string>('');
  const [fileName, setFileName] = useState<string>('');
  const [lineNumber, setLineNumber] = useState<number | null>(null);
  
  useEffect(() => {
    if (!selectedNodeId) {
      setSourceCode('');
      setFileName('');
      setLineNumber(null);
      return;
    }
  
    // Find the node in the graph
    const node = graph.nodes.find(n => n.id === selectedNodeId);
    if (!node) return;
  
    // For functions, get the source code
    if (node.label === 'Function' || node.label === 'Method') {
      const filePath = node.properties.path;
      const startLine = node.properties.start_line;
    
      // In a real implementation, you'd have the source code available
      setFileName(filePath);
      setLineNumber(startLine);
      setSourceCode(`# Source code for ${node.properties.qualified_name}
# Line ${startLine} and following...`);
    }
  }, [graph, selectedNodeId]);
  
  if (!selectedNodeId || !sourceCode) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50">
        <p className="text-gray-500">Select a node to view source code</p>
      </div>
    );
  }
  
  return (
    <div className="flex flex-col h-full">
      <div className="p-2 bg-gray-100 border-b border-gray-200 flex justify-between items-center">
        <span className="text-sm font-medium text-gray-700 truncate">{fileName}</span>
        {lineNumber && (
          <span className="text-xs text-gray-500">Line {lineNumber}</span>
        )}
      </div>
      <div className="flex-1 overflow-auto p-2 font-mono text-sm bg-black text-white">
        <pre>{sourceCode}</pre>
      </div>
    </div>
  );
};
```

**How this works:**

1. When a node is selected, it finds the corresponding code element
2. It displays the source code with line numbers
3. It highlights the relevant part of the code

**Why is this important?** It bridges the gap between the abstract graph and the concrete code, helping users understand what they're seeing.

## Phase 5: RAG Chat Interface

### Step 11: Implement LLM Service

**Why this matters:** The chat interface needs to connect to LLMs (Large Language Models) to translate natural language to graph queries.

**Key concepts:**

- We'll support multiple LLM providers (OpenAI, Anthropic, Gemini)
- Users provide their own API keys (privacy-focused)
- We need a consistent interface for different providers

**Implementation:**

```typescript
import { ChatOpenAI } from 'langchain/chat_models/openai';
import { ChatAnthropic } from 'langchain/chat_models/anthropic';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';

export type LLMProvider = 'openai' | 'anthropic' | 'gemini';

export interface LLMConfig {
  provider: LLMProvider;
  apiKey: string;
  model?: string;
}

export class LLMService {
  private config: LLMConfig;
  
  constructor(config: LLMConfig) {
    this.config = config;
  }
  
  getChatModel() {
    switch (this.config.provider) {
      case 'openai':
        return new ChatOpenAI({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'gpt-4-turbo',
          temperature: 0
        });
      case 'anthropic':
        return new ChatAnthropic({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'claude-3-sonnet-20240229',
          temperature: 0
        });
      case 'gemini':
        return new ChatGoogleGenerativeAI({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'gemini-1.5-pro-latest',
          temperature: 0
        });
      default:
        throw new Error(`Unsupported LLM provider: ${this.config.provider}`);
    }
  }
}
```

**How this works:**

1. The service takes an LLM configuration (provider, API key, model)
2. It returns a consistent chat model interface regardless of provider
3. It handles provider-specific initialization

**Why support multiple providers?** Different users have different preferences and API key availability.

### Step 12: Implement Cypher Generator

**Why this matters:** The core of the RAG system - translating natural language questions to graph queries.

**Key concepts:**

- We use a system prompt to instruct the LLM
- The prompt includes our graph schema
- We clean the response to get a valid Cypher query

**Implementation:**

```typescript
import { BaseChatModel } from 'langchain/chat_models/base';
import { CYPHER_SYSTEM_PROMPT } from '../prompts/cypher';

export class CypherGenerator {
  private llm: BaseChatModel;
  
  constructor(llm: BaseChatModel) {
    this.llm = llm;
  }
  
  async generate(naturalLanguageQuery: string): Promise<string> {
    const response = await this.llm.call([
      { role: 'system', content: CYPHER_SYSTEM_PROMPT },
      { role: 'user', content: naturalLanguageQuery }
    ]);
  
    return this.cleanResponse(response.content);
  }
  
  private cleanResponse(response: string): string {
    // Remove markdown code blocks
    let cleaned = response.replace(/```cypher/g, '').replace(/```/g, '');
    // Ensure it ends with a semicolon
    if (!cleaned.trim().endsWith(';')) {
      cleaned = cleaned.trim() + ';';
    }
    return cleaned;
  }
}
```

**How this works:**

1. It sends the natural language query with a system prompt to the LLM
2. The system prompt teaches the LLM about our graph structure
3. It cleans the response to extract a valid Cypher query

**Why is the system prompt important?** It provides the LLM with the context it needs to generate correct queries. Without it, the LLM wouldn't know about our graph schema.

### Step 13: Implement RAG Orchestrator

**Why this matters:** This is the "brain" of the system that coordinates the query process.

**Key concepts:**

- It follows a ReAct (Reason + Act) pattern
- It plans steps, uses tools, observes results, and responds
- It prevents hallucination by sticking to tool results

**Implementation:**

```typescript
import { BaseChatModel } from 'langchain/chat_models/base';
import { RAG_ORCHESTRATOR_SYSTEM_PROMPT } from '../prompts/rag-orchestrator';

export class RAGOrchestrator {
  private llm: BaseChatModel;
  
  constructor(llm: BaseChatModel) {
    this.llm = llm;
  }
  
  async query(
    userQuery: string,
    queryGraph: (cypher: string) => Promise<any>,
    retrieveCode: (nodeId: string) => Promise<string>
  ) {
    // Start with the system prompt
    let conversation = [
      { role: 'system', content: RAG_ORCHESTRATOR_SYSTEM_PROMPT }
    ];
  
    // Add the user's question
    conversation.push({ role: 'user', content: userQuery });
  
    // Simple ReAct loop
    for (let i = 0; i < 5; i++) { // Max 5 steps
      const response = await this.llm.call(conversation);
      const responseContent = response.content;
    
      // Check if the response contains a tool call
      if (responseContent.includes('Action: query_graph')) {
        const match = responseContent.match(/Action Input: (.*)/);
        if (match) {
          const cypherQuery = match[1].trim();
        
          // Execute the query
          const queryResults = await queryGraph(cypherQuery);
        
          // Add the observation to the conversation
          conversation.push({
            role: 'assistant',
            content: responseContent
          });
        
          conversation.push({
            role: 'system',
            content: `Observation: ${JSON.stringify(queryResults)}`
          });
        
          // If we have results, we might be done
          if (queryResults.length > 0) {
            break;
          }
        }
      } 
      else if (responseContent.includes('Action: retrieve_code')) {
        // Similar handling for code retrieval
      }
      else {
        // This appears to be the final answer
        return responseContent;
      }
    }
  
    // If we got here without a final answer, generate one
    conversation.push({
      role: 'user',
      content: 'Please provide your final answer based on the information gathered.'
    });
  
    const finalResponse = await this.llm.call(conversation);
    return finalResponse.content;
  }
}
```

**How this works:**

1. It starts with a system prompt that defines the rules
2. It sends the user's query to the LLM
3. The LLM responds with either:
   - A tool call (query_graph or retrieve_code)
   - A final answer
4. If it's a tool call, it executes the tool and adds the result to the conversation
5. It repeats until it gets a final answer or hits the step limit

**Why the step limit?** To prevent infinite loops if the LLM gets stuck.

## Phase 6: Main Application Integration

### Step 14: Create Main Application Component

**Why this matters:** This brings all the pieces together into a cohesive UI.

**Implementation:**

```tsx
import React, { useState, useRef } from 'react';
import { GraphVisualization } from '@/ui/components/graph/Visualization';
import { GraphControls } from '@/ui/components/graph/Controls';
import { SourceViewer } from '@/ui/components/graph/SourceViewer';
import { ChatInterface } from '@/ui/components/chat/ChatInterface';
import { KnowledgeGraph } from '@/core/graph/types';
import { GitHubService } from '@/services/github';
import { ZipService } from '@/services/zip';
import { ingestionWorkerApi } from '@/lib/workerUtils';

export const HomePage = () => {
  const [graph, setGraph] = useState<KnowledgeGraph | null>(null);
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [repoUrl, setRepoUrl] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  const handleRepoSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!repoUrl.trim() || isLoading) return;
  
    setIsLoading(true);
    setError(null);
  
    try {
      // Parse the GitHub URL
      const urlMatch = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
      if (!urlMatch) {
        throw new Error('Invalid GitHub repository URL');
      }
    
      const owner = urlMatch[1];
      const repo = urlMatch[2].replace(/\.git$/, '');
    
      // Fetch repository contents
      const githubService = new GitHubService();
      const contents = await githubService.getRepoContents(owner, repo);
    
      // Filter for Python files
      const pythonFiles = contents
        .filter((item: any) => item.type === 'file' && item.name.endsWith('.py'))
        .map((item: any) => item.path);
    
      // Fetch file contents
      const fileContents: Record<string, string> = {};
      for (const filePath of pythonFiles) {
        fileContents[filePath] = await githubService.getFileContent(owner, repo, filePath);
      }
    
      // Process the repository
      const projectName = `${owner}/${repo}`;
      const processedGraph = await ingestionWorkerApi.processRepository(
        repoUrl,
        projectName,
        pythonFiles,
        fileContents
      );
    
      setGraph(processedGraph);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to process repository');
      console.error('Processing error:', err);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleQuery = async (query: string): Promise<string> => {
    if (!graph) {
      throw new Error('No graph available');
    }
  
    // In a real implementation, this would use the RAG orchestrator
    return `I found information related to "${query}" in the codebase.`;
  };
  
  return (
    <div className="h-screen flex flex-col">
      {/* Header with repository input */}
      <header className="p-4 bg-white border-b border-gray-200">
        <div className="max-w-7xl mx-auto flex flex-col sm:flex-row sm:items-center gap-4">
          <h1 className="text-2xl font-bold text-gray-900">GitNexus</h1>
        
          <div className="flex-1 flex gap-2">
            <form onSubmit={handleRepoSubmit} className="flex-1">
              <div className="flex gap-2">
                <input
                  type="text"
                  value={repoUrl}
                  onChange={(e) => setRepoUrl(e.target.value)}
                  placeholder="https://github.com/owner/repo.git"
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                />
                <button
                  type="submit"
                  disabled={isLoading}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
                >
                  {isLoading ? 'Processing...' : 'Analyze'}
                </button>
              </div>
            </form>
          
            <div className="flex items-center">
              <span className="text-gray-500 mx-2">or</span>
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleZipUpload}
                accept=".zip"
                className="hidden"
                id="zip-upload"
              />
              <label
                htmlFor="zip-upload"
                className="px-3 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 cursor-pointer"
              >
                Upload ZIP
              </label>
            </div>
          </div>
        </div>
      </header>
    
      <main className="flex-1 max-w-7xl mx-auto w-full flex gap-4 p-4">
        {/* Graph Visualization Pane */}
        <div className="flex-1 flex flex-col min-w-0">
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col">
            {graph ? (
              <>
                <GraphControls 
                  onFilterChange={() => {}} 
                  onLayoutChange={() => {}} 
                />
                <div className="flex-1 min-h-0">
                  <GraphVisualization 
                    graph={graph} 
                    onNodeClick={setSelectedNodeId}
                  />
                </div>
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                {isLoading ? (
                  <div className="text-center">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
                    <p>Processing repository...</p>
                  </div>
                ) : (
                  <p>Enter a repository URL or upload a ZIP to get started</p>
                )}
              </div>
            )}
          </div>
        </div>
      
        {/* Right Panel */}
        <div className="w-80 flex flex-col gap-4">
          {/* Source Viewer */}
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col h-[40%]">
            <div className="p-3 border-b border-gray-200 bg-gray-50">
              <h2 className="text-sm font-medium text-gray-700">Source Code</h2>
            </div>
            {graph ? (
              <SourceViewer graph={graph} selectedNodeId={selectedNodeId} />
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                <p>Select a node to view source</p>
              </div>
            )}
          </div>
        
          {/* Chat Interface */}
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col h-[60%]">
            <div className="p-3 border-b border-gray-200 bg-gray-50">
              <h2 className="text-sm font-medium text-gray-700">Ask About Code</h2>
            </div>
            {graph ? (
              <ChatInterface graph={graph} onQuery={handleQuery} />
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500 p-4">
                <p>Process a repository to ask questions about the code</p>
              </div>
            )}
          </div>
        </div>
      </main>
    </div>
  );
};
```

**How this works:**

1. The header has inputs for GitHub URLs and ZIP uploads
2. The main area has two panes:
   - Left: Graph visualization
   - Right: Source viewer and chat interface
3. When a repository is processed, the graph is displayed
4. Users can click nodes to see source code and ask questions

**Why this layout?** It provides a cohesive experience where users can:

- See the big picture (graph)
- Drill down to specific code (source viewer)
- Ask questions about what they're seeing (chat)

## Final Steps: Testing and Optimization

### Step 15: Add Error Boundaries

**Why this matters:** Inevitably, something will go wrong. We want to handle errors gracefully.

**Implementation:**

```tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="p-4 bg-red-50 border border-red-200 rounded-md">
          <h2 className="text-lg font-medium text-red-800 mb-2">Something went wrong</h2>
          <p className="text-red-700 mb-2">{this.state.error?.message}</p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            className="px-3 py-1 bg-red-100 text-red-700 rounded-md hover:bg-red-200"
          >
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**How this works:**

- It catches JavaScript errors in child components
- It displays a friendly error message instead of a blank screen
- It allows users to try again without losing their work

**Why use error boundaries?** They prevent a single error from breaking the entire application.

### Step 16: Implement Performance Optimizations

**Why this matters:** Large repositories can be slow to process. We need to keep the UI responsive.

**Key optimizations:**

1. **Web Workers**: Already implemented for graph processing
2. **Progress Indicators**: Show users what's happening
3. **File Filtering**: Only process relevant files
4. **Lazy Loading**: Load components as needed

**Implementation:**

```tsx
// Add to your GitHub processing function
const MAX_FILES = 500; // Limit for free tier
if (pythonFiles.length > MAX_FILES) {
  // Offer to filter by directory or file pattern
  const shouldFilter = window.confirm(
    `Repository has ${pythonFiles.length} Python files (max ${MAX_FILES}). ` +
    `Would you like to filter by directory or file pattern?`
  );
  if (shouldFilter) {
    const filterPattern = prompt(
      "Enter a directory path or file pattern to filter (e.g., 'src/', '*.py')",
      "src/"
    );
    if (filterPattern) {
      const filteredFiles = pythonFiles.filter(file => 
        file.includes(filterPattern) || file.endsWith(filterPattern)
      );
      pythonFiles = filteredFiles;
    }
  }
}
```

**Why limit file processing?** Processing too many files can:

- Freeze the browser tab
- Exceed GitHub API rate limits
- Use excessive memory

### Step 17: Add Export Functionality

**Why this matters:** Users might want to save or share their generated graphs.

**Implementation:**

```tsx
export function exportGraphToJson(graph: KnowledgeGraph): string {
  return JSON.stringify(graph, null, 2);
}

export function downloadGraph(graph: KnowledgeGraph, filename: string = 'gitnexus-graph.json') {
  const json = exportGraphToJson(graph);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
```

**How this works:**

1. Converts the graph to JSON
2. Creates a downloadable file
3. Triggers a download

**Why include export?** It allows users to:

- Save their work for later
- Share graphs with teammates
- Use the data in other tools

## Conclusion

This implementation guide has walked you through building a complete edge-based code knowledge graph generator using Deno. By following these steps, you'll create a privacy-focused tool that runs entirely in the user's browser.

**Key advantages of this approach:**

- **Zero server costs**: All processing happens in the user's browser
- **Strong privacy**: Code never leaves the user's machine
- **Modular architecture**: Easy to add more languages later
- **Clear separation of concerns**: Makes the codebase maintainable
- **Deno compatibility**: Modern runtime with built-in TypeScript support

Remember to start small (Python support only) and iterate, adding more features and language support as you validate the core functionality. The most important part is getting the graph construction pipeline working correctly - everything else builds on that foundation.

Good luck with your implementation of GitNexus!

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: README.md
================
# GitNexus: Edge-Based Code Knowledge Graph Generator for Deno - Step-by-Step Implementation Guide

This guide will walk you through building a fully edge-based code knowledge graph generator from scratch using Deno. I'll explain each concept before showing the implementation, so you understand **why** we're doing something, not just **how** to do it.

## Phase 1: Project Setup & Core Infrastructure

### Step 1: Project Structure and Tooling Setup

**Why this matters:** Before writing any code, we need to set up our development environment properly. A well-structured project makes it easier to add features later and keeps everything organized.

**Key concepts:**

- We're using Vite (a modern build tool) with React and TypeScript
- We need special configuration for WebAssembly (WASM) files
- A clear directory structure helps us scale to multiple languages later

**Implementation Steps:**

1. **Create the base project:**

```bash
# Create project root
mkdir GitNexus
cd GitNexus

# Initialize Vite project with React and TypeScript
npm create vite@latest . -- --template react-ts

# Initialize Deno project
deno init
```

2. **Create the application directory structure:**

```bash
# Create directories for our core components
mkdir -p src/{core,core/tree-sitter,core/graph,core/ingestion,services,ai,ai/agents,ai/prompts,ui,ui/components,ui/components/graph,ui/components/chat,ui/hooks,workers,lib,config,store}
```

**Why this structure?**

- `core/`: Contains the engine that builds the knowledge graph
- `services/`: Handles external interactions (GitHub API, ZIP processing)
- `ai/`: Contains the RAG and chat functionality
- `ui/`: All user interface components
- `workers/`: Web Workers for heavy processing (keeps UI responsive)
- `lib/`: Utility functions used throughout the app

### Step 2: Configure Build Tools for WASM

**Why this matters:** WebAssembly (WASM) is how we'll run the Tree-sitter parsers in the browser. We need special configuration to handle these binary files correctly.

**Key concepts:**

- WASM files are binary files that run at near-native speed in browsers
- Vite needs special configuration to handle them properly
- We want to avoid inlining large WASM files in our JavaScript bundles

**Implementation:**

1. **Update `vite.config.ts`:**

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
export default defineConfig({
  plugins: [react()],
  worker: {
    format: 'es'
  },
  assetsInclude: ['**/*.wasm'],
  build: {
    target: 'esnext',
    assetsInlineLimit: 0 // Don't inline WASM files
  }
})
```

**What this does:**

- `assetsInclude: ['**/*.wasm']` tells Vite to treat WASM files as assets
- `assetsInlineLimit: 0` ensures WASM files aren't inlined into JavaScript (they're too large)
- `worker: { format: 'es' }` configures Web Workers to use ES modules

2. **Configure TypeScript** with a `tsconfig.json` that has strict settings for better code quality.

**Why strict settings?** They help catch errors early and make the code more maintainable as the project grows.

### Step 3: Set Up WASM Parser Infrastructure

**Why this matters:** Tree-sitter is the engine that parses code into ASTs (Abstract Syntax Trees). We need to get these parsers working in the browser via WASM.

**Key concepts:**

- Tree-sitter parsers for different languages are written in C
- We compile them to WASM so they can run in browsers
- We need to load these parsers on demand

**Implementation:**

1. **Create a public directory for WASM files:**

```bash
mkdir -p public/wasm/python
```

2. **Download the Tree-sitter Python parser:**
   - Get `tree-sitter-python.wasm` from [tree-sitter-python releases](https://github.com/tree-sitter/tree-sitter-python/releases)
   - Place it in `public/wasm/python/`

**Why host WASM files separately?** Browsers can't access the user's file system directly for security reasons. We need to serve the WASM files from a URL.

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase - Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase - Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase - Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

3. **Create a loader for Tree-sitter parsers:**

```typescript
import WebTreeSitter from 'web-tree-sitter';
let parserInstance: WebTreeSitter | null = null;
const parserCache = new Map<string, WebTreeSitter.Language>();

export async function initTreeSitter() {
  if (parserInstance) return parserInstance;
  parserInstance = await WebTreeSitter.init();
  return parserInstance;
}

export async function loadPythonParser(): Promise<WebTreeSitter.Language> {
  if (parserCache.has('python')) {
    return parserCache.get('python')!;
  }
  const Parser = await initTreeSitter();
  const pythonLang = await Parser.Language.load(
    '/wasm/python/tree-sitter-python.wasm'
  );
  parserCache.set('python', pythonLang);
  return pythonLang;
}
```

**How this works:**

1. `initTreeSitter()` initializes the WebAssembly module once
2. `loadPythonParser()` loads the Python parser from the WASM file
3. We cache parsers to avoid reloading them multiple times

**Why cache parsers?** Loading WASM files is relatively slow, so we want to do it once and reuse the parsers.

## Phase 2: Code Acquisition Module

### Step 4: Implement GitHub API Integration

**Why this matters:** Users will want to analyze public GitHub repositories, so we need a way to fetch code from GitHub.

**Key concepts:**

- GitHub has a REST API for accessing repository contents
- We need to handle rate limits (GitHub limits how many requests you can make)
- We'll let users provide their own API tokens for higher limits

**Implementation:**

```typescript
export class GitHubService {
  private token: string | null = null;
  
  setToken(token: string) {
    this.token = token;
  }
  
  async getRepoContents(owner: string, repo: string, path = '') {
    const headers: HeadersInit = {
      'Accept': 'application/vnd.github.v3+json'
    };
    if (this.token) {
      headers['Authorization'] = `token ${this.token}`;
    }
  
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${path}`,
      { headers }
    );
  
    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status}`);
    }
  
    return response.json();
  }
}
```

**How this works:**

- `getRepoContents()` fetches the directory structure of a repository
- It uses the GitHub API with proper headers
- It handles authentication via a token

**Important note:** GitHub API has rate limits. For unauthenticated requests, it's about 60 requests/hour. With a token, it's 5,000/hour.

### Step 5: Implement ZIP Processing

**Why this matters:** Not all code is on GitHub. Users might want to analyze local code or private repositories by uploading a ZIP file.

**Key concepts:**

- JSZip is a library for handling ZIP files in JavaScript
- We need to extract files and their contents from the ZIP
- We'll use a Map to store file paths and contents

**Implementation:**

```typescript
import JSZip from 'jszip';

export class ZipService {
  async processZip(file: File): Promise<Map<string, string>> {
    const zip = await JSZip.loadAsync(file);
    const files = new Map<string, string>();
  
    for (const [filePath, zipEntry] of Object.entries(zip.files)) {
      if (!zipEntry.dir) {
        const content = await zipEntry.async('text');
        files.set(filePath, content);
      }
    }
  
    return files;
  }
}
```

**How this works:**

1. `JSZip.loadAsync(file)` loads the ZIP file
2. We iterate through all entries in the ZIP
3. For each file (not directory), we extract its content as text
4. We store the file path and content in a Map

**Why use a Map?** It provides O(1) lookups by file path, which is important when we need to find files during graph construction.

## Phase 3: Graph Construction Pipeline

### Step 6: Define Graph Data Structures

**Why this matters:** Before we can build a graph, we need to define what nodes and relationships look like.

**Key concepts:**

- A knowledge graph consists of nodes and relationships
- Nodes represent code elements (functions, classes, etc.)
- Relationships represent connections between elements (calls, contains, etc.)

**Implementation:**

```typescript
export type NodeLabel = 
  | 'Project' 
  | 'Package' 
  | 'Module' 
  | 'Folder' 
  | 'File' 
  | 'Class' 
  | 'Function' 
  | 'Method' 
  | 'Variable';

export interface GraphNode {
  id: string;
  label: NodeLabel;
  properties: Record<string, any>;
}

export type RelationshipType = 
  | 'CONTAINS'
  | 'CALLS'
  | 'INHERITS'
  | 'OVERRIDES'
  | 'IMPORTS';

export interface GraphRelationship {
  id: string;
  type: RelationshipType;
  source: string;
  target: string;
  properties?: Record<string, any>;
}

export interface KnowledgeGraph {
  nodes: GraphNode[];
  relationships: GraphRelationship[];
}
```

**Why these specific types?**

- `NodeLabel` defines all possible types of code elements we'll track
- `RelationshipType` defines how code elements connect to each other
- `KnowledgeGraph` is the complete structure we'll build

**Important relationships:**

- `CONTAINS`: A folder contains files, a file contains functions
- `CALLS`: A function calls another function
- `IMPORTS`: One module imports from another

### Step 7: Implement the 3-Pass Ingestion Pipeline

**Why this matters:** Building a complete knowledge graph requires multiple passes to handle cross-file references properly.

**Key concepts:**

- **Pass 1**: Identify the overall structure (folders, modules)
- **Pass 2**: Parse individual files and cache ASTs
- **Pass 3**: Process function calls across files (the hardest part)

This three-pass approach solves the "island problem" - where functions in different files appear disconnected.

#### Pass 1: Structure Identification

```typescript
export class StructureProcessor {
  private graph: KnowledgeGraph;
  private projectRoot: string;
  private projectName: string;
  
  constructor(graph: KnowledgeGraph, projectRoot: string, projectName: string) {
    this.graph = graph;
    this.projectRoot = projectRoot;
    this.projectName = projectName;
  }
  
  identifyStructure(filePaths: string[]): void {
    // Add Project node
    this.graph.nodes.push({
      id: `project:${this.projectName}`,
      label: 'Project',
      properties: { name: this.projectName }
    });
  
    // Track directory structure
    const directories = new Set<string>();
    for (const filePath of filePaths) {
      const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
      if (dirPath && !directories.has(dirPath)) {
        directories.add(dirPath);
        // Create Folder node
        this.graph.nodes.push({
          id: `folder:${dirPath}`,
          label: 'Folder',
          properties: { path: dirPath }
        });
      
        // Create CONTAINS relationship with parent
        if (dirPath.includes('/')) {
          const parentPath = dirPath.substring(0, dirPath.lastIndexOf('/'));
          this.graph.relationships.push({
            id: `rel:folder:${dirPath}:parent`,
            type: 'CONTAINS',
            source: `folder:${parentPath}`,
            target: `folder:${dirPath}`
          });
        } else {
          // Root folder connects to project
          this.graph.relationships.push({
            id: `rel:folder:${dirPath}:project`,
            type: 'CONTAINS',
            source: `project:${this.projectName}`,
            target: `folder:${dirPath}`
          });
        }
      }
    }
  }
}
```

**How this works:**

1. Creates a root Project node
2. Walks through all file paths to identify directories
3. Creates Folder nodes and CONTAINS relationships

**Why identify structure first?** We need to know the overall organization before parsing individual files.

#### Pass 2: File Parsing

```typescript
export class ParsingProcessor {
  private graph: KnowledgeGraph;
  private astCache = new Map<string, any>();
  
  constructor(graph: KnowledgeGraph) {
    this.graph = graph;
  }
  
  async parseFiles(filePaths: string[], fileContents: Map<string, string>): Promise<Map<string, any>> {
    for (const [filePath, content] of fileContents) {
      if (filePath.endsWith('.py')) {
        await this.parsePythonFile(filePath, content);
      }
    }
    return this.astCache;
  }
  
  private async parsePythonFile(filePath: string, content: string): Promise<void> {
    const parser = await loadPythonParser();
    const tree = parser.parse(content);
    // Cache the AST
    this.astCache.set(filePath, tree);
    // Extract definitions from the AST
    this.extractDefinitions(filePath, tree, content);
  }
  
  private extractDefinitions(filePath: string, tree: any, content: string): void {
    // Extract modules
    this.graph.nodes.push({
      id: `module:${filePath}`,
      label: 'Module',
      properties: { 
        path: filePath,
        name: filePath.split('/').pop()!.replace('.py', ''),
        extension: '.py'
      }
    });
  
    // Extract functions from the AST
    const rootNode = tree.rootNode;
    const functionDefs = rootNode.descendantsOfType('function_definition');
    for (const funcNode of functionDefs) {
      const nameNode = funcNode.childForFieldName('name');
      const name = nameNode ? nameNode.text : 'unknown';
    
      // Calculate position
      const startLine = funcNode.startPosition.row + 1;
    
      // Create function node
      this.graph.nodes.push({
        id: `function:${filePath}:${name}`,
        label: 'Function',
        properties: {
          name,
          qualified_name: `${this.getModuleName(filePath)}.${name}`,
          path: filePath,
          start_line: startLine
        }
      });
    
      // Create CONTAINS relationship with module
      this.graph.relationships.push({
        id: `rel:function:${filePath}:${name}:module`,
        type: 'CONTAINS',
        source: `module:${filePath}`,
        target: `function:${filePath}:${name}`
      });
    }
  }
}
```

**How this works:**

1. Parses each file with the appropriate Tree-sitter parser
2. Caches the AST for later use
3. Extracts definitions (functions, classes) from the AST
4. Creates nodes and relationships in the graph

**Why cache ASTs?** We need them in Pass 3 to resolve cross-file function calls.

#### Pass 3: Call Resolution

```typescript
export class CallProcessor {
  private graph: KnowledgeGraph;
  private astCache: Map<string, any>;
  private projectRoot: string;
  private projectName: string;
  
  constructor(
    graph: KnowledgeGraph,
    astCache: Map<string, any>,
    projectRoot: string,
    projectName: string
  ) {
    this.graph = graph;
    this.astCache = astCache;
    this.projectRoot = projectRoot;
    this.projectName = projectName;
  }
  
  processCalls(): void {
    for (const [filePath, tree] of this.astCache) {
      if (filePath.endsWith('.py')) {
        this.processPythonCalls(filePath, tree);
      }
    }
  }
  
  private processPythonCalls(filePath: string, tree: any): void {
    const rootNode = tree.rootNode;
    // Find all call expressions
    const callExpressions = rootNode.descendantsOfType('call');
    for (const callNode of callExpressions) {
      const functionNameNode = callNode.childForFieldName('function');
      if (!functionNameNode) continue;
    
      // Handle different types of function references
      let targetFunctionName = '';
      if (functionNameNode.type === 'identifier') {
        targetFunctionName = functionNameNode.text;
      } else if (functionNameNode.type === 'attribute') {
        // Handle method calls like obj.method()
        const attrNode = functionNameNode;
        const objectNode = attrNode.childForFieldName('object');
        const attrNameNode = attrNode.childForFieldName('attribute');
        if (objectNode && attrNameNode) {
          const objectName = objectNode.text;
          const methodName = attrNameNode.text;
          targetFunctionName = `${objectName}.${methodName}`;
        }
      }
    
      if (!targetFunctionName) continue;
    
      // Try to resolve the target function
      const targetNode = this.resolveTargetFunction(targetFunctionName, filePath);
      if (targetNode) {
        // Create CALLS relationship
        const callerId = this.getCallerId(callNode, filePath);
        this.graph.relationships.push({
          id: `rel:call:${callerId}:${targetNode.id}`,
          type: 'CALLS',
          source: callerId,
          target: targetNode.id
        });
      }
    }
  }
  
  private resolveTargetFunction(targetName: string, currentFilePath: string): { id: string; type: string } | null {
    // 1. Check if it's a built-in function
    if (this.isBuiltInFunction(targetName)) {
      return {
        id: `builtin:${targetName}`,
        type: 'builtin'
      };
    }
  
    // 2. Check if it's an imported function
    const importInfo = this.findImportForFunction(targetName, currentFilePath);
    if (importInfo) {
      const targetId = `function:${importInfo.sourceFile}:${importInfo.targetName}`;
      return {
        id: targetId,
        type: 'imported'
      };
    }
  
    // 3. Check if it's defined in the current file
    for (const node of this.graph.nodes) {
      if (node.label === 'Function' && 
          node.properties.name === targetName &&
          node.properties.path === currentFilePath) {
        return {
          id: node.id,
          type: 'local'
        };
      }
    }
  
    return null;
  }
}
```

**How this works:**

1. Finds all function calls in the AST
2. Determines what function is being called
3. Resolves the target function across files using imports
4. Creates CALLS relationships in the graph

**Why is this the hardest part?** Resolving cross-file references requires understanding:

- How imports work in the language
- How to map a simple name to a fully qualified name
- Handling edge cases like aliases (`import helper as h`)

### Step 8: Implement Web Workers for Performance

**Why this matters:** Parsing code and building graphs can be CPU-intensive. Web Workers keep the UI responsive.

**Key concepts:**

- Web Workers run JavaScript in background threads
- They can't access the DOM directly
- We use Comlink to simplify communication

**Implementation:**

```typescript
// src/workers/ingestion.worker.ts
import { expose } from 'comlink';
import { GraphPipeline } from '../core/ingestion/pipeline';

class IngestionWorker {
  async processRepository(
    projectRoot: string,
    projectName: string,
    filePaths: string[],
    fileContents: Record<string, string>
  ) {
    const pipeline = new GraphPipeline(projectRoot, projectName);
    return pipeline.run(filePaths, new Map(Object.entries(fileContents)));
  }
}

expose(new IngestionWorker());
```

**How this works:**

1. The worker runs the heavy processing in a background thread
2. We expose methods via Comlink to call them from the main thread
3. The main thread can call these methods without blocking the UI

**Why use Web Workers?** Without them, large repositories would freeze the browser tab while processing.

## Phase 4: Graph Visualization

### Step 9: Implement Graph Visualization Components

**Why this matters:** A knowledge graph is useless if users can't see and interact with it.

**Key concepts:**

- Cytoscape.js is a powerful graph visualization library
- We need to convert our graph data to Cytoscape's format
- Users need controls to filter and navigate the graph

**Implementation:**

```tsx
import React, { useEffect, useRef } from 'react';
import cytoscape from 'cytoscape';
import dagre from 'cytoscape-dagre';
import { KnowledgeGraph } from '@/core/graph/types';

cytoscape.use(dagre);

interface GraphVisualizationProps {
  graph: KnowledgeGraph;
  onNodeClick?: (nodeId: string) => void;
  filter?: (node: any) => boolean;
}

export const GraphVisualization: React.FC<GraphVisualizationProps> = ({ 
  graph, 
  onNodeClick,
  filter 
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const cyRef = useRef<cytoscape.Core | null>(null);
  
  useEffect(() => {
    if (!containerRef.current) return;
  
    // Clean up previous instance
    if (cyRef.current) {
      cyRef.current.destroy();
    }
  
    // Convert our graph to Cytoscape format
    const cyElements = convertToCytoscapeElements(graph, filter);
  
    const cy = cytoscape({
      container: containerRef.current,
      elements: cyElements,
      style: [
        {
          selector: 'node',
          style: {
            'label': 'data(label)',
            'width': 'mapData(size, 0, 100, 20, 80)',
            'height': 'mapData(size, 0, 100, 20, 80)',
            'background-color': 'data(color)',
            'text-valign': 'center',
            'text-halign': 'center',
            'font-size': '8px'
          }
        },
        {
          selector: 'edge',
          style: {
            'width': 2,
            'line-color': '#ccc',
            'target-arrow-color': '#ccc',
            'target-arrow-shape': 'triangle'
          }
        }
      ],
      layout: {
        name: 'dagre',
        rankDir: 'TB',
        padding: 20
      }
    });
  
    // Add interactions
    cy.on('tap', 'node', (event) => {
      const node = event.target;
      const nodeId = node.data('id');
      if (onNodeClick) {
        onNodeClick(nodeId);
      }
    });
  
    cyRef.current = cy;
  
    return () => {
      if (cyRef.current) {
        cyRef.current.destroy();
        cyRef.current = null;
      }
    };
  }, [graph, filter]);
  
  return (
    <div 
      ref={containerRef} 
      className="w-full h-full bg-white rounded-lg border border-gray-200"
    />
  );
};

function convertToCytoscapeElements(
  graph: KnowledgeGraph, 
  filter?: (node: any) => boolean
) {
  const elements: any[] = [];
  
  // Add nodes
  for (const node of graph.nodes) {
    if (filter && !filter(node)) continue;
    elements.push({
      data: {
        id: node.id,
        label: getNodeLabel(node),
        type: node.label,
        color: getNodeColor(node.label),
        size: getNodeSize(node)
      }
    });
  }
  
  // Add edges
  for (const rel of graph.relationships) {
    elements.push({
      data: {
        id: rel.id,
        source: rel.source,
        target: rel.target,
        label: rel.type
      }
    });
  }
  
  return elements;
}
```

**How this works:**

1. Converts our graph data to Cytoscape's format
2. Sets up visual styles based on node type
3. Applies a hierarchical layout (dagre)
4. Adds interaction handlers for node clicks

**Why use Cytoscape.js?** It's specifically designed for graph visualization with:

- Multiple layout algorithms
- Good performance for medium-sized graphs
- Extensive customization options

### Step 10: Create Source Code Viewer

**Why this matters:** Seeing the graph isn't enough - users need to see the actual code behind the nodes.

**Implementation:**

```tsx
import React, { useState, useEffect } from 'react';
import { KnowledgeGraph } from '@/core/graph/types';

interface SourceViewerProps {
  graph: KnowledgeGraph;
  selectedNodeId: string | null;
}

export const SourceViewer: React.FC<SourceViewerProps> = ({ graph, selectedNodeId }) => {
  const [sourceCode, setSourceCode] = useState<string>('');
  const [fileName, setFileName] = useState<string>('');
  const [lineNumber, setLineNumber] = useState<number | null>(null);
  
  useEffect(() => {
    if (!selectedNodeId) {
      setSourceCode('');
      setFileName('');
      setLineNumber(null);
      return;
    }
  
    // Find the node in the graph
    const node = graph.nodes.find(n => n.id === selectedNodeId);
    if (!node) return;
  
    // For functions, get the source code
    if (node.label === 'Function' || node.label === 'Method') {
      const filePath = node.properties.path;
      const startLine = node.properties.start_line;
    
      // In a real implementation, you'd have the source code available
      setFileName(filePath);
      setLineNumber(startLine);
      setSourceCode(`# Source code for ${node.properties.qualified_name}
# Line ${startLine} and following...`);
    }
  }, [graph, selectedNodeId]);
  
  if (!selectedNodeId || !sourceCode) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50">
        <p className="text-gray-500">Select a node to view source code</p>
      </div>
    );
  }
  
  return (
    <div className="flex flex-col h-full">
      <div className="p-2 bg-gray-100 border-b border-gray-200 flex justify-between items-center">
        <span className="text-sm font-medium text-gray-700 truncate">{fileName}</span>
        {lineNumber && (
          <span className="text-xs text-gray-500">Line {lineNumber}</span>
        )}
      </div>
      <div className="flex-1 overflow-auto p-2 font-mono text-sm bg-black text-white">
        <pre>{sourceCode}</pre>
      </div>
    </div>
  );
};
```

**How this works:**

1. When a node is selected, it finds the corresponding code element
2. It displays the source code with line numbers
3. It highlights the relevant part of the code

**Why is this important?** It bridges the gap between the abstract graph and the concrete code, helping users understand what they're seeing.

## Phase 5: RAG Chat Interface

### Step 11: Implement LLM Service

**Why this matters:** The chat interface needs to connect to LLMs (Large Language Models) to translate natural language to graph queries.

**Key concepts:**

- We'll support multiple LLM providers (OpenAI, Anthropic, Gemini)
- Users provide their own API keys (privacy-focused)
- We need a consistent interface for different providers

**Implementation:**

```typescript
import { ChatOpenAI } from 'langchain/chat_models/openai';
import { ChatAnthropic } from 'langchain/chat_models/anthropic';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';

export type LLMProvider = 'openai' | 'anthropic' | 'gemini';

export interface LLMConfig {
  provider: LLMProvider;
  apiKey: string;
  model?: string;
}

export class LLMService {
  private config: LLMConfig;
  
  constructor(config: LLMConfig) {
    this.config = config;
  }
  
  getChatModel() {
    switch (this.config.provider) {
      case 'openai':
        return new ChatOpenAI({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'gpt-4-turbo',
          temperature: 0
        });
      case 'anthropic':
        return new ChatAnthropic({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'claude-3-sonnet-20240229',
          temperature: 0
        });
      case 'gemini':
        return new ChatGoogleGenerativeAI({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'gemini-1.5-pro-latest',
          temperature: 0
        });
      default:
        throw new Error(`Unsupported LLM provider: ${this.config.provider}`);
    }
  }
}
```

**How this works:**

1. The service takes an LLM configuration (provider, API key, model)
2. It returns a consistent chat model interface regardless of provider
3. It handles provider-specific initialization

**Why support multiple providers?** Different users have different preferences and API key availability.

### Step 12: Implement Cypher Generator

**Why this matters:** The core of the RAG system - translating natural language questions to graph queries.

**Key concepts:**

- We use a system prompt to instruct the LLM
- The prompt includes our graph schema
- We clean the response to get a valid Cypher query

**Implementation:**

```typescript
import { BaseChatModel } from 'langchain/chat_models/base';
import { CYPHER_SYSTEM_PROMPT } from '../prompts/cypher';

export class CypherGenerator {
  private llm: BaseChatModel;
  
  constructor(llm: BaseChatModel) {
    this.llm = llm;
  }
  
  async generate(naturalLanguageQuery: string): Promise<string> {
    const response = await this.llm.call([
      { role: 'system', content: CYPHER_SYSTEM_PROMPT },
      { role: 'user', content: naturalLanguageQuery }
    ]);
  
    return this.cleanResponse(response.content);
  }
  
  private cleanResponse(response: string): string {
    // Remove markdown code blocks
    let cleaned = response.replace(/```cypher/g, '').replace(/```/g, '');
    // Ensure it ends with a semicolon
    if (!cleaned.trim().endsWith(';')) {
      cleaned = cleaned.trim() + ';';
    }
    return cleaned;
  }
}
```

**How this works:**

1. It sends the natural language query with a system prompt to the LLM
2. The system prompt teaches the LLM about our graph structure
3. It cleans the response to extract a valid Cypher query

**Why is the system prompt important?** It provides the LLM with the context it needs to generate correct queries. Without it, the LLM wouldn't know about our graph schema.

### Step 13: Implement RAG Orchestrator

**Why this matters:** This is the "brain" of the system that coordinates the query process.

**Key concepts:**

- It follows a ReAct (Reason + Act) pattern
- It plans steps, uses tools, observes results, and responds
- It prevents hallucination by sticking to tool results

**Implementation:**

```typescript
import { BaseChatModel } from 'langchain/chat_models/base';
import { RAG_ORCHESTRATOR_SYSTEM_PROMPT } from '../prompts/rag-orchestrator';

export class RAGOrchestrator {
  private llm: BaseChatModel;
  
  constructor(llm: BaseChatModel) {
    this.llm = llm;
  }
  
  async query(
    userQuery: string,
    queryGraph: (cypher: string) => Promise<any>,
    retrieveCode: (nodeId: string) => Promise<string>
  ) {
    // Start with the system prompt
    let conversation = [
      { role: 'system', content: RAG_ORCHESTRATOR_SYSTEM_PROMPT }
    ];
  
    // Add the user's question
    conversation.push({ role: 'user', content: userQuery });
  
    // Simple ReAct loop
    for (let i = 0; i < 5; i++) { // Max 5 steps
      const response = await this.llm.call(conversation);
      const responseContent = response.content;
    
      // Check if the response contains a tool call
      if (responseContent.includes('Action: query_graph')) {
        const match = responseContent.match(/Action Input: (.*)/);
        if (match) {
          const cypherQuery = match[1].trim();
        
          // Execute the query
          const queryResults = await queryGraph(cypherQuery);
        
          // Add the observation to the conversation
          conversation.push({
            role: 'assistant',
            content: responseContent
          });
        
          conversation.push({
            role: 'system',
            content: `Observation: ${JSON.stringify(queryResults)}`
          });
        
          // If we have results, we might be done
          if (queryResults.length > 0) {
            break;
          }
        }
      } 
      else if (responseContent.includes('Action: retrieve_code')) {
        // Similar handling for code retrieval
      }
      else {
        // This appears to be the final answer
        return responseContent;
      }
    }
  
    // If we got here without a final answer, generate one
    conversation.push({
      role: 'user',
      content: 'Please provide your final answer based on the information gathered.'
    });
  
    const finalResponse = await this.llm.call(conversation);
    return finalResponse.content;
  }
}
```

**How this works:**

1. It starts with a system prompt that defines the rules
2. It sends the user's query to the LLM
3. The LLM responds with either:
   - A tool call (query_graph or retrieve_code)
   - A final answer
4. If it's a tool call, it executes the tool and adds the result to the conversation
5. It repeats until it gets a final answer or hits the step limit

**Why the step limit?** To prevent infinite loops if the LLM gets stuck.

## Phase 6: Main Application Integration

### Step 14: Create Main Application Component

**Why this matters:** This brings all the pieces together into a cohesive UI.

**Implementation:**

```tsx
import React, { useState, useRef } from 'react';
import { GraphVisualization } from '@/ui/components/graph/Visualization';
import { GraphControls } from '@/ui/components/graph/Controls';
import { SourceViewer } from '@/ui/components/graph/SourceViewer';
import { ChatInterface } from '@/ui/components/chat/ChatInterface';
import { KnowledgeGraph } from '@/core/graph/types';
import { GitHubService } from '@/services/github';
import { ZipService } from '@/services/zip';
import { ingestionWorkerApi } from '@/lib/workerUtils';

export const HomePage = () => {
  const [graph, setGraph] = useState<KnowledgeGraph | null>(null);
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [repoUrl, setRepoUrl] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  const handleRepoSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!repoUrl.trim() || isLoading) return;
  
    setIsLoading(true);
    setError(null);
  
    try {
      // Parse the GitHub URL
      const urlMatch = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
      if (!urlMatch) {
        throw new Error('Invalid GitHub repository URL');
      }
    
      const owner = urlMatch[1];
      const repo = urlMatch[2].replace(/\.git$/, '');
    
      // Fetch repository contents
      const githubService = new GitHubService();
      const contents = await githubService.getRepoContents(owner, repo);
    
      // Filter for Python files
      const pythonFiles = contents
        .filter((item: any) => item.type === 'file' && item.name.endsWith('.py'))
        .map((item: any) => item.path);
    
      // Fetch file contents
      const fileContents: Record<string, string> = {};
      for (const filePath of pythonFiles) {
        fileContents[filePath] = await githubService.getFileContent(owner, repo, filePath);
      }
    
      // Process the repository
      const projectName = `${owner}/${repo}`;
      const processedGraph = await ingestionWorkerApi.processRepository(
        repoUrl,
        projectName,
        pythonFiles,
        fileContents
      );
    
      setGraph(processedGraph);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to process repository');
      console.error('Processing error:', err);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleQuery = async (query: string): Promise<string> => {
    if (!graph) {
      throw new Error('No graph available');
    }
  
    // In a real implementation, this would use the RAG orchestrator
    return `I found information related to "${query}" in the codebase.`;
  };
  
  return (
    <div className="h-screen flex flex-col">
      {/* Header with repository input */}
      <header className="p-4 bg-white border-b border-gray-200">
        <div className="max-w-7xl mx-auto flex flex-col sm:flex-row sm:items-center gap-4">
          <h1 className="text-2xl font-bold text-gray-900">GitNexus</h1>
        
          <div className="flex-1 flex gap-2">
            <form onSubmit={handleRepoSubmit} className="flex-1">
              <div className="flex gap-2">
                <input
                  type="text"
                  value={repoUrl}
                  onChange={(e) => setRepoUrl(e.target.value)}
                  placeholder="https://github.com/owner/repo.git"
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                />
                <button
                  type="submit"
                  disabled={isLoading}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
                >
                  {isLoading ? 'Processing...' : 'Analyze'}
                </button>
              </div>
            </form>
          
            <div className="flex items-center">
              <span className="text-gray-500 mx-2">or</span>
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleZipUpload}
                accept=".zip"
                className="hidden"
                id="zip-upload"
              />
              <label
                htmlFor="zip-upload"
                className="px-3 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 cursor-pointer"
              >
                Upload ZIP
              </label>
            </div>
          </div>
        </div>
      </header>
    
      <main className="flex-1 max-w-7xl mx-auto w-full flex gap-4 p-4">
        {/* Graph Visualization Pane */}
        <div className="flex-1 flex flex-col min-w-0">
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col">
            {graph ? (
              <>
                <GraphControls 
                  onFilterChange={() => {}} 
                  onLayoutChange={() => {}} 
                />
                <div className="flex-1 min-h-0">
                  <GraphVisualization 
                    graph={graph} 
                    onNodeClick={setSelectedNodeId}
                  />
                </div>
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                {isLoading ? (
                  <div className="text-center">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
                    <p>Processing repository...</p>
                  </div>
                ) : (
                  <p>Enter a repository URL or upload a ZIP to get started</p>
                )}
              </div>
            )}
          </div>
        </div>
      
        {/* Right Panel */}
        <div className="w-80 flex flex-col gap-4">
          {/* Source Viewer */}
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col h-[40%]">
            <div className="p-3 border-b border-gray-200 bg-gray-50">
              <h2 className="text-sm font-medium text-gray-700">Source Code</h2>
            </div>
            {graph ? (
              <SourceViewer graph={graph} selectedNodeId={selectedNodeId} />
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                <p>Select a node to view source</p>
              </div>
            )}
          </div>
        
          {/* Chat Interface */}
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col h-[60%]">
            <div className="p-3 border-b border-gray-200 bg-gray-50">
              <h2 className="text-sm font-medium text-gray-700">Ask About Code</h2>
            </div>
            {graph ? (
              <ChatInterface graph={graph} onQuery={handleQuery} />
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500 p-4">
                <p>Process a repository to ask questions about the code</p>
              </div>
            )}
          </div>
        </div>
      </main>
    </div>
  );
};
```

**How this works:**

1. The header has inputs for GitHub URLs and ZIP uploads
2. The main area has two panes:
   - Left: Graph visualization
   - Right: Source viewer and chat interface
3. When a repository is processed, the graph is displayed
4. Users can click nodes to see source code and ask questions

**Why this layout?** It provides a cohesive experience where users can:

- See the big picture (graph)
- Drill down to specific code (source viewer)
- Ask questions about what they're seeing (chat)

## Final Steps: Testing and Optimization

### Step 15: Add Error Boundaries

**Why this matters:** Inevitably, something will go wrong. We want to handle errors gracefully.

**Implementation:**

```tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="p-4 bg-red-50 border border-red-200 rounded-md">
          <h2 className="text-lg font-medium text-red-800 mb-2">Something went wrong</h2>
          <p className="text-red-700 mb-2">{this.state.error?.message}</p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            className="px-3 py-1 bg-red-100 text-red-700 rounded-md hover:bg-red-200"
          >
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**How this works:**

- It catches JavaScript errors in child components
- It displays a friendly error message instead of a blank screen
- It allows users to try again without losing their work

**Why use error boundaries?** They prevent a single error from breaking the entire application.

### Step 16: Implement Performance Optimizations

**Why this matters:** Large repositories can be slow to process. We need to keep the UI responsive.

**Key optimizations:**

1. **Web Workers**: Already implemented for graph processing
2. **Progress Indicators**: Show users what's happening
3. **File Filtering**: Only process relevant files
4. **Lazy Loading**: Load components as needed

**Implementation:**

```tsx
// Add to your GitHub processing function
const MAX_FILES = 500; // Limit for free tier
if (pythonFiles.length > MAX_FILES) {
  // Offer to filter by directory or file pattern
  const shouldFilter = window.confirm(
    `Repository has ${pythonFiles.length} Python files (max ${MAX_FILES}). ` +
    `Would you like to filter by directory or file pattern?`
  );
  if (shouldFilter) {
    const filterPattern = prompt(
      "Enter a directory path or file pattern to filter (e.g., 'src/', '*.py')",
      "src/"
    );
    if (filterPattern) {
      const filteredFiles = pythonFiles.filter(file => 
        file.includes(filterPattern) || file.endsWith(filterPattern)
      );
      pythonFiles = filteredFiles;
    }
  }
}
```

**Why limit file processing?** Processing too many files can:

- Freeze the browser tab
- Exceed GitHub API rate limits
- Use excessive memory

### Step 17: Add Export Functionality

**Why this matters:** Users might want to save or share their generated graphs.

**Implementation:**

```tsx
export function exportGraphToJson(graph: KnowledgeGraph): string {
  return JSON.stringify(graph, null, 2);
}

export function downloadGraph(graph: KnowledgeGraph, filename: string = 'gitnexus-graph.json') {
  const json = exportGraphToJson(graph);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
```

**How this works:**

1. Converts the graph to JSON
2. Creates a downloadable file
3. Triggers a download

**Why include export?** It allows users to:

- Save their work for later
- Share graphs with teammates
- Use the data in other tools

## Conclusion

This implementation guide has walked you through building a complete edge-based code knowledge graph generator using Deno. By following these steps, you'll create a privacy-focused tool that runs entirely in the user's browser.

**Key advantages of this approach:**

- **Zero server costs**: All processing happens in the user's browser
- **Strong privacy**: Code never leaves the user's machine
- **Modular architecture**: Easy to add more languages later
- **Clear separation of concerns**: Makes the codebase maintainable
- **Deno compatibility**: Modern runtime with built-in TypeScript support

Remember to start small (Python support only) and iterate, adding more features and language support as you validate the core functionality. The most important part is getting the graph construction pipeline working correctly - everything else builds on that foundation.

================
File: src/ai/cypher-generator.ts
================
import { HumanMessage, SystemMessage } from '@langchain/core/messages';
import type { LLMService, LLMConfig } from './llm-service.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface CypherQuery {
  cypher: string;
  explanation: string;
  confidence: number;
  warnings?: string[];
}

export interface CypherGenerationOptions {
  maxRetries?: number;
  includeExamples?: boolean;
  strictMode?: boolean;
}

export class CypherGenerator {
  private llmService: LLMService;
  private graphSchema: string = '';
  
  // Common Cypher patterns and examples
  private static readonly CYPHER_EXAMPLES = [
    {
      question: "What functions are in the main.py file?",
      cypher: "MATCH (f:File {name: 'main.py'})-[:CONTAINS]->(func:Function) RETURN func.name"
    },
    {
      question: "Which functions call the authenticate function?",
      cypher: "MATCH (caller)-[:CALLS]->(target:Function {name: 'authenticate'}) RETURN caller.name"
    },
    {
      question: "Show me all classes in the project",
      cypher: "MATCH (c:Class) RETURN c.name, c.filePath"
    },
    {
      question: "What modules import numpy?",
      cypher: "MATCH (m:Module)-[:IMPORTS]->(lib) WHERE lib.name CONTAINS 'numpy' RETURN m.name"
    }
  ];

  constructor(llmService: LLMService) {
    this.llmService = llmService;
  }

  /**
   * Update the graph schema for better query generation
   */
  public updateSchema(graph: KnowledgeGraph): void {
    this.graphSchema = this.generateSchemaDescription(graph);
  }

  /**
   * Generate a Cypher query from natural language
   */
  public async generateQuery(
    question: string,
    llmConfig: LLMConfig,
    options: CypherGenerationOptions = {}
  ): Promise<CypherQuery> {
    const { maxRetries = 2, includeExamples = true, strictMode = false } = options;
    
    let lastError: string | null = null;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const systemPrompt = this.buildSystemPrompt(includeExamples, strictMode, lastError);
        const userPrompt = this.buildUserPrompt(question);
        
        const messages = [
          new SystemMessage(systemPrompt),
          new HumanMessage(userPrompt)
        ];
        
        const response = await this.llmService.chat(llmConfig, messages);
        const result = this.parseResponse(response.content);
        
        // Validate the generated query
        const validation = this.validateQuery(result.cypher);
        if (!validation.isValid) {
          lastError = validation.error!;
          if (attempt < maxRetries) {
            console.warn(`Query validation failed (attempt ${attempt + 1}): ${validation.error}`);
            continue;
          }
        }
        
        return {
          ...result,
          warnings: validation.warnings
        };
        
      } catch (error) {
        lastError = error instanceof Error ? error.message : 'Unknown error';
        if (attempt < maxRetries) {
          console.warn(`Query generation failed (attempt ${attempt + 1}): ${lastError}`);
          continue;
        }
        
        throw new Error(`Failed to generate Cypher query after ${maxRetries + 1} attempts: ${lastError}`);
      }
    }
    
    throw new Error('Unexpected error in query generation');
  }

  /**
   * Build the system prompt with schema and examples
   */
  private buildSystemPrompt(includeExamples: boolean, strictMode: boolean, lastError?: string | null): string {
    let prompt = `You are a Cypher query expert for a code knowledge graph. Your task is to convert natural language questions into valid Cypher queries.

GRAPH SCHEMA:
${this.graphSchema}

NODE TYPES:
- Project: Root project node
- Folder: Directory containers
- File: Source code files
- Module: Python modules (.py files)
- Class: Class definitions
- Function: Function definitions
- Method: Class method definitions
- Variable: Variable declarations

RELATIONSHIP TYPES:
- CONTAINS: Hierarchical containment (Project->Folder, Folder->File, File->Function, etc.)
- CALLS: Function/method calls between code entities
- INHERITS: Class inheritance relationships
- IMPORTS: Module import relationships
- OVERRIDES: Method override relationships

IMPORTANT RULES:
1. Always use MATCH patterns to find nodes
2. Use WHERE clauses for filtering by properties
3. Node properties include: name, filePath, startLine, endLine, type
4. Return meaningful information, not just node IDs
5. Use case-insensitive matching when appropriate (e.g., WHERE toLower(n.name) CONTAINS toLower('search'))
6. Prefer specific node types over generic matches
7. Always return results in a readable format`;

    if (includeExamples) {
      prompt += `\n\nEXAMPLES:`;
      for (const example of CypherGenerator.CYPHER_EXAMPLES) {
        prompt += `\nQ: "${example.question}"\nA: ${example.cypher}\n`;
      }
    }

    if (strictMode) {
      prompt += `\n\nSTRICT MODE: Only generate queries that exactly match the schema. Do not make assumptions about node properties that aren't explicitly defined.`;
    }

    if (lastError) {
      prompt += `\n\nPREVIOUS ERROR: The last query attempt failed with: "${lastError}". Please fix this issue in your new query.`;
    }

    prompt += `\n\nRESPONSE FORMAT:
Provide your response in this exact JSON format:
{
  "cypher": "your cypher query here",
  "explanation": "brief explanation of what the query does",
  "confidence": 0.85
}

The confidence should be a number between 0 and 1 indicating how confident you are in the query.`;

    return prompt;
  }

  /**
   * Build the user prompt with the question
   */
  private buildUserPrompt(question: string): string {
    return `Please convert this question to a Cypher query: "${question}"`;
  }

  /**
   * Parse the LLM response to extract Cypher query
   */
  private parseResponse(response: string): { cypher: string; explanation: string; confidence: number } {
    try {
      // Try to extract JSON from the response
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          cypher: parsed.cypher || '',
          explanation: parsed.explanation || '',
          confidence: parsed.confidence || 0.5
        };
      }
      
      // Fallback: try to extract Cypher from code blocks
      const cypherMatch = response.match(/```(?:cypher)?\s*(.*?)\s*```/s);
      if (cypherMatch) {
        return {
          cypher: cypherMatch[1].trim(),
          explanation: 'Generated Cypher query',
          confidence: 0.7
        };
      }
      
      // Last resort: use the entire response as cypher
      return {
        cypher: response.trim(),
        explanation: 'Raw LLM response',
        confidence: 0.3
      };
      
    } catch (error) {
      throw new Error(`Failed to parse LLM response: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate the generated Cypher query
   */
  private validateQuery(cypher: string): { isValid: boolean; error?: string; warnings?: string[] } {
    const warnings: string[] = [];
    
    if (!cypher || cypher.trim().length === 0) {
      return { isValid: false, error: 'Empty query generated' };
    }
    
    // Basic syntax checks
    const upperCypher = cypher.toUpperCase();
    
    // Must have MATCH or CREATE or other valid starting keywords
    if (!upperCypher.match(/^\s*(MATCH|CREATE|MERGE|WITH|RETURN|CALL|SHOW)/)) {
      return { isValid: false, error: 'Query must start with a valid Cypher keyword (MATCH, CREATE, etc.)' };
    }
    
    // Check for balanced parentheses
    const openParens = (cypher.match(/\(/g) || []).length;
    const closeParens = (cypher.match(/\)/g) || []).length;
    if (openParens !== closeParens) {
      return { isValid: false, error: 'Unbalanced parentheses in query' };
    }
    
    // Check for balanced brackets
    const openBrackets = (cypher.match(/\[/g) || []).length;
    const closeBrackets = (cypher.match(/\]/g) || []).length;
    if (openBrackets !== closeBrackets) {
      return { isValid: false, error: 'Unbalanced brackets in query' };
    }
    
    // Check for balanced braces
    const openBraces = (cypher.match(/\{/g) || []).length;
    const closeBraces = (cypher.match(/\}/g) || []).length;
    if (openBraces !== closeBraces) {
      return { isValid: false, error: 'Unbalanced braces in query' };
    }
    
    // Warn about potentially expensive operations
    if (upperCypher.includes('MATCH ()') || upperCypher.includes('MATCH (*)')) {
      warnings.push('Query matches all nodes - this could be expensive');
    }
    
    if (!upperCypher.includes('RETURN') && !upperCypher.includes('DELETE') && !upperCypher.includes('SET')) {
      warnings.push('Query does not return results');
    }
    
    return { isValid: true, warnings };
  }

  /**
   * Generate a schema description from the knowledge graph
   */
  private generateSchemaDescription(graph: KnowledgeGraph): string {
    const nodeTypes = new Set<string>();
    const relationshipTypes = new Set<string>();
    const nodeProperties = new Map<string, Set<string>>();
    
    // Analyze nodes
    graph.nodes.forEach(node => {
      nodeTypes.add(node.label);
      
      if (!nodeProperties.has(node.label)) {
        nodeProperties.set(node.label, new Set());
      }
      
      Object.keys(node.properties).forEach(prop => {
        nodeProperties.get(node.label)!.add(prop);
      });
    });
    
    // Analyze relationships
    graph.relationships.forEach(rel => {
      relationshipTypes.add(rel.type);
    });
    
    let schema = `NODES (${graph.nodes.length} total):\n`;
    for (const nodeType of Array.from(nodeTypes).sort()) {
      const props = nodeProperties.get(nodeType);
      const propList = props ? Array.from(props).sort().join(', ') : 'none';
      const count = graph.nodes.filter(n => n.label === nodeType).length;
      schema += `- ${nodeType} (${count}): ${propList}\n`;
    }
    
    schema += `\nRELATIONSHIPS (${graph.relationships.length} total):\n`;
    for (const relType of Array.from(relationshipTypes).sort()) {
      const count = graph.relationships.filter(r => r.type === relType).length;
      schema += `- ${relType} (${count})\n`;
    }
    
    return schema;
  }

  /**
   * Get the current schema description
   */
  public getSchema(): string {
    return this.graphSchema;
  }

  /**
   * Clean and format a Cypher query
   */
  public cleanQuery(cypher: string): string {
    return cypher
      .trim()
      .replace(/\s+/g, ' ')
      .replace(/\s*([(),\[\]{}])\s*/g, '$1')
      .replace(/\s*([=<>!]+)\s*/g, ' $1 ')
      .replace(/\s+/g, ' ')
      .trim();
  }
}

================
File: src/ai/index.ts
================
export { LLMService, type LLMProvider, type LLMConfig, type ChatResponse } from './llm-service.ts';
export { CypherGenerator, type CypherQuery, type CypherGenerationOptions } from './cypher-generator.ts';
export { 
  RAGOrchestrator, 
  type RAGContext, 
  type RAGResponse, 
  type RAGOptions, 
  type ToolResult, 
  type ReasoningStep 
} from './orchestrator.ts';
export {
  LangChainRAGOrchestrator,
  type LangChainRAGContext,
  type LangChainRAGResponse,
  type LangChainRAGOptions
} from './langchain-orchestrator.ts';

================
File: src/ai/langchain-orchestrator.ts
================
import { createReactAgent } from '@langchain/langgraph/prebuilt';
import { MemorySaver } from '@langchain/langgraph';
import { DynamicStructuredTool } from '@langchain/core/tools';
import { z } from 'zod';
import { SystemMessage } from '@langchain/core/messages';
import type { LLMService, LLMConfig } from './llm-service.ts';
import type { CypherGenerator } from './cypher-generator.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface LangChainRAGContext {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
}

export interface ToolCall {
  tool: string;
  input: Record<string, unknown>;
  output: string;
}

export interface LangChainRAGResponse {
  answer: string;
  sources: string[];
  confidence: number;
  toolCalls: ToolCall[];
}

export interface LangChainRAGOptions {
  maxIterations?: number;
  temperature?: number;
  enableMemory?: boolean;
  threadId?: string;
}

type AgentType = ReturnType<typeof createReactAgent>;
type MemoryType = InstanceType<typeof MemorySaver>;

export class LangChainRAGOrchestrator {
  private llmService: LLMService;
  private cypherGenerator: CypherGenerator;
  private context: LangChainRAGContext | null = null;
  private agent: AgentType | null = null;
  private memory: MemoryType | null = null;

  constructor(llmService: LLMService, cypherGenerator: CypherGenerator) {
    this.llmService = llmService;
    this.cypherGenerator = cypherGenerator;
    this.memory = new MemorySaver();
  }

  /**
   * Set the current context and initialize the agent
   */
  public async setContext(context: LangChainRAGContext, llmConfig: LLMConfig): Promise<void> {
    this.context = context;
    this.cypherGenerator.updateSchema(context.graph);

    // Create LangChain-compliant tools
    const tools = this.createTools(llmConfig);

    // Get the LLM from our service
    const llm = this.llmService.getChatModel(llmConfig);

    // Create system message for ReAct behavior
    const systemMessage = this.buildSystemMessage();

    // Create the ReAct agent using LangGraph
    this.agent = createReactAgent({
      llm: llm,
      tools: tools,
      checkpointSaver: this.memory || undefined,
      messageModifier: systemMessage
    });
  }

  /**
   * Answer a question using the LangChain ReAct agent
   */
  public async answerQuestion(
    question: string,
    options: LangChainRAGOptions = {}
  ): Promise<LangChainRAGResponse> {
    if (!this.agent || !this.context) {
      throw new Error('Agent not initialized. Call setContext() first.');
    }

    const {
      maxIterations = 10,
      enableMemory = false,
      threadId = 'default'
    } = options;

    try {
      const config = enableMemory 
        ? { 
            configurable: { thread_id: threadId },
            recursionLimit: maxIterations
          }
        : { recursionLimit: maxIterations };

      // Stream the agent execution
      const stream = await this.agent.stream(
        { messages: [{ role: "user", content: question }] },
        config
      );

      let finalAnswer = '';
      const toolCalls: ToolCall[] = [];
      const sources: string[] = [];

      // Process the stream
      for await (const chunk of stream) {
        if (chunk.agent) {
          finalAnswer = chunk.agent.messages[chunk.agent.messages.length - 1].content;
        }
        
        if (chunk.tools) {
          const toolMessage = chunk.tools.messages[chunk.tools.messages.length - 1];
          if (toolMessage.tool_calls) {
            toolMessage.tool_calls.forEach((toolCall: { name: string; args: Record<string, unknown> }) => {
              toolCalls.push({
                tool: toolCall.name,
                input: toolCall.args,
                output: toolMessage.content || ''
              });
            });
          }
        }
      }

      // Calculate confidence based on successful tool usage
      const confidence = this.calculateConfidence(toolCalls);

      return {
        answer: finalAnswer || 'I was unable to find a complete answer to your question.',
        sources: Array.from(new Set(sources)),
        confidence,
        toolCalls
      };

    } catch (error) {
      throw new Error(`LangChain RAG orchestration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Create LangChain-compliant tools
   */
  private createTools(llmConfig: LLMConfig) {
    const queryGraphTool = new DynamicStructuredTool({
      name: "query_graph",
      description: "Query the code knowledge graph using natural language. Use this to find information about code structure, relationships, functions, classes, etc.",
      schema: z.object({
        question: z.string().describe("Natural language question about the codebase")
      }),
      func: async (input: { question: string }) => {
        try {
          const cypherQuery = await this.cypherGenerator.generateQuery(input.question, llmConfig);
          const mockResults = this.simulateGraphQuery(cypherQuery.cypher);
          
          return `Query: ${cypherQuery.cypher}\n\nResults:\n${mockResults}\n\nExplanation: ${cypherQuery.explanation}`;
        } catch (error) {
          return `Error generating graph query: ${error instanceof Error ? error.message : 'Unknown error'}`;
        }
      }
    });

    const getCodeContentTool = new DynamicStructuredTool({
      name: "get_code_content",
      description: "Retrieve the source code content of a specific file. Use this when you need to examine the actual code implementation.",
      schema: z.object({
        filePath: z.string().describe("The path to the file whose content you want to retrieve")
      }),
      func: async (input: { filePath: string }) => {
        if (!this.context) {
          return 'No context available';
        }

        const content = this.context.fileContents.get(input.filePath);
        if (!content) {
          // Try to find similar file paths
          const similarFiles = Array.from(this.context.fileContents.keys())
            .filter(path => path.includes(input.filePath) || input.filePath.includes(path))
            .slice(0, 3);

          if (similarFiles.length > 0) {
            return `File not found. Similar files available: ${similarFiles.join(', ')}`;
          }
          return 'File not found';
        }

        return `File: ${input.filePath}\n\n${content}`;
      }
    });

    const searchFilesTool = new DynamicStructuredTool({
      name: "search_files",
      description: "Search for files matching a pattern or containing specific text. Use this to find relevant files in the codebase.",
      schema: z.object({
        pattern: z.string().describe("Search pattern or text to look for in file names or content")
      }),
      func: async (input: { pattern: string }) => {
        if (!this.context) {
          return 'No context available';
        }

        const matchingFiles: string[] = [];
        const lowerPattern = input.pattern.toLowerCase();

        // Search in file paths
        for (const filePath of this.context.fileContents.keys()) {
          if (filePath.toLowerCase().includes(lowerPattern)) {
            matchingFiles.push(filePath);
          }
        }

        // Search in file contents
        for (const [filePath, content] of this.context.fileContents.entries()) {
          if (!matchingFiles.includes(filePath) && 
              content.toLowerCase().includes(lowerPattern)) {
            matchingFiles.push(filePath);
          }
        }

        return matchingFiles.length > 0 
          ? `Found ${matchingFiles.length} files:\n${matchingFiles.slice(0, 10).join('\n')}${matchingFiles.length > 10 ? '\n... and more' : ''}`
          : 'No files found matching the pattern';
      }
    });

    return [queryGraphTool, getCodeContentTool, searchFilesTool];
  }

  /**
   * Build system message for ReAct behavior
   */
  private buildSystemMessage(): SystemMessage {
    const systemPrompt = `You are an expert code analyst that helps users understand codebases by using available tools.

You have access to the following tools:
1. query_graph: Query the code knowledge graph using natural language
2. get_code_content: Retrieve the source code content of a specific file  
3. search_files: Search for files matching a pattern or containing specific text

IMPORTANT GUIDELINES:
- Always think step by step about what information you need
- Use tools to gather factual information before providing answers
- Base your responses ONLY on information retrieved from tools
- If you cannot find information, say so explicitly
- Provide helpful, accurate answers about the codebase structure and functionality
- When referencing code, always cite the specific files you examined

Your goal is to provide accurate, evidence-based answers about the codebase using the available tools.`;

    return new SystemMessage(systemPrompt);
  }

  /**
   * Simulate graph query execution (same as before)
   */
  private simulateGraphQuery(cypher: string): string {
    if (!this.context) return 'No context available';

    const upperCypher = cypher.toUpperCase();
    
    if (upperCypher.includes('FUNCTION') && upperCypher.includes('RETURN')) {
      const functions = this.context.graph.nodes
        .filter(n => n.label === 'Function')
        .slice(0, 5)
        .map(n => `${n.properties.name} (${n.properties.filePath})`)
        .join('\n');
      return functions || 'No functions found';
    }
    
    if (upperCypher.includes('CLASS') && upperCypher.includes('RETURN')) {
      const classes = this.context.graph.nodes
        .filter(n => n.label === 'Class')
        .slice(0, 5)
        .map(n => `${n.properties.name} (${n.properties.filePath})`)
        .join('\n');
      return classes || 'No classes found';
    }
    
    if (upperCypher.includes('FILE') && upperCypher.includes('RETURN')) {
      const files = this.context.graph.nodes
        .filter(n => n.label === 'File')
        .slice(0, 5)
        .map(n => n.properties.name)
        .join('\n');
      return files || 'No files found';
    }

    return 'Query executed successfully (simulated)';
  }

  /**
   * Calculate confidence based on tool usage
   */
  private calculateConfidence(toolCalls: ToolCall[]): number {
    if (toolCalls.length === 0) return 0.3;

    const successfulCalls = toolCalls.filter(call => 
      !call.output.includes('Error') && 
      !call.output.includes('not found') &&
      call.output.length > 10
    ).length;

    const baseConfidence = 0.5;
    const toolBonus = (successfulCalls / toolCalls.length) * 0.4;
    
    return Math.min(0.95, Math.max(0.1, baseConfidence + toolBonus));
  }

  /**
   * Get current context information
   */
  public getContextInfo(): { nodeCount: number; fileCount: number; hasContext: boolean; hasAgent: boolean } {
    return {
      nodeCount: this.context?.graph.nodes.length || 0,
      fileCount: this.context?.fileContents.size || 0,
      hasContext: !!this.context,
      hasAgent: !!this.agent
    };
  }

  /**
   * Clear memory for a specific thread
   */
  public async clearMemory(threadId: string): Promise<void> {
    if (this.memory) {
      // Note: MemorySaver doesn't have a direct clear method in the current API
      // This would need to be implemented based on the specific memory backend
      console.log(`Memory clearing not implemented for thread: ${threadId}`);
    }
  }
}

================
File: src/ai/llm-service.ts
================
import { ChatOpenAI } from '@langchain/openai';
import { AzureChatOpenAI } from '@langchain/openai';
import { ChatAnthropic } from '@langchain/anthropic';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';
import type { BaseMessage } from '@langchain/core/messages';
import type { BaseChatModel } from '@langchain/core/language_models/chat_models';

export type LLMProvider = 'openai' | 'azure-openai' | 'anthropic' | 'gemini';

export interface LLMConfig {
  provider: LLMProvider;
  apiKey: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  maxRetries?: number;
  // Azure OpenAI specific fields
  azureOpenAIEndpoint?: string;
  azureOpenAIApiVersion?: string;
  azureOpenAIDeploymentName?: string;
}

export interface ChatResponse {
  content: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  model?: string;
  finishReason?: string;
}

export class LLMService {
  private models: Map<string, BaseChatModel> = new Map();
  private defaultConfig: Partial<LLMConfig> = {
    temperature: 0.1,
    maxTokens: 4000,
    maxRetries: 3,
    azureOpenAIApiVersion: '2024-02-01' // Default Azure OpenAI API version
  };

  // Default models for each provider
  private static readonly DEFAULT_MODELS: Record<LLMProvider, string> = {
    openai: 'gpt-4o-mini',
    'azure-openai': 'gpt-4o-mini',
    anthropic: 'claude-3-haiku-20240307',
    gemini: 'gemini-2.5-flash'  // Use the latest 2.5 Flash model as default (2025)
  };

  constructor() {}

  /**
   * Initialize or get a chat model for the specified provider
   */
  public getChatModel(config: LLMConfig): BaseChatModel {
    const cacheKey = this.getCacheKey(config);
    
    if (this.models.has(cacheKey)) {
      return this.models.get(cacheKey)!;
    }

    const model = this.createChatModel(config);
    this.models.set(cacheKey, model);
    return model;
  }

  /**
   * Send a chat message and get a response
   */
  public async chat(
    config: LLMConfig,
    messages: BaseMessage[],
    options?: { stream?: boolean }
  ): Promise<ChatResponse> {
    try {
      const model = this.getChatModel(config);
      
      if (options?.stream) {
        // For streaming, we'd need to handle this differently
        // For now, we'll just use regular invoke
        console.warn('Streaming not implemented yet, falling back to regular invoke');
      }

      const response = await model.invoke(messages);
      
      return {
        content: response.content as string,
        usage: response.response_metadata?.usage ? {
          promptTokens: response.response_metadata.usage.prompt_tokens || 0,
          completionTokens: response.response_metadata.usage.completion_tokens || 0,
          totalTokens: response.response_metadata.usage.total_tokens || 0
        } : undefined,
        model: config.model || LLMService.DEFAULT_MODELS[config.provider],
        finishReason: response.response_metadata?.finish_reason
      };
    } catch (error) {
      throw new Error(`LLM chat failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate API key format for different providers
   */
  public validateApiKey(provider: LLMProvider, apiKey: string): boolean {
    if (!apiKey || apiKey.trim().length === 0) {
      return false;
    }

    switch (provider) {
      case 'openai':
        return apiKey.startsWith('sk-') && apiKey.length > 20;
      case 'azure-openai':
        // Azure OpenAI keys are typically 32 characters long and don't have a specific prefix
        return apiKey.length >= 20; // More flexible validation for Azure keys
      case 'anthropic':
        return apiKey.startsWith('sk-ant-') && apiKey.length > 20;
      case 'gemini':
        return apiKey.length > 20; // Google API keys don't have a consistent prefix
      default:
        return false;
    }
  }

  /**
   * Validate Azure OpenAI configuration
   */
  public validateAzureOpenAIConfig(config: LLMConfig): { valid: boolean; error?: string } {
    if (config.provider !== 'azure-openai') {
      return { valid: false, error: 'Provider must be azure-openai' };
    }

    if (!config.azureOpenAIEndpoint) {
      return { valid: false, error: 'Azure OpenAI endpoint is required' };
    }

    if (!config.azureOpenAIEndpoint.includes('openai.azure.com')) {
      return { valid: false, error: 'Invalid Azure OpenAI endpoint format. Should contain "openai.azure.com"' };
    }

    if (!config.azureOpenAIDeploymentName) {
      return { valid: false, error: 'Azure OpenAI deployment name is required' };
    }

    return { valid: true };
  }

  /**
   * Get available models for a provider
   */
  public getAvailableModels(provider: LLMProvider): string[] {
    switch (provider) {
      case 'openai':
        return [
          'gpt-4o',
          'gpt-4o-mini',
          'gpt-4-turbo',
          'gpt-4',
          'gpt-3.5-turbo'
        ];
      case 'azure-openai':
        return [
          'gpt-4o',
          'gpt-4o-mini', 
          'gpt-4.1-mini-v2', // Common deployment name
          'gpt-4-turbo',
          'gpt-4',
          'gpt-35-turbo', // Note: Azure uses gpt-35-turbo instead of gpt-3.5-turbo
          'gpt-4-32k'
        ];
      case 'anthropic':
        return [
          'claude-3-5-sonnet-20241022',
          'claude-3-5-haiku-20241022',
          'claude-3-opus-20240229',
          'claude-3-sonnet-20240229',
          'claude-3-haiku-20240307'
        ];
      case 'gemini':
        return [
          'gemini-2.5-flash',         // Latest and fastest (2025) - NEW DEFAULT
          'gemini-2.5-pro',           // Latest pro model (2025) - PREMIUM
          'gemini-1.5-flash',         // Most stable and widely available
          'gemini-1.5-pro',           // Stable pro model
          'gemini-1.0-pro',           // Legacy but very stable
          'gemini-1.5-flash-8b',      // Smaller, efficient version
          'gemini-2.0-flash',         // Newer model (may not be available to all users)
          'gemini-2.0-flash-lite'     // Lightweight version
        ];
      default:
        return [];
    }
  }

  /**
   * Get provider display name
   */
  public getProviderDisplayName(provider: LLMProvider): string {
    switch (provider) {
      case 'openai':
        return 'OpenAI';
      case 'azure-openai':
        return 'Azure OpenAI';
      case 'anthropic':
        return 'Anthropic';
      case 'gemini':
        return 'Google Gemini';
      default:
        return provider;
    }
  }

  /**
   * Test connection with the provider
   */
  public async testConnection(config: LLMConfig): Promise<{ success: boolean; error?: string }> {
    try {
      // Validate Azure OpenAI config if needed
      if (config.provider === 'azure-openai') {
        const validation = this.validateAzureOpenAIConfig(config);
        if (!validation.valid) {
          return {
            success: false,
            error: validation.error
          };
        }
      }

      const model = this.createChatModel(config);
      
      // Send a simple test message
      const testMessages = [{
        role: 'user' as const,
        content: 'Hello, this is a connection test. Please respond with "OK".'
      }];

      const response = await model.invoke(testMessages);
      
      return {
        success: true
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Connection test failed'
      };
    }
  }

  /**
   * Clear cached models (useful for updating API keys)
   */
  public clearCache(): void {
    this.models.clear();
  }

  /**
   * Create a chat model instance based on the provider
   */
  private createChatModel(config: LLMConfig): BaseChatModel {
    const mergedConfig = { ...this.defaultConfig, ...config };
    const model = mergedConfig.model || LLMService.DEFAULT_MODELS[config.provider];

    switch (config.provider) {
      case 'openai':
        return new ChatOpenAI({
          apiKey: config.apiKey,
          model,
          temperature: mergedConfig.temperature,
          maxTokens: mergedConfig.maxTokens,
          maxRetries: mergedConfig.maxRetries,
          timeout: 30000
        });

      case 'azure-openai':
        return new AzureChatOpenAI({
          azureOpenAIApiKey: config.apiKey,
          model: config.azureOpenAIDeploymentName, // Use deployment name as model
          temperature: mergedConfig.temperature,
          maxTokens: mergedConfig.maxTokens,
          maxRetries: mergedConfig.maxRetries,
          timeout: 30000,
          azureOpenAIApiInstanceName: config.azureOpenAIEndpoint?.replace('https://', '').split('.')[0],
          azureOpenAIApiVersion: config.azureOpenAIApiVersion,
          azureOpenAIApiDeploymentName: config.azureOpenAIDeploymentName
        });

      case 'anthropic':
        return new ChatAnthropic({
          apiKey: config.apiKey,
          model,
          temperature: mergedConfig.temperature,
          maxTokens: mergedConfig.maxTokens,
          maxRetries: mergedConfig.maxRetries,
          timeout: 30000
        });

      case 'gemini':
        return new ChatGoogleGenerativeAI({
          apiKey: config.apiKey,
          model,
          temperature: mergedConfig.temperature,
          maxOutputTokens: mergedConfig.maxTokens,
          maxRetries: mergedConfig.maxRetries
        });

      default:
        throw new Error(`Unsupported provider: ${config.provider}`);
    }
  }

  /**
   * Generate cache key for model instances
   */
  private getCacheKey(config: LLMConfig): string {
    const model = config.model || LLMService.DEFAULT_MODELS[config.provider];
    let baseKey = `${config.provider}:${model}:${config.apiKey.slice(-8)}:${config.temperature}:${config.maxTokens}`;
    
    // Add Azure OpenAI specific fields to cache key
    if (config.provider === 'azure-openai') {
      baseKey += `:${config.azureOpenAIEndpoint}:${config.azureOpenAIDeploymentName}:${config.azureOpenAIApiVersion}`;
    }
    
    return baseKey;
  }
}

================
File: src/ai/orchestrator.ts
================
import { HumanMessage, SystemMessage, AIMessage } from '@langchain/core/messages';
import type { LLMService, LLMConfig } from './llm-service.ts';
import type { CypherGenerator, CypherQuery } from './cypher-generator.ts';
import type { KnowledgeGraph, GraphNode } from '../core/graph/types.ts';

export interface RAGContext {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
}

export interface ToolResult {
  toolName: string;
  input: string;
  output: string;
  success: boolean;
  error?: string;
}

export interface ReasoningStep {
  step: number;
  thought: string;
  action: string;
  actionInput: string;
  observation: string;
  toolResult?: ToolResult;
}

export interface RAGResponse {
  answer: string;
  reasoning: ReasoningStep[];
  cypherQueries: CypherQuery[];
  confidence: number;
  sources: string[];
}

export interface RAGOptions {
  maxReasoningSteps?: number;
  includeReasoning?: boolean;
  strictMode?: boolean;
  temperature?: number;
}

export class RAGOrchestrator {
  private llmService: LLMService;
  private cypherGenerator: CypherGenerator;
  private context: RAGContext | null = null;

  constructor(llmService: LLMService, cypherGenerator: CypherGenerator) {
    this.llmService = llmService;
    this.cypherGenerator = cypherGenerator;
  }

  /**
   * Set the current context (graph and file contents)
   */
  public setContext(context: RAGContext): void {
    this.context = context;
    this.cypherGenerator.updateSchema(context.graph);
  }

  /**
   * Answer a question using ReAct pattern
   */
  public async answerQuestion(
    question: string,
    llmConfig: LLMConfig,
    options: RAGOptions = {}
  ): Promise<RAGResponse> {
    if (!this.context) {
      throw new Error('Context not set. Call setContext() first.');
    }

    const {
      maxReasoningSteps = 5,
      includeReasoning = true,
      strictMode = false,
      temperature = 0.1
    } = options;

    const reasoning: ReasoningStep[] = [];
    const cypherQueries: CypherQuery[] = [];
    const sources: string[] = [];

    // Enhanced LLM config for reasoning
    const reasoningConfig: LLMConfig = {
      ...llmConfig,
      temperature: temperature
    };

    let currentStep = 1;
    let finalAnswer = '';
    let confidence = 0.5;

    try {
      // Initial system prompt for ReAct
      const systemPrompt = this.buildReActSystemPrompt(strictMode);
      const conversation = [new SystemMessage(systemPrompt)];

      // Add the user question
      conversation.push(new HumanMessage(`Question: ${question}`));

      while (currentStep <= maxReasoningSteps) {
        // Get reasoning from LLM
        const response = await this.llmService.chat(reasoningConfig, conversation);
        const reasoning_step = this.parseReasoningStep(response.content, currentStep);

        reasoning.push(reasoning_step);

        // Check if we have a final answer
        if (reasoning_step.action.toLowerCase().includes('final_answer')) {
          finalAnswer = reasoning_step.actionInput;
          confidence = this.calculateConfidence(reasoning, cypherQueries);
          break;
        }

        // Execute the action
        let toolResult: ToolResult | null = null;
        
        try {
          if (reasoning_step.action.toLowerCase().includes('query_graph')) {
            toolResult = await this.executeGraphQuery(reasoning_step.actionInput, reasoningConfig);
            if (toolResult.success) {
              cypherQueries.push(...this.extractCypherQueries(toolResult));
            }
          } else if (reasoning_step.action.toLowerCase().includes('get_code')) {
            toolResult = await this.getCodeContent(reasoning_step.actionInput);
            if (toolResult.success) {
              sources.push(...this.extractSources(toolResult));
            }
          } else if (reasoning_step.action.toLowerCase().includes('search_files')) {
            toolResult = await this.searchFiles(reasoning_step.actionInput);
          } else {
            toolResult = {
              toolName: 'unknown',
              input: reasoning_step.actionInput,
              output: 'Unknown action type',
              success: false,
              error: `Unknown action: ${reasoning_step.action}`
            };
          }
        } catch (error) {
          toolResult = {
            toolName: reasoning_step.action,
            input: reasoning_step.actionInput,
            output: '',
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          };
        }

        // Update the reasoning step with tool result
        reasoning_step.observation = toolResult.output;
        reasoning_step.toolResult = toolResult;

        // Add the tool result to conversation
        conversation.push(new AIMessage(response.content));
        conversation.push(new HumanMessage(`Observation: ${toolResult.output}`));

        currentStep++;
      }

      // If we didn't get a final answer, generate one based on the reasoning
      if (!finalAnswer && reasoning.length > 0) {
        const summaryPrompt = this.buildSummaryPrompt(question, reasoning);
        conversation.push(new HumanMessage(summaryPrompt));
        
        const summaryResponse = await this.llmService.chat(reasoningConfig, conversation);
        finalAnswer = summaryResponse.content;
        confidence = Math.max(0.3, confidence - 0.2); // Lower confidence for incomplete reasoning
      }

      return {
        answer: finalAnswer || 'I was unable to find a complete answer to your question.',
        reasoning: includeReasoning ? reasoning : [],
        cypherQueries,
        confidence,
        sources: Array.from(new Set(sources)) // Remove duplicates
      };

    } catch (error) {
      throw new Error(`RAG orchestration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Build the ReAct system prompt
   */
  private buildReActSystemPrompt(strictMode: boolean): string {
    const prompt = `You are an expert code analyst using a ReAct (Reasoning + Acting) approach to answer questions about a codebase.

You have access to the following tools:
1. query_graph(question): Query the code knowledge graph using natural language
2. get_code(file_path): Retrieve the source code content of a specific file
3. search_files(pattern): Search for files matching a pattern or containing specific text

IMPORTANT INSTRUCTIONS:
- Always think step by step using the format: Thought: [your reasoning]
- Then specify an action using: Action: [tool_name]
- Provide the input using: Action Input: [input for the tool]
- After receiving an observation, continue reasoning or provide a final answer
- Use Final Answer: [your answer] when you have sufficient information
- Base your answers ONLY on the information retrieved from tools
- Do not make assumptions or hallucinate information
- If you cannot find information, say so explicitly

RESPONSE FORMAT:
Thought: [Your reasoning about what to do next]
Action: [query_graph, get_code, search_files, or Final Answer]
Action Input: [The input for the action]

After receiving an Observation, continue with:
Thought: [Your analysis of the observation]
Action: [Next action or Final Answer]
Action Input: [Input for next action or your final answer]

${strictMode ? '\nSTRICT MODE: Only use information explicitly found in the tools. Do not infer or assume anything.' : ''}

Remember: Your goal is to provide accurate, evidence-based answers about the codebase.`;

    return prompt;
  }

  /**
   * Parse a reasoning step from LLM response
   */
  private parseReasoningStep(response: string, stepNumber: number): ReasoningStep {
    const thoughtMatch = response.match(/Thought:\s*(.*?)(?=\n|Action:|$)/s);
    const actionMatch = response.match(/Action:\s*(.*?)(?=\n|Action Input:|$)/s);
    const inputMatch = response.match(/Action Input:\s*(.*?)(?=\n|$)/s);

    return {
      step: stepNumber,
      thought: thoughtMatch?.[1]?.trim() || 'No thought provided',
      action: actionMatch?.[1]?.trim() || 'unknown',
      actionInput: inputMatch?.[1]?.trim() || '',
      observation: '' // Will be filled after tool execution
    };
  }

  /**
   * Execute a graph query using the Cypher generator
   */
  private async executeGraphQuery(question: string, llmConfig: LLMConfig): Promise<ToolResult> {
    try {
      const cypherQuery = await this.cypherGenerator.generateQuery(question, llmConfig);
      
      // For now, we'll simulate query execution since we don't have a real graph database
      // In a real implementation, this would execute the Cypher query against Neo4j or similar
      const mockResults = this.simulateGraphQuery(cypherQuery.cypher);
      
      return {
        toolName: 'query_graph',
        input: question,
        output: `Query: ${cypherQuery.cypher}\n\nResults:\n${mockResults}\n\nExplanation: ${cypherQuery.explanation}`,
        success: true
      };
    } catch (error) {
      return {
        toolName: 'query_graph',
        input: question,
        output: '',
        success: false,
        error: error instanceof Error ? error.message : 'Query execution failed'
      };
    }
  }

  /**
   * Get code content from a file
   */
  private async getCodeContent(filePath: string): Promise<ToolResult> {
    if (!this.context) {
      return {
        toolName: 'get_code',
        input: filePath,
        output: '',
        success: false,
        error: 'No context available'
      };
    }

    const content = this.context.fileContents.get(filePath);
    if (!content) {
      // Try to find similar file paths
      const similarFiles = Array.from(this.context.fileContents.keys())
        .filter(path => path.includes(filePath) || filePath.includes(path))
        .slice(0, 3);

      if (similarFiles.length > 0) {
        return {
          toolName: 'get_code',
          input: filePath,
          output: `File not found. Similar files available: ${similarFiles.join(', ')}`,
          success: false,
          error: 'File not found'
        };
      }

      return {
        toolName: 'get_code',
        input: filePath,
        output: 'File not found',
        success: false,
        error: 'File not found'
      };
    }

    return {
      toolName: 'get_code',
      input: filePath,
      output: `File: ${filePath}\n\n${content}`,
      success: true
    };
  }

  /**
   * Search for files matching a pattern
   */
  private async searchFiles(pattern: string): Promise<ToolResult> {
    if (!this.context) {
      return {
        toolName: 'search_files',
        input: pattern,
        output: '',
        success: false,
        error: 'No context available'
      };
    }

    const matchingFiles: string[] = [];
    const lowerPattern = pattern.toLowerCase();

    // Search in file paths
    for (const filePath of this.context.fileContents.keys()) {
      if (filePath.toLowerCase().includes(lowerPattern)) {
        matchingFiles.push(filePath);
      }
    }

    // Search in file contents
    for (const [filePath, content] of this.context.fileContents.entries()) {
      if (!matchingFiles.includes(filePath) && 
          content.toLowerCase().includes(lowerPattern)) {
        matchingFiles.push(filePath);
      }
    }

    return {
      toolName: 'search_files',
      input: pattern,
      output: matchingFiles.length > 0 
        ? `Found ${matchingFiles.length} files:\n${matchingFiles.slice(0, 10).join('\n')}${matchingFiles.length > 10 ? '\n... and more' : ''}`
        : 'No files found matching the pattern',
      success: true
    };
  }

  /**
   * Simulate graph query execution (placeholder for real implementation)
   */
  private simulateGraphQuery(cypher: string): string {
    if (!this.context) return 'No context available';

    // Simple simulation based on common patterns
    const upperCypher = cypher.toUpperCase();
    
    if (upperCypher.includes('FUNCTION') && upperCypher.includes('RETURN')) {
      const functions = this.context.graph.nodes
        .filter(n => n.label === 'Function')
        .slice(0, 5)
        .map(n => `${n.properties.name} (${n.properties.filePath})`)
        .join('\n');
      return functions || 'No functions found';
    }
    
    if (upperCypher.includes('CLASS') && upperCypher.includes('RETURN')) {
      const classes = this.context.graph.nodes
        .filter(n => n.label === 'Class')
        .slice(0, 5)
        .map(n => `${n.properties.name} (${n.properties.filePath})`)
        .join('\n');
      return classes || 'No classes found';
    }
    
    if (upperCypher.includes('FILE') && upperCypher.includes('RETURN')) {
      const files = this.context.graph.nodes
        .filter(n => n.label === 'File')
        .slice(0, 5)
        .map(n => n.properties.name)
        .join('\n');
      return files || 'No files found';
    }

    return 'Query executed successfully (simulated)';
  }

  /**
   * Extract Cypher queries from tool results
   */
  private extractCypherQueries(toolResult: ToolResult): CypherQuery[] {
    const queries: CypherQuery[] = [];
    const queryMatch = toolResult.output.match(/Query: (.*?)(?=\n|$)/);
    
    if (queryMatch) {
      queries.push({
        cypher: queryMatch[1],
        explanation: 'Generated during reasoning',
        confidence: 0.8
      });
    }

    return queries;
  }

  /**
   * Extract sources from tool results
   */
  private extractSources(toolResult: ToolResult): string[] {
    const sources: string[] = [];
    const fileMatch = toolResult.output.match(/File: (.*?)(?=\n|$)/);
    
    if (fileMatch) {
      sources.push(fileMatch[1]);
    }

    return sources;
  }

  /**
   * Calculate confidence based on reasoning quality
   */
  private calculateConfidence(reasoning: ReasoningStep[], queries: CypherQuery[]): number {
    let confidence = 0.5;

    // Boost confidence for successful tool usage
    const successfulSteps = reasoning.filter(step => step.toolResult?.success).length;
    confidence += (successfulSteps / reasoning.length) * 0.3;

    // Boost confidence for high-quality queries
    const avgQueryConfidence = queries.length > 0 
      ? queries.reduce((sum, q) => sum + q.confidence, 0) / queries.length
      : 0.5;
    confidence += avgQueryConfidence * 0.2;

    // Cap at reasonable bounds
    return Math.min(0.95, Math.max(0.1, confidence));
  }

  /**
   * Build summary prompt for incomplete reasoning
   */
  private buildSummaryPrompt(question: string, reasoning: ReasoningStep[]): string {
    const observations = reasoning
      .map(step => `Step ${step.step}: ${step.observation}`)
      .join('\n');

    return `Based on the following observations from your reasoning process, please provide a final answer to the question: "${question}"

Observations:
${observations}

Final Answer:`;
  }

  /**
   * Get current context information
   */
  public getContextInfo(): { nodeCount: number; fileCount: number; hasContext: boolean } {
    if (!this.context) {
      return { nodeCount: 0, fileCount: 0, hasContext: false };
    }

    return {
      nodeCount: this.context.graph.nodes.length,
      fileCount: this.context.fileContents.size,
      hasContext: true
    };
  }
}

================
File: src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: src/App.tsx
================
import React from 'react';
import { HomePage, ErrorBoundary } from './ui/index.ts';

const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <HomePage />
    </ErrorBoundary>
  );
};

export default App;

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/core/graph/types.ts
================
export type NodeLabel = 
  | 'Project' 
  | 'Package' 
  | 'Module' 
  | 'Folder' 
  | 'File' 
  | 'Class' 
  | 'Function' 
  | 'Method' 
  | 'Variable';

export interface GraphNode {
  id: string;
  label: NodeLabel;
  properties: Record<string, unknown>;
}

export type RelationshipType = 
  | 'CONTAINS' 
  | 'CALLS' 
  | 'INHERITS' 
  | 'OVERRIDES' 
  | 'IMPORTS';

export interface GraphRelationship {
  id: string;
  type: RelationshipType;
  source: string;
  target: string;
  properties?: Record<string, unknown>;
}

export interface KnowledgeGraph {
  nodes: GraphNode[];
  relationships: GraphRelationship[];
}

================
File: src/core/ingestion/call-processor.ts
================
import type { KnowledgeGraph, GraphNode, GraphRelationship } from '../graph/types.ts';
import { generateId } from '../../lib/utils.ts';

import type Parser from 'web-tree-sitter';

export interface CallResolutionInput {
  graph: KnowledgeGraph;
  astCache: Map<string, any>;
  fileContents: Map<string, string>;
}

interface FunctionCall {
  callerFilePath: string;
  callerFunction: string;
  calledName: string;
  callType: 'function' | 'method' | 'attribute' | 'super';
  line: number;
  column: number;
  isChained?: boolean;
  objectName?: string;
  superMethodName?: string;
  assignedToVariable?: string;
  chainedFromVariable?: string;
}

interface ImportInfo {
  filePath: string;
  importedName: string;
  alias?: string;
  fromModule: string;
  importType: 'function' | 'class' | 'module' | 'attribute';
}

interface VariableTypeInfo {
  variableName: string;
  inferredType: string;
  filePath: string;
  functionContext: string;
  line: number;
  confidence: 'high' | 'medium' | 'low';
  source: 'constructor' | 'method_return' | 'factory' | 'assignment' | 'parameter';
}

interface MethodReturnTypeInfo {
  methodId: string;
  methodName: string;
  className: string;
  returnType?: string;
  filePath: string;
}

const BUILTIN_FUNCTIONS = new Set([
  'print', 'len', 'str', 'int', 'float', 'bool', 'list', 'dict', 'tuple', 'set',
  'range', 'enumerate', 'zip', 'map', 'filter', 'sum', 'max', 'min', 'abs',
  'round', 'sorted', 'reversed', 'any', 'all', 'type', 'isinstance', 'hasattr',
  'getattr', 'setattr', 'delattr', 'dir', 'vars', 'id', 'hash', 'repr',
  'open', 'input', 'format', 'exec', 'eval', 'compile', 'globals', 'locals'
]);

export class CallProcessor {
  private importCache: Map<string, ImportInfo[]> = new Map();
  private functionNodes: Map<string, GraphNode> = new Map();
  private variableTypes: Map<string, VariableTypeInfo> = new Map();
  private methodReturnTypes: Map<string, MethodReturnTypeInfo> = new Map();
  private classConstructors: Map<string, GraphNode> = new Map();

  public async process(input: CallResolutionInput): Promise<void> {
    const { graph, astCache, fileContents } = input;
    
    // Build function node lookup for fast resolution
    this.buildFunctionNodeLookup(graph);
    
    console.log(`CallProcessor: Processing ${astCache.size} files with ASTs`);
    
    // Extract imports from all files first
    for (const [filePath, ast] of astCache) {
      if (this.isPythonFile(filePath)) {
        const content = fileContents.get(filePath);
        if (content && ast) {
          await this.extractImports(filePath, ast, content);
        }
      }
    }
    
    // For files without ASTs, try regex-based import extraction
    const pythonFiles = Array.from(fileContents.keys()).filter(path => this.isPythonFile(path));
    const filesWithoutAST = pythonFiles.filter(path => !astCache.has(path));
    
    if (filesWithoutAST.length > 0) {
      console.log(`CallProcessor: ${filesWithoutAST.length} files don't have ASTs, using regex fallback for imports`);
      for (const filePath of filesWithoutAST) {
        const content = fileContents.get(filePath);
        if (content) {
          await this.extractImportsRegex(filePath, content);
        }
      }
    }
    
    // Process function calls in all files
    for (const [filePath, ast] of astCache) {
      if (this.isPythonFile(filePath)) {
        const content = fileContents.get(filePath);
        if (content && ast) {
          await this.processFunctionCalls(graph, filePath, ast, content);
        }
      }
    }
    
    console.log(`CallProcessor: Found imports in ${this.importCache.size} files`);
    
    // Create import relationships between files
    this.createImportRelationships(graph);
  }

  private createImportRelationships(graph: KnowledgeGraph): void {
    let importRelationshipsCreated = 0;
    
    for (const [filePath, imports] of this.importCache) {
      const sourceFileNode = graph.nodes.find(node => 
        node.label === 'File' && node.properties.filePath === filePath
      );
      
      if (!sourceFileNode) continue;
      
      for (const importInfo of imports) {
        // Try to find the target file based on the module name
        const targetFileNode = this.findTargetFileForImport(graph, importInfo);
        
        if (targetFileNode) {
          // Create IMPORTS relationship
          const relationship: GraphRelationship = {
            id: generateId('relationship', `${sourceFileNode.id}-imports-${targetFileNode.id}`),
            type: 'IMPORTS',
            source: sourceFileNode.id,
            target: targetFileNode.id,
            properties: {
              importedName: importInfo.importedName,
              fromModule: importInfo.fromModule,
              importType: importInfo.importType
            }
          };
          
          // Check if relationship already exists
          const existingRel = graph.relationships.find(rel => 
            rel.source === sourceFileNode.id && 
            rel.target === targetFileNode.id && 
            rel.type === 'IMPORTS'
          );
          
          if (!existingRel) {
            graph.relationships.push(relationship);
            importRelationshipsCreated++;
          }
        }
      }
    }
    
    console.log(`CallProcessor: Created ${importRelationshipsCreated} import relationships`);
  }

  private findTargetFileForImport(graph: KnowledgeGraph, importInfo: ImportInfo): GraphNode | null {
    const moduleName = importInfo.fromModule;
    
    // Try different strategies to find the target file
    const fileNodes = graph.nodes.filter(node => node.label === 'File');
    
    // Strategy 1: Direct module name match (e.g., "utils" -> "utils.py")
    let targetFile = fileNodes.find(node => {
      const fileName = node.properties.name as string;
      return fileName === `${moduleName}.py`;
    });
    
    if (targetFile) return targetFile;
    
    // Strategy 2: Last part of module path (e.g., "myproject.utils" -> "utils.py")
    const lastPart = moduleName.split('.').pop();
    if (lastPart) {
      targetFile = fileNodes.find(node => {
        const fileName = node.properties.name as string;
        return fileName === `${lastPart}.py`;
      });
    }
    
    if (targetFile) return targetFile;
    
    // Strategy 3: Check if module path matches file path
    targetFile = fileNodes.find(node => {
      const filePath = node.properties.filePath as string;
      return filePath && filePath.includes(moduleName.replace('.', '/'));
    });
    
    return targetFile || null;
  }

  private buildFunctionNodeLookup(graph: KnowledgeGraph): void {
    for (const node of graph.nodes) {
      if (node.label === 'Function' || node.label === 'Method') {
        const filePath = node.properties.filePath as string;
        const functionName = node.properties.name as string;
        
        // Create different keys for Functions vs Methods to avoid conflicts
        if (node.label === 'Method') {
          const parentClass = node.properties.parentClass as string;
          const methodKey = `${filePath}:method:${parentClass}.${functionName}`;
          this.functionNodes.set(methodKey, node);
          
          // Also add a general method key for resolution when class context is unknown
          const generalMethodKey = `${filePath}:method:${functionName}`;
          if (!this.functionNodes.has(generalMethodKey)) {
            this.functionNodes.set(generalMethodKey, node);
          }
          
          // Track method return type information
          this.buildMethodReturnTypeInfo(node, parentClass, functionName, filePath);
        } else {
          const functionKey = `${filePath}:function:${functionName}`;
          this.functionNodes.set(functionKey, node);
        }
      } else if (node.label === 'Class') {
        // Track class constructors for instantiation inference
        const className = node.properties.name as string;
        const filePath = node.properties.filePath as string;
        const classKey = `${filePath}:${className}`;
        this.classConstructors.set(classKey, node);
      }
    }
  }

  private buildMethodReturnTypeInfo(methodNode: GraphNode, className: string, methodName: string, filePath: string): void {
    const methodId = methodNode.id;
    
    // Infer return type based on method name and class context
    let returnType: string | undefined;
    
    // Constructor methods return the class instance
    if (methodName === '__init__' || methodName === '__new__') {
      returnType = className;
    }
    // Factory methods often return class instances
    else if (methodName.startsWith('create_') || methodName.startsWith('build_') || 
             methodName.startsWith('make_') || methodName.includes('factory')) {
      returnType = this.inferFactoryReturnType(methodName, className);
    }
    // Getter methods often return specific types
    else if (methodName.startsWith('get_')) {
      returnType = this.inferGetterReturnType(methodName, className);
    }
    // Property methods (decorated with @property) return the property type
    else if (methodNode.properties.decorators) {
      const decorators = methodNode.properties.decorators as string[];
      if (decorators.includes('property')) {
        returnType = this.inferPropertyReturnType(methodName, className);
      }
    }
    
    const returnTypeInfo: MethodReturnTypeInfo = {
      methodId,
      methodName,
      className,
      returnType,
      filePath
    };
    
    this.methodReturnTypes.set(methodId, returnTypeInfo);
  }

  private inferFactoryReturnType(methodName: string, className: string): string | undefined {
    // Factory methods like create_user, build_report, make_connection
    if (methodName.startsWith('create_')) {
      const typeName = methodName.substring(7); // Remove 'create_'
      return this.capitalizeFirstLetter(typeName);
    }
    if (methodName.startsWith('build_')) {
      const typeName = methodName.substring(6); // Remove 'build_'
      return this.capitalizeFirstLetter(typeName);
    }
    if (methodName.startsWith('make_')) {
      const typeName = methodName.substring(5); // Remove 'make_'
      return this.capitalizeFirstLetter(typeName);
    }
    
    // If it's a factory class, it might return instances of the main entity
    if (className.endsWith('Factory')) {
      const entityName = className.substring(0, className.length - 7); // Remove 'Factory'
      return entityName;
    }
    
    return undefined;
  }

  private inferGetterReturnType(methodName: string, className: string): string | undefined {
    // Common getter patterns
    if (methodName === 'get_name' || methodName === 'get_title') return 'str';
    if (methodName === 'get_id' || methodName === 'get_count') return 'int';
    if (methodName === 'get_price' || methodName === 'get_amount') return 'float';
    if (methodName === 'get_active' || methodName === 'get_enabled') return 'bool';
    if (methodName.includes('_list') || methodName.includes('_all')) return 'list';
    if (methodName.includes('_dict') || methodName.includes('_data')) return 'dict';
    
    return undefined;
  }

  private inferPropertyReturnType(methodName: string, className: string): string | undefined {
    // Property return type inference based on naming patterns
    if (methodName === 'name' || methodName === 'title' || methodName === 'description') return 'str';
    if (methodName === 'id' || methodName === 'count' || methodName === 'size') return 'int';
    if (methodName === 'price' || methodName === 'amount' || methodName === 'rate') return 'float';
    if (methodName === 'active' || methodName === 'enabled' || methodName === 'valid') return 'bool';
    
    return undefined;
  }

  private capitalizeFirstLetter(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private async extractImports(filePath: string, ast: any, content: string): Promise<void> {
    const imports: ImportInfo[] = [];
    
    this.traverseNode(ast.rootNode, (node: any) => {
      if (node.type === 'import_statement') {
        this.processImportStatement(node, imports, filePath);
      } else if (node.type === 'import_from_statement') {
        this.processImportFromStatement(node, imports, filePath);
      }
    });
    
    this.importCache.set(filePath, imports);
  }

  private processImportStatement(node: any, imports: ImportInfo[], filePath: string): void {
    const nameNode = node.childForFieldName('name');
    if (nameNode) {
      const moduleName = nameNode.text;
      
      // Handle aliased imports (import module as alias)
      const asNode = node.children.find((child: any) => child.type === 'as_pattern');
      const alias = asNode ? asNode.childForFieldName('alias')?.text : undefined;
      
      imports.push({
        filePath,
        importedName: moduleName,
        alias,
        fromModule: moduleName,
        importType: 'module'
      });
    }
  }

  private processImportFromStatement(node: any, imports: ImportInfo[], filePath: string): void {
    const moduleNameNode = node.childForFieldName('module_name');
    const importListNode = node.children.find((child: any) => child.type === 'import_list');
    
    if (moduleNameNode && importListNode) {
      const moduleName = moduleNameNode.text;
      
      this.traverseNode(importListNode, (child: any) => {
        if (child.type === 'dotted_name' || child.type === 'identifier') {
          const importedName = child.text;
          imports.push({
            filePath,
            importedName,
            fromModule: moduleName,
            importType: 'function' // Default assumption, could be refined
          });
        } else if (child.type === 'as_pattern') {
          const nameNode = child.childForFieldName('name');
          const aliasNode = child.childForFieldName('alias');
          
          if (nameNode && aliasNode) {
            imports.push({
              filePath,
              importedName: nameNode.text,
              alias: aliasNode.text,
              fromModule: moduleName,
              importType: 'function'
            });
          }
        }
      });
    }
  }

  private async processFunctionCalls(
    graph: KnowledgeGraph, 
    filePath: string, 
    ast: any, 
    content: string
  ): Promise<void> {
    const functionCalls: FunctionCall[] = [];
    let currentFunction: string | null = null;
    
    this.traverseNode(ast.rootNode, (node: any) => {
      // Track current function context
      if (node.type === 'function_definition') {
        const nameNode = node.childForFieldName('name');
        if (nameNode) {
          currentFunction = nameNode.text;
        }
      }
      
      // Track variable assignments for type inference
      if (node.type === 'assignment') {
        this.processVariableAssignment(node, filePath, currentFunction);
      }
      
      // Find function calls
      if (node.type === 'call') {
        const callInfo = this.extractCallInfo(node, filePath, currentFunction, content);
        if (callInfo) {
          // Check if this call is part of an assignment
          const assignmentInfo = this.extractAssignmentInfo(node);
          if (assignmentInfo) {
            callInfo.assignedToVariable = assignmentInfo.variableName;
          }
          
          functionCalls.push(callInfo);
        }
      }
    });
    
    // Resolve calls and create relationships
    for (const call of functionCalls) {
      await this.resolveAndCreateCallRelationship(graph, call);
      
      // Track variable type if this call is assigned to a variable
      if (call.assignedToVariable) {
        this.inferAndTrackVariableType(graph, call);
      }
    }
  }

  private processVariableAssignment(assignmentNode: any, filePath: string, currentFunction: string | null): void {
    const leftNode = assignmentNode.childForFieldName('left');
    const rightNode = assignmentNode.childForFieldName('right');
    
    if (!leftNode || !rightNode) return;
    
    // Extract variable name from left side
    let variableName: string | null = null;
    if (leftNode.type === 'identifier') {
      variableName = leftNode.text;
    }
    
    if (!variableName) return;
    
    // Analyze right side for type inference
    if (rightNode.type === 'call') {
      // This will be handled in the call processing
      return;
    } else if (rightNode.type === 'identifier') {
      // Variable assignment from another variable
      const sourceVariable = rightNode.text;
      this.copyVariableType(filePath, currentFunction || '<module>', sourceVariable, variableName);
    }
  }

  private extractAssignmentInfo(callNode: any): { variableName: string } | null {
    // Walk up the AST to find if this call is part of an assignment
    let parent = callNode.parent;
    
    while (parent) {
      if (parent.type === 'assignment') {
        const leftNode = parent.childForFieldName('left');
        if (leftNode && leftNode.type === 'identifier') {
          return { variableName: leftNode.text };
        }
      }
      parent = parent.parent;
    }
    
    return null;
  }

  private inferAndTrackVariableType(graph: KnowledgeGraph, call: FunctionCall): void {
    if (!call.assignedToVariable) return;
    
    let inferredType: string | undefined;
    let confidence: 'high' | 'medium' | 'low' = 'low';
    let source: VariableTypeInfo['source'] = 'assignment';
    
    // Try to infer type based on the call
    if (call.callType === 'function' || call.callType === 'method') {
      // Check if it's a class constructor call
      const constructorType = this.inferConstructorType(graph, call);
      if (constructorType) {
        inferredType = constructorType;
        confidence = 'high';
        source = 'constructor';
      } else {
        // Check if it's a method call with known return type
        const methodReturnType = this.inferMethodReturnType(graph, call);
        if (methodReturnType) {
          inferredType = methodReturnType.returnType;
          confidence = methodReturnType.confidence;
          source = 'method_return';
        }
      }
    }
    
    if (inferredType) {
      const variableKey = `${call.callerFilePath}:${call.callerFunction}:${call.assignedToVariable}`;
      const typeInfo: VariableTypeInfo = {
        variableName: call.assignedToVariable,
        inferredType,
        filePath: call.callerFilePath,
        functionContext: call.callerFunction,
        line: call.line,
        confidence,
        source
      };
      
      this.variableTypes.set(variableKey, typeInfo);
      this.logTypeInference(call, inferredType, confidence);
    }
  }

  private inferConstructorType(graph: KnowledgeGraph, call: FunctionCall): string | undefined {
    // Check if the called function is a class constructor
    const classKey = `${call.callerFilePath}:${call.calledName}`;
    if (this.classConstructors.has(classKey)) {
      return call.calledName;
    }
    
    // Check for imported class constructors
    const imports = this.importCache.get(call.callerFilePath) || [];
    for (const importInfo of imports) {
      if (importInfo.importedName === call.calledName && importInfo.importType === 'class') {
        return call.calledName;
      }
    }
    
    return undefined;
  }

  private inferMethodReturnType(graph: KnowledgeGraph, call: FunctionCall): { returnType?: string, confidence: 'high' | 'medium' | 'low' } | null {
    // Find the method node that was called
    const targetNode = this.resolveMethodCall(graph, call) || this.resolveLocalFunction(call);
    
    if (targetNode && this.methodReturnTypes.has(targetNode.id)) {
      const returnTypeInfo = this.methodReturnTypes.get(targetNode.id)!;
      return {
        returnType: returnTypeInfo.returnType,
        confidence: returnTypeInfo.returnType ? 'medium' : 'low'
      };
    }
    
    return null;
  }

  private copyVariableType(filePath: string, functionContext: string, sourceVar: string, targetVar: string): void {
    const sourceKey = `${filePath}:${functionContext}:${sourceVar}`;
    const sourceType = this.variableTypes.get(sourceKey);
    
    if (sourceType) {
      const targetKey = `${filePath}:${functionContext}:${targetVar}`;
      const copiedType: VariableTypeInfo = {
        ...sourceType,
        variableName: targetVar
      };
      this.variableTypes.set(targetKey, copiedType);
    }
  }

  private extractCallInfo(
    callNode: any, 
    filePath: string, 
    currentFunction: string | null,
    content: string
  ): FunctionCall | null {
    const functionNode = callNode.childForFieldName('function');
    if (!functionNode) return null;
    
    const position = callNode.startPosition;
    const line = position.row + 1;
    const column = position.column + 1;
    
    if (functionNode.type === 'identifier') {
      // Simple function call: func()
      return {
        callerFilePath: filePath,
        callerFunction: currentFunction || '<module>',
        calledName: functionNode.text,
        callType: 'function',
        line,
        column
      };
    } else if (functionNode.type === 'attribute') {
      // Method call: obj.method() or super().method() or chained call
      const objectNode = functionNode.childForFieldName('object');
      const attributeNode = functionNode.childForFieldName('attribute');
      
      if (objectNode && attributeNode) {
        // Check if this is a super() call
        if (objectNode.type === 'call') {
          const superFunctionNode = objectNode.childForFieldName('function');
          if (superFunctionNode && superFunctionNode.type === 'identifier' && superFunctionNode.text === 'super') {
            // This is a super().method() call
            return {
              callerFilePath: filePath,
              callerFunction: currentFunction || '<module>',
              calledName: 'super',
              callType: 'super',
              line,
              column,
              superMethodName: attributeNode.text
            };
          }
        }
        
        // Check if the object is a variable with known type (for chained calls)
        let objectName = objectNode.text;
        let chainedFromVariable: string | undefined;
        
        if (objectNode.type === 'identifier') {
          // This might be a method call on a typed variable
          const variableType = this.getVariableType(filePath, currentFunction || '<module>', objectName);
          if (variableType) {
            chainedFromVariable = objectName;
          }
        }
        
        // Regular method call
        return {
          callerFilePath: filePath,
          callerFunction: currentFunction || '<module>',
          calledName: attributeNode.text,
          callType: 'method',
          line,
          column,
          objectName: objectName,
          chainedFromVariable
        };
      }
    }
    
    return null;
  }

  private async resolveAndCreateCallRelationship(
    graph: KnowledgeGraph, 
    call: FunctionCall
  ): Promise<void> {
    const callerNode = this.findCallerNode(graph, call);
    if (!callerNode) return;
    
    // Improved resolution order: prioritize imports to avoid self-referential calls
    const targetNode = 
      this.resolveBuiltinFunction(call) ||
      this.resolveImportedFunction(call) ||  // Check imports first
      this.resolveSuperCall(graph, call) ||  // Check super() calls
      this.resolveMethodCall(graph, call) ||
      this.resolveLocalFunction(call) ||     // Check local functions
      this.resolveWithAdvancedFallback(graph, call);  // Advanced fallback for ambiguous calls
    
    if (targetNode) {
      // Prevent self-referential calls unless it's actually recursive
      if (callerNode.id === targetNode.id) {
        // Only allow self-calls if the function name matches exactly (true recursion)
        const callerName = callerNode.properties.name as string;
        if (callerName !== call.calledName) {
          console.warn(`Prevented incorrect self-referential call from ${callerName} to ${call.calledName}`);
          return;
        }
      }
      
      const existingNode = graph.nodes.find(node => node.id === targetNode.id);
      if (!existingNode) {
        graph.nodes.push(targetNode);
      }
      
      const relationship = this.createCallRelationship(callerNode.id, targetNode.id, call);
      graph.relationships.push(relationship);
    }
  }

  private findCallerNode(graph: KnowledgeGraph, call: FunctionCall): GraphNode | null {
    if (call.callerFunction === '<module>') {
      // Call is at module level
      return graph.nodes.find(node => 
        node.label === 'Module' && 
        node.properties.path === call.callerFilePath
      ) || null;
    } else {
      // Call is within a function
      const key = `${call.callerFilePath}:${call.callerFunction}`;
      return this.functionNodes.get(key) || null;
    }
  }

  private resolveBuiltinFunction(call: FunctionCall): GraphNode | null {
    if (BUILTIN_FUNCTIONS.has(call.calledName)) {
      return this.getOrCreateBuiltinNode(call.calledName);
    }
    return null;
  }

  private resolveImportedFunction(call: FunctionCall): GraphNode | null {
    const imports = this.importCache.get(call.callerFilePath) || [];
    
    for (const importInfo of imports) {
      // Handle direct import match (from module import function)
      if (importInfo.importedName === call.calledName || importInfo.alias === call.calledName) {
        return this.getOrCreateImportedNode(call.calledName, importInfo.fromModule);
      }
      
      // Handle module.function pattern (import module; module.function())
      if (call.callType === 'method' && call.objectName) {
        // Check if objectName matches imported module or alias
        if (importInfo.importedName === call.objectName || importInfo.alias === call.objectName) {
          // This is a call to an imported module's function
          return this.getOrCreateImportedNode(call.calledName, importInfo.fromModule);
        }
      }
      
      // Handle import module as alias patterns
      if (call.callType === 'method' && call.objectName === importInfo.alias && importInfo.importType === 'module') {
        return this.getOrCreateImportedNode(call.calledName, importInfo.fromModule);
      }
    }
    
    return null;
  }

  private resolveWithAdvancedFallback(graph: KnowledgeGraph, call: FunctionCall): GraphNode | null {
    // Find all potential candidates across the entire graph
    const candidates = this.findAllCandidates(graph, call);
    
    if (candidates.length === 0) {
      return null;
    }
    
    if (candidates.length === 1) {
      return candidates[0];
    }
    
    // Multiple candidates found - use heuristics to pick the best one
    const rankedCandidates = this.rankCandidatesByProximity(call.callerFilePath, candidates);
    
    if (rankedCandidates.length > 0) {
      const bestCandidate = rankedCandidates[0];
      
      // Enable detailed logging for debugging (can be controlled via environment variable)
      const enableDetailedLogging = process.env.GITNEXUS_DEBUG_FALLBACK === 'true';
      if (enableDetailedLogging) {
        this.logCandidateAnalysis(call, rankedCandidates);
      } else {
        console.log(`Advanced fallback: Selected ${bestCandidate.node.properties.filePath}:${bestCandidate.node.properties.name} for call to ${call.calledName} from ${call.callerFilePath} (score: ${bestCandidate.score.toFixed(2)})`);
      }
      
      return bestCandidate.node;
    }
    
    return null;
  }

  private applySpecialCaseHeuristics(call: FunctionCall, candidates: GraphNode[]): GraphNode[] {
    // Apply special case filtering and prioritization
    const filtered = candidates.filter(candidate => {
      const candidatePath = candidate.properties.filePath as string;
      const candidateName = candidate.properties.name as string;
      
      // Skip obvious non-matches
      if (this.isObviousNonMatch(call, candidate)) {
        return false;
      }
      
      return true;
    });
    
    // Apply framework-specific heuristics
    return this.applyFrameworkHeuristics(call, filtered);
  }

  private isObviousNonMatch(call: FunctionCall, candidate: GraphNode): boolean {
    const candidatePath = candidate.properties.filePath as string;
    const candidateName = candidate.properties.name as string;
    const callerPath = call.callerFilePath;
    
    // Skip if candidate is in a completely different domain
    const callerDomain = this.extractDomain(callerPath);
    const candidateDomain = this.extractDomain(candidatePath);
    
    if (callerDomain && candidateDomain && callerDomain !== candidateDomain) {
      const commonDomains = ['utils', 'helpers', 'common', 'shared', 'lib', 'core'];
      if (!commonDomains.includes(candidateDomain.toLowerCase())) {
        return true;
      }
    }
    
    // Skip private/internal functions when caller is not in same module
    if (candidateName.startsWith('_') && !this.areInSameModule(callerPath, candidatePath)) {
      return true;
    }
    
    return false;
  }

  private applyFrameworkHeuristics(call: FunctionCall, candidates: GraphNode[]): GraphNode[] {
    // Django-specific heuristics
    if (this.isDjangoProject(call.callerFilePath)) {
      return this.applyDjangoHeuristics(call, candidates);
    }
    
    // Flask-specific heuristics
    if (this.isFlaskProject(call.callerFilePath)) {
      return this.applyFlaskHeuristics(call, candidates);
    }
    
    // FastAPI-specific heuristics
    if (this.isFastAPIProject(call.callerFilePath)) {
      return this.applyFastAPIHeuristics(call, candidates);
    }
    
    return candidates;
  }

  private extractDomain(filePath: string): string | null {
    const parts = filePath.split('/').filter(p => p.length > 0);
    if (parts.length >= 2) {
      return parts[parts.length - 2]; // Directory containing the file
    }
    return null;
  }

  private areInSameModule(path1: string, path2: string): boolean {
    const parts1 = path1.split('/').slice(0, -1); // Remove filename
    const parts2 = path2.split('/').slice(0, -1); // Remove filename
    
    // Consider same module if they share at least 2 path segments
    let commonSegments = 0;
    const minLength = Math.min(parts1.length, parts2.length);
    
    for (let i = 0; i < minLength; i++) {
      if (parts1[i] === parts2[i]) {
        commonSegments++;
      } else {
        break;
      }
    }
    
    return commonSegments >= 2;
  }

  private isDjangoProject(filePath: string): boolean {
    return filePath.includes('django') || 
           filePath.includes('models.py') || 
           filePath.includes('views.py') ||
           filePath.includes('urls.py');
  }

  private isFlaskProject(filePath: string): boolean {
    return filePath.includes('flask') || 
           filePath.includes('app.py') ||
           filePath.includes('routes.py');
  }

  private isFastAPIProject(filePath: string): boolean {
    return filePath.includes('fastapi') || 
           filePath.includes('main.py') ||
           filePath.includes('routers/');
  }

  private applyDjangoHeuristics(call: FunctionCall, candidates: GraphNode[]): GraphNode[] {
    // Prefer models.py for model-related functions, views.py for view functions, etc.
    return candidates.sort((a, b) => {
      const pathA = a.properties.filePath as string;
      const pathB = b.properties.filePath as string;
      
      if (call.callerFilePath.includes('views.py') && pathA.includes('models.py')) {
        return -1; // Prefer models.py when called from views.py
      }
      
      return 0;
    });
  }

  private applyFlaskHeuristics(call: FunctionCall, candidates: GraphNode[]): GraphNode[] {
    // Flask-specific prioritization logic
    return candidates;
  }

  private applyFastAPIHeuristics(call: FunctionCall, candidates: GraphNode[]): GraphNode[] {
    // FastAPI-specific prioritization logic
    return candidates;
  }

  private findAllCandidates(graph: KnowledgeGraph, call: FunctionCall): GraphNode[] {
    const candidates: GraphNode[] = [];
    
    // Look for functions and methods with matching names across all files
    for (const node of graph.nodes) {
      if ((node.label === 'Function' || node.label === 'Method') && 
          node.properties.name === call.calledName &&
          node.properties.filePath !== call.callerFilePath) {  // Exclude same file (already checked)
        candidates.push(node);
      }
    }
    
    // Apply special case heuristics to filter and prioritize candidates
    return this.applySpecialCaseHeuristics(call, candidates);
  }

  private rankCandidatesByProximity(callerFilePath: string, candidates: GraphNode[]): Array<{node: GraphNode, score: number}> {
    const scored = candidates.map(candidate => ({
      node: candidate,
      score: this.calculateProximityScore(callerFilePath, candidate.properties.filePath as string)
    }));
    
    // Sort by score (higher is better)
    return scored.sort((a, b) => b.score - a.score);
  }

  private calculateProximityScore(callerPath: string, candidatePath: string): number {
    // Normalize paths (convert backslashes to forward slashes)
    const normalizedCaller = this.normalizePath(callerPath);
    const normalizedCandidate = this.normalizePath(candidatePath);
    
    const callerParts = normalizedCaller.split('/').filter(part => part.length > 0);
    const candidateParts = normalizedCandidate.split('/').filter(part => part.length > 0);
    
    let score = 0;
    
    // Base score: prefer shorter paths (closer to root)
    score += Math.max(0, 10 - candidateParts.length);
    
    // Proximity score: count common path segments from the beginning
    let commonPrefixLength = 0;
    const minLength = Math.min(callerParts.length, candidateParts.length);
    
    for (let i = 0; i < minLength - 1; i++) {  // Exclude filename
      if (callerParts[i] === candidateParts[i]) {
        commonPrefixLength++;
      } else {
        break;
      }
    }
    
    // Higher score for more common path segments
    score += commonPrefixLength * 20;
    
    // Same directory bonus
    if (commonPrefixLength === Math.min(callerParts.length - 1, candidateParts.length - 1)) {
      score += 30;
    }
    
    // Sibling directory bonus (same parent, different immediate directory)
    if (commonPrefixLength === Math.min(callerParts.length - 2, candidateParts.length - 2) && 
        commonPrefixLength > 0) {
      score += 15;
    }
    
    // Naming convention bonuses
    score += this.calculateNamingConventionScore(normalizedCaller, normalizedCandidate);
    
    // Penalize deep nested paths
    const nestingPenalty = Math.max(0, candidateParts.length - 5) * 2;
    score -= nestingPenalty;
    
    return score;
  }

  private calculateNamingConventionScore(callerPath: string, candidatePath: string): number {
    let score = 0;
    
    // Extract directory and file names
    const callerParts = callerPath.split('/');
    const candidateParts = candidatePath.split('/');
    
    const callerDir = callerParts[callerParts.length - 2] || '';
    const candidateDir = candidateParts[candidateParts.length - 2] || '';
    
    const callerFile = callerParts[callerParts.length - 1].replace(/\.[^.]*$/, '');
    const candidateFile = candidateParts[candidateParts.length - 1].replace(/\.[^.]*$/, '');
    
    // Prefer utils, helpers, common files
    if (candidateFile.match(/^(utils?|helpers?|common|shared|lib|core)$/i)) {
      score += 10;
    }
    
    // Prefer files with similar names
    if (this.calculateStringSimilarity(callerFile, candidateFile) > 0.6) {
      score += 8;
    }
    
    // Prefer similar directory names
    if (this.calculateStringSimilarity(callerDir, candidateDir) > 0.7) {
      score += 5;
    }
    
    // Avoid test files unless caller is also a test
    if (candidateFile.match(/test|spec/i) && !callerFile.match(/test|spec/i)) {
      score -= 20;
    }
    
    // Avoid legacy/deprecated paths
    if (candidatePath.match(/(legacy|deprecated|old|archive)/i)) {
      score -= 15;
    }
    
    return score;
  }

  private calculateStringSimilarity(str1: string, str2: string): number {
    if (str1 === str2) return 1.0;
    if (str1.length === 0 || str2.length === 0) return 0.0;
    
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const editDistance = this.calculateLevenshteinDistance(longer, shorter);
    return (longer.length - editDistance) / longer.length;
  }

  private calculateLevenshteinDistance(str1: string, str2: string): number {
    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
    
    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
    
    for (let j = 1; j <= str2.length; j++) {
      for (let i = 1; i <= str1.length; i++) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[j][i] = Math.min(
          matrix[j][i - 1] + 1,     // deletion
          matrix[j - 1][i] + 1,     // insertion
          matrix[j - 1][i - 1] + indicator  // substitution
        );
      }
    }
    
    return matrix[str2.length][str1.length];
  }

  private normalizePath(path: string): string {
    return path.replace(/\\/g, '/').toLowerCase();
  }

  private resolveSuperCall(graph: KnowledgeGraph, call: FunctionCall): GraphNode | null {
    if (call.callType !== 'super' || !call.superMethodName) return null;
    
    // Find the current method node to get its class context
    const currentMethodNode = graph.nodes.find(node => 
      node.label === 'Method' && 
      node.properties.filePath === call.callerFilePath &&
      node.properties.name === call.callerFunction
    );
    
    if (!currentMethodNode || !currentMethodNode.properties.parentClass) return null;
    
    const currentClassName = currentMethodNode.properties.parentClass as string;
    
    // Find the current class node to get its base classes
    const currentClassNode = graph.nodes.find(node => 
      node.label === 'Class' && 
      node.properties.filePath === call.callerFilePath &&
      node.properties.name === currentClassName
    );
    
    if (!currentClassNode || !currentClassNode.properties.baseClasses) return null;
    
    const baseClasses = currentClassNode.properties.baseClasses as string[];
    
    // Look for the method in each base class (in order)
    for (const baseClassName of baseClasses) {
      const baseMethodNode = graph.nodes.find(node => 
        node.label === 'Method' && 
        node.properties.name === call.superMethodName &&
        node.properties.parentClass === baseClassName
      );
      
      if (baseMethodNode) {
        return baseMethodNode;
      }
    }
    
    return null;
  }

  private resolveLocalFunction(call: FunctionCall): GraphNode | null {
    // Try function key first
    const functionKey = `${call.callerFilePath}:function:${call.calledName}`;
    const functionNode = this.functionNodes.get(functionKey);
    if (functionNode) {
      return functionNode;
    }
    
    // Try method key if function not found
    const methodKey = `${call.callerFilePath}:method:${call.calledName}`;
    return this.functionNodes.get(methodKey) || null;
  }

  private getVariableType(filePath: string, functionContext: string, variableName: string): VariableTypeInfo | null {
    const variableKey = `${filePath}:${functionContext}:${variableName}`;
    return this.variableTypes.get(variableKey) || null;
  }

  private resolveMethodCall(graph: KnowledgeGraph, call: FunctionCall): GraphNode | null {
    if (call.callType !== 'method') return null;
    
    // If this is a chained method call, use type information to resolve
    if (call.chainedFromVariable) {
      const variableType = this.getVariableType(call.callerFilePath, call.callerFunction, call.chainedFromVariable);
      if (variableType) {
        return this.resolveMethodOnType(graph, call, variableType.inferredType);
      }
    }
    
    // First try to find methods in the same file using the new key format
    const methodKey = `${call.callerFilePath}:method:${call.calledName}`;
    const methodNode = this.functionNodes.get(methodKey);
    if (methodNode) {
      return methodNode;
    }
    
    // Fallback: look for method nodes in the graph (for cases where key lookup fails)
    const methods = graph.nodes.filter(node => 
      node.label === 'Method' && 
      node.properties.filePath === call.callerFilePath &&
      node.properties.name === call.calledName
    );
    
    return methods[0] || null;
  }

  private resolveMethodOnType(graph: KnowledgeGraph, call: FunctionCall, typeName: string): GraphNode | null {
    // Look for methods of the specified type across all files
    const methods = graph.nodes.filter(node => 
      node.label === 'Method' && 
      node.properties.name === call.calledName &&
      node.properties.parentClass === typeName
    );
    
    if (methods.length > 0) {
      // Prefer methods in the same file, then use proximity-based ranking
      const sameFileMethod = methods.find(method => 
        method.properties.filePath === call.callerFilePath
      );
      
      if (sameFileMethod) {
        return sameFileMethod;
      }
      
      // Use advanced fallback ranking for cross-file method resolution
      const rankedMethods = this.rankCandidatesByProximity(call.callerFilePath, methods);
      return rankedMethods.length > 0 ? rankedMethods[0].node : methods[0];
    }
    
    return null;
  }

  private getOrCreateBuiltinNode(functionName: string): GraphNode {
    const id = generateId('builtin', functionName);
    return {
      id,
      label: 'Function',
      properties: {
        name: functionName,
        type: 'builtin',
        language: 'python'
      }
    };
  }

  private getOrCreateImportedNode(functionName: string, moduleName: string): GraphNode {
    const id = generateId('imported', `${moduleName}.${functionName}`);
    return {
      id,
      label: 'Function',
      properties: {
        name: functionName,
        module: moduleName,
        type: 'imported',
        language: 'python'
      }
    };
  }

  private createCallRelationship(
    callerId: string, 
    targetId: string, 
    call: FunctionCall
  ): GraphRelationship {
    return {
      id: generateId('relationship', `${callerId}-calls-${targetId}`),
      type: 'CALLS',
      source: callerId,
      target: targetId,
      properties: {
        callType: call.callType,
        line: call.line,
        column: call.column,
        ...(call.objectName && { objectName: call.objectName })
      }
    };
  }

  private traverseNode(node: any, callback: (node: any) => void): void {
    callback(node);
    
    for (let i = 0; i < node.childCount; i++) {
      const child = node.child(i);
      if (child) {
        this.traverseNode(child, callback);
      }
    }
  }

  private isPythonFile(filePath: string): boolean {
    return filePath.endsWith('.py');
  }

  public getImportInfo(filePath: string): ImportInfo[] {
    return this.importCache.get(filePath) || [];
  }

  public getCallStats(): { totalCalls: number; callTypes: Record<string, number> } {
    const stats = {
      totalCalls: 0,
      callTypes: {
        function: 0,
        method: 0,
        builtin: 0,
        imported: 0,
        local: 0
      }
    };
    
    // This would be populated during processing
    return stats;
  }

  public getTypeInferenceStats(): {
    totalVariablesTyped: number;
    typesByConfidence: Record<string, number>;
    typesBySource: Record<string, number>;
    mostCommonTypes: Array<{type: string, count: number}>;
  } {
    const stats = {
      totalVariablesTyped: this.variableTypes.size,
      typesByConfidence: { high: 0, medium: 0, low: 0 },
      typesBySource: { constructor: 0, method_return: 0, factory: 0, assignment: 0, parameter: 0 },
      mostCommonTypes: [] as Array<{type: string, count: number}>
    };
    
    const typeCounts = new Map<string, number>();
    
    for (const typeInfo of this.variableTypes.values()) {
      stats.typesByConfidence[typeInfo.confidence]++;
      stats.typesBySource[typeInfo.source]++;
      
      const currentCount = typeCounts.get(typeInfo.inferredType) || 0;
      typeCounts.set(typeInfo.inferredType, currentCount + 1);
    }
    
    // Sort types by frequency
    stats.mostCommonTypes = Array.from(typeCounts.entries())
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
    
    return stats;
  }

  public getVariableTypeInfo(filePath: string, functionContext: string, variableName: string): VariableTypeInfo | null {
    return this.getVariableType(filePath, functionContext, variableName);
  }

  public getAllVariableTypes(): VariableTypeInfo[] {
    return Array.from(this.variableTypes.values());
  }

  private logTypeInference(call: FunctionCall, inferredType: string, confidence: string): void {
    if (process.env.GITNEXUS_DEBUG_TYPES === 'true') {
      console.log(`Type inference: ${call.assignedToVariable} = ${call.calledName}() -> ${inferredType} (${confidence} confidence)`);
    }
  }

  public getAdvancedFallbackStats(): {
    totalFallbackResolutions: number; 
    successfulResolutions: number;
    ambiguousCallsResolved: number;
  } {
    // This would be populated during processing in a real implementation
    return {
      totalFallbackResolutions: 0,
      successfulResolutions: 0,
      ambiguousCallsResolved: 0
    };
  }

  private logCandidateAnalysis(call: FunctionCall, candidates: Array<{node: GraphNode, score: number}>): void {
    console.log(`\n=== Advanced Fallback Analysis for ${call.calledName} ===`);
    console.log(`Caller: ${call.callerFilePath}:${call.callerFunction}`);
    console.log(`Found ${candidates.length} candidates:`);
    
    candidates.forEach((candidate, index) => {
      const filePath = candidate.node.properties.filePath as string;
      const name = candidate.node.properties.name as string;
      const label = candidate.node.label;
      
      console.log(`  ${index + 1}. ${filePath}:${name} (${label}) - Score: ${candidate.score.toFixed(2)}`);
      
      if (index === 0) {
        console.log(`     ‚úÖ SELECTED`);
      }
    });
    console.log(`==========================================\n`);
  }

  private async extractImportsRegex(filePath: string, content: string): Promise<void> {
    const imports: ImportInfo[] = [];
    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      // Match: import module
      const importMatch = trimmedLine.match(/^import\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)/);
      if (importMatch) {
        const moduleName = importMatch[1];
        imports.push({
          filePath,
          importedName: moduleName,
          fromModule: moduleName,
          importType: 'module'
        });
      }
      
      // Match: from module import item
      const fromImportMatch = trimmedLine.match(/^from\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)\s+import\s+([a-zA-Z_][a-zA-Z0-9_]*)/);
      if (fromImportMatch) {
        const moduleName = fromImportMatch[1];
        const importedName = fromImportMatch[2];
        imports.push({
          filePath,
          importedName,
          fromModule: moduleName,
          importType: 'function' // Default assumption
        });
      }
    }
    
    if (imports.length > 0) {
      this.importCache.set(filePath, imports);
      console.log(`Regex-extracted ${imports.length} imports from ${filePath}`);
    }
  }
}

================
File: src/core/ingestion/parsing-processor.ts
================
import type { KnowledgeGraph, GraphNode, GraphRelationship } from '../graph/types.ts';
import { initTreeSitter, loadPythonParser } from '../tree-sitter/parser-loader.ts';
import { generateId } from '../../lib/utils.ts';

import type Parser from 'web-tree-sitter';

export interface ParsingInput {
  filePaths: string[];
  fileContents: Map<string, string>;
}

interface ParsedDefinition {
  name: string;
  type: 'function' | 'class' | 'method';
  startLine: number;
  endLine: number;
  parentClass?: string;
  decorators?: string[];
  baseClasses?: string[];
}

export class ParsingProcessor {
  private parser: Parser | null = null;
  private astCache: Map<string, Parser.Tree> = new Map();

  public async process(graph: KnowledgeGraph, input: ParsingInput): Promise<void> {
    const { filePaths, fileContents } = input;

    console.log('ParsingProcessor: Processing', filePaths.length, 'files');

    // Memory optimization: Process files in batches to prevent OOM
    const BATCH_SIZE = 10; // Process 10 files at a time
    const sourceFiles = filePaths.filter(path => this.isSourceFile(path));
    
    console.log(`ParsingProcessor: Found ${sourceFiles.length} source files, processing in batches of ${BATCH_SIZE}`);

    // Enable tree-sitter parsing once WASM files are available
    try {
      await this.initializeParser();
      
      let successfullyParsed = 0;
      let failedToParse = 0;
      
      // Process files in batches
      for (let i = 0; i < sourceFiles.length; i += BATCH_SIZE) {
        const batch = sourceFiles.slice(i, i + BATCH_SIZE);
        console.log(`Processing batch ${Math.floor(i / BATCH_SIZE) + 1}/${Math.ceil(sourceFiles.length / BATCH_SIZE)} (${batch.length} files)`);
        
        for (const filePath of batch) {
          const fileContent = fileContents.get(filePath);
          if (!fileContent) {
            console.warn(`No content found for source file: ${filePath}`);
            continue;
          }

          // Memory optimization: Skip very large files
          if (fileContent.length > 500000) { // Skip files larger than 500KB
            console.warn(`Skipping large file (${fileContent.length} chars): ${filePath}`);
            continue;
          }

          try {
            const definitions = this.parseFile(filePath, fileContent);
            
            // Find the existing file node created by StructureProcessor
            const existingFileNode = graph.nodes.find(node => 
              node.label === 'File' && 
              (node.properties.path === filePath || node.properties.filePath === filePath)
            );
            
            if (existingFileNode) {
              // Update the existing file node with parsing results
              const extension = this.getFileExtension(filePath);
              const language = this.getLanguageFromExtension(extension);
              
              existingFileNode.properties.filePath = filePath; // Ensure filePath is set
              existingFileNode.properties.extension = extension;
              existingFileNode.properties.language = language;
              existingFileNode.properties.definitionCount = definitions.length;
              
              // Create definition nodes and relationships
              for (const definition of definitions) {
                const defNode = this.createDefinitionNode(filePath, definition);
                graph.nodes.push(defNode);
                
                // Create CONTAINS relationship from file to definition
                graph.relationships.push({
                  id: generateId('relationship', `${existingFileNode.id}-contains-${defNode.id}`),
                  type: 'CONTAINS',
                  source: existingFileNode.id,
                  target: defNode.id,
                  properties: {}
                });
              }
              
              // Create inheritance and override relationships
              this.createInheritanceRelationships(graph, filePath, definitions);
              
              if (definitions.length > 0) {
                successfullyParsed++;
                console.log(`‚úÖ Successfully parsed ${filePath} - found ${definitions.length} definitions`);
              } else {
                console.log(`‚ö†Ô∏è No definitions found in ${filePath} (file may be empty or contain only imports)`);
              }
            } else {
              console.warn(`‚ö†Ô∏è File node not found for ${filePath}, creating new one`);
              
              // Fallback: create file node if StructureProcessor missed it
              const extension = this.getFileExtension(filePath);
              const language = this.getLanguageFromExtension(extension);
              
              const fileNode: GraphNode = {
                id: generateId('file', filePath),
                label: 'File',
                properties: {
                  name: filePath.split('/').pop() || filePath,
                  filePath,
                  extension,
                  language,
                  definitionCount: definitions.length
                }
              };
              graph.nodes.push(fileNode);
              
              // Create definition nodes and relationships
              for (const definition of definitions) {
                const defNode = this.createDefinitionNode(filePath, definition);
                graph.nodes.push(defNode);
                
                // Create CONTAINS relationship from file to definition
                graph.relationships.push({
                  id: generateId('relationship', `${fileNode.id}-contains-${defNode.id}`),
                  type: 'CONTAINS',
                  source: fileNode.id,
                  target: defNode.id,
                  properties: {}
                });
              }
              
              // Create inheritance and override relationships
              this.createInheritanceRelationships(graph, filePath, definitions);
            }
            
          } catch (parseError) {
            failedToParse++;
            console.error(`‚ùå Failed to parse ${filePath}:`, parseError);
            
            // Find existing file node and mark it as failed to parse
            const existingFileNode = graph.nodes.find(node => 
              node.label === 'File' && 
              (node.properties.path === filePath || node.properties.filePath === filePath)
            );
            
            if (existingFileNode) {
              existingFileNode.properties.parseError = true;
              existingFileNode.properties.definitionCount = 0;
            }
          }
          
          // Clear AST cache periodically to save memory
          if (this.astCache.size > 20) {
            const oldestKeys = Array.from(this.astCache.keys()).slice(0, 10);
            for (const key of oldestKeys) {
              this.astCache.delete(key);
            }
          }
        }
        
        // Small delay between batches to prevent overwhelming the system
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      
      console.log(`ParsingProcessor: Completed - ${successfullyParsed} successful, ${failedToParse} failed`);
    } catch (error) {
      console.warn('Tree-sitter parsing failed, falling back to basic file nodes:', error);
      
      // Fallback: create basic file nodes without parsing (also in batches)
      for (let i = 0; i < sourceFiles.length; i += BATCH_SIZE) {
        const batch = sourceFiles.slice(i, i + BATCH_SIZE);
        
        for (const filePath of batch) {
          const extension = this.getFileExtension(filePath);
          const language = this.getLanguageFromExtension(extension);
          
          const fileNode: GraphNode = {
            id: generateId('file', filePath),
            label: 'File',
            properties: {
              name: filePath.split('/').pop() || filePath,
              filePath,
              extension,
              language
            }
          };
          graph.nodes.push(fileNode);
        }
      }
    }

    console.log('ParsingProcessor: Created', graph.nodes.filter(n => n.label === 'File').length, 'file nodes');
  }

  private async initializeParser(): Promise<void> {
    if (this.parser) return;

    try {
      await initTreeSitter();
      await loadPythonParser();
      
      this.parser = await initTreeSitter();
      const pythonLang = await loadPythonParser();
      this.parser.setLanguage(pythonLang);
      
      console.log('Tree-sitter parser initialized successfully');
    } catch (error) {
      console.error('Failed to initialize parser:', error);
      throw new Error(`Parser initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private parseFile(filePath: string, fileContent: string): ParsedDefinition[] {
    const extension = this.getFileExtension(filePath);
    
    if (extension === '.py') {
      // Try Tree-sitter first, fallback to regex if it fails
      if (this.parser) {
        return this.parsePythonFile(filePath, fileContent);
      } else {
        console.warn(`Tree-sitter not available for ${filePath}, using regex fallback`);
        return this.parsePythonFileRegex(filePath, fileContent);
      }
    }
    
    // Only Python files are processed now
    return [];
  }

  private parsePythonFileRegex(filePath: string, fileContent: string): ParsedDefinition[] {
    const definitions: ParsedDefinition[] = [];
    const lines = fileContent.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const lineNumber = i + 1;
      
      // Extract decorators for upcoming function/class definitions
      const decorators = this.extractDecoratorsRegex(lines, i);
      
      // Match function definitions: def function_name(
      const functionMatch = line.match(/^def\s+(\w+)\s*\(/);
      if (functionMatch) {
        definitions.push({
          name: functionMatch[1],
          type: 'function',
          startLine: lineNumber,
          endLine: lineNumber,
          decorators: decorators.length > 0 ? decorators : undefined
        });
      }
      
      // Match class definitions: class ClassName
      const classMatch = line.match(/^class\s+(\w+)(?:\s*\(.*\))?\s*:/);
      if (classMatch) {
        const baseClasses = this.extractBaseClassesRegex(line);
        definitions.push({
          name: classMatch[1],
          type: 'class',
          startLine: lineNumber,
          endLine: lineNumber,
          decorators: decorators.length > 0 ? decorators : undefined,
          baseClasses: baseClasses.length > 0 ? baseClasses : undefined
        });
      }
      
      // Match method definitions inside classes (indented def)
      const methodMatch = line.match(/^\s+def\s+(\w+)\s*\(/);
      if (methodMatch) {
        // Find the parent class by looking backwards
        let parentClass = 'UnknownClass';
        for (let j = i - 1; j >= 0; j--) {
          const prevLine = lines[j].trim();
          const classMatch = prevLine.match(/^class\s+(\w+)(?:\s*\(.*\))?\s*:/);
          if (classMatch) {
            parentClass = classMatch[1];
            break;
          }
          // Stop if we hit another function or class at root level
          if (prevLine.match(/^(def|class)\s+/)) {
            break;
          }
        }
        
        // Extract decorators for methods (look for indented decorators)
        const methodDecorators = this.extractMethodDecoratorsRegex(lines, i);
        
        definitions.push({
          name: methodMatch[1],
          type: 'method',
          startLine: lineNumber,
          endLine: lineNumber,
          parentClass,
          decorators: methodDecorators.length > 0 ? methodDecorators : undefined
        });
      }
    }
    
    console.log(`Regex-parsed ${definitions.length} Python definitions from ${filePath}`);
    return definitions;
  }

  private extractDecoratorsRegex(lines: string[], currentIndex: number): string[] {
    const decorators: string[] = [];
    
    // Look backwards for decorator lines
    for (let i = currentIndex - 1; i >= 0; i--) {
      const line = lines[i].trim();
      
      // Stop if we hit a non-decorator, non-empty line
      if (line && !line.startsWith('@')) {
        break;
      }
      
      if (line.startsWith('@')) {
        const decoratorName = this.parseDecoratorNameRegex(line);
        if (decoratorName) {
          decorators.unshift(decoratorName);
        }
      }
    }
    
    return decorators;
  }

  private extractMethodDecoratorsRegex(lines: string[], currentIndex: number): string[] {
    const decorators: string[] = [];
    
    // Look backwards for indented decorator lines
    for (let i = currentIndex - 1; i >= 0; i--) {
      const line = lines[i];
      const trimmedLine = line.trim();
      
      // Stop if we hit a non-decorator line that's not just whitespace
      if (trimmedLine && !trimmedLine.startsWith('@')) {
        break;
      }
      
      if (trimmedLine.startsWith('@') && line.match(/^\s+@/)) {
        const decoratorName = this.parseDecoratorNameRegex(trimmedLine);
        if (decoratorName) {
          decorators.unshift(decoratorName);
        }
      }
    }
    
    return decorators;
  }

  private extractBaseClassesRegex(classLine: string): string[] {
    const baseClasses: string[] = [];
    
    // Match class definition with parentheses: class Child(Parent1, Parent2):
    const match = classLine.match(/^class\s+\w+\s*\(([^)]+)\)\s*:/);
    if (match) {
      const baseClassesStr = match[1].trim();
      if (baseClassesStr) {
        // Split by comma and clean up each base class name
        const classes = baseClassesStr.split(',').map(cls => cls.trim());
        for (const cls of classes) {
          // Handle simple names and qualified names
          const cleanClass = cls.replace(/\s+/g, '');
          if (cleanClass && cleanClass.match(/^[a-zA-Z_][a-zA-Z0-9_.]*$/)) {
            baseClasses.push(cleanClass);
          }
        }
      }
    }
    
    return baseClasses;
  }

  private parseDecoratorNameRegex(decoratorLine: string): string | null {
    // Remove @ symbol and extract decorator name
    const withoutAt = decoratorLine.substring(1);
    
    // Handle simple decorators: @decorator_name
    const simpleMatch = withoutAt.match(/^([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)/);
    if (simpleMatch) {
      return simpleMatch[1];
    }
    
    // Handle decorators with arguments: @decorator_name(args)
    const withArgsMatch = withoutAt.match(/^([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)\s*\(/);
    if (withArgsMatch) {
      return withArgsMatch[1];
    }
    
    return null;
  }

  private parsePythonFile(filePath: string, fileContent: string): ParsedDefinition[] {
    if (!this.parser) {
      console.warn('Parser not initialized. Cannot parse Python file:', filePath);
      return this.parsePythonFileRegex(filePath, fileContent);
    }

    try {
      const tree = this.parser.parse(fileContent);
      
      this.astCache.set(filePath, tree);
      
      const definitions: ParsedDefinition[] = [];
      const rootNode = tree.rootNode;
      const processedMethodNodes = new Set<Parser.SyntaxNode>();

      // First pass: identify all methods inside classes
      this.traverseNode(rootNode, (currentNode: Parser.SyntaxNode) => {
        if (currentNode.type === 'class_definition') {
          this.traverseNode(currentNode, (methodNode: Parser.SyntaxNode) => {
            if (methodNode.type === 'function_definition' && methodNode !== currentNode) {
              processedMethodNodes.add(methodNode);
            }
          });
        }
      });

      // Second pass: process all definitions, skipping methods that will be handled as class methods
      this.traverseNode(rootNode, (currentNode: Parser.SyntaxNode) => {
        if (currentNode.type === 'function_definition' && !processedMethodNodes.has(currentNode)) {
          const nameNode = currentNode.childForFieldName('name');
          if (nameNode) {
            const decorators = this.extractDecorators(currentNode);
            definitions.push({
              name: nameNode.text,
              type: 'function',
              startLine: currentNode.startPosition.row + 1,
              endLine: currentNode.endPosition.row + 1,
              decorators: decorators.length > 0 ? decorators : undefined
            });
          }
        } else if (currentNode.type === 'class_definition') {
          const nameNode = currentNode.childForFieldName('name');
          if (nameNode) {
            const className = nameNode.text;
            const decorators = this.extractDecorators(currentNode);
            const baseClasses = this.extractBaseClasses(currentNode);
            definitions.push({
              name: className,
              type: 'class',
              startLine: currentNode.startPosition.row + 1,
              endLine: currentNode.endPosition.row + 1,
              decorators: decorators.length > 0 ? decorators : undefined,
              baseClasses: baseClasses.length > 0 ? baseClasses : undefined
            });
            
            const methods = this.extractMethodsFromClass(currentNode, className);
            definitions.push(...methods);
          }
        }
      });
      
      console.log(`Tree-sitter parsed ${definitions.length} Python definitions from ${filePath}`);
      return definitions;
    } catch (error) {
      console.error(`Error parsing Python file ${filePath}:`, error);
      console.log(`Falling back to regex parsing for ${filePath}`);
      return this.parsePythonFileRegex(filePath, fileContent);
    }
  }

  private createDefinitionNode(filePath: string, definition: ParsedDefinition): GraphNode {
    const nodeLabel = definition.type === 'function' ? 'Function' : 
                     (definition.type === 'method' ? 'Method' : 'Class');
    
    return {
      id: generateId(definition.type, `${filePath}:${definition.name}`),
      label: nodeLabel as 'Function' | 'Method' | 'Class',
      properties: {
        name: definition.name,
        filePath,
        startLine: definition.startLine,
        endLine: definition.endLine,
        ...(definition.parentClass && { parentClass: definition.parentClass }),
        ...(definition.decorators && { decorators: definition.decorators }),
        ...(definition.baseClasses && { baseClasses: definition.baseClasses })
      }
    };
  }

  private createInheritanceRelationships(
    graph: KnowledgeGraph,
    filePath: string,
    definitions: ParsedDefinition[]
  ): void {
    // Create INHERITS relationships for classes with base classes
    const classDefinitions = definitions.filter(def => def.type === 'class');
    
    for (const classDef of classDefinitions) {
      if (classDef.baseClasses && classDef.baseClasses.length > 0) {
        const childClassId = generateId('class', `${filePath}:${classDef.name}`);
        
        for (const baseClassName of classDef.baseClasses) {
          // Try to find the base class in the same file first
          let baseClassId = generateId('class', `${filePath}:${baseClassName}`);
          let baseClassExists = graph.nodes.some(node => node.id === baseClassId);
          
          if (!baseClassExists) {
            // If not found in same file, look for it in other files
            const baseClassNode = graph.nodes.find(node => 
              node.label === 'Class' && 
              node.properties.name === baseClassName
            );
            
            if (baseClassNode) {
              baseClassId = baseClassNode.id;
              baseClassExists = true;
            }
          }
          
          if (baseClassExists) {
            // Create INHERITS relationship
            const inheritanceRelationship: GraphRelationship = {
              id: generateId('relationship', `${childClassId}-inherits-${baseClassId}`),
              type: 'INHERITS',
              source: childClassId,
              target: baseClassId,
              properties: {}
            };
            
            graph.relationships.push(inheritanceRelationship);
            
            // Create OVERRIDES relationships for methods
            this.createOverrideRelationships(graph, filePath, classDef, baseClassName, definitions);
          }
        }
      }
    }
  }

  private createOverrideRelationships(
    graph: KnowledgeGraph,
    filePath: string,
    childClass: ParsedDefinition,
    baseClassName: string,
    allDefinitions: ParsedDefinition[]
  ): void {
    // Get all methods from the child class
    const childMethods = allDefinitions.filter(def => 
      def.type === 'method' && def.parentClass === childClass.name
    );
    
    for (const childMethod of childMethods) {
      // Look for a method with the same name in the base class
      const baseMethodId = this.findBaseClassMethod(graph, baseClassName, childMethod.name);
      
      if (baseMethodId) {
        const childMethodId = generateId('method', `${filePath}:${childMethod.name}`);
        
        // Create OVERRIDES relationship
        const overrideRelationship: GraphRelationship = {
          id: generateId('relationship', `${childMethodId}-overrides-${baseMethodId}`),
          type: 'OVERRIDES',
          source: childMethodId,
          target: baseMethodId,
          properties: {
            methodName: childMethod.name,
            childClass: childClass.name,
            baseClass: baseClassName
          }
        };
        
        graph.relationships.push(overrideRelationship);
      }
    }
  }

  private findBaseClassMethod(graph: KnowledgeGraph, baseClassName: string, methodName: string): string | null {
    // Look for a method with the given name in the base class
    const baseMethod = graph.nodes.find(node => 
      node.label === 'Method' && 
      node.properties.name === methodName &&
      node.properties.parentClass === baseClassName
    );
    
    return baseMethod ? baseMethod.id : null;
  }

  private createDefinitionRelationships(
    graph: KnowledgeGraph,
    filePath: string,
    definitions: ParsedDefinition[]
  ): void {
    const fileNodeId = generateId('file', filePath);
    
    for (const definition of definitions) {
      const defNodeId = generateId(definition.type, `${filePath}:${definition.name}`);
      
      const relationship: GraphRelationship = {
        id: generateId('relationship', `${fileNodeId}-contains-${defNodeId}`),
        source: fileNodeId,
        target: defNodeId,
        type: 'CONTAINS',
        properties: {}
      };
      
      graph.relationships.push(relationship);
      
      if (definition.type === 'method' && definition.parentClass) {
        const classNodeId = generateId('class', `${filePath}:${definition.parentClass}`);
        const methodRelationship: GraphRelationship = {
          id: generateId('relationship', `${classNodeId}-has-method-${defNodeId}`),
          source: classNodeId,
          target: defNodeId,
          type: 'CONTAINS',
          properties: {}
        };
        
        graph.relationships.push(methodRelationship);
      }
    }
  }

  private extractDefinitions(node: Parser.SyntaxNode): ParsedDefinition[] {
    const definitions: ParsedDefinition[] = [];
    
    this.traverseNode(node, (currentNode: Parser.SyntaxNode) => {
      if (currentNode.type === 'function_definition') {
        const nameNode = currentNode.childForFieldName('name');
        if (nameNode) {
          definitions.push({
            name: nameNode.text,
            type: 'function',
            startLine: currentNode.startPosition.row + 1,
            endLine: currentNode.endPosition.row + 1
          });
        }
      } else if (currentNode.type === 'class_definition') {
        const nameNode = currentNode.childForFieldName('name');
        if (nameNode) {
          const className = nameNode.text;
          definitions.push({
            name: className,
            type: 'class',
            startLine: currentNode.startPosition.row + 1,
            endLine: currentNode.endPosition.row + 1
          });
          
          const methods = this.extractMethodsFromClass(currentNode, className);
          definitions.push(...methods);
        }
      }
    });
    
    return definitions;
  }

  private extractMethodsFromClass(classNode: Parser.SyntaxNode, className: string): ParsedDefinition[] {
    const methods: ParsedDefinition[] = [];
    
    this.traverseNode(classNode, (node: Parser.SyntaxNode) => {
      if (node.type === 'function_definition') {
        const nameNode = node.childForFieldName('name');
        if (nameNode) {
          const decorators = this.extractDecorators(node);
          methods.push({
            name: nameNode.text,
            type: 'method',
            startLine: node.startPosition.row + 1,
            endLine: node.endPosition.row + 1,
            parentClass: className,
            decorators: decorators.length > 0 ? decorators : undefined
          });
        }
      }
    });
    
    return methods;
  }

  private extractBaseClasses(classNode: Parser.SyntaxNode): string[] {
    const baseClasses: string[] = [];
    
    // Look for argument_list node which contains base classes
    const argumentList = classNode.childForFieldName('superclasses');
    if (argumentList) {
      this.traverseNode(argumentList, (node: Parser.SyntaxNode) => {
        if (node.type === 'identifier') {
          baseClasses.push(node.text);
        } else if (node.type === 'attribute') {
          // Handle qualified names like module.ClassName
          baseClasses.push(node.text);
        }
      });
    }
    
    return baseClasses;
  }

  private extractDecorators(node: Parser.SyntaxNode): string[] {
    const decorators: string[] = [];
    
    // Look for decorator nodes that are siblings before the function/class definition
    let currentNode = node.previousSibling;
    
    while (currentNode && currentNode.type === 'decorator') {
      const decoratorName = this.getDecoratorName(currentNode);
      if (decoratorName) {
        decorators.unshift(decoratorName); // Add to beginning to maintain order
      }
      currentNode = currentNode.previousSibling;
    }
    
    return decorators;
  }

  private getDecoratorName(decoratorNode: Parser.SyntaxNode): string | null {
    // Find the identifier or attribute after the '@' symbol
    for (let i = 0; i < decoratorNode.childCount; i++) {
      const child = decoratorNode.child(i);
      if (!child) continue;
      
      if (child.type === 'identifier') {
        return child.text;
      } else if (child.type === 'attribute') {
        // Handle dotted decorators like @app.route
        return child.text;
      } else if (child.type === 'call') {
        // Handle decorators with arguments like @retry(attempts=3)
        const functionNode = child.childForFieldName('function');
        if (functionNode) {
          if (functionNode.type === 'identifier') {
            return functionNode.text;
          } else if (functionNode.type === 'attribute') {
            return functionNode.text;
          }
        }
      }
    }
    
    return null;
  }

  private traverseNode(node: Parser.SyntaxNode, callback: (node: Parser.SyntaxNode) => void): void {
    callback(node);
    
    for (let i = 0; i < node.childCount; i++) {
      const child = node.child(i);
      if (child) {
        this.traverseNode(child, callback);
      }
    }
  }

  private isSourceFile(filePath: string): boolean {
    // Only process Python source files
    if (!filePath) return false;
    const extension = this.getFileExtension(filePath).toLowerCase();
    return extension === '.py';
  }

  private getFileExtension(filePath: string): string {
    if (!filePath) return '';
    const lastDotIndex = filePath.lastIndexOf('.');
    if (lastDotIndex === -1) {
      return '';
    }
    return filePath.substring(lastDotIndex);
  }

  private getLanguageFromExtension(extension: string): string {
    switch (extension.toLowerCase()) {
      case '.py':
      case '.pyx':
      case '.pyi':
        return 'python';
      default:
        return 'unknown';
    }
  }

  public getAst(filePath: string): Parser.Tree | undefined {
    return this.astCache.get(filePath);
  }

  public getCachedAsts(): Map<string, Parser.Tree> {
    return new Map(this.astCache);
  }
}

================
File: src/core/ingestion/pipeline.ts
================
import type { KnowledgeGraph, GraphRelationship } from '../graph/types.ts';
import { StructureProcessor } from './structure-processor.ts';
import { ParsingProcessor } from './parsing-processor.ts';
import { CallProcessor } from './call-processor.ts';

export interface PipelineInput {
  projectRoot: string;
  projectName: string;
  filePaths: string[];
  fileContents: Map<string, string>;
}

export class GraphPipeline {
  private structureProcessor: StructureProcessor;
  private parsingProcessor: ParsingProcessor;
  private callProcessor: CallProcessor;

  constructor() {
    this.structureProcessor = new StructureProcessor();
    this.parsingProcessor = new ParsingProcessor();
    this.callProcessor = new CallProcessor();
  }

  public async run(input: PipelineInput): Promise<KnowledgeGraph> {
    const { projectRoot, projectName, filePaths, fileContents } = input;
    
    const graph: KnowledgeGraph = {
      nodes: [],
      relationships: []
    };

    console.log(`Starting 3-pass ingestion for project: ${projectName}`);
    
    // Pass 1: Structure Analysis
    console.log('Pass 1: Analyzing project structure...');
    await this.structureProcessor.process(graph, {
      projectRoot,
      projectName,
      filePaths
    });
    
    // Pass 2: Code Parsing and Definition Extraction
    console.log('Pass 2: Parsing code and extracting definitions...');
    await this.parsingProcessor.process(graph, {
      filePaths,
      fileContents
    });
    
    // Pass 3: Call Resolution
    console.log('Pass 3: Resolving function calls and references...');
    await this.callProcessor.process({
      graph,
      astCache: this.parsingProcessor.getCachedAsts(),
      fileContents
    });
    
    console.log(`Ingestion complete. Graph contains ${graph.nodes.length} nodes and ${graph.relationships.length} relationships.`);
    
    // Debug: Show graph structure
    const nodesByType = graph.nodes.reduce((acc, node) => {
      acc[node.label] = (acc[node.label] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    const relationshipsByType = graph.relationships.reduce((acc, rel) => {
      acc[rel.type] = (acc[rel.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    console.log('Node distribution:', nodesByType);
    console.log('Relationship distribution:', relationshipsByType);
    
    // Validate graph integrity
    this.validateGraph(graph);
    
    return graph;
  }

  private validateGraph(graph: KnowledgeGraph): void {
    const nodeIds = new Set(graph.nodes.map(node => node.id));
    const orphanedRelationships: GraphRelationship[] = [];
    
    for (const relationship of graph.relationships) {
      if (!nodeIds.has(relationship.source)) {
        console.warn(`Orphaned relationship: source node '${relationship.source}' not found for relationship '${relationship.id}'`);
        orphanedRelationships.push(relationship);
      }
      
      if (!nodeIds.has(relationship.target)) {
        console.warn(`Orphaned relationship: target node '${relationship.target}' not found for relationship '${relationship.id}'`);
        orphanedRelationships.push(relationship);
      }
    }
    
    // Remove orphaned relationships to prevent graph errors
    if (orphanedRelationships.length > 0) {
      console.warn(`Removing ${orphanedRelationships.length} orphaned relationships`);
      const orphanedIds = new Set(orphanedRelationships.map(rel => rel.id));
      graph.relationships = graph.relationships.filter(rel => !orphanedIds.has(rel.id));
    }
    
    console.log(`Graph validation complete. Final graph: ${graph.nodes.length} nodes, ${graph.relationships.length} relationships`);
  }

  public getStats(graph: KnowledgeGraph): { nodeStats: Record<string, number>; relationshipStats: Record<string, number> } {
    const nodeStats: Record<string, number> = {};
    const relationshipStats: Record<string, number> = {};
    
    for (const node of graph.nodes) {
      nodeStats[node.label] = (nodeStats[node.label] || 0) + 1;
    }
    
    for (const relationship of graph.relationships) {
      relationshipStats[relationship.type] = (relationshipStats[relationship.type] || 0) + 1;
    }
    
    return { nodeStats, relationshipStats };
  }

  public getCallStats(): { totalCalls: number; callTypes: Record<string, number> } {
    return this.callProcessor.getCallStats();
  }
}

================
File: src/core/ingestion/structure-processor.ts
================
import type { KnowledgeGraph, GraphNode, GraphRelationship } from '../graph/types.ts';
import { generateId } from '../../lib/utils.ts';

export interface StructureInput {
  projectRoot: string;
  projectName: string;
  filePaths: string[];
}

export class StructureProcessor {
  private nodeIdMap: Map<string, string> = new Map();

  public async process(graph: KnowledgeGraph, input: StructureInput): Promise<void> {
    const { projectRoot, projectName, filePaths } = input;
    
    // Create project root node
    const projectNode = this.createProjectNode(projectName, projectRoot);
    graph.nodes.push(projectNode);
    
    // Extract unique folder paths from file paths
    const folderPaths = this.extractFolderPaths(filePaths);
    
    // Create folder nodes and establish hierarchy
    const folderNodes = this.createFolderNodes(folderPaths);
    graph.nodes.push(...folderNodes);
    
    // Create file nodes
    const fileNodes = this.createFileNodes(filePaths);
    graph.nodes.push(...fileNodes);
    
    // Establish CONTAINS relationships
    this.createContainsRelationships(graph, projectNode.id, folderPaths, filePaths);
  }

  private createProjectNode(projectName: string, projectRoot: string): GraphNode {
    const id = generateId('project', projectName);
    this.nodeIdMap.set('', id); // Empty path represents project root
    
    return {
      id,
      label: 'Project',
      properties: {
        name: projectName,
        path: projectRoot,
        createdAt: new Date().toISOString()
      }
    };
  }

  private extractFolderPaths(filePaths: string[]): string[] {
    const folderSet = new Set<string>();
    
    for (const filePath of filePaths) {
      const pathParts = filePath.split('/');
      
      // Generate all parent folder paths
      for (let i = 1; i < pathParts.length; i++) {
        const folderPath = pathParts.slice(0, i).join('/');
        if (folderPath) {
          folderSet.add(folderPath);
        }
      }
    }
    
    return Array.from(folderSet).sort();
  }

  private createFolderNodes(folderPaths: string[]): GraphNode[] {
    const nodes: GraphNode[] = [];
    
    for (const folderPath of folderPaths) {
      const pathParts = folderPath.split('/');
      const folderName = pathParts[pathParts.length - 1];
      const id = generateId('folder', folderPath);
      
      this.nodeIdMap.set(folderPath, id);
      
      nodes.push({
        id,
        label: 'Folder',
        properties: {
          name: folderName,
          path: folderPath,
          depth: pathParts.length
        }
      });
    }
    
    return nodes;
  }

  private createFileNodes(filePaths: string[]): GraphNode[] {
    const nodes: GraphNode[] = [];
    
    for (const filePath of filePaths) {
      const pathParts = filePath.split('/');
      const fileName = pathParts[pathParts.length - 1];
      const fileExtension = this.getFileExtension(fileName);
      const id = generateId('file', filePath);
      
      this.nodeIdMap.set(filePath, id);
      
      nodes.push({
        id,
        label: 'File',
        properties: {
          name: fileName,
          filePath: filePath, // Use filePath consistently
          path: filePath, // Keep path for backward compatibility
          extension: fileExtension,
          isSourceFile: this.isSourceFile(fileExtension)
        }
      });
    }
    
    return nodes;
  }

  private createContainsRelationships(
    graph: KnowledgeGraph, 
    projectId: string, 
    folderPaths: string[], 
    filePaths: string[]
  ): void {
    const relationships: GraphRelationship[] = [];
    
    // Project contains root folders
    const rootFolders = folderPaths.filter(path => path && !path.includes('/'));
    for (const rootFolder of rootFolders) {
      const folderId = this.nodeIdMap.get(rootFolder);
      if (folderId) {
        relationships.push({
          id: generateId('relationship', `${projectId}-contains-${folderId}`),
          type: 'CONTAINS',
          source: projectId,
          target: folderId
        });
      }
    }
    
    // Folders contain subfolders
    for (const folderPath of folderPaths) {
      const parentPath = this.getParentPath(folderPath);
      const parentId = this.nodeIdMap.get(parentPath);
      const folderId = this.nodeIdMap.get(folderPath);
      
      if (parentId && folderId && parentPath !== folderPath) {
        relationships.push({
          id: generateId('relationship', `${parentId}-contains-${folderId}`),
          type: 'CONTAINS',
          source: parentId,
          target: folderId
        });
      }
    }
    
    // Folders and project contain files
    for (const filePath of filePaths) {
      const parentPath = this.getParentPath(filePath);
      const parentId = this.nodeIdMap.get(parentPath);
      const fileId = this.nodeIdMap.get(filePath);
      
      if (parentId && fileId) {
        relationships.push({
          id: generateId('relationship', `${parentId}-contains-${fileId}`),
          type: 'CONTAINS',
          source: parentId,
          target: fileId
        });
      }
    }
    
    graph.relationships.push(...relationships);
  }

  private getParentPath(path: string): string {
    const pathParts = path.split('/');
    if (pathParts.length <= 1) return '';
    return pathParts.slice(0, -1).join('/');
  }

  private getFileExtension(fileName: string): string {
    const lastDotIndex = fileName.lastIndexOf('.');
    return lastDotIndex !== -1 ? fileName.substring(lastDotIndex) : '';
  }

  private isSourceFile(extension: string): boolean {
    const sourceExtensions = new Set([
      '.py', '.js', '.ts', '.tsx', '.jsx', '.java', '.cpp', '.c', '.h', '.hpp',
      '.cs', '.php', '.rb', '.go', '.rs', '.swift', '.kt', '.scala'
    ]);
    return sourceExtensions.has(extension);
  }

  public getNodeId(path: string): string | undefined {
    return this.nodeIdMap.get(path);
  }
}

================
File: src/core/tree-sitter/parser-loader.ts
================
// Import tree-sitter explicitly to ensure Vite pre-optimizes it
import Parser from "web-tree-sitter";

let parserInstance: Parser | null = null;
const parserCache = new Map<string, Parser.Language>();

export async function initTreeSitter(): Promise<Parser> {
  if (parserInstance) return parserInstance;
  
  try {
    // Initialize WebAssembly with proper configuration
    await Parser.init({
      locateFile(scriptName: string, scriptDirectory: string) {
        // Return the correct path for WASM files
        if (scriptName.endsWith('.wasm')) {
          return `/wasm/${scriptName}`;
        }
        return scriptDirectory + scriptName;
      }
    });
    parserInstance = new Parser();
    return parserInstance;
  } catch (error) {
    console.error('Failed to initialize Tree-sitter:', error);
    throw new Error(`Tree-sitter initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function loadPythonParser(): Promise<Parser.Language> {
  if (parserCache.has('python')) {
    return parserCache.get('python')!;
  }
  
  try {
    // Load Python language from WASM file
    const wasmPath = '/wasm/python/tree-sitter-python.wasm';
    console.log('Loading Python parser from:', wasmPath);
    
    const pythonLang = await Parser.Language.load(wasmPath);
    
    parserCache.set('python', pythonLang);
    console.log('Python parser loaded successfully');
    return pythonLang;
  } catch (error) {
    console.error('Failed to load Python parser:', error);
    throw new Error(`Python parser loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

================
File: src/index.css
================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

================
File: src/lib/export.ts
================
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface ExportOptions {
  filename?: string;
  includeMetadata?: boolean;
  prettyPrint?: boolean;
  includeTimestamp?: boolean;
}

export interface ExportMetadata {
  exportedAt: string;
  version: string;
  nodeCount: number;
  relationshipCount: number;
  fileCount?: number;
  processingDuration?: number;
}

export interface ExportedGraph {
  metadata: ExportMetadata;
  graph: KnowledgeGraph;
  fileContents?: Record<string, string>;
}

/**
 * Export a KnowledgeGraph to JSON format
 */
export function exportGraphToJSON(
  graph: KnowledgeGraph,
  options: ExportOptions = {},
  fileContents?: Map<string, string>,
  processingStats?: { duration: number }
): string {
  const {
    includeMetadata = true,
    prettyPrint = true,
    includeTimestamp = true
  } = options;

  let exportData: ExportedGraph | KnowledgeGraph;

  if (includeMetadata) {
    const metadata: ExportMetadata = {
      exportedAt: includeTimestamp ? new Date().toISOString() : '',
      version: '1.0.0',
      nodeCount: graph.nodes.length,
      relationshipCount: graph.relationships.length,
      fileCount: fileContents?.size,
      processingDuration: processingStats?.duration
    };

    exportData = {
      metadata,
      graph,
      ...(fileContents && { fileContents: Object.fromEntries(fileContents) })
    };
  } else {
    exportData = graph;
  }

  return JSON.stringify(exportData, null, prettyPrint ? 2 : 0);
}

/**
 * Trigger download of a JSON file
 */
export function downloadJSON(content: string, filename: string): void {
  try {
    // Create blob with JSON content
    const blob = new Blob([content], { type: 'application/json' });
    
    // Create download URL
    const url = URL.createObjectURL(blob);
    
    // Create temporary download link
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    // Add to DOM, click, and remove
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up URL
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('Failed to download JSON file:', error);
    throw new Error('Failed to download file. Please check your browser permissions.');
  }
}

/**
 * Generate a default filename for the export
 */
export function generateExportFilename(
  projectName?: string,
  includeTimestamp: boolean = true
): string {
  const baseName = projectName 
    ? `gitnexus-${projectName.replace(/[^a-zA-Z0-9-_]/g, '-')}`
    : 'gitnexus-graph';
  
  if (includeTimestamp) {
    const timestamp = new Date().toISOString()
      .replace(/[:.]/g, '-')
      .replace('T', '_')
      .split('.')[0]; // Remove milliseconds
    return `${baseName}_${timestamp}.json`;
  }
  
  return `${baseName}.json`;
}

/**
 * Export and download a KnowledgeGraph
 */
export function exportAndDownloadGraph(
  graph: KnowledgeGraph,
  options: ExportOptions & { projectName?: string } = {},
  fileContents?: Map<string, string>,
  processingStats?: { duration: number }
): void {
  const {
    filename,
    projectName,
    includeTimestamp = true,
    ...exportOptions
  } = options;

  try {
    // Generate filename if not provided
    const finalFilename = filename || generateExportFilename(projectName, includeTimestamp);
    
    // Export to JSON
    const jsonContent = exportGraphToJSON(graph, exportOptions, fileContents, processingStats);
    
    // Trigger download
    downloadJSON(jsonContent, finalFilename);
    
    console.log(`Successfully exported graph to ${finalFilename}`);
  } catch (error) {
    console.error('Export failed:', error);
    throw error;
  }
}

/**
 * Calculate export file size (approximate)
 */
export function calculateExportSize(
  graph: KnowledgeGraph,
  includeFileContents: boolean = false,
  fileContents?: Map<string, string>
): { sizeBytes: number; sizeFormatted: string } {
  // Create a sample export to measure size
  const sampleExport = exportGraphToJSON(
    graph,
    { includeMetadata: true, prettyPrint: false },
    includeFileContents ? fileContents : undefined
  );
  
  const sizeBytes = new Blob([sampleExport]).size;
  const sizeFormatted = formatFileSize(sizeBytes);
  
  return { sizeBytes, sizeFormatted };
}

/**
 * Format file size in human-readable format
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Validate if a graph can be exported
 */
export function validateGraphForExport(graph: KnowledgeGraph): {
  isValid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  // Check if graph exists
  if (!graph) {
    errors.push('Graph is null or undefined');
    return { isValid: false, errors, warnings };
  }
  
  // Check if graph has nodes
  if (!graph.nodes || graph.nodes.length === 0) {
    warnings.push('Graph has no nodes');
  }
  
  // Check if graph has relationships
  if (!graph.relationships || graph.relationships.length === 0) {
    warnings.push('Graph has no relationships');
  }
  
  // Check for invalid node IDs
  const nodeIds = new Set(graph.nodes.map(n => n.id));
  if (nodeIds.size !== graph.nodes.length) {
    errors.push('Graph contains duplicate node IDs');
  }
  
  // Check for invalid relationships
  graph.relationships.forEach((rel, index) => {
    if (!nodeIds.has(rel.source)) {
      errors.push(`Relationship ${index} has invalid source node ID: ${rel.source}`);
    }
    if (!nodeIds.has(rel.target)) {
      errors.push(`Relationship ${index} has invalid target node ID: ${rel.target}`);
    }
  });
  
  // Check for very large exports
  const approximateSize = JSON.stringify(graph).length;
  if (approximateSize > 50 * 1024 * 1024) { // 50MB
    warnings.push('Export file will be very large (>50MB). Consider filtering the data.');
  }
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Import a KnowledgeGraph from JSON string
 */
export function importGraphFromJSON(jsonString: string): {
  graph: KnowledgeGraph;
  metadata?: ExportMetadata;
  fileContents?: Map<string, string>;
} {
  try {
    const parsed = JSON.parse(jsonString);
    
    // Check if it's an exported graph with metadata
    if (parsed.metadata && parsed.graph) {
      const result: {
        graph: KnowledgeGraph;
        metadata: ExportMetadata;
        fileContents?: Map<string, string>;
      } = {
        graph: parsed.graph,
        metadata: parsed.metadata
      };
      
      // Convert file contents back to Map if present
      if (parsed.fileContents) {
        result.fileContents = new Map(Object.entries(parsed.fileContents));
      }
      
      return result;
    }
    
    // Assume it's a raw graph
    return { graph: parsed };
  } catch (error) {
    throw new Error(`Failed to import graph: ${error instanceof Error ? error.message : 'Invalid JSON'}`);
  }
}

/**
 * Create a filtered export of the graph
 */
export function createFilteredExport(
  graph: KnowledgeGraph,
  filters: {
    nodeTypes?: string[];
    relationshipTypes?: string[];
    filePatterns?: string[];
    maxNodes?: number;
  }
): KnowledgeGraph {
  const { nodeTypes, relationshipTypes, filePatterns, maxNodes } = filters;
  
  let filteredNodes = graph.nodes;
  let filteredRelationships = graph.relationships;
  
  // Filter by node types
  if (nodeTypes && nodeTypes.length > 0) {
    filteredNodes = filteredNodes.filter(node => nodeTypes.includes(node.label));
  }
  
  // Filter by file patterns
  if (filePatterns && filePatterns.length > 0) {
    filteredNodes = filteredNodes.filter(node => {
      const filePath = node.properties.filePath as string;
      if (!filePath) return true; // Keep nodes without file paths
      
      return filePatterns.some(pattern => {
        const regex = new RegExp(pattern.replace(/\*/g, '.*'), 'i');
        return regex.test(filePath);
      });
    });
  }
  
  // Limit number of nodes
  if (maxNodes && filteredNodes.length > maxNodes) {
    filteredNodes = filteredNodes.slice(0, maxNodes);
  }
  
  // Get filtered node IDs
  const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
  
  // Filter relationships to only include those between filtered nodes
  filteredRelationships = filteredRelationships.filter(rel => 
    filteredNodeIds.has(rel.source) && filteredNodeIds.has(rel.target)
  );
  
  // Filter by relationship types
  if (relationshipTypes && relationshipTypes.length > 0) {
    filteredRelationships = filteredRelationships.filter(rel => 
      relationshipTypes.includes(rel.type)
    );
  }
  
  return {
    nodes: filteredNodes,
    relationships: filteredRelationships
  };
}

================
File: src/lib/polyfills.ts
================
// Browser polyfill for Node.js AsyncLocalStorage
export class AsyncLocalStorage<T> {
  private storage = new Map<string, T>();
  private currentId = 0;

  constructor() {}

  run<R>(store: T, callback: () => R): R {
    const id = (++this.currentId).toString();
    this.storage.set(id, store);
    try {
      return callback();
    } finally {
      this.storage.delete(id);
    }
  }

  getStore(): T | undefined {
    // In browser context, we can't truly replicate AsyncLocalStorage
    // Return undefined as fallback
    return undefined;
  }
}

// Export as both named and default to match different import styles
export { AsyncLocalStorage as default };

// Polyfill for global async_hooks if not available
if (typeof globalThis !== 'undefined' && !(globalThis as any).AsyncLocalStorage) {
  (globalThis as any).AsyncLocalStorage = AsyncLocalStorage;
}

================
File: src/lib/preload.ts
================
// Preload all dependencies that might be loaded during processing
// This ensures Vite optimizes them during initial build rather than during runtime

import 'web-tree-sitter';
import 'comlink';

// Import all the processing modules to ensure their dependencies are discovered
import '../core/ingestion/pipeline';
import '../core/ingestion/parsing-processor';
import '../core/ingestion/call-processor';
import '../core/ingestion/structure-processor';
import '../core/tree-sitter/parser-loader';

console.log('Dependencies preloaded to prevent runtime optimization');

================
File: src/lib/utils.ts
================
export function generateId(type: string, identifier: string): string {
  const timestamp = Date.now();
  const hash = simpleHash(identifier);
  return `${type}_${hash}_${timestamp}`;
}

function simpleHash(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

================
File: src/lib/workerUtils.ts
================
// @ts-expect-error -  imports are resolved at runtime in Deno
import * as Comlink from 'comlink';
import type { IngestionWorker, IngestionProgress, IngestionResult } from '../workers/ingestion.worker.ts';
import type { PipelineInput } from '../core/ingestion/pipeline.ts';

// Export types for external use
export type { IngestionProgress, IngestionResult };

export interface WorkerProxy {
  processRepository(input: PipelineInput): Promise<IngestionResult>;
  processFiles(projectName: string, files: { path: string; content: string }[]): Promise<IngestionResult>;
  validateRepository(input: PipelineInput): Promise<{ valid: boolean; errors: string[] }>;
  getWorkerInfo(): Promise<{ version: string; capabilities: string[] }>;
  setProgressCallback(callback: (progress: IngestionProgress) => void): Promise<void>;
  terminate(): Promise<void>;
}

export class IngestionWorkerManager {
  private worker: Worker | null = null;
  private workerProxy: WorkerProxy | null = null;
  private isInitialized = false;

  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      // Create the worker
      this.worker = new Worker(
        new URL('../workers/ingestion.worker.ts', import.meta.url).href,
        {
          type: 'module',
          name: 'ingestion-worker'
        }
      );

      // Wrap with Comlink
      this.workerProxy = Comlink.wrap<IngestionWorker>(this.worker) as WorkerProxy;
      
      this.isInitialized = true;
      console.log('Ingestion worker initialized successfully');
      
    } catch (error) {
      throw new Error(`Failed to initialize ingestion worker: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async processRepository(input: PipelineInput): Promise<IngestionResult> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.processRepository(input);
    } catch (error) {
      throw new Error(`Worker processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async processFiles(
    projectName: string, 
    files: { path: string; content: string }[]
  ): Promise<IngestionResult> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.processFiles(projectName, files);
    } catch (error) {
      throw new Error(`Worker file processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async validateRepository(input: PipelineInput): Promise<{ valid: boolean; errors: string[] }> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.validateRepository(input);
    } catch (error) {
      return {
        valid: false,
        errors: [`Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`]
      };
    }
  }

  public async setProgressCallback(callback: (progress: IngestionProgress) => void): Promise<void> {
    await this.ensureInitialized();
    
    try {
      // Wrap callback with Comlink.proxy to allow it to be called from worker
      const proxiedCallback = Comlink.proxy(callback);
      await this.workerProxy!.setProgressCallback(proxiedCallback);
    } catch (error) {
      console.warn('Failed to set progress callback:', error);
    }
  }

  public async getWorkerInfo(): Promise<{ version: string; capabilities: string[] }> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.getWorkerInfo();
    } catch (error) {
      throw new Error(`Failed to get worker info: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async terminate(): Promise<void> {
    if (!this.isInitialized || !this.worker) {
      return;
    }

    try {
      // Notify worker to cleanup
      if (this.workerProxy) {
        await this.workerProxy.terminate();
      }
      
      // Terminate the worker
      this.worker.terminate();
      
      // Cleanup references
      this.worker = null;
      this.workerProxy = null;
      this.isInitialized = false;
      
      console.log('Ingestion worker terminated');
      
    } catch (error) {
      console.warn('Error during worker termination:', error);
      
      // Force terminate if cleanup fails
      if (this.worker) {
        this.worker.terminate();
        this.worker = null;
        this.workerProxy = null;
        this.isInitialized = false;
      }
    }
  }

  public isWorkerReady(): boolean {
    return this.isInitialized && this.worker !== null && this.workerProxy !== null;
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.isInitialized) {
      await this.initialize();
    }
  }
}

// Singleton instance for easy access
let workerManager: IngestionWorkerManager | null = null;

export function getIngestionWorker(): IngestionWorkerManager {
  if (!workerManager) {
    workerManager = new IngestionWorkerManager();
  }
  return workerManager;
}

export async function createIngestionWorker(): Promise<IngestionWorkerManager> {
  const manager = new IngestionWorkerManager();
  await manager.initialize();
  return manager;
}

// Utility function for processing with automatic cleanup
export async function processWithWorker<T>(
  processor: (worker: IngestionWorkerManager) => Promise<T>
): Promise<T> {
  const worker = await createIngestionWorker();
  
  try {
    return await processor(worker);
  } finally {
    await worker.terminate();
  }
}

// Error handling utilities
export class WorkerError extends Error {
  constructor(message: string, public readonly cause?: Error) {
    super(message);
    this.name = 'WorkerError';
  }
}

export function isWorkerSupported(): boolean {
  try {
    return typeof Worker !== 'undefined';
  } catch {
    return false;
  }
}

================
File: src/main.tsx
================
import './lib/polyfills.ts';
import './lib/preload.ts';
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById('root')!).render(
  <App />
)

================
File: src/services/github.ts
================
import axios, { type AxiosInstance, type AxiosResponse } from 'axios';

interface GitHubFile {
  name: string;
  path: string;
  sha: string;
  size: number;
  url: string;
  html_url: string;
  git_url: string;
  download_url: string | null;
  type: 'file' | 'dir';
  content?: string;
  encoding?: string;
}

interface GitHubDirectory {
  name: string;
  path: string;
  sha: string;
  size: number;
  url: string;
  html_url: string;
  git_url: string;
  download_url: string | null;
  type: 'file' | 'dir';
}

interface RateLimitInfo {
  limit: number;
  remaining: number;
  reset: number;
  used: number;
}

interface GitHubError {
  message: string;
  documentation_url?: string;
}

export class GitHubService {
  private client: AxiosInstance;
  private baseURL = 'https://api.github.com';
  private rateLimitInfo: RateLimitInfo | null = null;

  constructor(token?: string) {
    this.client = axios.create({
      baseURL: this.baseURL,
      headers: {
        'Accept': 'application/vnd.github.v3+json',
        ...(token && { 'Authorization': `Bearer ${token}` })
      },
      timeout: 30000
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    this.client.interceptors.response.use(
      (response: AxiosResponse) => {
        this.updateRateLimitInfo(response);
        return response;
      },
      (error: { response?: AxiosResponse; message: string }) => {
        if (error.response) {
          this.updateRateLimitInfo(error.response);
          
          if (error.response.status === 403 && this.isRateLimited()) {
            const resetTime = new Date(this.rateLimitInfo!.reset * 1000);
            throw new Error(`GitHub API rate limit exceeded. Resets at ${resetTime.toISOString()}`);
          }
          
          if (error.response.status === 401) {
            throw new Error('GitHub API authentication failed. Please check your token.');
          }
          
          if (error.response.status === 404) {
            throw new Error('Repository or resource not found.');
          }
          
          const githubError: GitHubError = error.response.data;
          throw new Error(`GitHub API error: ${githubError.message}`);
        }
        
        throw new Error(`Network error: ${error.message}`);
      }
    );
  }

  private updateRateLimitInfo(response: AxiosResponse): void {
    const headers = response.headers;
    if (headers['x-ratelimit-limit']) {
      this.rateLimitInfo = {
        limit: parseInt(headers['x-ratelimit-limit'], 10),
        remaining: parseInt(headers['x-ratelimit-remaining'], 10),
        reset: parseInt(headers['x-ratelimit-reset'], 10),
        used: parseInt(headers['x-ratelimit-used'], 10)
      };
    }
  }

  private isRateLimited(): boolean {
    return this.rateLimitInfo !== null && this.rateLimitInfo.remaining === 0;
  }

  public getRateLimitInfo(): RateLimitInfo | null {
    return this.rateLimitInfo;
  }

  public async checkRateLimit(): Promise<void> {
    if (this.isRateLimited()) {
      const resetTime = new Date(this.rateLimitInfo!.reset * 1000);
      const now = new Date();
      
      if (now < resetTime) {
        const waitTime = Math.ceil((resetTime.getTime() - now.getTime()) / 1000);
        throw new Error(`Rate limit exceeded. Wait ${waitTime} seconds before making another request.`);
      }
    }
  }

  public async getRepositoryContents(
    owner: string, 
    repo: string, 
    path: string = ''
  ): Promise<(GitHubFile | GitHubDirectory)[]> {
    await this.checkRateLimit();
    
    try {
      const response = await this.client.get(`/repos/${owner}/${repo}/contents/${path}`);
      
      if (!Array.isArray(response.data)) {
        throw new Error('Expected directory contents, but received a single file.');
      }
      
      return response.data as (GitHubFile | GitHubDirectory)[];
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to fetch repository contents');
    }
  }

  public async getFileContent(
    owner: string, 
    repo: string, 
    path: string
  ): Promise<string> {
    await this.checkRateLimit();
    
    try {
      const response = await this.client.get(`/repos/${owner}/${repo}/contents/${path}`);
      const file = response.data as GitHubFile;
      
      if (file.type !== 'file') {
        throw new Error(`Path ${path} is not a file`);
      }
      
      // If content or encoding is missing, try to download directly
      if (!file.content || !file.encoding) {
        if (file.download_url) {
          console.warn(`File ${path} missing content/encoding, downloading directly`);
          return await this.downloadFileRaw(owner, repo, path);
        } else {
          throw new Error('File content, encoding, and download URL are all missing');
        }
      }
      
      if (file.encoding === 'base64') {
        try {
          return atob(file.content.replace(/\s/g, ''));
        } catch {
          throw new Error('Failed to decode base64 content');
        }
      }
      
      return file.content;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to fetch file content');
    }
  }

  public async downloadFileRaw(
    owner: string, 
    repo: string, 
    path: string
  ): Promise<string> {
    await this.checkRateLimit();
    
    try {
      const response = await this.client.get(`/repos/${owner}/${repo}/contents/${path}`);
      const file = response.data as GitHubFile;
      
      if (file.type !== 'file' || !file.download_url) {
        throw new Error(`Cannot download file: ${path}`);
      }
      
      const downloadResponse = await axios.get(file.download_url, {
        timeout: 30000
      });
      
      return downloadResponse.data;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to download file');
    }
  }

  public async getAllFilesRecursively(owner: string, repo: string, path: string = ''): Promise<GitHubFile[]> {
    const files: GitHubFile[] = [];
    
    try {
      const contents = await this.getRepositoryContents(owner, repo, path);
      
      for (const item of contents) {
        if (item.type === 'dir') {
          // Skip common directories that shouldn't be processed
          if (this.shouldSkipDirectory(item.path)) {
            console.log(`Skipping directory: ${item.path}`);
            continue;
          }
          
          // Recursively get files from subdirectories
          const subFiles = await this.getAllFilesRecursively(owner, repo, item.path);
          files.push(...subFiles);
        } else if (item.type === 'file') {
          // Only include files that should be processed
          if (this.shouldIncludeFile(item.path)) {
            files.push(item);
          } else {
            console.log(`Skipping file: ${item.path}`);
          }
        }
      }
    } catch (error) {
      console.error(`Error fetching contents for ${path}:`, error);
    }
    
    return files;
  }

  private shouldSkipDirectory(path: string): boolean {
    if (!path) return true; // Skip if path is undefined/null
    
    const skipDirs = [
      // Git version control
      '.git',
      // JavaScript dependencies (common in full-stack projects)
      'node_modules',
      // Python bytecode cache
      '__pycache__',
      // Python virtual environments
      'venv',
      'env', 
      '.venv',
      'envs',
      'virtualenv',
      // Build, distribution, and temporary directories
      'build',
      'dist', 
      'docs',
      'logs',
      'tmp',
      '.tmp',
      // Additional common directories to skip
      'coverage',
      '.coverage',
      'htmlcov',
      'vendor',
      'deps',
      '_build',
      '.gradle',
      'bin',
      'obj',
      '.vs',
      '.vscode',
      '.idea',
      'temp'
    ];
    
    // Check each directory component in the path
    const pathParts = path.split('/');
    for (const part of pathParts) {
      const dirName = part.toLowerCase();
      
      // Check for exact matches
      if (skipDirs.includes(dirName) || dirName.startsWith('.')) {
        return true;
      }
      
      // Check for .egg-info directories
      if (dirName.endsWith('.egg-info')) {
        return true;
      }
    }
    
    // Check for virtual environment patterns anywhere in the path
    const fullPathLower = path.toLowerCase();
    const venvPatterns = [
      '/.venv/',
      '/venv/',
      '/env/',
      '/.env/',
      '/envs/',
      '/virtualenv/',
      '/site-packages/',
      '/lib/python',
      '/lib64/python',
      '/scripts/',
      '/bin/python'
    ];
    
    if (venvPatterns.some(pattern => fullPathLower.includes(pattern))) {
      return true;
    }
    
    return false;
  }

  private shouldIncludeFile(path: string): boolean {
    if (!path) return false; // Skip if path is undefined/null
    
    const fileName = path.split('/').pop() || '';
    
    // Skip hidden files except specific config files
    if (fileName.startsWith('.') && !fileName.endsWith('.env.example')) {
      return false;
    }
    
    // Skip Python-specific file patterns
    const skipPatterns = [
      // Python compiled bytecode
      /\.pyc$/,
      /\.pyo$/,
      // Python extension modules (binary)
      /\.pyd$/,
      /\.so$/,
      // Python packages
      /\.egg$/,
      /\.whl$/,
      // Lock files
      /\.lock$/,
      /poetry\.lock$/,
      /Pipfile\.lock$/,
      // Editor swap files
      /\..*\.swp$/,
      /\..*\.swo$/,
      // OS metadata files
      /^Thumbs\.db$/,
      /^\.DS_Store$/,
      // General binary and archive files
      /\.zip$/,
      /\.tar$/,
      /\.rar$/,
      /\.7z$/,
      /\.gz$/,
      // Media files
      /\.(jpg|jpeg|png|gif|bmp|svg|ico)$/i,
      /\.(mp4|avi|mov|wmv|flv|webm)$/i,
      /\.(mp3|wav|flac|aac|ogg)$/i,
      // Document files
      /\.(pdf|doc|docx|xls|xlsx|ppt|pptx)$/i,
      // Other binary files
      /\.(exe|dll|dylib)$/i,
      // Minified files and source maps
      /\.min\.(js|css)$/,
      /\.map$/,
      // Log and temporary files
      /\.log$/,
      /\.tmp$/,
      /\.cache$/,
      /\.pid$/,
      /\.seed$/
    ];
    
    if (skipPatterns.some(pattern => pattern.test(fileName))) {
      return false;
    }
    
    // Only include Python files and essential config files
    const extension = '.' + fileName.split('.').pop()?.toLowerCase();
    
    // Python source files
    if (extension === '.py') {
      return true;
    }
    
    // Essential Python config files
    const importantPythonFiles = [
      'pyproject.toml',
      'setup.py',
      'requirements.txt',
      'setup.cfg',
      'tox.ini',
      'pytest.ini',
      'Pipfile',
      'poetry.toml',
      'README.md',
      'LICENSE',
      'CHANGELOG.md',
      'MANIFEST.in'
    ];
    
    if (importantPythonFiles.includes(fileName)) {
      return true;
    }
    
    return false;
  }

  public getAuthenticationStatus(): { authenticated: boolean; rateLimitInfo: RateLimitInfo | null } {
    const authHeader = this.client.defaults.headers['Authorization'];
    return {
      authenticated: !!authHeader,
      rateLimitInfo: this.rateLimitInfo
    };
  }
}

================
File: src/services/ingestion.service.ts
================
import { GitHubService } from './github.ts';
import { ZipService } from './zip.ts';
import { getIngestionWorker, type IngestionProgress } from '../lib/workerUtils.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface IngestionOptions {
  directoryFilter?: string;
  fileExtensions?: string;
  onProgress?: (message: string) => void;
}

export interface IngestionResult {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
}

export class IngestionService {
  private githubService: GitHubService;
  private zipService: ZipService;

  constructor(githubToken?: string) {
    this.githubService = new GitHubService(githubToken);
    this.zipService = new ZipService();
  }

  async processGitHubRepo(
    githubUrl: string, 
    options: IngestionOptions = {}
  ): Promise<IngestionResult> {
    const { directoryFilter, fileExtensions, onProgress } = options;

    // Parse GitHub URL
    const match = githubUrl.match(/^https:\/\/github\.com\/([^/]+)\/([^/]+)(?:\/.*)?$/);
    if (!match) {
      throw new Error('Invalid GitHub repository URL');
    }

    const [, owner, repo] = match;
    
    onProgress?.('Fetching repository structure...');
    
    // Get all files from the repository
    const allFiles = await this.githubService.getAllFilesRecursively(owner, repo);
    
    // Filter files based on options
    const filteredFiles = this.filterFiles(allFiles, directoryFilter, fileExtensions);
    
    onProgress?.(`Found ${filteredFiles.length} files. Downloading content...`);
    
    // Download file contents
    const fileContents = new Map<string, string>();
    let processedFiles = 0;
    
    for (const file of filteredFiles) {
      try {
        const content = await this.githubService.getFileContent(owner, repo, file.path);
        if (content && content.length <= 1000000) { // Skip files larger than 1MB
          fileContents.set(file.path, content);
        }
        processedFiles++;
        
        if (processedFiles % 10 === 0) {
          onProgress?.(`Downloaded ${processedFiles}/${filteredFiles.length} files...`);
        }
      } catch (error) {
        console.warn(`Failed to download ${file.path}:`, error);
      }
    }

    onProgress?.('Processing files with knowledge graph engine...');
    
    // Process with ingestion worker
    const graph = await this.processWithWorker(
      fileContents,
      `${owner}/${repo}`,
      Array.from(fileContents.keys()),
      onProgress
    );

    return { graph, fileContents };
  }

  async processZipFile(
    file: File,
    options: IngestionOptions = {}
  ): Promise<IngestionResult> {
    const { directoryFilter, fileExtensions, onProgress } = options;

    onProgress?.('Extracting ZIP file...');
    
    // Extract ZIP contents
    const allFileContents = await this.zipService.extractTextFiles(file);
    
    // Filter files based on options
    const filteredFileContents = new Map<string, string>();
    const allPaths = Array.from(allFileContents.keys());
    const filteredPaths = this.filterPaths(allPaths, directoryFilter, fileExtensions);
    
    filteredPaths.forEach(path => {
      const content = allFileContents.get(path);
      if (content) {
        filteredFileContents.set(path, content);
      }
    });

    onProgress?.(`Extracted ${filteredFileContents.size} files. Processing...`);
    
    // Process with ingestion worker
    const projectName = file.name.replace(/\.zip$/i, '');
    const graph = await this.processWithWorker(
      filteredFileContents,
      projectName,
      Array.from(filteredFileContents.keys()),
      onProgress
    );

    return { graph, fileContents: filteredFileContents };
  }

  private async processWithWorker(
    fileContents: Map<string, string>,
    projectName: string,
    filePaths: string[],
    onProgress?: (message: string) => void
  ): Promise<KnowledgeGraph> {
    const worker = getIngestionWorker();
    
    try {
      await worker.initialize();
      
      // Set up progress callback
      await worker.setProgressCallback((progress: IngestionProgress) => {
        onProgress?.(progress.message);
      });

      onProgress?.('Building knowledge graph...');
      
      // Process repository
      const result = await worker.processRepository({
        projectRoot: '/',
        projectName,
        filePaths,
        fileContents
      });

      if (!result.success || !result.graph) {
        throw new Error(result.error || 'Failed to process repository');
      }

      return result.graph;
    } catch (error) {
      throw new Error(`Processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private filterFiles(files: any[], directoryFilter?: string, fileExtensions?: string): any[] {
    let filtered = files;

    // Filter by directory
    if (directoryFilter?.trim()) {
      const dirPatterns = directoryFilter.toLowerCase().split(',').map(p => p.trim());
      filtered = filtered.filter(file => 
        dirPatterns.some(pattern => file.path.toLowerCase().includes(pattern))
      );
    }

    // Filter by file extensions
    if (fileExtensions?.trim()) {
      const extensions = fileExtensions.toLowerCase().split(',').map(ext => ext.trim());
      filtered = filtered.filter(file => 
        extensions.some(ext => file.path.toLowerCase().endsWith(ext))
      );
    }

    return filtered;
  }

  private filterPaths(paths: string[], directoryFilter?: string, fileExtensions?: string): string[] {
    let filtered = paths;

    // Filter by directory
    if (directoryFilter?.trim()) {
      const dirPatterns = directoryFilter.toLowerCase().split(',').map(p => p.trim());
      filtered = filtered.filter(path => 
        dirPatterns.some(pattern => path.toLowerCase().includes(pattern))
      );
    }

    // Filter by file extensions
    if (fileExtensions?.trim()) {
      const extensions = fileExtensions.toLowerCase().split(',').map(ext => ext.trim());
      filtered = filtered.filter(path => 
        extensions.some(ext => path.toLowerCase().endsWith(ext))
      );
    }

    return filtered;
  }
}

================
File: src/services/zip.ts
================
import JSZip from 'jszip';

interface JSZipObjectWithData extends JSZip.JSZipObject {
  _data?: {
    uncompressedSize: number;
  };
}

interface ZipFileEntry {
  path: string;
  content: string;
  isDirectory: boolean;
  size: number;
  lastModified: Date;
}

interface ExtractionOptions {
  maxFileSize?: number;
  maxTotalSize?: number;
  allowedExtensions?: string[];
  excludeDirectories?: boolean;
}

export class ZipService {
  private static readonly DEFAULT_MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
  private static readonly DEFAULT_MAX_TOTAL_SIZE = 100 * 1024 * 1024; // 100MB
  private static readonly TEXT_EXTENSIONS = new Set([
    '.js', '.ts', '.tsx', '.jsx', '.py', '.java', '.cpp', '.c', '.h', '.hpp',
    '.cs', '.php', '.rb', '.go', '.rs', '.swift', '.kt', '.scala', '.clj',
    '.html', '.htm', '.xml', '.css', '.scss', '.sass', '.less', '.json',
    '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf', '.md', '.txt',
    '.sql', '.sh', '.bash', '.zsh', '.fish', '.ps1', '.bat', '.cmd',
    '.dockerfile', '.gitignore', '.gitattributes', '.env', '.properties'
  ]);

  constructor() {}

  public async extractTextFiles(
    file: File,
    options: ExtractionOptions = {}
  ): Promise<Map<string, string>> {
    const {
      maxFileSize = ZipService.DEFAULT_MAX_FILE_SIZE,
      maxTotalSize = ZipService.DEFAULT_MAX_TOTAL_SIZE,
      allowedExtensions = Array.from(ZipService.TEXT_EXTENSIONS),
      excludeDirectories = true
    } = options;

    if (!file) {
      throw new Error('No file provided');
    }

    if (file.type !== 'application/zip' && !file.name.toLowerCase().endsWith('.zip')) {
      throw new Error('File must be a ZIP archive');
    }

    try {
      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      const zipContent = await zip.loadAsync(arrayBuffer);
      
      const extractedFiles = new Map<string, string>();
      let totalExtractedSize = 0;
      
      const files = Object.keys(zipContent.files);
      
      for (const filePath of files) {
        const zipFile = zipContent.files[filePath];
        
        if (zipFile.dir && excludeDirectories) {
          continue;
        }
        
        if (zipFile.dir) {
          extractedFiles.set(filePath, '');
          continue;
        }
        
        // Skip directories and files that shouldn't be processed
        if (this.shouldSkipPath(filePath)) {
          console.log(`Skipping filtered path: ${filePath}`);
          continue;
        }
        
        if (!this.isTextFile(filePath, allowedExtensions)) {
          continue;
        }
        
        const zipFileWithData = zipFile as JSZipObjectWithData;
        if (zipFileWithData._data && zipFileWithData._data.uncompressedSize > maxFileSize) {
          console.warn(`Skipping file ${filePath}: exceeds maximum file size (${maxFileSize} bytes)`);
          continue;
        }
        
        if (totalExtractedSize + (zipFileWithData._data?.uncompressedSize || 0) > maxTotalSize) {
          console.warn(`Stopping extraction: total size would exceed maximum (${maxTotalSize} bytes)`);
          break;
        }
        
        try {
          const content = await zipFile.async('text');
          
          if (content.length > maxFileSize) {
            console.warn(`Skipping file ${filePath}: content exceeds maximum file size`);
            continue;
          }
          
          extractedFiles.set(filePath, content);
          totalExtractedSize += content.length;
          
        } catch (fileError) {
          console.warn(`Failed to extract file ${filePath}:`, fileError);
          continue;
        }
      }
      
      return extractedFiles;
      
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes('corrupt') || error.message.includes('invalid')) {
          throw new Error('ZIP file appears to be corrupted or invalid');
        }
        throw new Error(`Failed to extract ZIP file: ${error.message}`);
      }
      throw new Error('Unknown error occurred while extracting ZIP file');
    }
  }

  public async getZipFileInfo(file: File): Promise<ZipFileEntry[]> {
    if (!file) {
      throw new Error('No file provided');
    }

    try {
      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      const zipContent = await zip.loadAsync(arrayBuffer);
      
      const fileInfos: ZipFileEntry[] = [];
      
      for (const [path, zipFile] of Object.entries(zipContent.files)) {
        const file = zipFile as { dir: boolean; _data?: { uncompressedSize: number }; date?: Date };
        fileInfos.push({
          path,
          content: '', // Don't load content for info request
          isDirectory: file.dir,
          size: file._data?.uncompressedSize || 0,
          lastModified: file.date || new Date()
        });
      }
      
      return fileInfos.sort((a, b) => a.path.localeCompare(b.path));
      
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to read ZIP file info: ${error.message}`);
      }
      throw new Error('Unknown error occurred while reading ZIP file info');
    }
  }

  public async extractSpecificFiles(
    file: File,
    filePaths: string[]
  ): Promise<Map<string, string>> {
    if (!file) {
      throw new Error('No file provided');
    }

    if (!filePaths || filePaths.length === 0) {
      throw new Error('No file paths specified');
    }

    try {
      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      const zipContent = await zip.loadAsync(arrayBuffer);
      
      const extractedFiles = new Map<string, string>();
      
      for (const filePath of filePaths) {
        const zipFile = zipContent.files[filePath];
        
        if (!zipFile) {
          console.warn(`File not found in ZIP: ${filePath}`);
          continue;
        }
        
        if (zipFile.dir) {
          extractedFiles.set(filePath, '');
          continue;
        }
        
        try {
          const content = await zipFile.async('text');
          extractedFiles.set(filePath, content);
        } catch (fileError) {
          console.warn(`Failed to extract file ${filePath}:`, fileError);
          continue;
        }
      }
      
      return extractedFiles;
      
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to extract specific files from ZIP: ${error.message}`);
      }
      throw new Error('Unknown error occurred while extracting specific files');
    }
  }

  public isValidZipFile(file: File): boolean {
    if (!file) return false;
    
    return (
      file.type === 'application/zip' || 
      file.type === 'application/x-zip-compressed' ||
      file.name.toLowerCase().endsWith('.zip')
    );
  }

  private async fileToArrayBuffer(file: File): Promise<ArrayBuffer> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = () => {
        if (reader.result instanceof ArrayBuffer) {
          resolve(reader.result);
        } else {
          reject(new Error('Failed to read file as ArrayBuffer'));
        }
      };
      
      reader.onerror = () => {
        reject(new Error('Error reading file'));
      };
      
      reader.readAsArrayBuffer(file);
    });
  }

  private isTextFile(filePath: string, allowedExtensions: string[]): boolean {
    if (!filePath || filePath.endsWith('/')) {
      return false;
    }
    
    const extension = filePath.toLowerCase().split('.').pop();
    return extension ? allowedExtensions.includes(`.${extension}`) : false;
  }

  private shouldSkipPath(filePath: string): boolean {
    // Skip directories that shouldn't be processed
    if (this.shouldSkipDirectory(filePath)) {
      return true;
    }
    
    // Skip files that shouldn't be processed
    if (!this.shouldIncludeFile(filePath)) {
      return true;
    }
    
    return false;
  }

  private shouldSkipDirectory(path: string): boolean {
    if (!path) return true; // Skip if path is undefined/null
    
    const skipDirs = [
      // Git version control
      '.git',
      // JavaScript dependencies (common in full-stack projects)
      'node_modules',
      // Python bytecode cache
      '__pycache__',
      // Python virtual environments
      'venv',
      'env', 
      '.venv',
      'envs',
      'virtualenv',
      // Build, distribution, and temporary directories
      'build',
      'dist', 
      'docs',
      'logs',
      'tmp',
      '.tmp',
      // Additional common directories to skip
      'coverage',
      '.coverage',
      'htmlcov',
      'vendor',
      'deps',
      '_build',
      '.gradle',
      'bin',
      'obj',
      '.vs',
      '.vscode',
      '.idea',
      'temp'
    ];
    
    // Check each directory component in the path
    const pathParts = path.split('/');
    for (const part of pathParts) {
      const dirName = part.toLowerCase();
      
      // Check for exact matches
      if (skipDirs.includes(dirName) || dirName.startsWith('.')) {
        return true;
      }
      
      // Check for .egg-info directories
      if (dirName.endsWith('.egg-info')) {
        return true;
      }
    }
    
    // Check for virtual environment patterns anywhere in the path
    const fullPathLower = path.toLowerCase();
    const venvPatterns = [
      '/.venv/',
      '/venv/',
      '/env/',
      '/.env/',
      '/envs/',
      '/virtualenv/',
      '/site-packages/',
      '/lib/python',
      '/lib64/python',
      '/scripts/',
      '/bin/python'
    ];
    
    if (venvPatterns.some(pattern => fullPathLower.includes(pattern))) {
      return true;
    }
    
    return false;
  }

  private shouldIncludeFile(path: string): boolean {
    if (!path) return false; // Skip if path is undefined/null
    
    const fileName = path.split('/').pop() || '';
    
    // Skip hidden files except specific config files
    if (fileName.startsWith('.') && !fileName.endsWith('.env.example')) {
      return false;
    }
    
    // Skip Python-specific file patterns
    const skipPatterns = [
      // Python compiled bytecode
      /\.pyc$/,
      /\.pyo$/,
      // Python extension modules (binary)
      /\.pyd$/,
      /\.so$/,
      // Python packages
      /\.egg$/,
      /\.whl$/,
      // Lock files
      /\.lock$/,
      /poetry\.lock$/,
      /Pipfile\.lock$/,
      // Editor swap files
      /\..*\.swp$/,
      /\..*\.swo$/,
      // OS metadata files
      /^Thumbs\.db$/,
      /^\.DS_Store$/,
      // General binary and archive files
      /\.zip$/,
      /\.tar$/,
      /\.rar$/,
      /\.7z$/,
      /\.gz$/,
      // Media files
      /\.(jpg|jpeg|png|gif|bmp|svg|ico)$/i,
      /\.(mp4|avi|mov|wmv|flv|webm)$/i,
      /\.(mp3|wav|flac|aac|ogg)$/i,
      // Document files
      /\.(pdf|doc|docx|xls|xlsx|ppt|pptx)$/i,
      // Other binary files
      /\.(exe|dll|dylib)$/i,
      // Minified files and source maps
      /\.min\.(js|css)$/,
      /\.map$/,
      // Log and temporary files
      /\.log$/,
      /\.tmp$/,
      /\.cache$/,
      /\.pid$/,
      /\.seed$/
    ];
    
    if (skipPatterns.some(pattern => pattern.test(fileName))) {
      return false;
    }
    
    // Only include Python files and essential config files
    const extension = '.' + fileName.split('.').pop()?.toLowerCase();
    
    // Python source files
    if (extension === '.py') {
      return true;
    }
    
    // Essential Python config files
    const importantPythonFiles = [
      'pyproject.toml',
      'setup.py',
      'requirements.txt',
      'setup.cfg',
      'tox.ini',
      'pytest.ini',
      'Pipfile',
      'poetry.toml',
      'README.md',
      'LICENSE',
      'CHANGELOG.md',
      'MANIFEST.in'
    ];
    
    if (importantPythonFiles.includes(fileName)) {
      return true;
    }
    
    return false;
  }

  public getDefaultTextExtensions(): string[] {
    return Array.from(ZipService.TEXT_EXTENSIONS);
  }

  public async validateZipFile(file: File): Promise<{ valid: boolean; error?: string }> {
    try {
      if (!this.isValidZipFile(file)) {
        return { valid: false, error: 'File is not a valid ZIP archive' };
      }

      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      await zip.loadAsync(arrayBuffer);
      
      return { valid: true };
      
    } catch (error) {
      return { 
        valid: false, 
        error: error instanceof Error ? error.message : 'Unknown validation error' 
      };
    }
  }
}

================
File: src/ui/components/chat/ChatInterface.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import type { KnowledgeGraph } from '../../../core/graph/types.ts';
import { LLMService, type LLMProvider, type LLMConfig } from '../../../ai/llm-service.ts';
import { CypherGenerator } from '../../../ai/cypher-generator.ts';
import { RAGOrchestrator, type RAGResponse, type RAGOptions } from '../../../ai/orchestrator.ts';

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  metadata?: {
    cypherQueries?: Array<{ cypher: string; explanation: string }>;
    sources?: string[];
    confidence?: number;
    reasoning?: Array<{ step: number; thought: string; action: string }>;
  };
}

interface ChatInterfaceProps {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
  className?: string;
  style?: React.CSSProperties;
}

interface LLMSettings {
  provider: LLMProvider;
  apiKey: string;
  model: string;
  temperature: number;
  maxTokens: number;
  // Azure OpenAI specific fields
  azureOpenAIEndpoint?: string;
  azureOpenAIDeploymentName?: string;
  azureOpenAIApiVersion?: string;
}

const ChatInterface: React.FC<ChatInterfaceProps> = ({
  graph,
  fileContents,
  className = '',
  style = {}
}) => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showReasoning, setShowReasoning] = useState(false);
  
  // LLM Configuration
  const [llmSettings, setLLMSettings] = useState<LLMSettings>({
    provider: 'openai',
    apiKey: '',
    model: 'gpt-4o-mini',
    temperature: 0.1,
    maxTokens: 4000,
    azureOpenAIEndpoint: '',
    azureOpenAIDeploymentName: '',
    azureOpenAIApiVersion: '2024-02-01'
  });

  // Services
  const [llmService] = useState(new LLMService());
  const [cypherGenerator] = useState(new CypherGenerator(llmService));
  const [ragOrchestrator] = useState(new RAGOrchestrator(llmService, cypherGenerator));

  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  // Initialize RAG context when graph or fileContents change
  useEffect(() => {
    ragOrchestrator.setContext({ graph, fileContents });
  }, [graph, fileContents, ragOrchestrator]);

  // Load settings from localStorage on mount
  useEffect(() => {
    const savedProvider = localStorage.getItem('llm_provider') as LLMProvider;
    const savedApiKey = localStorage.getItem('llm_api_key');
    const savedAzureEndpoint = localStorage.getItem('azure_openai_endpoint');
    const savedAzureDeployment = localStorage.getItem('azure_openai_deployment');
    const savedAzureApiVersion = localStorage.getItem('azure_openai_api_version');

    if (savedProvider || savedApiKey || savedAzureEndpoint) {
      setLLMSettings(prev => ({
        ...prev,
        provider: savedProvider || prev.provider,
        apiKey: savedApiKey || prev.apiKey,
        azureOpenAIEndpoint: savedAzureEndpoint || prev.azureOpenAIEndpoint,
        azureOpenAIDeploymentName: savedAzureDeployment || prev.azureOpenAIDeploymentName,
        azureOpenAIApiVersion: savedAzureApiVersion || prev.azureOpenAIApiVersion,
        // For Azure OpenAI, use deployment name as model, otherwise use default model
        model: savedProvider === 'azure-openai' 
          ? (savedAzureDeployment || 'gpt-4.1-mini-v2')
          : (savedProvider ? llmService.getAvailableModels(savedProvider)[0] : prev.model)
      }));
    }
  }, [llmService]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputValue.trim() || isLoading) return;

    // Validate API key
    if (!llmSettings.apiKey.trim()) {
      alert('Please configure your API key in settings');
      setShowSettings(true);
      return;
    }

    if (!llmService.validateApiKey(llmSettings.provider, llmSettings.apiKey)) {
      alert('Invalid API key format. Please check your settings.');
      setShowSettings(true);
      return;
    }

    // Additional validation for Azure OpenAI
    if (llmSettings.provider === 'azure-openai') {
      if (!llmSettings.azureOpenAIEndpoint?.trim()) {
        alert('Please configure your Azure OpenAI endpoint in settings');
        setShowSettings(true);
        return;
      }
      if (!llmSettings.azureOpenAIDeploymentName?.trim()) {
        alert('Please configure your Azure OpenAI deployment name in settings');
        setShowSettings(true);
        return;
      }
    }

    const userMessage: ChatMessage = {
      id: generateId(),
      role: 'user',
      content: inputValue.trim(),
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInputValue('');
    setIsLoading(true);

    try {
      const llmConfig: LLMConfig = {
        provider: llmSettings.provider,
        apiKey: llmSettings.apiKey,
        model: llmSettings.model,
        temperature: llmSettings.temperature,
        maxTokens: llmSettings.maxTokens,
        // Azure OpenAI specific fields
        azureOpenAIEndpoint: llmSettings.azureOpenAIEndpoint,
        azureOpenAIDeploymentName: llmSettings.azureOpenAIDeploymentName,
        azureOpenAIApiVersion: llmSettings.azureOpenAIApiVersion
      };

      const ragOptions: RAGOptions = {
        maxReasoningSteps: 5,
        includeReasoning: showReasoning,
        strictMode: false,
        temperature: llmSettings.temperature
      };

      const response: RAGResponse = await ragOrchestrator.answerQuestion(
        userMessage.content,
        llmConfig,
        ragOptions
      );

      const assistantMessage: ChatMessage = {
        id: generateId(),
        role: 'assistant',
        content: response.answer,
        timestamp: new Date(),
        metadata: {
          cypherQueries: response.cypherQueries.map(q => ({
            cypher: q.cypher,
            explanation: q.explanation
          })),
          sources: response.sources,
          confidence: response.confidence,
          reasoning: showReasoning ? response.reasoning.map(r => ({
            step: r.step,
            thought: r.thought,
            action: r.action
          })) : undefined
        }
      };

      setMessages(prev => [...prev, assistantMessage]);

    } catch (error) {
      const errorMessage: ChatMessage = {
        id: generateId(),
        role: 'assistant',
        content: `I apologize, but I encountered an error while processing your question: ${error instanceof Error ? error.message : 'Unknown error'}`,
        timestamp: new Date()
      };

      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  // Handle key press in textarea
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e as any);
    }
  };

  // Clear conversation
  const clearConversation = () => {
    setMessages([]);
  };

  // Generate unique ID
  const generateId = () => {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  };

  // Get available models for current provider
  const getAvailableModels = () => {
    return llmService.getAvailableModels(llmSettings.provider);
  };

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    height: '600px',
    border: '1px solid #ddd',
    borderRadius: '8px',
    backgroundColor: '#fff',
    ...style
  };

  const headerStyle: React.CSSProperties = {
    padding: '16px',
    borderBottom: '1px solid #eee',
    backgroundColor: '#f8f9fa',
    borderRadius: '8px 8px 0 0',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center'
  };

  const messagesStyle: React.CSSProperties = {
    flex: 1,
    overflowY: 'auto',
    padding: '16px',
    display: 'flex',
    flexDirection: 'column',
    gap: '16px'
  };

  const inputAreaStyle: React.CSSProperties = {
    padding: '16px',
    borderTop: '1px solid #eee'
  };

  const messageStyle = (role: 'user' | 'assistant'): React.CSSProperties => ({
    padding: '12px 16px',
    borderRadius: '12px',
    maxWidth: '80%',
    alignSelf: role === 'user' ? 'flex-end' : 'flex-start',
    backgroundColor: role === 'user' ? '#007bff' : '#f1f3f4',
    color: role === 'user' ? '#fff' : '#333',
    wordWrap: 'break-word'
  });

  const buttonStyle: React.CSSProperties = {
    padding: '8px 16px',
    border: 'none',
    borderRadius: '4px',
    backgroundColor: '#007bff',
    color: '#fff',
    cursor: 'pointer',
    fontSize: '14px'
  };

  const textareaStyle: React.CSSProperties = {
    width: '100%',
    minHeight: '60px',
    padding: '12px',
    border: '1px solid #ddd',
    borderRadius: '4px',
    resize: 'vertical',
    fontSize: '14px',
    fontFamily: 'inherit'
  };

  return (
    <div className={`chat-interface ${className}`} style={containerStyle}>
      {/* Header */}
      <div style={headerStyle}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <span style={{ fontSize: '18px', fontWeight: '600' }}>üí¨</span>
          <span style={{ fontSize: '16px', fontWeight: '600' }}>Code Assistant</span>
          <span style={{ 
            fontSize: '12px', 
            color: '#666',
            backgroundColor: '#e9ecef',
            padding: '2px 8px',
            borderRadius: '12px'
          }}>
            {llmService.getProviderDisplayName(llmSettings.provider)}
          </span>
        </div>
        
        <div style={{ display: 'flex', gap: '8px' }}>
          <button
            onClick={() => setShowReasoning(!showReasoning)}
            style={{
              ...buttonStyle,
              backgroundColor: showReasoning ? '#28a745' : '#6c757d',
              fontSize: '12px',
              padding: '6px 12px'
            }}
            title="Toggle reasoning display"
          >
            üß† Reasoning
          </button>
          <button
            onClick={() => setShowSettings(!showSettings)}
            style={{ ...buttonStyle, fontSize: '12px', padding: '6px 12px' }}
            title="Settings"
          >
            ‚öôÔ∏è
          </button>
          <button
            onClick={clearConversation}
            style={{
              ...buttonStyle,
              backgroundColor: '#dc3545',
              fontSize: '12px',
              padding: '6px 12px'
            }}
            title="Clear conversation"
          >
            üóëÔ∏è
          </button>
        </div>
      </div>

      {/* Settings Panel */}
      {showSettings && (
        <div style={{
          padding: '16px',
          backgroundColor: '#f8f9fa',
          borderBottom: '1px solid #eee'
        }}>
          <h4 style={{ margin: '0 0 12px 0', fontSize: '14px' }}>LLM Configuration</h4>
          
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', marginBottom: '12px' }}>
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>Provider</label>
              <select
                value={llmSettings.provider}
                onChange={(e) => setLLMSettings(prev => ({
                  ...prev,
                  provider: e.target.value as LLMProvider,
                  model: llmService.getAvailableModels(e.target.value as LLMProvider)[0]
                }))}
                style={{ width: '100%', padding: '6px', fontSize: '14px' }}
              >
                <option value="openai">OpenAI</option>
                <option value="azure-openai">Azure OpenAI</option>
                <option value="anthropic">Anthropic</option>
                <option value="gemini">Google Gemini</option>
              </select>
            </div>
            
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>
                {llmSettings.provider === 'azure-openai' ? 'Deployment Name' : 'Model'}
              </label>
              {llmSettings.provider === 'azure-openai' ? (
                <input
                  type="text"
                  value={llmSettings.model}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, model: e.target.value }))}
                  placeholder="gpt-4.1-mini-v2"
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                />
              ) : (
                <select
                  value={llmSettings.model}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, model: e.target.value }))}
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                >
                  {getAvailableModels().map(model => (
                    <option key={model} value={model}>{model}</option>
                  ))}
                </select>
              )}
            </div>
          </div>

          <div style={{ marginBottom: '12px' }}>
            <label style={{ fontSize: '12px', color: '#666' }}>API Key</label>
            <input
              type="password"
              value={llmSettings.apiKey}
              onChange={(e) => setLLMSettings(prev => ({ ...prev, apiKey: e.target.value }))}
              placeholder={
                llmSettings.provider === 'azure-openai' ? 'Your Azure OpenAI key...' :
                llmSettings.provider === 'anthropic' ? 'sk-ant-...' :
                llmSettings.provider === 'gemini' ? 'Your Google API key...' : 'sk-...'
              }
              style={{ width: '100%', padding: '6px', fontSize: '14px' }}
            />
          </div>

          {/* Azure OpenAI Specific Fields */}
          {llmSettings.provider === 'azure-openai' && (
            <>
              <div style={{ marginBottom: '12px' }}>
                <label style={{ fontSize: '12px', color: '#666' }}>Azure OpenAI Endpoint</label>
                <input
                  type="text"
                  value={llmSettings.azureOpenAIEndpoint || ''}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, azureOpenAIEndpoint: e.target.value }))}
                  placeholder="https://your-resource.openai.azure.com"
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                />
              </div>

              <div style={{ marginBottom: '12px' }}>
                <label style={{ fontSize: '12px', color: '#666' }}>API Version</label>
                <input
                  type="text"
                  value={llmSettings.azureOpenAIApiVersion || '2024-02-01'}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, azureOpenAIApiVersion: e.target.value }))}
                  placeholder="2024-02-01"
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                />
              </div>
            </>
          )}

          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>
                Temperature: {llmSettings.temperature}
              </label>
              <input
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={llmSettings.temperature}
                onChange={(e) => setLLMSettings(prev => ({ ...prev, temperature: parseFloat(e.target.value) }))}
                style={{ width: '100%' }}
              />
            </div>
            
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>Max Tokens</label>
              <input
                type="number"
                min="100"
                max="8000"
                step="100"
                value={llmSettings.maxTokens}
                onChange={(e) => setLLMSettings(prev => ({ ...prev, maxTokens: parseInt(e.target.value) }))}
                style={{ width: '100%', padding: '6px', fontSize: '14px' }}
              />
            </div>
          </div>

          {/* Save Button */}
          <div style={{ marginTop: '16px', display: 'flex', justifyContent: 'flex-end', gap: '8px' }}>
            <button
              onClick={() => {
                // Save to localStorage
                localStorage.setItem('llm_provider', llmSettings.provider);
                localStorage.setItem('llm_api_key', llmSettings.apiKey);
                if (llmSettings.azureOpenAIEndpoint) {
                  localStorage.setItem('azure_openai_endpoint', llmSettings.azureOpenAIEndpoint);
                }
                // For Azure OpenAI, the model field contains the deployment name
                if (llmSettings.provider === 'azure-openai' && llmSettings.model) {
                  localStorage.setItem('azure_openai_deployment', llmSettings.model);
                }
                if (llmSettings.azureOpenAIApiVersion) {
                  localStorage.setItem('azure_openai_api_version', llmSettings.azureOpenAIApiVersion);
                }
                setShowSettings(false);
                alert('Settings saved successfully!');
              }}
              style={{
                ...buttonStyle,
                backgroundColor: '#28a745',
                fontSize: '12px',
                padding: '8px 16px'
              }}
            >
              üíæ Save Settings
            </button>
            <button
              onClick={() => setShowSettings(false)}
              style={{
                ...buttonStyle,
                backgroundColor: '#6c757d',
                fontSize: '12px',
                padding: '8px 16px'
              }}
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Messages */}
      <div style={messagesStyle}>
        {messages.length === 0 && (
          <div style={{
            textAlign: 'center',
            color: '#666',
            fontSize: '14px',
            padding: '40px 20px'
          }}>
            <div style={{ fontSize: '48px', marginBottom: '16px', opacity: 0.3 }}>üí¨</div>
            <div>Ask me anything about the codebase!</div>
            <div style={{ fontSize: '12px', marginTop: '8px', color: '#999' }}>
              I can help you understand functions, classes, dependencies, and more.
            </div>
          </div>
        )}

        {messages.map((message) => (
          <div key={message.id}>
            <div style={messageStyle(message.role)}>
              <div style={{ marginBottom: message.metadata ? '8px' : '0' }}>
                {message.content}
              </div>
              
              {/* Metadata */}
              {message.metadata && (
                <div style={{ fontSize: '12px', opacity: 0.8 }}>
                  {message.metadata.confidence && (
                    <div style={{ marginBottom: '4px' }}>
                      Confidence: {Math.round(message.metadata.confidence * 100)}%
                    </div>
                  )}
                  
                  {message.metadata.sources && message.metadata.sources.length > 0 && (
                    <div style={{ marginBottom: '4px' }}>
                      Sources: {message.metadata.sources.join(', ')}
                    </div>
                  )}
                  
                  {message.metadata.cypherQueries && message.metadata.cypherQueries.length > 0 && (
                    <details style={{ marginTop: '8px' }}>
                      <summary style={{ cursor: 'pointer' }}>View Queries ({message.metadata.cypherQueries.length})</summary>
                      {message.metadata.cypherQueries.map((query, index) => (
                        <div key={index} style={{ 
                          marginTop: '4px', 
                          padding: '8px', 
                          backgroundColor: 'rgba(0,0,0,0.1)', 
                          borderRadius: '4px',
                          fontFamily: 'monospace',
                          fontSize: '11px'
                        }}>
                          <div><strong>Query:</strong> {query.cypher}</div>
                          <div><strong>Explanation:</strong> {query.explanation}</div>
                        </div>
                      ))}
                    </details>
                  )}

                  {message.metadata.reasoning && message.metadata.reasoning.length > 0 && (
                    <details style={{ marginTop: '8px' }}>
                      <summary style={{ cursor: 'pointer' }}>View Reasoning ({message.metadata.reasoning.length} steps)</summary>
                      {message.metadata.reasoning.map((step, index) => (
                        <div key={index} style={{ 
                          marginTop: '4px', 
                          padding: '8px', 
                          backgroundColor: 'rgba(0,0,0,0.1)', 
                          borderRadius: '4px',
                          fontSize: '11px'
                        }}>
                          <div><strong>Step {step.step}:</strong> {step.thought}</div>
                          <div><strong>Action:</strong> {step.action}</div>
                        </div>
                      ))}
                    </details>
                  )}
                </div>
              )}
            </div>
            
            <div style={{
              fontSize: '11px',
              color: '#999',
              textAlign: message.role === 'user' ? 'right' : 'left',
              marginTop: '4px'
            }}>
              {message.timestamp.toLocaleTimeString()}
            </div>
          </div>
        ))}

        {isLoading && (
          <div style={messageStyle('assistant')}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              <div style={{ 
                width: '16px', 
                height: '16px', 
                border: '2px solid #ccc',
                borderTop: '2px solid #007bff',
                borderRadius: '50%',
                animation: 'spin 1s linear infinite'
              }} />
              Thinking...
            </div>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Input Area */}
      <div style={inputAreaStyle}>
        <form onSubmit={handleSubmit} style={{ display: 'flex', gap: '8px' }}>
          <textarea
            ref={inputRef}
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Ask a question about the code..."
            style={textareaStyle}
            disabled={isLoading}
          />
          <button
            type="submit"
            disabled={isLoading || !inputValue.trim()}
            style={{
              ...buttonStyle,
              minWidth: '80px',
              opacity: (isLoading || !inputValue.trim()) ? 0.5 : 1
            }}
          >
            {isLoading ? '...' : 'Send'}
          </button>
        </form>
      </div>

      {/* CSS for spinner animation */}
      <style>{`
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `}</style>
    </div>
  );
};

export default ChatInterface;

================
File: src/ui/components/chat/CodeAssistant.tsx
================
import React, { useState } from 'react';
import ChatInterface from './ChatInterface.tsx';
import { GraphExplorer } from '../graph/index.ts';
import type { KnowledgeGraph } from '../../../core/graph/types.ts';

interface CodeAssistantProps {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
  className?: string;
  style?: React.CSSProperties;
}

type ViewMode = 'chat' | 'graph' | 'split';

const CodeAssistant: React.FC<CodeAssistantProps> = ({
  graph,
  fileContents,
  className = '',
  style = {}
}) => {
  const [viewMode, setViewMode] = useState<ViewMode>('split');

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    height: '800px',
    backgroundColor: '#f5f5f5',
    borderRadius: '8px',
    overflow: 'hidden',
    ...style
  };

  const headerStyle: React.CSSProperties = {
    padding: '16px',
    backgroundColor: '#fff',
    borderBottom: '1px solid #ddd',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center'
  };

  const contentStyle: React.CSSProperties = {
    flex: 1,
    display: 'flex',
    overflow: 'hidden'
  };

  const panelStyle: React.CSSProperties = {
    flex: 1,
    display: 'flex',
    flexDirection: 'column',
    overflow: 'hidden'
  };

  const buttonStyle = (active: boolean): React.CSSProperties => ({
    padding: '8px 16px',
    border: 'none',
    borderRadius: '4px',
    backgroundColor: active ? '#007bff' : '#6c757d',
    color: '#fff',
    cursor: 'pointer',
    fontSize: '14px',
    marginLeft: '8px'
  });

  const renderContent = () => {
    switch (viewMode) {
      case 'chat':
        return (
          <div style={panelStyle}>
            <ChatInterface
              graph={graph}
              fileContents={fileContents}
              style={{ height: '100%' }}
            />
          </div>
        );

      case 'graph':
        return (
          <div style={panelStyle}>
            <GraphExplorer
              graph={graph}
              style={{ height: '100%' }}
            />
          </div>
        );

      case 'split':
        return (
          <>
            <div style={{ ...panelStyle, marginRight: '8px' }}>
              <div style={{
                fontSize: '14px',
                fontWeight: '600',
                padding: '8px 12px',
                backgroundColor: '#e9ecef',
                borderRadius: '4px 4px 0 0',
                marginBottom: '8px'
              }}>
                üí¨ AI Assistant
              </div>
              <ChatInterface
                graph={graph}
                fileContents={fileContents}
                style={{ height: 'calc(100% - 40px)' }}
              />
            </div>
            
            <div style={{ ...panelStyle, marginLeft: '8px' }}>
              <div style={{
                fontSize: '14px',
                fontWeight: '600',
                padding: '8px 12px',
                backgroundColor: '#e9ecef',
                borderRadius: '4px 4px 0 0',
                marginBottom: '8px'
              }}>
                üï∏Ô∏è Knowledge Graph
              </div>
              <GraphExplorer
                graph={graph}
                style={{ height: 'calc(100% - 40px)' }}
              />
            </div>
          </>
        );

      default:
        return null;
    }
  };

  const getStatsText = () => {
    const nodeCount = graph.nodes.length;
    const relationshipCount = graph.relationships.length;
    const fileCount = fileContents.size;
    
    return `${nodeCount} nodes ‚Ä¢ ${relationshipCount} relationships ‚Ä¢ ${fileCount} files`;
  };

  return (
    <div className={`code-assistant ${className}`} style={containerStyle}>
      {/* Header */}
      <div style={headerStyle}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <span style={{ fontSize: '20px', fontWeight: '600' }}>ü§ñ</span>
          <div>
            <div style={{ fontSize: '18px', fontWeight: '600' }}>
              GitNexus Code Assistant
            </div>
            <div style={{ fontSize: '12px', color: '#666' }}>
              {getStatsText()}
            </div>
          </div>
        </div>

        <div style={{ display: 'flex', alignItems: 'center' }}>
          <span style={{ fontSize: '14px', color: '#666', marginRight: '12px' }}>
            View:
          </span>
          <button
            onClick={() => setViewMode('chat')}
            style={buttonStyle(viewMode === 'chat')}
          >
            üí¨ Chat Only
          </button>
          <button
            onClick={() => setViewMode('graph')}
            style={buttonStyle(viewMode === 'graph')}
          >
            üï∏Ô∏è Graph Only
          </button>
          <button
            onClick={() => setViewMode('split')}
            style={buttonStyle(viewMode === 'split')}
          >
            üì± Split View
          </button>
        </div>
      </div>

      {/* Content */}
      <div style={contentStyle}>
        {renderContent()}
      </div>

      {/* Help Text */}
      {graph.nodes.length === 0 && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          textAlign: 'center',
          color: '#666',
          fontSize: '16px',
          zIndex: 10
        }}>
          <div style={{ fontSize: '64px', marginBottom: '16px', opacity: 0.3 }}>
            ü§ñ
          </div>
          <div style={{ marginBottom: '8px' }}>
            No knowledge graph loaded
          </div>
          <div style={{ fontSize: '14px', color: '#999' }}>
            Please load a project to start using the AI assistant
          </div>
        </div>
      )}
    </div>
  );
};

export default CodeAssistant;

================
File: src/ui/components/chat/index.ts
================
export { default as ChatInterface } from './ChatInterface.tsx';
export { default as CodeAssistant } from './CodeAssistant.tsx';

================
File: src/ui/components/ErrorBoundary.tsx
================
import React, { Component, ReactNode } from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    // Update state so the next render will show the fallback UI
    return {
      hasError: true,
      error
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log the error to console for debugging
    console.error('ErrorBoundary caught an error:', error);
    console.error('Error info:', errorInfo);

    // Update state with error details
    this.setState({
      error,
      errorInfo
    });

    // Call optional error handler
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }

    // In a production app, you might want to log this to an error reporting service
    // logErrorToService(error, errorInfo);
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };

  render() {
    if (this.state.hasError) {
      // Custom fallback UI
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Default error UI
      return (
        <div style={containerStyle}>
          <div style={errorBoxStyle}>
            <div style={iconStyle}>‚ö†Ô∏è</div>
            
            <h2 style={titleStyle}>Something went wrong</h2>
            
            <p style={messageStyle}>
              We encountered an unexpected error. This might be due to a temporary issue 
              or an incompatibility with your browser.
            </p>

            <div style={buttonContainerStyle}>
              <button
                onClick={this.handleReset}
                style={primaryButtonStyle}
              >
                Try Again
              </button>
              
              <button
                onClick={() => window.location.reload()}
                style={secondaryButtonStyle}
              >
                Reload Page
              </button>
            </div>

            {/* Error details (collapsible) */}
            <details style={detailsStyle}>
              <summary style={summaryStyle}>
                Technical Details (for developers)
              </summary>
              
              <div style={errorDetailsStyle}>
                <div style={errorSectionStyle}>
                  <strong>Error:</strong>
                  <pre style={preStyle}>
                    {this.state.error?.toString()}
                  </pre>
                </div>
                
                {this.state.errorInfo && (
                  <div style={errorSectionStyle}>
                    <strong>Component Stack:</strong>
                    <pre style={preStyle}>
                      {this.state.errorInfo.componentStack}
                    </pre>
                  </div>
                )}
                
                {this.state.error?.stack && (
                  <div style={errorSectionStyle}>
                    <strong>Stack Trace:</strong>
                    <pre style={preStyle}>
                      {this.state.error.stack}
                    </pre>
                  </div>
                )}
              </div>
            </details>

            <div style={helpTextStyle}>
              <p>
                <strong>What you can do:</strong>
              </p>
              <ul style={helpListStyle}>
                <li>Try refreshing the page</li>
                <li>Clear your browser cache and reload</li>
                <li>Try a different browser</li>
                <li>Check the console for additional error details</li>
              </ul>
              
              <p style={reportStyle}>
                If this problem persists, please report it with the technical details above.
              </p>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

// Styles
const containerStyle: React.CSSProperties = {
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  minHeight: '400px',
  padding: '20px',
  backgroundColor: '#f8f9fa',
  fontFamily: 'system-ui, -apple-system, sans-serif'
};

const errorBoxStyle: React.CSSProperties = {
  maxWidth: '600px',
  width: '100%',
  backgroundColor: '#fff',
  borderRadius: '8px',
  padding: '32px',
  boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
  border: '1px solid #e9ecef',
  textAlign: 'center'
};

const iconStyle: React.CSSProperties = {
  fontSize: '48px',
  marginBottom: '16px'
};

const titleStyle: React.CSSProperties = {
  fontSize: '24px',
  fontWeight: '600',
  color: '#dc3545',
  margin: '0 0 16px 0'
};

const messageStyle: React.CSSProperties = {
  fontSize: '16px',
  color: '#666',
  lineHeight: '1.5',
  margin: '0 0 24px 0'
};

const buttonContainerStyle: React.CSSProperties = {
  display: 'flex',
  gap: '12px',
  justifyContent: 'center',
  marginBottom: '24px'
};

const primaryButtonStyle: React.CSSProperties = {
  padding: '12px 24px',
  backgroundColor: '#007bff',
  color: '#fff',
  border: 'none',
  borderRadius: '4px',
  fontSize: '14px',
  fontWeight: '500',
  cursor: 'pointer',
  transition: 'background-color 0.2s ease'
};

const secondaryButtonStyle: React.CSSProperties = {
  padding: '12px 24px',
  backgroundColor: '#6c757d',
  color: '#fff',
  border: 'none',
  borderRadius: '4px',
  fontSize: '14px',
  fontWeight: '500',
  cursor: 'pointer',
  transition: 'background-color 0.2s ease'
};

const detailsStyle: React.CSSProperties = {
  textAlign: 'left',
  marginTop: '24px',
  border: '1px solid #dee2e6',
  borderRadius: '4px'
};

const summaryStyle: React.CSSProperties = {
  padding: '12px 16px',
  backgroundColor: '#f8f9fa',
  cursor: 'pointer',
  fontSize: '14px',
  fontWeight: '500',
  borderBottom: '1px solid #dee2e6'
};

const errorDetailsStyle: React.CSSProperties = {
  padding: '16px',
  fontSize: '12px'
};

const errorSectionStyle: React.CSSProperties = {
  marginBottom: '16px'
};

const preStyle: React.CSSProperties = {
  backgroundColor: '#f8f9fa',
  padding: '12px',
  borderRadius: '4px',
  overflow: 'auto',
  fontSize: '11px',
  fontFamily: 'Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace',
  color: '#e83e8c',
  border: '1px solid #dee2e6',
  marginTop: '8px'
};

const helpTextStyle: React.CSSProperties = {
  textAlign: 'left',
  marginTop: '24px',
  padding: '16px',
  backgroundColor: '#f8f9fa',
  borderRadius: '4px',
  fontSize: '14px'
};

const helpListStyle: React.CSSProperties = {
  margin: '8px 0',
  paddingLeft: '20px'
};

const reportStyle: React.CSSProperties = {
  fontSize: '12px',
  color: '#666',
  fontStyle: 'italic',
  marginTop: '12px'
};

export default ErrorBoundary;

================
File: src/ui/components/graph/GraphExplorer.tsx
================
import React, { useState, useEffect } from 'react';
import GraphVisualization from './Visualization.tsx';
import type { KnowledgeGraph } from '../../../core/graph/types.ts';

interface GraphExplorerProps {
  graph: KnowledgeGraph;
  fileContents?: Map<string, string>;
  className?: string;
  style?: React.CSSProperties;
  onNodeSelect?: (nodeId: string | null) => void;
  selectedNodeId?: string | null;
}

const GraphExplorer: React.FC<GraphExplorerProps> = ({
  graph,
  fileContents,
  className = '',
  style = {},
  onNodeSelect,
  selectedNodeId
}) => {
  const [internalSelectedNodeId, setInternalSelectedNodeId] = useState<string | null>(null);

  // Use external selectedNodeId if provided, otherwise use internal state
  const currentSelectedNodeId = selectedNodeId !== undefined ? selectedNodeId : internalSelectedNodeId;

  const handleNodeSelect = (nodeId: string | null) => {
    if (onNodeSelect) {
      onNodeSelect(nodeId);
    } else {
      setInternalSelectedNodeId(nodeId);
    }
  };

  const handleDownloadKG = () => {
    if (!graph) return;

    const kgData = {
      nodes: graph.nodes,
      relationships: graph.relationships,
      metadata: {
        exportDate: new Date().toISOString(),
        nodeCount: graph.nodes.length,
        relationshipCount: graph.relationships.length,
        version: "1.0"
      }
    };

    const jsonString = JSON.stringify(kgData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `knowledge-graph-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  // Warm tone colors to match the new theme
  const colors = {
    background: '#FEF9F0', // Slightly warm white
    surface: '#FFFFFF',
    text: '#451A03', // Dark brown
    textSecondary: '#78350F', // Medium brown
    textMuted: '#A16207', // Light brown
    border: '#FED7AA', // Light orange
    borderLight: '#FEF3C7', // Very light orange
    primary: '#D97706' // Warm orange
  };

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    width: '100%',
    backgroundColor: colors.background,
    overflow: 'hidden',
    ...style
  };

  const headerStyle: React.CSSProperties = {
    padding: '24px 24px 16px 24px',
    backgroundColor: colors.surface,
    borderBottom: `1px solid ${colors.borderLight}`
  };

  const titleStyle: React.CSSProperties = {
    fontSize: '20px',
    fontWeight: '700',
    color: colors.text,
    marginBottom: '16px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    width: '100%'
  };

  const titleLeftStyle: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    gap: '12px'
  };

  const downloadButtonStyle: React.CSSProperties = {
    padding: '8px 16px',
    backgroundColor: colors.primary,
    color: '#FFFFFF',
    border: 'none',
    borderRadius: '6px',
    fontSize: '14px',
    fontWeight: '500',
    cursor: 'pointer',
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
    transition: 'all 0.2s ease',
    boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
  };

  const statsContainerStyle: React.CSSProperties = {
    display: 'flex',
    gap: '24px',
    flexWrap: 'wrap'
  };

  const statItemStyle: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
    padding: '8px 16px',
    backgroundColor: colors.background,
    borderRadius: '8px',
    border: `1px solid ${colors.borderLight}`,
    fontSize: '14px',
    fontWeight: '500',
    color: colors.textSecondary
  };

  const graphContainerStyle: React.CSSProperties = {
    flex: 1,
    overflow: 'hidden',
    position: 'relative'
  };

  const selectedNodeInfoStyle: React.CSSProperties = {
    position: 'absolute',
    top: '16px',
    left: '16px',
    backgroundColor: 'rgba(255, 255, 255, 0.95)',
    backdropFilter: 'blur(8px)',
    padding: '12px 16px',
    borderRadius: '8px',
    border: `1px solid ${colors.borderLight}`,
    fontSize: '14px',
    fontWeight: '500',
    color: colors.text,
    zIndex: 10,
    boxShadow: '0 4px 12px rgba(0,0,0,0.1)'
  };

  // Calculate graph statistics
  const nodeStats = graph?.nodes?.reduce((acc, node) => {
    acc[node.label] = (acc[node.label] || 0) + 1;
    return acc;
  }, {} as Record<string, number>) || {};

  function getSelectedNodeName(): string {
    if (!currentSelectedNodeId || !graph?.nodes) return '';
    const node = graph.nodes.find(n => n.id === currentSelectedNodeId);
    return node?.properties.name as string || node?.id || '';
  }

  function getNodeTypeIcon(nodeType: string): string {
    switch (nodeType.toLowerCase()) {
      case 'project': return 'üìÅ';
      case 'folder': return 'üìÇ';
      case 'file': return 'üìÑ';
      case 'module': return 'üì¶';
      case 'function': return '‚ö°';
      case 'method': return 'üîß';
      case 'class': return 'üèóÔ∏è';
      case 'variable': return 'üìä';
      default: return 'üìÑ';
    }
  }

  return (
    <div className={`graph-explorer ${className}`} style={containerStyle}>
      {/* Header with Statistics */}
      <div style={headerStyle}>
        <div style={titleStyle}>
          <div style={titleLeftStyle}>
            <span>üï∏Ô∏è</span>
            <span>Knowledge Graph</span>
          </div>
          <button 
            onClick={handleDownloadKG}
            style={downloadButtonStyle}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = '#B45309';
              e.currentTarget.style.transform = 'translateY(-1px)';
              e.currentTarget.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = colors.primary;
              e.currentTarget.style.transform = 'translateY(0)';
              e.currentTarget.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
            }}
            title="Download Knowledge Graph as JSON"
          >
            <span>üíæ</span>
            <span>Download KG</span>
          </button>
        </div>
        
        <div style={statsContainerStyle}>
          <div style={statItemStyle}>
            <span>üìä</span>
            <span>{graph?.nodes?.length || 0} nodes</span>
          </div>
          <div style={statItemStyle}>
            <span>üîó</span>
            <span>{graph?.relationships?.length || 0} relationships</span>
          </div>
          {Object.entries(nodeStats).slice(0, 4).map(([type, count]) => (
            <div key={type} style={statItemStyle}>
              <span>{getNodeTypeIcon(type)}</span>
              <span>{count} {type.toLowerCase()}s</span>
            </div>
          ))}
        </div>
      </div>

      {/* Graph Visualization */}
      <div style={graphContainerStyle}>
        <GraphVisualization
          graph={graph}
          selectedNodeId={currentSelectedNodeId}
          onNodeSelect={handleNodeSelect}
          style={{ height: '100%' }}
        />
        
        {/* Selected Node Info Overlay */}
        {currentSelectedNodeId && (
          <div style={selectedNodeInfoStyle}>
            <strong>Selected:</strong> {getSelectedNodeName()}
          </div>
        )}
      </div>
    </div>
  );
};

export default GraphExplorer;

================
File: src/ui/components/graph/index.ts
================
export { default as GraphVisualization } from './Visualization.tsx';
export { default as SourceViewer } from './SourceViewer.tsx';
export { default as GraphExplorer } from './GraphExplorer.tsx';

================
File: src/ui/components/graph/SourceViewer.tsx
================
import React, { useMemo } from 'react';
import type { KnowledgeGraph, GraphNode } from '../../../core/graph/types.ts';

interface SourceViewerProps {
  graph: KnowledgeGraph;
  selectedNodeId: string | null;
  fileContents?: Map<string, string>;
  className?: string;
  style?: React.CSSProperties;
}

interface SourceInfo {
  fileName: string;
  filePath: string;
  content: string;
  startLine?: number;
  endLine?: number;
  nodeType: string;
  nodeName: string;
  language?: string;
}

const SourceViewer: React.FC<SourceViewerProps> = ({
  graph,
  selectedNodeId,
  fileContents,
  className = '',
  style = {}
}) => {
  // Warm tone colors to match the new theme
  const colors = {
    background: '#FEF9F0', // Slightly warm white
    surface: '#FFFFFF',
    text: '#451A03', // Dark brown
    textSecondary: '#78350F', // Medium brown
    textMuted: '#A16207', // Light brown
    border: '#FED7AA', // Light orange
    borderLight: '#FEF3C7', // Very light orange
    primary: '#D97706', // Warm orange
    codeBackground: '#FDF6E3', // Warm cream for code
    lineNumbers: '#92400E' // Dark orange for line numbers
  };

  // Extract relevant content from a file for a specific function/class/method
  const extractRelevantContent = (fileContent: string, targetName: string, nodeType: string): string | null => {
    const lines = fileContent.split('\n');
    
    try {
      if (nodeType === 'Function') {
        // Look for function definition patterns
        const patterns = [
          new RegExp(`^\\s*def\\s+${targetName}\\s*\\(`),     // Python
          new RegExp(`^\\s*function\\s+${targetName}\\s*\\(`), // JavaScript
          new RegExp(`^\\s*const\\s+${targetName}\\s*=`),     // JavaScript const
          new RegExp(`^\\s*let\\s+${targetName}\\s*=`),       // JavaScript let
          new RegExp(`^\\s*export\\s+function\\s+${targetName}\\s*\\(`), // ES6 export
          new RegExp(`^\\s*(public|private|protected)?\\s*\\w*\\s*${targetName}\\s*\\(`) // Java/C#
        ];
        
        for (let i = 0; i < lines.length; i++) {
          if (patterns.some(pattern => pattern.test(lines[i]))) {
            // Found the function, now extract it with context
            const startLine = Math.max(0, i - 2); // Include 2 lines before for context
            let endLine = i + 1;
            
            // Find the end of the function (simple heuristic)
            let braceCount = 0;
            const indentLevel = lines[i].match(/^\s*/)?.[0].length || 0;
            
            for (let j = i + 1; j < lines.length; j++) {
              const line = lines[j];
              const currentIndent = line.match(/^\s*/)?.[0].length || 0;
              
              // For Python, use indentation
              if (lines[i].includes('def ')) {
                if (line.trim() && currentIndent <= indentLevel && !line.startsWith(' ')) {
                  break;
                }
                endLine = j;
              } 
              // For JavaScript/Java, use braces
              else {
                braceCount += (line.match(/\{/g) || []).length;
                braceCount -= (line.match(/\}/g) || []).length;
                endLine = j;
                if (braceCount === 0 && j > i) {
                  break;
                }
              }
              
              // Safety limit
              if (j - i > 100) break;
            }
            
            return lines.slice(startLine, endLine + 3).join('\n'); // Include 3 lines after
          }
        }
      }
      
      if (nodeType === 'Class') {
        const patterns = [
          new RegExp(`^\\s*class\\s+${targetName}\\b`),
          new RegExp(`^\\s*(public|private)?\\s*class\\s+${targetName}\\b`)
        ];
        
        for (let i = 0; i < lines.length; i++) {
          if (patterns.some(pattern => pattern.test(lines[i]))) {
            const startLine = Math.max(0, i - 2);
            const endLine = i + 20; // Show first 20 lines of class
            
            return lines.slice(startLine, Math.min(endLine, lines.length)).join('\n');
          }
        }
      }
      
      // If we can't extract specifically, return null to use full file
      return null;
    } catch (error) {
      console.warn('Error extracting content:', error);
      return null;
    }
  };

  // Generate mock source content based on node type
  const generateMockContent = (node: GraphNode): string => {
    try {
      const name = node.properties.name as string || 'unknown';
      
      switch (node.label) {
        case 'Function':
          return `def ${name}():
    """
    Function: ${name}
    """
    # Implementation here
    pass`;

        case 'Method': {
          const parentClass = node.properties.parentClass as string || 'UnknownClass';
          return `class ${parentClass}:
    def ${name}(self):
        """
        Method: ${name}
        Class: ${parentClass}
        """
        # Implementation here
        pass`;
        }

        case 'Class':
          return `class ${name}:
    """
    Class: ${name}
    """
    
    def __init__(self):
        # Constructor
        pass`;

        case 'Variable':
          return `# Variable: ${name}
${name} = None  # Initialize variable`;

        case 'File': {
          const path = node.properties.path as string || name;
          const extension = path.split('.').pop()?.toLowerCase() || 'txt';
          
          switch (extension) {
            case 'py':
              return `# File: ${path}
"""
Python module: ${name}
"""

def main():
    print("Hello from ${name}")

if __name__ == "__main__":
    main()`;
            
            case 'js':
            case 'ts':
              return `// File: ${path}
/**
 * JavaScript/TypeScript module: ${name}
 */

function main() {
    console.log("Hello from ${name}");
}

export default main;`;
            
            case 'java':
              return `// File: ${path}
/**
 * Java class: ${name}
 */
public class ${name.replace(/\.[^/.]+$/, "")} {
    public static void main(String[] args) {
        System.out.println("Hello from ${name}");
    }
}`;
            
            default:
              return `// File: ${path}
// Content of ${name}`;
          }
        }

        case 'Folder':
          return `# Directory: ${name}
# This is a folder containing other files and directories`;

        case 'Project':
          return `# Project: ${name}
# Root directory of the project`;

        default:
          return `# ${node.label}: ${name}
# No specific content available`;
      }
    } catch (error) {
      return `# Error generating content for ${node.label}
# ${error instanceof Error ? error.message : 'Unknown error'}`;
    }
  };

  // Generate content for built-in functions
  const generateBuiltinFunctionContent = (functionName: string): string => {
    switch (functionName) {
      case 'round':
        return `# Built-in Function: ${functionName}
"""
Rounds a number to the nearest integer.
"""

def round(number: float, ndigits: int = 0) -> float:
    """
    Rounds a number to the nearest integer.
    Args:
        number (float): The number to round.
        ndigits (int, optional): The number of decimal places to round to. Defaults to 0.
    Returns:
        float: The rounded number.
    """
    # Implementation here
    pass`;
      case 'len':
        return `# Built-in Function: ${functionName}
"""
Returns the number of items in an object.
"""

def len(obj: Any) -> int:
    """
    Returns the number of items in an object.
    Args:
        obj (Any): The object to get the length of.
    Returns:
        int: The number of items.
    """
    # Implementation here
    pass`;
      case 'print':
        return `# Built-in Function: ${functionName}
"""
Prints the given arguments to the standard output.
"""

def print(*args, sep: str = " ", end: str = "\\n") -> None:
    """
    Prints the given arguments to the standard output.
    Args:
        *args: The arguments to print.
        sep (str, optional): The separator between arguments. Defaults to " ".
        end (str, optional): The string to print at the end. Defaults to "\\n".
    """
    # Implementation here
    pass`;
      case 'input':
        return `# Built-in Function: ${functionName}
"""
Reads a line from the standard input.
"""

def input(prompt: str = "") -> str:
    """
    Reads a line from the standard input.
    Args:
        prompt (str, optional): The prompt to display. Defaults to "".
    Returns:
        str: The input string.
    """
    # Implementation here
    pass`;
      case 'open':
        return `# Built-in Function: ${functionName}
"""
Opens a file and returns a file object.
"""

def open(file: str, mode: str = "r", buffering: int = -1, encoding: str | None = None, errors: str | None = None, newline: str | None = None) -> Any:
    """
    Opens a file and returns a file object.
    Args:
        file (str): The path to the file.
        mode (str, optional): The mode in which the file is opened. Defaults to "r".
        buffering (int, optional): The buffering strategy. Defaults to -1.
        encoding (str | None, optional): The encoding to use. Defaults to None.
        errors (str | None, optional): How to handle encoding errors. Defaults to None.
        newline (str | None, optional): How to handle newlines. Defaults to None.
    Returns:
        Any: The file object.
    """
    # Implementation here
    pass`;
      case 'type':
        return `# Built-in Function: ${functionName}
"""
Returns the type of an object.
"""

def type(obj: Any) -> type:
    """
    Returns the type of an object.
    Args:
        obj (Any): The object to get the type of.
    Returns:
        type: The type of the object.
    """
    # Implementation here
    pass`;
      case 'isinstance':
        return `# Built-in Function: ${functionName}
"""
Checks if an object is an instance of a class or a tuple of classes.
"""

def isinstance(obj: Any, classinfo: type | tuple[type, ...]) -> bool:
    """
    Checks if an object is an instance of a class or a tuple of classes.
    Args:
        obj (Any): The object to check.
        classinfo (type | tuple[type, ...]): The class or tuple of classes to check against.
    Returns:
        bool: True if the object is an instance of the class or one of the classes in the tuple.
    """
    # Implementation here
    pass`;
      case 'hasattr':
        return `# Built-in Function: ${functionName}
"""
Checks if an object has an attribute.
"""

def hasattr(obj: Any, name: str) -> bool:
    """
    Checks if an object has an attribute.
    Args:
        obj (Any): The object to check.
        name (str): The name of the attribute to check for.
    Returns:
        bool: True if the object has the attribute, False otherwise.
    """
    # Implementation here
    pass`;
      default:
        return `# Built-in Function: ${functionName}
# No specific content available`;
    }
  };

  // Get source info for selected node
  const sourceInfo = useMemo((): SourceInfo | null => {
    if (!selectedNodeId || !graph?.nodes) return null;

    const node = graph.nodes.find(n => n.id === selectedNodeId);
    if (!node) return null;

    const nodeName = node.properties.name as string || node.id;
    
    // First, try to get the file path from the node's properties
    let filePath = node.properties.path as string || node.properties.filePath as string;
    
    // If the node doesn't have a direct file path, find it through graph relationships
    if (!filePath || filePath === nodeName) {
      console.log('SourceViewer - Finding file through graph relationships for:', nodeName);
      
      // Find the file that CONTAINS this node
      const containsRelationship = graph.relationships?.find(rel => 
        rel.type === 'CONTAINS' && rel.target === selectedNodeId
      );
      
      if (containsRelationship) {
        const fileNode = graph.nodes.find(n => n.id === containsRelationship.source);
        if (fileNode && fileNode.label === 'File') {
          filePath = fileNode.properties.path as string || fileNode.properties.filePath as string;
          console.log('SourceViewer - Found file through CONTAINS relationship:', filePath);
        }
      }
      
      // If still no file path, try reverse lookup by searching for the node name in file contents
      if (!filePath && fileContents) {
        console.log('SourceViewer - Searching file contents for node:', nodeName);
        
        // Try multiple search patterns for the function
        const searchPatterns = [
          `def ${nodeName}(`,           // Python function
          `def ${nodeName} (`,          // Python function with space
          `function ${nodeName}(`,      // JavaScript function
          `function ${nodeName} (`,     // JavaScript function with space
          `const ${nodeName} =`,        // JavaScript const
          `let ${nodeName} =`,          // JavaScript let
          `var ${nodeName} =`,          // JavaScript var
          `class ${nodeName}`,          // Class definition
          `${nodeName}:`,               // Object property or TypeScript type
          `export const ${nodeName}`,   // ES6 export
          `export function ${nodeName}`, // ES6 export function
          `public ${nodeName}(`,        // Java/C# method
          `private ${nodeName}(`,       // Java/C# method
          `protected ${nodeName}(`,     // Java/C# method
          // Also try with underscores and variations
          `def ${nodeName}_`,           // Python with underscore
          `function ${nodeName}_`,      // JavaScript with underscore
        ];
        
        for (const [path, content] of fileContents) {
          console.log(`SourceViewer - Checking file: ${path}`);
          
          // Check if any pattern matches
          const foundPattern = searchPatterns.find(pattern => {
            const found = content.includes(pattern);
            if (found) {
              console.log(`SourceViewer - Found pattern "${pattern}" in ${path}`);
            }
            return found;
          });
          
          if (foundPattern) {
            filePath = path;
            console.log('SourceViewer - Found file through content search:', filePath);
            break;
          }
        }
        
        // If still not found, try a more lenient search (case-insensitive)
        if (!filePath) {
          console.log('SourceViewer - Trying case-insensitive search for:', nodeName);
          for (const [path, content] of fileContents) {
            const lowerContent = content.toLowerCase();
            const lowerNodeName = nodeName.toLowerCase();
            
            if (lowerContent.includes(`def ${lowerNodeName}(`) || 
                lowerContent.includes(`function ${lowerNodeName}(`) ||
                lowerContent.includes(`const ${lowerNodeName} =`) ||
                lowerContent.includes(`class ${lowerNodeName}`)) {
              filePath = path;
              console.log('SourceViewer - Found file through case-insensitive search:', filePath);
              break;
            }
          }
        }
      }
    }

    const fileName = filePath ? filePath.split('/').pop() || filePath : nodeName;

    console.log('SourceViewer - Final node details:', {
      nodeId: selectedNodeId,
      nodeName,
      filePath,
      fileName,
      nodeLabel: node.label,
      nodeProperties: node.properties,
      fileContentsSize: fileContents?.size || 0,
      // Add detailed relationship debugging
      allRelationships: graph?.relationships?.length || 0,
      containsRelationships: graph?.relationships?.filter(rel => rel.type === 'CONTAINS').length || 0,
      relationshipsForThisNode: graph?.relationships?.filter(rel => rel.target === selectedNodeId || rel.source === selectedNodeId) || [],
      fileNodesInGraph: graph?.nodes?.filter(n => n.label === 'File').map(n => ({
        id: n.id,
        path: n.properties.path,
        filePath: n.properties.filePath,
        name: n.properties.name
      })) || [],
      availableFileContents: fileContents ? Array.from(fileContents.entries()).map(([path, content]) => ({
        path,
        size: content.length,
        firstLines: content.split('\n').slice(0, 3).join('\\n'),
        containsSub: content.includes('def sub(') || content.includes('function sub(')
      })) : []
    });

    // Try to get actual file content
    let content = '';
    
    if (filePath && fileContents && fileContents.has(filePath)) {
      content = fileContents.get(filePath)!;
      console.log('SourceViewer - Found file content for:', filePath);
      
      // For function/method/class nodes, try to extract just the relevant part
      if (node.label === 'Function' || node.label === 'Method' || node.label === 'Class') {
        const extractedContent = extractRelevantContent(content, nodeName, node.label);
        if (extractedContent) {
          content = extractedContent;
          console.log('SourceViewer - Extracted relevant content for:', nodeName);
        }
      }
    } else {
      console.log('SourceViewer - No file content found, checking if this is a built-in function');
      
      // Check if this is a built-in function
      if (node.id.includes('builtin_') || nodeName === 'round' || nodeName === 'len' || nodeName === 'print' || 
          ['round', 'len', 'str', 'int', 'float', 'bool', 'list', 'dict', 'tuple', 'set',
           'range', 'enumerate', 'zip', 'map', 'filter', 'sum', 'max', 'min', 'abs',
           'print', 'input', 'open', 'type', 'isinstance', 'hasattr'].includes(nodeName)) {
        
        content = generateBuiltinFunctionContent(nodeName);
        console.log('SourceViewer - Using built-in function content for:', nodeName);
      } else {
        console.log('SourceViewer - Using mock content for user-defined node:', nodeName);
        content = generateMockContent(node);
      }
    }

    // Detect language from file extension
    const extension = fileName.split('.').pop()?.toLowerCase();
    let language = 'text';
    switch (extension) {
      case 'js':
      case 'jsx':
        language = 'javascript';
        break;
      case 'ts':
      case 'tsx':
        language = 'typescript';
        break;
      case 'py':
        language = 'python';
        break;
      case 'java':
        language = 'java';
        break;
      case 'cpp':
      case 'cc':
      case 'cxx':
        language = 'cpp';
        break;
      case 'c':
        language = 'c';
        break;
      case 'cs':
        language = 'csharp';
        break;
      case 'php':
        language = 'php';
        break;
      case 'rb':
        language = 'ruby';
        break;
      case 'go':
        language = 'go';
        break;
      case 'rs':
        language = 'rust';
        break;
      case 'swift':
        language = 'swift';
        break;
      case 'kt':
        language = 'kotlin';
        break;
      case 'scala':
        language = 'scala';
        break;
      case 'html':
        language = 'html';
        break;
      case 'css':
        language = 'css';
        break;
      case 'scss':
        language = 'scss';
        break;
      case 'json':
        language = 'json';
        break;
      case 'xml':
        language = 'xml';
        break;
      case 'yaml':
      case 'yml':
        language = 'yaml';
        break;
      case 'md':
        language = 'markdown';
        break;
      case 'sh':
        language = 'bash';
        break;
      case 'sql':
        language = 'sql';
        break;
    }

    return {
      fileName,
      filePath: filePath || nodeName,
      content,
      nodeType: node.label,
      nodeName,
      language,
      startLine: node.properties.startLine as number,
      endLine: node.properties.endLine as number
    };
  }, [selectedNodeId, graph?.nodes, graph?.relationships, fileContents]);

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    width: '100%',
    backgroundColor: colors.background,
    overflow: 'hidden',
    ...style
  };

  const headerStyle: React.CSSProperties = {
    padding: '16px 20px',
    backgroundColor: colors.surface,
    borderBottom: `1px solid ${colors.borderLight}`,
    flexShrink: 0
  };

  const titleStyle: React.CSSProperties = {
    fontSize: '16px',
    fontWeight: '600',
    color: colors.text,
    marginBottom: '8px',
    display: 'flex',
    alignItems: 'center',
    gap: '8px'
  };

  const infoStyle: React.CSSProperties = {
    fontSize: '12px',
    color: colors.textMuted,
    display: 'flex',
    alignItems: 'center',
    gap: '16px',
    flexWrap: 'wrap'
  };

  const codeContainerStyle: React.CSSProperties = {
    flex: 1,
    overflow: 'auto',
    backgroundColor: colors.codeBackground,
    position: 'relative'
  };

  const codeStyle: React.CSSProperties = {
    fontFamily: "'Fira Code', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace",
    fontSize: '13px',
    lineHeight: '1.5',
    padding: '16px',
    margin: 0,
    backgroundColor: 'transparent',
    color: colors.text,
    whiteSpace: 'pre-wrap',
    wordBreak: 'break-word',
    border: 'none',
    outline: 'none',
    resize: 'none',
    width: '100%',
    minHeight: '100%',
    boxSizing: 'border-box'
  };

  const emptyStateStyle: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'column',
    height: '100%',
    color: colors.textMuted,
    fontSize: '14px',
    gap: '12px',
    padding: '32px'
  };

  const renderEmptyState = () => (
    <div style={emptyStateStyle}>
      <div style={{ fontSize: '48px', opacity: 0.3 }}>üìù</div>
      <div style={{ textAlign: 'center' }}>
        Select a node in the graph to view its source code
      </div>
    </div>
  );

  const renderSourceContent = (info: SourceInfo) => {
    const lines = info.content.split('\n');

    return (
      <>
        <div style={headerStyle}>
          <div style={titleStyle}>
            <span>üìù</span>
            <span>{info.fileName}</span>
          </div>
          <div style={infoStyle}>
            <span>üìÑ {info.nodeType}</span>
            <span>üè∑Ô∏è {info.nodeName}</span>
            {info.language && <span>üíª {info.language}</span>}
            <span>üìè {lines.length} lines</span>
          </div>
        </div>
        
        <div style={codeContainerStyle}>
          <pre style={codeStyle}>
            {info.content}
          </pre>
        </div>
      </>
    );
  };

  return (
    <div className={`source-viewer ${className}`} style={containerStyle}>
      {sourceInfo ? renderSourceContent(sourceInfo) : renderEmptyState()}
    </div>
  );
};

export default SourceViewer;

================
File: src/ui/components/graph/Visualization.tsx
================
import React, { useEffect, useRef, useState } from 'react';
import * as d3 from 'd3';
import type { KnowledgeGraph, GraphNode, GraphRelationship } from '../../../core/graph/types.ts';

interface GraphVisualizationProps {
  graph: KnowledgeGraph;
  onNodeSelect?: (nodeId: string | null) => void;
  selectedNodeId?: string | null;
  className?: string;
  style?: React.CSSProperties;
}

interface D3Node extends d3.SimulationNodeDatum {
  id: string;
  label: string;
  nodeType: string;
  properties: Record<string, unknown>;
  color: string;
  size: number;
}

interface D3Link extends d3.SimulationLinkDatum<D3Node> {
  id: string;
  source: string | D3Node;
  target: string | D3Node;
  relationshipType: string;
  color: string;
  width: number;
}

const GraphVisualization: React.FC<GraphVisualizationProps> = ({
  graph,
  onNodeSelect,
  selectedNodeId,
  className = '',
  style = {}
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const simulationRef = useRef<d3.Simulation<D3Node, D3Link> | null>(null);
  const onNodeSelectRef = useRef(onNodeSelect);
  const [isReady, setIsReady] = useState(false);

  // Update the ref whenever onNodeSelect changes
  onNodeSelectRef.current = onNodeSelect;

  // Convert KnowledgeGraph to D3 format
  const convertToD3Format = (graph: KnowledgeGraph) => {
    const nodeIds = new Set<string>();
    
    // First pass: collect all node IDs and analyze the graph structure
    graph.nodes.forEach(node => nodeIds.add(node.id));
    
    // Calculate node metrics for intelligent sizing
    const nodeMetrics = new Map<string, {
      inDegree: number;
      outDegree: number;
      totalDegree: number;
      depth: number;
      isRoot: boolean;
      childrenCount: number;
    }>();
    
    // Initialize metrics
    graph.nodes.forEach(node => {
      nodeMetrics.set(node.id, {
        inDegree: 0,
        outDegree: 0,
        totalDegree: 0,
        depth: 0,
        isRoot: false,
        childrenCount: 0
      });
    });
    
    // Calculate degrees and relationships
    graph.relationships.forEach(rel => {
      const sourceMetrics = nodeMetrics.get(rel.source);
      const targetMetrics = nodeMetrics.get(rel.target);
      
      if (sourceMetrics && targetMetrics) {
        sourceMetrics.outDegree++;
        targetMetrics.inDegree++;
        
        // For CONTAINS relationships, count children
        if (rel.type.toLowerCase() === 'contains') {
          sourceMetrics.childrenCount++;
        }
      }
    });
    
    // Calculate total degree and identify root nodes
    nodeMetrics.forEach((metrics) => {
      metrics.totalDegree = metrics.inDegree + metrics.outDegree;
      // Root nodes typically have high out-degree and low/zero in-degree
      metrics.isRoot = metrics.inDegree === 0 && metrics.outDegree > 0;
    });
    
    // Calculate depth (simplified - could be more sophisticated)
    const calculateDepth = (nodeId: string, visited = new Set<string>()): number => {
      if (visited.has(nodeId)) return 0;
      visited.add(nodeId);
      
      const parentRels = graph.relationships.filter(rel => 
        rel.target === nodeId && rel.type.toLowerCase() === 'contains'
      );
      
      if (parentRels.length === 0) return 0; // Root level
      
      const parentDepths = parentRels.map(rel => calculateDepth(rel.source, new Set(visited)));
      return Math.max(...parentDepths, 0) + 1;
    };
    
    // Calculate depths for all nodes
    graph.nodes.forEach(node => {
      const metrics = nodeMetrics.get(node.id);
      if (metrics) {
        metrics.depth = calculateDepth(node.id);
      }
    });
    
    // Convert nodes with intelligent sizing
    const nodes: D3Node[] = graph.nodes.map((node: GraphNode) => {
      const metrics = nodeMetrics.get(node.id)!;
      
      // Determine base color and size based on type
      let color = '#69b3a2';
      let baseSize = 8;
      
      switch (node.label.toLowerCase()) {
        case 'project':
          color = '#2E7D32';
          baseSize = 25; // Largest - project root
          break;
        case 'folder':
          color = '#F57C00';
          baseSize = 16;
          break;
        case 'file':
          color = '#1976D2';
          baseSize = 12;
          break;
        case 'function':
          color = '#00796B';
          baseSize = 8;
          break;
        case 'method':
          color = '#00695C';
          baseSize = 7;
          break;
        case 'class':
          color = '#C2185B';
          baseSize = 12;
          break;
        case 'variable':
          color = '#546E7A';
          baseSize = 6;
          break;
        default:
          color = '#69b3a2';
          baseSize = 8;
      }
      
      // Calculate final size based on multiple factors
      let finalSize = baseSize;
      
      // Factor 1: Hierarchy depth (higher levels = bigger)
      const depthMultiplier = Math.max(0.7, 1.5 - (metrics.depth * 0.15));
      finalSize *= depthMultiplier;
      
      // Factor 2: Connection importance (more connections = bigger)
      if (metrics.totalDegree > 0) {
        const connectionMultiplier = 1 + Math.min(0.8, metrics.totalDegree * 0.1);
        finalSize *= connectionMultiplier;
      }
      
      // Factor 3: Container nodes (nodes with children) should be bigger
      if (metrics.childrenCount > 0) {
        const containerMultiplier = 1 + Math.min(0.6, metrics.childrenCount * 0.08);
        finalSize *= containerMultiplier;
      }
      
      // Factor 4: Root nodes get a boost
      if (metrics.isRoot) {
        finalSize *= 1.4;
      }
      
      // Factor 5: Special boost for hub nodes (high degree centrality)
      if (metrics.totalDegree > 10) {
        finalSize *= 1.3;
        color = adjustColorBrightness(color, 20); // Make hub nodes slightly brighter
      }
      
      // Ensure size bounds
      finalSize = Math.max(4, Math.min(35, finalSize));
      
      return {
        id: node.id,
        label: node.properties.name as string || node.id,
        nodeType: node.label.toLowerCase(),
        properties: node.properties,
        color,
        size: Math.round(finalSize),
        // Store metrics for potential future use
        metrics
      };
    });

    // Convert links with validation (unchanged)
    const links: D3Link[] = [];
    graph.relationships.forEach((rel: GraphRelationship) => {
      // Validate that both source and target nodes exist
      if (!nodeIds.has(rel.source) || !nodeIds.has(rel.target)) {
        console.warn(`Skipping invalid relationship: ${rel.source} -> ${rel.target}`);
        return;
      }
      
      // Skip self-loops
      if (rel.source === rel.target) {
        return;
      }

      // Determine link color and width based on type
      let color = '#999';
      let width = 1;
      
      switch (rel.type.toLowerCase()) {
        case 'contains':
          color = '#4CAF50';
          width = 2;
          break;
        case 'calls':
          color = '#F44336';
          width = 1;
          break;
        case 'imports':
          color = '#9C27B0';
          width = 1.5;
          break;
        case 'inherits':
          color = '#2196F3';
          width = 2;
          break;
        default:
          color = '#999';
          width = 1;
      }

      links.push({
        id: rel.id,
        source: rel.source,
        target: rel.target,
        relationshipType: rel.type.toLowerCase(),
        color,
        width
      });
    });

    return { nodes, links };
  };

  // Helper function to adjust color brightness
  const adjustColorBrightness = (hex: string, percent: number): string => {
    const num = parseInt(hex.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
      (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
      (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
  };

  // Initialize D3 visualization
  useEffect(() => {
    if (!svgRef.current || !graph) return;

    const svg = d3.select(svgRef.current);
    const container = svg.select('.graph-container');
    
    // Clear previous content
    container.selectAll('*').remove();

    const { nodes, links } = convertToD3Format(graph);

    // Get SVG dimensions
    const rect = svgRef.current.getBoundingClientRect();
    const width = rect.width || 800;
    const height = rect.height || 600;

    // Set up zoom behavior
    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        container.attr('transform', event.transform);
      });

    // Apply zoom behavior to SVG
    svg.call(zoom);

    // Reset zoom on double-click
    svg.on('dblclick.zoom', null);
    svg.on('dblclick', () => {
      svg.transition().duration(750).call(
        zoom.transform,
        d3.zoomIdentity
      );
    });

    // Create force simulation
    const simulation = d3.forceSimulation<D3Node>(nodes)
      .force('link', d3.forceLink<D3Node, D3Link>(links)
        .id((d: D3Node) => d.id)
        .distance((d: D3Link) => {
          switch (d.relationshipType) {
            case 'contains': return 60;
            case 'imports': return 100;
            case 'calls': return 80;
            default: return 90;
          }
        })
        .strength(0.7)
      )
      .force('charge', d3.forceManyBody()
        .strength((d: d3.SimulationNodeDatum) => {
          const node = d as D3Node;
          switch (node.nodeType) {
            case 'project': return -800;
            case 'folder': return -400;
            case 'file': return -300;
            default: return -200;
          }
        })
      )
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide()
        .radius((node: d3.SimulationNodeDatum) => {
          const d = node as D3Node;
          return d.size + 5;
        })
        .strength(0.7)
      )
      .alphaTarget(0.05)
      .alphaDecay(0.005);

    simulationRef.current = simulation;

    // Create links
    const link = container.append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(links)
      .enter().append('line')
      .attr('stroke', (d) => d.color)
      .attr('stroke-width', (d) => d.width)
      .attr('stroke-opacity', 0.8)
      .style('stroke-dasharray', (d) => {
        switch (d.relationshipType) {
          case 'calls': return '5,5';
          case 'imports': return '3,3';
          default: return 'none';
        }
      });

    // Create nodes
    const node = container.append('g')
      .attr('class', 'nodes')
      .selectAll('circle')
      .data(nodes)
      .enter().append('circle')
      .attr('r', (d) => d.size)
      .attr('fill', (d) => d.color)
      .attr('stroke', '#fff')
      .attr('stroke-width', 2)
      .style('cursor', 'pointer');

    // Use D3 drag with proper click distance to prevent sticking
    node.call(d3.drag<SVGCircleElement, D3Node>()
      .clickDistance(10) // Larger threshold to better distinguish clicks from drags
      .on('start', function(event) {
        // Only fix position if this is actually a drag (not a click)
        if (event.sourceEvent.type === 'mousedown') {
          // Don't fix position immediately - wait for actual drag
        }
      })
      .on('drag', function(event, d) {
        // This only fires on actual drags (beyond clickDistance)
        if (!d.fx && !d.fy) {
          // First drag event - fix position and restart simulation
          d.fx = d.x;
          d.fy = d.y;
          if (!event.active) simulation.alphaTarget(0.3).restart();
        }
        d.fx = event.x;
        d.fy = event.y;
      })
      .on('end', function(event, d) {
        if (!event.active) simulation.alphaTarget(0.05);
        // Release the node
        d.fx = null;
        d.fy = null;
      })
    );

    // Create labels
    const label = container.append('g')
      .attr('class', 'labels')
      .selectAll('text')
      .data(nodes)
      .enter().append('text')
      .text((d) => d.label)
      .attr('font-size', (d) => Math.max(8, d.size - 2))
      .attr('font-family', 'Inter, system-ui, sans-serif')
      .attr('font-weight', '500')
      .attr('fill', '#fff')
      .attr('text-anchor', 'middle')
      .attr('dy', '0.35em')
      .style('pointer-events', 'none')
      .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)');

    // Node click handler
    node.on('click', (event, d) => {
      
      // Ignore clicks if we're dragging or just finished dragging
      if (d.fx || d.fy) return; // Check if node is being dragged
      
      event.stopPropagation();
      
      // Remove previous selection
      node.classed('selected', false);
      node.attr('stroke-width', 2);
      
      // Add selection to clicked node
      d3.select(event.currentTarget)
        .classed('selected', true)
        .attr('stroke-width', 4)
        .attr('stroke', '#FFD54F');
      
      // Highlight connected elements
      const connectedNodeIds = new Set<string>();
      link.attr('stroke-opacity', 0.1);
      node.attr('opacity', 0.3);
      label.attr('opacity', 0.3);
      
      links.forEach(linkData => {
        const sourceId = typeof linkData.source === 'object' ? linkData.source.id : linkData.source;
        const targetId = typeof linkData.target === 'object' ? linkData.target.id : linkData.target;
        
        if (sourceId === d.id || targetId === d.id) {
          connectedNodeIds.add(sourceId);
          connectedNodeIds.add(targetId);
        }
      });
      
      // Highlight connected nodes and links
      link.filter(linkData => {
        const sourceId = typeof linkData.source === 'object' ? linkData.source.id : linkData.source;
        const targetId = typeof linkData.target === 'object' ? linkData.target.id : linkData.target;
        return sourceId === d.id || targetId === d.id;
      }).attr('stroke-opacity', 1);
      
      node.filter(nodeData => connectedNodeIds.has(nodeData.id))
        .attr('opacity', 1);
      
      label.filter(nodeData => connectedNodeIds.has(nodeData.id))
        .attr('opacity', 1);
      
      // Keep selected node fully visible
      d3.select(event.currentTarget).attr('opacity', 1);
      label.filter(nodeData => nodeData.id === d.id).attr('opacity', 1);
      
      if (onNodeSelectRef.current) {
        onNodeSelectRef.current(d.id);
      }
    });

    // Background click handler - clear selection when clicking empty space
    svg.on('click', (event) => {
      // Only handle clicks on the SVG background (not on nodes or other elements)
      if (event.target === event.currentTarget) {
        // Remove all selections and highlighting
        node.classed('selected', false);
        node.attr('stroke-width', 2).attr('stroke', '#fff').attr('opacity', 1);
        link.attr('stroke-opacity', 0.8);
        label.attr('opacity', 1);
        
        if (onNodeSelectRef.current) {
          onNodeSelectRef.current(null);
        }
      }
    });

    // Hover effects
    node.on('mouseover', (event, d) => {
      d3.select(event.currentTarget)
        .transition()
        .duration(200)
        .attr('r', d.size * 1.3);
    });

    node.on('mouseout', (event, d) => {
      d3.select(event.currentTarget)
        .transition()
        .duration(200)
        .attr('r', d.size);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
      link
        .attr('x1', (d) => (d.source as D3Node).x!)
        .attr('y1', (d) => (d.source as D3Node).y!)
        .attr('x2', (d) => (d.target as D3Node).x!)
        .attr('y2', (d) => (d.target as D3Node).y!);

      node
        .attr('cx', (d) => d.x!)
        .attr('cy', (d) => d.y!);

      label
        .attr('x', (d) => d.x!)
        .attr('y', (d) => d.y!);
    });

    setIsReady(true);

    // Cleanup function
    return () => {
      if (simulationRef.current) {
        simulationRef.current.stop();
        simulationRef.current = null;
      }
      setIsReady(false);
    };
  }, [graph]); // Removed onNodeSelect from dependencies to prevent re-renders

  // Handle selected node changes
  useEffect(() => {
    if (!svgRef.current || !isReady || !selectedNodeId) return;

    const svg = d3.select(svgRef.current);
    const nodes = svg.selectAll('.nodes circle');
    
    // Remove previous selection
    nodes.classed('selected', false);
    nodes.attr('stroke-width', 2).attr('stroke', '#fff');
    
    // Select the specified node
    nodes.filter(function(d) { return (d as D3Node).id === selectedNodeId; })
      .classed('selected', true)
      .attr('stroke-width', 4)
      .attr('stroke', '#FFD54F');
  }, [selectedNodeId, isReady]);

  const defaultStyle: React.CSSProperties = {
    width: '100%',
    height: '100%',
    minHeight: '400px',
    border: '1px solid #37474F',
    borderRadius: '8px',
    backgroundColor: '#263238',
    boxShadow: '0 4px 20px rgba(0,0,0,0.1)',
    ...style
  };

  return (
    <div className={`graph-visualization ${className}`} style={{ position: 'relative', width: '100%', height: '100%', minHeight: '400px' }}>
      <svg
        ref={svgRef}
        style={defaultStyle}
        className="d3-graph-container"
      >
        <g className="graph-container" />
      </svg>
      {!isReady && (
        <div
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: '#90A4AE',
            fontSize: '16px',
            fontFamily: 'Inter, system-ui, sans-serif',
            fontWeight: '500',
            zIndex: 10,
            display: 'flex',
            alignItems: 'center',
            gap: '12px'
          }}
        >
          <div
            style={{
              width: '20px',
              height: '20px',
              border: '2px solid #90A4AE',
              borderTop: '2px solid transparent',
              borderRadius: '50%',
              animation: 'spin 1s linear infinite'
            }}
          />
          Loading knowledge graph...
        </div>
      )}
      
      {/* Add navigation instructions */}
      <div
        style={{
          position: 'absolute',
          top: '10px',
          right: '16px',
          backgroundColor: 'rgba(0, 0, 0, 0.7)',
          color: '#fff',
          padding: '8px 12px',
          borderRadius: '4px',
          fontSize: '12px',
          fontFamily: 'Inter, system-ui, sans-serif',
          zIndex: 10,
          lineHeight: '1.4'
        }}
      >
        <div>üñ±Ô∏è <strong>Navigation:</strong></div>
        <div>‚Ä¢ Drag to pan</div>
        <div>‚Ä¢ Scroll to zoom</div>
        <div>‚Ä¢ Double-click to reset view</div>
        <div>‚Ä¢ Drag nodes to reposition</div>
      </div>

      <style>{`
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        .d3-graph-container {
          font-family: 'Inter', system-ui, sans-serif;
          cursor: grab;
        }
        
        .d3-graph-container:active {
          cursor: grabbing;
        }
        
        .nodes circle.selected {
          filter: drop-shadow(0 0 10px rgba(255, 213, 79, 0.8));
        }
        
        .links line {
          transition: stroke-opacity 0.3s ease;
        }
        
        .nodes circle {
          transition: opacity 0.3s ease, r 0.2s ease;
        }
        
        .labels text {
          transition: opacity 0.3s ease;
        }
      `}</style>
    </div>
  );
};

export default GraphVisualization;

================
File: src/ui/components/index.ts
================
export * from './graph/index.ts';
export * from './chat/index.ts';
export { default as ErrorBoundary } from './ErrorBoundary.tsx';

================
File: src/ui/index.ts
================
export * from './components/index';
export * from './pages/index';

================
File: src/ui/pages/HomePage.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import ErrorBoundary from '../components/ErrorBoundary.tsx';
import { GraphExplorer } from '../components/graph/index.ts';
import { ChatInterface } from '../components/chat/index.ts';
import SourceViewer from '../components/graph/SourceViewer.tsx';
import type { KnowledgeGraph } from '../../core/graph/types.ts';
import { IngestionService } from '../../services/ingestion.service.ts';
import { LLMService, type LLMProvider } from '../../ai/llm-service.ts';

interface AppState {
  // Data
  graph: KnowledgeGraph | null;
  fileContents: Map<string, string>;
  
  // UI State
  selectedNodeId: string | null;
  showWelcome: boolean;
  
  // Input State
  githubUrl: string;
  directoryFilter: string;
  fileExtensions: string;
  
  // Processing State
  isProcessing: boolean;
  progress: string;
  error: string;
  
  // Settings
  llmProvider: LLMProvider;
  llmApiKey: string;
  // Azure OpenAI specific settings
  azureOpenAIEndpoint: string;
  azureOpenAIDeploymentName: string;
  azureOpenAIApiVersion: string;
  showSettings: boolean;
}

const initialState: AppState = {
  graph: null,
  fileContents: new Map(),
  selectedNodeId: null,
  showWelcome: true,
  githubUrl: '',
  directoryFilter: 'src,lib,components,pages,utils',
  fileExtensions: '.ts,.tsx,.js,.jsx,.py,.java,.cpp,.c,.cs,.php,.rb,.go,.rs,.swift,.kt,.scala,.clj,.hs,.ml,.fs,.elm,.dart,.lua,.r,.m,.sh,.sql,.html,.css,.scss,.less,.vue,.svelte',
  isProcessing: false,
  progress: '',
  error: '',
  llmProvider: (localStorage.getItem('llm_provider') as LLMProvider) || 'openai',
  llmApiKey: localStorage.getItem('llm_api_key') || '',
  azureOpenAIEndpoint: localStorage.getItem('azure_openai_endpoint') || '',
  azureOpenAIDeploymentName: localStorage.getItem('azure_openai_deployment') || '',
  azureOpenAIApiVersion: localStorage.getItem('azure_openai_api_version') || '2024-02-01',
  showSettings: false
};

const HomePage: React.FC = () => {
  const [state, setState] = useState<AppState>(initialState);
  const [services] = useState(() => ({
    ingestion: new IngestionService(),
    llm: new LLMService()
  }));

  const updateState = useCallback((updates: Partial<AppState>) => {
    setState(prev => ({ ...prev, ...updates }));
  }, []);

  // Save LLM settings to localStorage
  useEffect(() => {
    if (state.llmApiKey) {
      localStorage.setItem('llm_api_key', state.llmApiKey);
    }
    localStorage.setItem('llm_provider', state.llmProvider);
    if (state.azureOpenAIEndpoint) {
      localStorage.setItem('azure_openai_endpoint', state.azureOpenAIEndpoint);
    }
    if (state.azureOpenAIDeploymentName) {
      localStorage.setItem('azure_openai_deployment', state.azureOpenAIDeploymentName);
    }
    if (state.azureOpenAIApiVersion) {
      localStorage.setItem('azure_openai_api_version', state.azureOpenAIApiVersion);
    }
  }, [state.llmApiKey, state.llmProvider, state.azureOpenAIEndpoint, state.azureOpenAIDeploymentName, state.azureOpenAIApiVersion]);

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !file.name.endsWith('.zip')) {
      updateState({ error: 'Please select a valid ZIP file' });
      return;
    }

    try {
      updateState({ 
        isProcessing: true, 
        error: '', 
        progress: 'Reading ZIP file...',
        showWelcome: false
      });

      console.log('Starting ZIP processing...', file.name);

      const result = await services.ingestion.processZipFile(file, {
        directoryFilter: state.directoryFilter,
        fileExtensions: state.fileExtensions
      });

      console.log('ZIP processing completed:', {
        nodeCount: result.graph?.nodes?.length || 0,
        relationshipCount: result.graph?.relationships?.length || 0,
        fileCount: result.fileContents?.size || 0
      });

      updateState({
        graph: result.graph,
        fileContents: result.fileContents,
        isProcessing: false,
        progress: '',
        showWelcome: false // Ensure we stay in main interface
      });
    } catch (error) {
      console.error('ZIP processing error:', error);
      updateState({
        error: error instanceof Error ? error.message : 'Failed to process ZIP file',
        isProcessing: false,
        progress: '',
        showWelcome: true // Return to welcome screen on error
      });
    }
  };

  const handleGitHubProcess = async () => {
    if (!state.githubUrl.trim()) {
      updateState({ error: 'Please enter a GitHub repository URL' });
      return;
    }

    try {
      updateState({ 
        isProcessing: true, 
        error: '', 
        progress: 'Fetching repository...',
        showWelcome: false
      });

      console.log('Starting GitHub processing...', state.githubUrl);

      const result = await services.ingestion.processGitHubRepo(state.githubUrl, {
        directoryFilter: state.directoryFilter,
        fileExtensions: state.fileExtensions,
        onProgress: (progress) => {
          console.log('Progress:', progress);
          updateState({ progress });
        }
      });

      console.log('GitHub processing completed:', {
        nodeCount: result.graph?.nodes?.length || 0,
        relationshipCount: result.graph?.relationships?.length || 0,
        fileCount: result.fileContents?.size || 0
      });

      updateState({
        graph: result.graph,
        fileContents: result.fileContents,
        isProcessing: false,
        progress: '',
        showWelcome: false // Ensure we stay in main interface
      });
    } catch (error) {
      console.error('GitHub processing error:', error);
      updateState({
        error: error instanceof Error ? error.message : 'Failed to process repository',
        isProcessing: false,
        progress: '',
        showWelcome: true // Return to welcome screen on error
      });
    }
  };

  const handleNewProject = () => {
    updateState({
      graph: null,
      fileContents: new Map(),
      selectedNodeId: null,
      showWelcome: true,
      githubUrl: '',
      error: '',
      progress: ''
    });
  };

  const handleNodeSelect = (nodeId: string | null) => {
    console.log('HomePage - Node selected:', {
      nodeId,
      fileContentsSize: state.fileContents.size,
      fileContentsKeys: Array.from(state.fileContents.keys()).slice(0, 10),
      graphNodeCount: state.graph?.nodes?.length || 0
    });
    updateState({ selectedNodeId: nodeId });
  };

  const isApiKeyValid = (() => {
    if (state.llmProvider === 'azure-openai') {
      // For Azure OpenAI, we need to validate all required fields
      return services.llm.validateApiKey(state.llmProvider, state.llmApiKey) &&
             state.azureOpenAIEndpoint.trim() !== '' &&
             state.azureOpenAIDeploymentName.trim() !== '';
    }
    return services.llm.validateApiKey(state.llmProvider, state.llmApiKey);
  })();
  const isGraphValid = state.graph && state.graph.nodes && Array.isArray(state.graph.nodes) && state.graph.relationships && Array.isArray(state.graph.relationships);

  // Warm tone color palette
  const colors = {
    background: '#FDF6E3', // Warm cream
    surface: '#FFFFFF',
    surfaceWarm: '#FEF9F0', // Slightly warm white
    primary: '#D97706', // Warm orange
    primaryLight: '#F59E0B', // Light orange
    secondary: '#92400E', // Dark orange
    accent: '#DC2626', // Warm red
    text: '#451A03', // Dark brown
    textSecondary: '#78350F', // Medium brown
    textMuted: '#A16207', // Light brown
    border: '#FED7AA', // Light orange
    borderLight: '#FEF3C7', // Very light orange
    success: '#059669', // Warm green
    warning: '#D97706', // Orange
    error: '#DC2626' // Red
  };

  // Modern styles with warm theme
  const styles = {
    container: {
      display: 'flex',
      flexDirection: 'column' as const,
      height: '100vh',
      width: '100vw',
      backgroundColor: colors.background,
      fontFamily: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
      overflow: 'hidden'
    },

    // Top navbar (only visible when project is loaded)
    navbar: {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: '12px 24px',
      backgroundColor: colors.surface,
      borderBottom: `1px solid ${colors.borderLight}`,
      boxShadow: '0 1px 3px rgba(0,0,0,0.05)',
      position: 'relative' as const
    },

    navbarContent: {
      display: 'flex',
      alignItems: 'center',
      gap: '16px',
      fontSize: '14px',
      fontWeight: '500',
      color: colors.textSecondary
    },

    navbarButton: {
      padding: '8px 16px',
      backgroundColor: colors.surfaceWarm,
      border: `1px solid ${colors.border}`,
      borderRadius: '8px',
      color: colors.text,
      fontSize: '14px',
      fontWeight: '500',
      cursor: 'pointer',
      transition: 'all 0.2s ease',
      display: 'flex',
      alignItems: 'center',
      gap: '8px'
    },

    // Welcome screen (center overlay)
    welcomeOverlay: {
      position: 'fixed' as const,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: colors.background,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 1000
    },

    welcomeCard: {
      backgroundColor: colors.surface,
      borderRadius: '20px',
      padding: '48px',
      boxShadow: '0 20px 40px rgba(0,0,0,0.1)',
      border: `1px solid ${colors.borderLight}`,
      maxWidth: '600px',
      width: '90%',
      textAlign: 'center' as const
    },

    welcomeTitle: {
      fontSize: '32px',
      fontWeight: '700',
      color: colors.text,
      marginBottom: '16px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '12px'
    },

    welcomeSubtitle: {
      fontSize: '18px',
      color: colors.textSecondary,
      marginBottom: '40px',
      lineHeight: '1.6'
    },

    inputSection: {
      display: 'flex',
      flexDirection: 'column' as const,
      gap: '24px',
      marginBottom: '32px'
    },

    inputGroup: {
      display: 'flex',
      flexDirection: 'column' as const,
      gap: '8px',
      textAlign: 'left' as const
    },

    label: {
      fontSize: '14px',
      fontWeight: '600',
      color: colors.text
    },

    input: {
      padding: '16px',
      border: `2px solid ${colors.border}`,
      borderRadius: '12px',
      fontSize: '16px',
      backgroundColor: colors.surfaceWarm,
      color: colors.text,
      transition: 'all 0.2s ease',
      outline: 'none'
    },

    primaryButton: {
      padding: '16px 32px',
      backgroundColor: colors.primary,
      border: 'none',
      borderRadius: '12px',
      color: 'white',
      fontSize: '16px',
      fontWeight: '600',
      cursor: 'pointer',
      transition: 'all 0.2s ease',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '8px'
    },

    secondaryButton: {
      padding: '12px 24px',
      backgroundColor: colors.surfaceWarm,
      border: `2px solid ${colors.border}`,
      borderRadius: '12px',
      color: colors.text,
      fontSize: '14px',
      fontWeight: '500',
      cursor: 'pointer',
      transition: 'all 0.2s ease'
    },

    orDivider: {
      display: 'flex',
      alignItems: 'center',
      gap: '16px',
      margin: '20px 0',
      color: colors.textMuted,
      fontSize: '14px',
      fontWeight: '500'
    },

    orLine: {
      flex: 1,
      height: '1px',
      backgroundColor: colors.border
    },

    // Main layout (when project is loaded)
    mainLayout: {
      display: 'flex',
      flex: 1,
      overflow: 'hidden'
    },

    // Left side - Knowledge Graph (70% width)
    leftPanel: {
      flex: '0 0 70%',
      backgroundColor: colors.surface,
      borderRight: `1px solid ${colors.borderLight}`,
      overflow: 'hidden'
    },

    // Right side - Chat and Source (30% width)
    rightPanel: {
      flex: '0 0 30%',
      display: 'flex',
      flexDirection: 'column' as const,
      backgroundColor: colors.surfaceWarm
    },

    // Right panel sections
    chatSection: {
      flex: '0 0 60%',
      borderBottom: `1px solid ${colors.borderLight}`,
      overflow: 'hidden'
    },

    sourceSection: {
      flex: '0 0 40%',
      overflow: 'hidden'
    },

    // Error and progress styles
    errorBanner: {
      backgroundColor: '#FEF2F2',
      border: `1px solid #FECACA`,
      color: colors.error,
      padding: '16px',
      borderRadius: '12px',
      margin: '16px 0',
      fontSize: '14px'
    },

    progressBanner: {
      backgroundColor: '#FEF3C7',
      border: `1px solid ${colors.border}`,
      color: colors.secondary,
      padding: '16px',
      borderRadius: '12px',
      margin: '16px 0',
      fontSize: '14px',
      display: 'flex',
      alignItems: 'center',
      gap: '12px'
    },

    spinner: {
      width: '20px',
      height: '20px',
      border: `2px solid ${colors.border}`,
      borderTop: `2px solid ${colors.primary}`,
      borderRadius: '50%',
      animation: 'spin 1s linear infinite'
    }
  };

  const renderWelcomeScreen = () => (
    <div style={styles.welcomeOverlay}>
      <div style={styles.welcomeCard}>
        <div style={styles.welcomeTitle}>
          <span>üîç</span>
          <span>GitNexus</span>
        </div>
        <div style={styles.welcomeSubtitle}>
          Transform your codebase into an interactive knowledge graph
        </div>

        {state.error && (
          <div style={styles.errorBanner}>
            {state.error}
          </div>
        )}

        {state.isProcessing && (
          <div style={styles.progressBanner}>
            <div style={styles.spinner}></div>
            {state.progress}
          </div>
        )}

        <div style={styles.inputSection}>
          <div style={styles.inputGroup}>
            <label style={styles.label}>GitHub Repository URL</label>
            <input
              type="text"
              value={state.githubUrl}
              onChange={(e) => updateState({ githubUrl: e.target.value })}
              placeholder="https://github.com/owner/repo"
              style={styles.input}
              disabled={state.isProcessing}
            />
            <button
              onClick={handleGitHubProcess}
              disabled={state.isProcessing || !state.githubUrl.trim()}
              style={{
                ...styles.primaryButton,
                opacity: state.isProcessing || !state.githubUrl.trim() ? 0.5 : 1
              }}
            >
              <span>üìä</span>
              Analyze Repository
            </button>
          </div>

          <div style={styles.orDivider}>
            <div style={styles.orLine}></div>
            <span>OR</span>
            <div style={styles.orLine}></div>
          </div>

          <div style={styles.inputGroup}>
            <label style={styles.label}>Upload ZIP File</label>
            <input
              type="file"
              accept=".zip"
              onChange={handleFileUpload}
              disabled={state.isProcessing}
              style={styles.input}
            />
          </div>
        </div>

        <button
          onClick={() => updateState({ showSettings: true })}
          style={styles.secondaryButton}
        >
          ‚öôÔ∏è Settings
        </button>
      </div>
    </div>
  );

  const renderMainInterface = () => {
    // Double-check graph validity before rendering
    if (!isGraphValid) {
      console.warn('Attempted to render main interface with invalid graph:', state.graph);
      return renderWelcomeScreen();
    }

    return (
      <>
        {/* Top Navbar */}
        <div style={styles.navbar}>
          <div style={styles.navbarContent}>
            <span>üîç GitNexus</span>
            <span>‚Ä¢</span>
            <span>{state.graph?.nodes.length || 0} nodes</span>
            <span>‚Ä¢</span>
            <span>{state.graph?.relationships.length || 0} relationships</span>
          </div>
          <button
            onClick={handleNewProject}
            style={{
              ...styles.navbarButton,
              position: 'absolute',
              right: '24px'
            }}
          >
            <span>üîÑ</span>
            New Project
          </button>
        </div>

        {/* Main Layout */}
        <div style={styles.mainLayout}>
          {/* Left Panel - Knowledge Graph */}
          <div style={styles.leftPanel}>
            <GraphExplorer
              graph={state.graph!}
              fileContents={state.fileContents}
              onNodeSelect={handleNodeSelect}
              selectedNodeId={state.selectedNodeId}
              style={{ height: '100%' }}
            />
          </div>

          {/* Right Panel - Chat and Source */}
          <div style={styles.rightPanel}>
            {/* Chat Section */}
            <div style={styles.chatSection}>
              {isApiKeyValid ? (
                <ChatInterface
                  graph={state.graph!}
                  fileContents={state.fileContents}
                  style={{ height: '100%' }}
                />
              ) : (
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  height: '100%',
                  flexDirection: 'column',
                  gap: '16px',
                  padding: '24px',
                  textAlign: 'center',
                  color: colors.textMuted
                }}>
                  <div style={{ fontSize: '48px', opacity: 0.3 }}>üîë</div>
                  <div>Configure your API key to use the chat interface</div>
                  <button
                    onClick={() => updateState({ showSettings: true })}
                    style={styles.secondaryButton}
                  >
                    Open Settings
                  </button>
                </div>
              )}
            </div>

            {/* Source Section */}
            <div style={styles.sourceSection}>
              <SourceViewer
                graph={state.graph!}
                selectedNodeId={state.selectedNodeId}
                fileContents={state.fileContents}
                style={{ height: '100%' }}
              />
            </div>
          </div>
        </div>
      </>
    );
  };

  return (
    <ErrorBoundary>
      <div style={styles.container}>
        <style>{`
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          
          #root {
            height: 100vh;
            width: 100vw;
          }
          
          input:focus, textarea:focus {
            border-color: ${colors.primary} !important;
            box-shadow: 0 0 0 3px ${colors.primary}20 !important;
          }
          
          button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          }
          
          button:active:not(:disabled) {
            transform: translateY(0);
          }
        `}</style>

        {state.showWelcome || !isGraphValid ? renderWelcomeScreen() : renderMainInterface()}

        {/* Settings Modal */}
        {state.showSettings && (
          <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'rgba(0,0,0,0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 2000
          }}>
            <div style={{
              backgroundColor: colors.surface,
              borderRadius: '16px',
              padding: '32px',
              maxWidth: '600px',
              width: '90%',
              maxHeight: '80vh',
              overflow: 'auto'
            }}>
              <h2 style={{ color: colors.text, marginBottom: '24px', fontSize: '24px', fontWeight: '700' }}>
                ü§ñ LLM Settings
              </h2>
              
              {/* Provider Selection */}
              <div style={styles.inputGroup}>
                <label style={styles.label}>LLM Provider</label>
                <select
                  value={state.llmProvider}
                  onChange={(e) => updateState({ llmProvider: e.target.value as LLMProvider })}
                  style={{
                    ...styles.input,
                    cursor: 'pointer'
                  }}
                >
                  <option value="openai">OpenAI</option>
                  <option value="azure-openai">Azure OpenAI</option>
                  <option value="anthropic">Anthropic</option>
                  <option value="gemini">Google Gemini</option>
                </select>
              </div>

              {/* API Key */}
              <div style={styles.inputGroup}>
                <label style={styles.label}>
                  {state.llmProvider === 'azure-openai' ? 'Azure OpenAI API Key' : 
                   state.llmProvider === 'anthropic' ? 'Anthropic API Key' :
                   state.llmProvider === 'gemini' ? 'Google API Key' : 'OpenAI API Key'}
                </label>
                <input
                  type="password"
                  value={state.llmApiKey}
                  onChange={(e) => updateState({ llmApiKey: e.target.value })}
                  placeholder={
                    state.llmProvider === 'azure-openai' ? 'Your Azure OpenAI key...' :
                    state.llmProvider === 'anthropic' ? 'sk-ant-...' :
                    state.llmProvider === 'gemini' ? 'Your Google API key...' : 'sk-...'
                  }
                  style={styles.input}
                />
              </div>

              {/* Azure OpenAI Specific Fields */}
              {state.llmProvider === 'azure-openai' && (
                <>
                  <div style={styles.inputGroup}>
                    <label style={styles.label}>Azure OpenAI Endpoint</label>
                    <input
                      type="text"
                      value={state.azureOpenAIEndpoint}
                      onChange={(e) => updateState({ azureOpenAIEndpoint: e.target.value })}
                      placeholder="https://your-resource.openai.azure.com"
                      style={styles.input}
                    />
                    <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                      Your Azure OpenAI resource endpoint
                    </div>
                  </div>

                  <div style={styles.inputGroup}>
                    <label style={styles.label}>Deployment Name</label>
                    <input
                      type="text"
                      value={state.azureOpenAIDeploymentName}
                      onChange={(e) => updateState({ azureOpenAIDeploymentName: e.target.value })}
                      placeholder="gpt-4o-mini"
                      style={styles.input}
                    />
                    <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                      The deployment name you created in Azure OpenAI Studio
                    </div>
                  </div>

                  <div style={styles.inputGroup}>
                    <label style={styles.label}>API Version</label>
                    <input
                      type="text"
                      value={state.azureOpenAIApiVersion}
                      onChange={(e) => updateState({ azureOpenAIApiVersion: e.target.value })}
                      placeholder="2024-02-01"
                      style={styles.input}
                    />
                    <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                      Azure OpenAI API version (e.g., 2024-02-01, 2025-01-01-preview)
                    </div>
                  </div>
                </>
              )}

              {/* Configuration Status */}
              <div style={{
                padding: '16px',
                borderRadius: '8px',
                backgroundColor: isApiKeyValid ? '#F0F9F0' : '#FFF5F5',
                border: `1px solid ${isApiKeyValid ? '#C6F6C6' : '#FED7D7'}`,
                marginTop: '16px'
              }}>
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  fontSize: '14px',
                  fontWeight: '500',
                  color: isApiKeyValid ? '#2F855A' : '#C53030'
                }}>
                  <span>{isApiKeyValid ? '‚úÖ' : '‚ùå'}</span>
                  {isApiKeyValid ? 'Configuration Valid' : 'Configuration Invalid'}
                </div>
                {!isApiKeyValid && (
                  <div style={{ fontSize: '12px', color: '#C53030', marginTop: '4px' }}>
                    {state.llmProvider === 'azure-openai' 
                      ? 'Please provide API key, endpoint, and deployment name'
                      : 'Please provide a valid API key'}
                  </div>
                )}
              </div>

              {/* Provider Information */}
              <div style={{
                padding: '16px',
                borderRadius: '8px',
                backgroundColor: colors.background,
                border: `1px solid ${colors.borderLight}`,
                marginTop: '16px'
              }}>
                <div style={{ fontSize: '14px', fontWeight: '600', color: colors.text, marginBottom: '8px' }}>
                  üìã Provider Information
                </div>
                <div style={{ fontSize: '12px', color: colors.textMuted, lineHeight: '1.5' }}>
                  {state.llmProvider === 'openai' && 'Direct OpenAI API. Get your API key from platform.openai.com'}
                  {state.llmProvider === 'azure-openai' && 'Azure OpenAI Service. Requires Azure subscription and deployed model.'}
                  {state.llmProvider === 'anthropic' && 'Anthropic Claude API. Get your API key from console.anthropic.com'}
                  {state.llmProvider === 'gemini' && 'Google Gemini API. Get your API key from aistudio.google.com'}
                </div>
              </div>

              <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>
                <button
                  onClick={() => updateState({ showSettings: false })}
                  style={styles.primaryButton}
                >
                  üíæ Save Settings
                </button>
                <button
                  onClick={() => updateState({ showSettings: false })}
                  style={styles.secondaryButton}
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </ErrorBoundary>
  );
};

export default HomePage;

================
File: src/ui/pages/index.ts
================
export { default as HomePage } from './HomePage.tsx';

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: src/workers/ingestion.worker.ts
================
import * as Comlink from 'comlink';
import { GraphPipeline, type PipelineInput } from '../core/ingestion/pipeline.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface IngestionProgress {
  phase: 'structure' | 'parsing' | 'calls' | 'complete';
  message: string;
  progress: number;
  timestamp: number;
}

export interface IngestionResult {
  success: boolean;
  graph?: KnowledgeGraph;
  error?: string;
  stats?: {
    nodeStats: Record<string, number>;
    relationshipStats: Record<string, number>;
    callStats: { totalCalls: number; callTypes: Record<string, number> };
  };
  duration: number;
}

export class IngestionWorker {
  private pipeline: GraphPipeline;
  private progressCallback?: (progress: IngestionProgress) => void;

  constructor() {
    this.pipeline = new GraphPipeline();
  }

  public setProgressCallback(callback: (progress: IngestionProgress) => void): void {
    this.progressCallback = callback;
  }

  public async processRepository(input: PipelineInput): Promise<IngestionResult> {
    const startTime = Date.now();
    
    try {
      console.log('IngestionWorker: Starting processing with', input.filePaths.length, 'files');
      
      // Memory optimization: Create a copy of file contents and clear originals gradually
      const fileContentsMap = new Map(input.fileContents);
      
      // Initialize pipeline
      if (!this.pipeline) {
        this.pipeline = new GraphPipeline();
      }
      
      // Progress tracking
      let currentProgress = 0;
      const totalSteps = 3; // structure, parsing, calls
      
      const updateProgress = (phase: IngestionProgress['phase'], message: string, stepProgress: number) => {
        const overallProgress = (currentProgress / totalSteps) * 100 + (stepProgress / totalSteps);
        if (this.progressCallback) {
          this.progressCallback({
            phase,
            message,
            progress: Math.min(overallProgress, 100),
            timestamp: Date.now()
          });
        }
      };

      // Run the pipeline with memory optimization
      updateProgress('structure', 'Analyzing project structure...', 0);
      const graph = await this.pipeline.run({
        ...input,
        fileContents: fileContentsMap
      });
      
      // Clear file contents to free memory after processing
      fileContentsMap.clear();
      
      const duration = Date.now() - startTime;
      
      console.log('IngestionWorker: Processing completed successfully');
      console.log(`Graph contains ${graph.nodes.length} nodes and ${graph.relationships.length} relationships`);
      
      // Calculate statistics
      const nodeStats: Record<string, number> = {};
      const relationshipStats: Record<string, number> = {};
      
      graph.nodes.forEach(node => {
        nodeStats[node.label] = (nodeStats[node.label] || 0) + 1;
      });
      
      graph.relationships.forEach(rel => {
        relationshipStats[rel.type] = (relationshipStats[rel.type] || 0) + 1;
      });

      return {
        success: true,
        graph,
        stats: {
          nodeStats,
          relationshipStats,
          callStats: { totalCalls: 0, callTypes: {} }
        },
        duration
      };
    } catch (error) {
      console.error('IngestionWorker: Processing failed:', error);
      
      const duration = Date.now() - startTime;
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred during processing',
        duration
      };
    }
  }

  public async processFiles(
    projectName: string,
    files: { path: string; content: string }[]
  ): Promise<IngestionResult> {
    const fileContents = new Map<string, string>();
    const filePaths: string[] = [];
    
    for (const file of files) {
      filePaths.push(file.path);
      fileContents.set(file.path, file.content);
    }
    
    const input: PipelineInput = {
      projectRoot: '/',
      projectName,
      filePaths,
      fileContents
    };
    
    return this.processRepository(input);
  }

  public async validateRepository(input: PipelineInput): Promise<{ valid: boolean; errors: string[] }> {
    const errors: string[] = [];
    
    try {
      this.validateInput(input);
      
      // Additional validation checks
      if (input.filePaths.length === 0) {
        errors.push('No files provided for processing');
      }
      
      if (input.fileContents.size === 0) {
        errors.push('No file contents provided');
      }
      
      // Check for Python files
      const pythonFiles = input.filePaths.filter(path => path.endsWith('.py'));
      if (pythonFiles.length === 0) {
        errors.push('No Python files found in the repository');
      }
      
      // Validate file contents exist
      for (const filePath of input.filePaths) {
        if (!input.fileContents.has(filePath)) {
          errors.push(`Missing content for file: ${filePath}`);
        }
      }
      
      return {
        valid: errors.length === 0,
        errors
      };
      
    } catch (error) {
      errors.push(error instanceof Error ? error.message : 'Validation failed');
      return {
        valid: false,
        errors
      };
    }
  }

  public getWorkerInfo(): { version: string; capabilities: string[] } {
    return {
      version: '1.0.0',
      capabilities: [
        'python-parsing',
        'structure-analysis',
        'call-resolution',
        'ast-caching',
        'progress-reporting'
      ]
    };
  }

  private validateInput(input: PipelineInput): void {
    if (!input.projectName || input.projectName.trim().length === 0) {
      throw new Error('Project name is required');
    }
    
    if (!input.projectRoot || input.projectRoot.trim().length === 0) {
      throw new Error('Project root is required');
    }
    
    if (!Array.isArray(input.filePaths)) {
      throw new Error('File paths must be an array');
    }
    
    if (!(input.fileContents instanceof Map)) {
      throw new Error('File contents must be a Map');
    }
  }

  private reportProgress(phase: IngestionProgress['phase'], message: string, progress: number): void {
    if (this.progressCallback) {
      this.progressCallback({
        phase,
        message,
        progress,
        timestamp: Date.now()
      });
    }
  }

  public terminate(): void {
    // Cleanup resources if needed
    console.log('Ingestion worker terminated');
  }
}

// Expose the worker class via Comlink
const worker = new IngestionWorker();
Comlink.expose(worker);

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

================
File: tsconfig.app.tsbuildinfo
================
{"root":["./src/app.tsx","./src/main.tsx","./src/vite-env.d.ts","./src/ai/cypher-generator.ts","./src/ai/index.ts","./src/ai/langchain-orchestrator.ts","./src/ai/llm-service.ts","./src/ai/orchestrator.ts","./src/core/graph/types.ts","./src/core/ingestion/call-processor.ts","./src/core/ingestion/parsing-processor.ts","./src/core/ingestion/pipeline.ts","./src/core/ingestion/structure-processor.ts","./src/core/tree-sitter/parser-loader.ts","./src/lib/export.ts","./src/lib/polyfills.ts","./src/lib/preload.ts","./src/lib/utils.ts","./src/lib/workerutils.ts","./src/services/github.ts","./src/services/ingestion.service.ts","./src/services/zip.ts","./src/ui/index.ts","./src/ui/components/errorboundary.tsx","./src/ui/components/index.ts","./src/ui/components/chat/chatinterface.tsx","./src/ui/components/chat/codeassistant.tsx","./src/ui/components/chat/index.ts","./src/ui/components/graph/graphexplorer.tsx","./src/ui/components/graph/sourceviewer.tsx","./src/ui/components/graph/visualization.tsx","./src/ui/components/graph/index.ts","./src/ui/pages/homepage.tsx","./src/ui/pages/index.ts","./src/workers/ingestion.worker.ts"],"errors":true,"version":"5.8.3"}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

================
File: tsconfig.node.tsbuildinfo
================
{"root":["./vite.config.ts"],"version":"5.8.3"}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  worker: {
    format: 'es'
  },
  assetsInclude: ['**/*.wasm'],
  server: {
    fs: {
      allow: ['..']
    },
    headers: {
      'Cross-Origin-Embedder-Policy': 'require-corp',
      'Cross-Origin-Opener-Policy': 'same-origin'
    },
    hmr: {
      overlay: false
    }
  },
  build: {
    target: 'esnext',
    assetsInlineLimit: 0,
    commonjsOptions: {
      include: [/node_modules/],
      transformMixedEsModules: true,
      defaultIsModuleExports: true
    }
  },
  define: {
    global: 'globalThis',
  },
  resolve: {
    alias: {
      'node:async_hooks': path.resolve(__dirname, 'src/lib/polyfills.ts'),
      'async_hooks': path.resolve(__dirname, 'src/lib/polyfills.ts')
    }
  },
  optimizeDeps: {
    exclude: ['@langchain/langgraph'],
    include: [
      'camelcase', 
      'decamelize', 
      'ansi-styles',
      'chalk',
      'supports-color',
      'p-queue',
      'p-retry',
      'semver',
      'base64-js',
      'num-sort',
      'binary-search',
      'js-tiktoken',
      'uuid',
      'ms',
      'retry',
      'p-timeout',
      'p-finally',
      'eventemitter3',
      'web-tree-sitter',
      'comlink'
    ],
    force: true,
    holdUntilCrawlEnd: true
  }
})
