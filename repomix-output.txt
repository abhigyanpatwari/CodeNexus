This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-17T03:31:21.892Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.clinerules/byterover-rules.md
.cursor/rules/byterover-rules.mdc
.gemini/settings.json
.gitignore
.kilocode/rules/byterover-rules.md
Agent.md
ARCHITECTURE_UPGRADE.md
CONVERSION_SUMMARY.md
DEBUG_FEATURES.md
eslint.config.js
FILTERING_FIX.md
GITNEXUS_README.md
gitnexus.txt
index.html
ISOLATED_NODES_FIX.md
jest.config.cjs
log.txt
package.json
project_guide.md
PRUNING_IMPLEMENTATION.md
public/vite.svg
quicksort.js
README.md
src/__tests__/error-handler.test.ts
src/__tests__/health-monitor.test.ts
src/__tests__/memory-manager.test.ts
src/__tests__/setup.ts
src/__tests__/streaming-processor.test.ts
src/__tests__/utils.test.ts
src/ai/cypher-generator.ts
src/ai/index.ts
src/ai/langchain-orchestrator.ts
src/ai/llm-service.ts
src/ai/orchestrator.ts
src/App.css
src/App.tsx
src/assets/react.svg
src/config/config.ts
src/config/language-config.ts
src/core/graph/graph.ts
src/core/graph/query-engine.ts
src/core/graph/query.ts
src/core/graph/trie.ts
src/core/graph/types.ts
src/core/ingestion/call-processor.ts
src/core/ingestion/import-processor.ts
src/core/ingestion/parsing-processor.ts
src/core/ingestion/pipeline.ts
src/core/ingestion/structure-processor.ts
src/core/ingestion/tree-sitter-queries.ts
src/core/tree-sitter/parser-loader.ts
src/index.css
src/lib/error-handler.ts
src/lib/export.ts
src/lib/polyfills.ts
src/lib/preload.ts
src/lib/shared-utils.ts
src/lib/streaming-processor.ts
src/lib/utils.ts
src/lib/validation.ts
src/lib/worker-pool.ts
src/lib/workerUtils.ts
src/main.tsx
src/services/github.ts
src/services/health-monitor.ts
src/services/ingestion.service.ts
src/services/memory-manager.ts
src/services/zip.ts
src/ui/components/chat/ChatInterface.tsx
src/ui/components/chat/CodeAssistant.tsx
src/ui/components/chat/index.ts
src/ui/components/ErrorBoundary.tsx
src/ui/components/graph/GraphExplorer.tsx
src/ui/components/graph/index.ts
src/ui/components/graph/SourceViewer.tsx
src/ui/components/graph/Visualization.tsx
src/ui/components/index.ts
src/ui/index.ts
src/ui/pages/HomePage.tsx
src/ui/pages/index.ts
src/vite-env.d.ts
src/workers/ingestion.worker.ts
STRUCTURE_FIX_SUMMARY.md
tsconfig.app.json
tsconfig.app.tsbuildinfo
tsconfig.json
tsconfig.node.json
tsconfig.node.tsbuildinfo
vite.config.ts

================================================================
Files
================================================================

================
File: .clinerules/byterover-rules.md
================
# important 
always use byterover-retrive-knowledge tool to get the related context before any tasks 
always use byterover-store-knowledge to store all the critical informations after sucessful tasks

================
File: .cursor/rules/byterover-rules.mdc
================
---
description: ByteRover MCP Custom Instructions
alwaysApply: true
---

# important 
always use byterover-retrive-knowledge tool to get the related context before any tasks 
always use byterover-store-knowledge to store all the critical informations after sucessful tasks

================
File: .gemini/settings.json
================
{
  "mcpServers": {
    "context7": {
      "command": "npx",
      "args": [
        "-y",
        "@upstash/context7-mcp"
      ]
    },
    "byterover-mcp": {
      "url": "https://mcp.byterover.dev/mcp?machineId=1f07a70b-9678-6360-94e8-39cdb5a69f06"
    }
  }
}

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: .kilocode/rules/byterover-rules.md
================
# important 
always use byterover-retrive-knowledge tool to get the related context before any tasks 
always use byterover-store-knowledge to store all the critical informations after sucessful tasks

================
File: Agent.md
================
# GitNexus - Complete Agent Documentation

## 🎯 Project Overview

**GitNexus** is a client-side, edge-based code knowledge graph generator that transforms any codebase into an interactive knowledge graph with AI-powered Graph RAG capabilities. It runs entirely in the browser with zero server dependencies.

### Core Mission

- **Zero-Setup Code Intelligence**: Analyze codebases without servers or configuration
- **Graph RAG-Powered**: Use knowledge graphs for AI-powered code understanding
- **Multi-Language Support**: Currently Python-focused with extensible architecture
- **Browser-Native**: All processing happens client-side using WebAssembly and Web Workers

### Key Capabilities

- **GitHub Integration**: Direct repository analysis via GitHub API
- **ZIP Processing**: Local archive analysis with intelligent filtering
- **Interactive Visualization**: Cytoscape.js-powered knowledge graphs
- **AI Chat Interface**: Multi-LLM support (OpenAI, Anthropic, Gemini)
- **Advanced Parsing**: Tree-sitter WASM for accurate AST analysis

## 🏗️ Architecture Deep Dive

### System Architecture Layers

```
┌─────────────────────────────────────────────────────────────┐
│                    User Interface Layer                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │   HomePage  │  │  Chat UI    │  │  Graph Explorer     │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                    Service Layer                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │ GitHub API  │  │ ZIP Service │  │ Ingestion Service   │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                  Processing Pipeline                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │  Structure  │  │   Parsing   │  │   Call Resolution   │ │
│  │  Processor  │  │  Processor  │  │   3-Stage Strategy  │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                  Core Engine                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │  Graph      │  │  Function   │  │  Import             │ │
│  │  Types      │  │  Registry   │  │  Resolution         │ │
│  └─────────────┘  │  (Trie)     │  └─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### Technology Stack

**Frontend Framework**: React 18 + TypeScript + Vite
**Graph Visualization**: Cytoscape.js + d3.js
**Code Parsing**: Tree-sitter WebAssembly
**AI Integration**: LangChain.js with ReAct pattern
**State Management**: React Context + custom hooks
**Build System**: Vite with WASM support

## 📊 4-Pass Processing Pipeline

### Pass 1: Structure Analysis (`StructureProcessor`)

**Purpose**: Discover complete repository structure without filtering

**Key Innovations**:

- **Complete Discovery**: Finds ALL directories and files (including ignored ones)
- **No Early Filtering**: Preserves complete structure for accurate representation
- **Smart Categorization**: Distinguishes files from directories algorithmically
- **Intermediate Paths**: Automatically discovers missing directory levels

**Implementation Details**:

```typescript
// Direct path processing instead of inference
const { directories, files } = this.categorizePaths(allPaths);
```

### Pass 2: Code Parsing & Definition Extraction (`ParsingProcessor`)

**Purpose**: Parse source code and extract definitions while applying intelligent filtering

**Key Components**:

- **Tree-sitter Integration**: WASM-based parsing for multiple languages
- **Function Registry Trie**: Optimized data structure for definition lookups
- **Two-Stage Filtering**:
  - Stage 1: Prune ignored directories (node_modules, .git, etc.)
  - Stage 2: Apply user filters (directory patterns, file extensions)

**Ignore Patterns**:

```typescript
IGNORE_PATTERNS = [
  '.git', 'node_modules', '__pycache__', '.venv', 'build', 'dist',
  '.vscode', '.idea', 'tmp', 'logs', 'coverage'
]
```

### Pass 3: Import Resolution (`ImportProcessor`)

**Purpose**: Build comprehensive project-wide import map

**Features**:

- **Multi-language Support**: Python, JavaScript, TypeScript imports
- **Path Resolution**: Handles relative and absolute imports
- **Alias Tracking**: Maps local names to actual exported functions
- **Validation**: Checks against actual project files

**Resolution Patterns**:

- Python: `import`, `from...import`
- JS/TS: `import`, `require()`, `export`
- Path normalization for complex project structures

### Pass 4: Call Resolution (`CallProcessor`)

**Purpose**: Resolve function calls using 3-stage strategy

**3-Stage Resolution Strategy**:

1. **Exact Match** (High Confidence): Uses import map for direct resolution
2. **Same-Module Match** (High Confidence): Local function calls within files
3. **Heuristic Fallback** (Intelligent): Uses FunctionRegistryTrie with distance scoring

**Heuristic Algorithm**:

```typescript
// Distance-based scoring for ambiguous calls
const distance = max(caller_parts, candidate_parts) - common_prefix_length
const score = distance - sibling_bonus
```

## 🤖 AI Integration Architecture

### ReAct Agent Implementation

**Pattern**: Reasoning + Acting for complex code queries

**Agent Components**:

- **LLM Service**: Multi-provider support (OpenAI, Anthropic, Gemini)
- **Cypher Generator**: Natural language to graph query translation
- **Tool System**: Graph queries, code retrieval, file search
- **Memory Management**: Configurable conversation history

### Available Tools

1. **query_graph**: Execute Cypher queries on knowledge graph
2. **get_code**: Retrieve specific code snippets
3. **search_files**: Find files by name or content patterns
4. **get_file_content**: Get complete file contents

### Debug Mode Features

- **Reasoning Steps**: Complete ReAct process visualization
- **Cypher Queries**: Generated queries with explanations
- **Configuration**: LLM settings and performance metrics
- **Context Info**: Graph statistics and source attribution

## 🔧 Service Layer Details

### GitHub Service (`src/services/github.ts`)

**Purpose**: GitHub API integration with rate limiting and error handling

**Key Features**:

- **Rate Limit Handling**: 5,000 requests/hour with token, 60 without
- **Error Recovery**: Comprehensive error handling with user-friendly messages
- **Authentication**: Personal access token support
- **Content Retrieval**: Efficient file and directory fetching

**API Methods**:

```typescript
getRepositoryContents(owner, repo, path) // Directory structure
getFileContent(owner, repo, path)       // Individual file content
downloadFileRaw(owner, repo, path)      // Raw file download
```

### ZIP Service (`src/services/zip.ts`)

**Purpose**: Local archive processing with complete structure discovery

**Features**:

- **Complete Structure**: Extracts all paths regardless of filtering
- **Memory Efficient**: Streaming processing for large archives
- **Path Normalization**: Handles common top-level folder removal
- **Content Mapping**: Efficient Map<string, string> for file contents

### Ingestion Service (`src/services/ingestion.service.ts`)

**Purpose**: Orchestrate the complete ingestion pipeline

**Orchestration Methods**:

```typescript
processGitHubRepo(url, options)    // GitHub repository processing
processZipFile(file, options)      // ZIP archive processing
```

## 📈 Data Models & Types

### Core Graph Types

```typescript
interface KnowledgeGraph {
  nodes: GraphNode[]
  relationships: Relationship[]
}

interface GraphNode {
  id: string
  label: 'Project' | 'Folder' | 'File' | 'Function' | 'Class' | 'Method' | 'Variable'
  properties: Record<string, any>
}

interface Relationship {
  id: string
  type: 'CONTAINS' | 'CALLS' | 'IMPORTS' | 'DECORATES'
  source: string
  target: string
  properties: Record<string, any>
}
```

### Function Registry Trie

**Purpose**: Optimized function definition lookups

**Key Features**:

- **Suffix-based search**: `findEndingWith(name)` for heuristic matching
- **Qualified names**: Full paths like `myProject.services.api.fetchUser`
- **Import distance**: Smart scoring for best match selection

## 🎨 User Interface Architecture

### Component Structure

```
App.tsx
├── HomePage.tsx (Main application page)
├── GraphExplorer.tsx (Interactive graph visualization)
├── ChatInterface.tsx (AI chat with debug mode)
├── SourceViewer.tsx (Code display with syntax highlighting)
└── ErrorBoundary.tsx (Comprehensive error handling)
```

### Interactive Features

- **Graph Navigation**: Node selection, zooming, panning
- **Real-time Progress**: Live updates during processing
- **Split-Panel Layout**: Graph + chat interface
- **Settings Management**: Persistent configuration
- **Export Functionality**: JSON export with metadata

## 🔍 Performance Optimization

### Processing Optimizations

- **Web Workers**: Background processing to keep UI responsive
- **Intelligent Filtering**: Skip massive directories (node_modules, .git)
- **Batch Processing**: Chunked processing for large repositories
- **Memory Management**: Configurable file limits (default: 500 files)

### Graph Optimization

- **Node Limiting**: Smart truncation for large graphs
- **Relationship Pruning**: Focus on high-confidence connections
- **Caching**: AST and processing result caching
- **Lazy Loading**: On-demand content loading

## 🛡️ Error Handling & Reliability

### Error Boundaries

- **Component-level**: Graceful degradation for UI components
- **Worker-level**: Web Worker error recovery
- **Service-level**: API and processing error handling

### User Experience

- **Progress Indicators**: Detailed phase-specific messaging
- **Confirmation Dialogs**: Smart warnings for expensive operations
- **Recovery Options**: Clear guidance for error resolution
- **Debug Information**: Comprehensive logging for troubleshooting

## 📊 Development Setup

### Prerequisites

- **Node.js 18+** and **npm/yarn**
- **GitHub Token** (optional, increases rate limits)
- **AI API Keys**: OpenAI, Anthropic, or Gemini

### Installation

```bash
npm install
npm run dev    # Development server on http://localhost:5173
npm run build  # Production build
```

### Configuration

- **GitHub Token**: Settings → GitHub Token
- **AI Keys**: Settings → AI Provider Configuration
- **Performance**: Settings → File limits and filtering

## 🎯 Usage Patterns

### GitHub Repository Analysis

1. **URL Input**: Enter GitHub repository URL
2. **Filtering**: Optional directory and file extension filters
3. **Processing**: 4-pass pipeline with progress tracking
4. **Exploration**: Interactive graph with AI chat

### ZIP Archive Analysis

1. **File Upload**: Select local ZIP archive
2. **Configuration**: Set processing limits and filters
3. **Analysis**: Complete repository structure discovery
4. **Results**: Knowledge graph with code intelligence

### Best Practices

- **Start Small**: Begin with focused directories
- **Use Filters**: Exclude dependencies and build artifacts
- **Monitor Progress**: Watch console for processing insights
- **Leverage AI**: Use chat interface for code exploration

## 🔮 Future Enhancements

### Language Support

- **JavaScript/TypeScript**: Enhanced parsing and analysis
- **Java**: Class and method relationship mapping
- **C++**: Template and inheritance analysis
- **Go**: Package and interface resolution

### Advanced Features

- **Code Metrics**: Complexity and quality analysis
- **Security Scanning**: Vulnerability detection
- **Documentation Generation**: Auto-generated docs
- **Team Collaboration**: Shared graph exploration

### Performance Improvements

- **Incremental Processing**: Update existing graphs
- **Distributed Processing**: Multiple worker threads
- **Caching Layer**: Persistent processing cache
- **Streaming Analysis**: Real-time code changes

---

## 📝 Quick Reference

### Key Files

- **Main Entry**: `src/App.tsx`
- **Pipeline**: `src/core/ingestion/pipeline.ts`
- **Services**: `src/services/`
- **AI Logic**: `src/ai/`
- **UI Components**: `src/ui/components/`

### Debug Commands

- **Enable Debug**: Click "🔍 Debug" in chat interface
- **Check Console**: F12 → Console for processing logs
- **Diagnose Issues**: Use "🩺 Diagnose" button

### Common Issues

- **Rate Limits**: Add GitHub token for higher limits
- **Large Repos**: Adjust file limits in settings
- **Parsing Errors**: Check file syntax and extensions
- **Memory Issues**: Reduce processing scope with filters

This documentation provides complete context for any agent working on GitNexus, from architecture understanding to implementation details and troubleshooting guidance.

================
File: ARCHITECTURE_UPGRADE.md
================
# 🚀 Knowledge Graph Generation Architecture Upgrade

## Overview

The knowledge graph generation pipeline has been completely restructured to address two critical weaknesses:

1. **Inaccurate Call Resolution** - Previous monolithic approach lacked project-wide visibility
2. **Inefficient Definition Lookups** - Simple map-based storage limited advanced resolution heuristics

## 🏗️ New Architecture: 4-Pass Decoupled Pipeline

### **Pass 1: Structure Analysis** 📁
- **Processor**: `StructureProcessor`
- **Purpose**: Build project hierarchy (folders, files)
- **Output**: Basic graph structure with CONTAINS relationships

### **Pass 2: Code Parsing & Definition Extraction** 🔍
- **Processor**: `ParsingProcessor` (Enhanced)
- **Purpose**: Parse source code and extract definitions
- **Key Enhancement**: Populates `FunctionRegistryTrie` for efficient lookups
- **Output**: Function/class/method nodes + optimized search structure

### **Pass 3: Import Resolution** 🔗
- **Processor**: `ImportProcessor` (NEW)
- **Purpose**: Build comprehensive project-wide import map
- **Key Features**:
  - Resolves all aliases and relative paths
  - Handles Python, JavaScript, TypeScript imports
  - Creates accurate IMPORTS relationships
- **Output**: Complete dependency graph + import map

### **Pass 4: Call Resolution** 📞
- **Processor**: `CallProcessor` (Completely Rewritten)
- **Purpose**: Resolve function calls using 3-stage strategy
- **Input**: Import map + Function registry trie
- **Output**: Accurate CALLS relationships

## 🧠 Key Innovations

### 1. FunctionRegistryTrie (`src/core/graph/trie.ts`)

**Purpose**: Optimized data structure for function definition lookups

**Key Features**:
- **Suffix-based search**: `findEndingWith(name)` for heuristic matching
- **Qualified names**: Stores full paths like `myProject.services.api.fetchUser`
- **Import distance calculation**: Smart scoring for best match selection

**Example Usage**:
```typescript
// Find all functions ending with "fetchUser" across the project
const candidates = trie.findEndingWith("fetchUser");
// Returns: [
//   { qualifiedName: "services.api.fetchUser", filePath: "services/api.py" },
//   { qualifiedName: "utils.cache.fetchUser", filePath: "utils/cache.js" }
// ]
```

### 2. ImportProcessor (`src/core/ingestion/import-processor.ts`)

**Purpose**: Dedicated import resolution with project-wide visibility

**Key Features**:
- **Language Support**: Python (`import`, `from...import`) and JS/TS (`import`, `require`)
- **Path Resolution**: Handles relative imports (`.`, `..`) and absolute imports
- **Alias Tracking**: Maps local names to actual exported functions
- **Validation**: Checks against actual project files

**Example Output**:
```typescript
importMap = {
  "src/api.js": {
    "fetchUser": {
      targetFile: "src/services/user.js",
      exportedName: "fetchUser",
      importType: "named"
    }
  }
}
```

### 3. Advanced Call Resolution Strategy

**3-Stage Resolution Process**:

#### Stage 1: Exact Match (High Confidence)
- Uses import map for direct resolution
- Example: `import { fetchUser } from './services'` → Direct link to `services/fetchUser`

#### Stage 2: Same-Module Match (High Confidence)  
- Checks for function definitions within the same file
- Example: Local function calls within a module

#### Stage 3: Heuristic Fallback (Intelligent Guessing)
- Uses `FunctionRegistryTrie.findEndingWith()` to find candidates
- Applies **import distance** algorithm for best match
- **Distance Formula**: `max(caller_parts, candidate_parts) - common_prefix_length`
- **Sibling Bonus**: -1 for functions in same parent directory

**Example Heuristic Resolution**:
```
Call: fetchUser() in "src/components/UserList.js"
Candidates found:
- src/services/user.js:fetchUser (distance: 2)
- src/utils/api.js:fetchUser (distance: 2) 
- src/components/utils.js:fetchUser (distance: 1) ← SELECTED (sibling bonus)
```

## 📊 Performance & Accuracy Improvements

### Resolution Statistics
The new CallProcessor provides detailed statistics:
- **Exact matches** (Stage 1): Highest confidence
- **Same-file matches** (Stage 2): High confidence  
- **Heuristic matches** (Stage 3): Medium confidence with distance scoring
- **Failed resolutions**: Tracked for debugging

### Expected Improvements
- **🎯 Higher Accuracy**: Project-wide visibility eliminates cross-file resolution failures
- **⚡ Better Performance**: Trie-based lookups vs linear searches
- **🔍 Smarter Heuristics**: Distance-based scoring for ambiguous cases
- **📈 Detailed Metrics**: Comprehensive resolution statistics

## 🔧 Technical Implementation Details

### File Structure
```
src/core/
├── graph/
│   └── trie.ts              # FunctionRegistryTrie implementation
├── ingestion/
│   ├── pipeline.ts          # Updated 4-pass orchestration
│   ├── structure-processor.ts
│   ├── parsing-processor.ts # Enhanced with trie population
│   ├── import-processor.ts  # NEW: Dedicated import resolution
│   └── call-processor.ts    # Completely rewritten
```

### Integration Points
1. **ParsingProcessor** populates the trie during definition extraction
2. **ImportProcessor** builds the complete import map
3. **CallProcessor** uses both trie and import map for resolution
4. **Pipeline** orchestrates the sequence with proper data flow

### Browser Compatibility
- Custom path utilities replace Node.js `path` module
- All processors work in browser environment
- Maintains existing WASM tree-sitter integration

## 🚀 Usage

The new architecture is fully integrated into the existing pipeline. No changes required for:
- UI components
- Worker integration  
- Export functionality
- Statistics display

The system automatically uses the new 4-pass architecture for all repository processing.

## 🎯 Results

This architecture upgrade transforms the knowledge graph generation from a basic parser into an intelligent code analysis system capable of:

- **Accurate cross-file call resolution**
- **Smart import dependency tracking** 
- **Heuristic-based intelligent guessing**
- **Comprehensive project-wide visibility**
- **Detailed resolution analytics**

The result is a significantly more accurate and comprehensive knowledge graph that truly represents the structure and relationships within a codebase.

================
File: CONVERSION_SUMMARY.md
================
# Deno to Node.js Conversion Summary

## Overview
Successfully converted the GitNexus repository from Deno to Node.js while maintaining all functionality.

## Changes Made

### 1. Configuration Files
- **Removed**: `deno.json`, `deno.lock`
- **Updated**: `package.json` with all dependencies from `deno.json`
  - Added all npm dependencies: jszip, axios, cytoscape, web-tree-sitter, langchain packages, etc.
  - Updated version to 1.0.0
  - Kept existing build scripts (Vite-based)

### 2. Import Statements
- **Removed**: All `npm:` prefixes from import statements
- **Removed**: All `@ts-expect-error` comments related to npm: imports
- **Files affected**: 13+ TypeScript files across the codebase

### 3. Dependencies Successfully Converted
- `react` & `react-dom` (already present)
- `jszip` for ZIP file processing
- `axios` for HTTP requests
- `cytoscape` & `cytoscape-dagre` for graph visualization
- `web-tree-sitter` for code parsing
- `comlink` for web workers
- `@langchain/*` packages for AI functionality
- `zod` for schema validation

### 4. Build System
- **Unchanged**: Vite configuration remains the same
- **Unchanged**: TypeScript configuration
- **Working**: Development server starts successfully on port 5173
- **Note**: Some TypeScript errors remain but don't prevent the dev server from running

## Current Status
✅ **Development server running** - The application starts and runs on Node.js
✅ **All dependencies installed** - npm install completed successfully  
✅ **Import statements fixed** - All Deno-style imports converted to Node.js style
⚠️ **TypeScript errors** - Some type errors remain but don't block functionality

## Next Steps (Optional)
The conversion is complete and functional, but to achieve a clean build:
1. Fix TypeScript errors in langchain imports
2. Update type definitions for cytoscape
3. Fix unused variable warnings
4. Address JSZip type compatibility issues

## Files Modified
- `package.json` - Added all dependencies
- 13+ TypeScript files - Removed npm: prefixes and Deno comments
- Removed `deno.json` and `deno.lock`

The repository is now fully converted to Node.js and ready for development!

================
File: DEBUG_FEATURES.md
================
# 🔍 Debug Mode Features

The GitNexus chat interface now includes a comprehensive debug mode that shows the internal workings of the Graph RAG agent.

## 📝 Markdown Formatting

**NEW**: The chat interface now supports full markdown formatting for better readability!

### Supported Markdown Features:
- **Headers** (# ## ###) for organizing information
- **Bold** and *italic* text for emphasis  
- `Inline code` for function names and file paths
- Code blocks with syntax highlighting for multiple languages
- Bullet points and numbered lists
- Tables for structured data
- Blockquotes for important notes
- Links (automatically open in new tabs)

### Enhanced Debug Display:
- **Reasoning observations** are now rendered with markdown
- **Query explanations** support formatted text
- **Tool outputs** preserve formatting and structure
- **Code snippets** get proper syntax highlighting

## How to Use Debug Mode

1. **Toggle Debug Mode**: Click the `🔍 Debug` button in the chat interface header
2. **Ask Questions**: When debug mode is enabled, all assistant responses will include detailed debug information
3. **Explore Tabs**: The debug panel includes multiple tabs showing different aspects of the processing

## Debug Panel Tabs

### 🧠 Reasoning Steps
Shows the complete ReAct (Reasoning + Acting) process:
- **Step-by-step thinking**: See how the agent reasons about your question
- **Actions taken**: View which tools the agent decides to use
- **Tool inputs**: See the exact parameters passed to each tool
- **Observations**: View the results returned by each tool
- **Success/failure status**: Monitor tool execution success

### 🔍 Cypher Queries
Displays generated graph queries:
- **Generated Cypher**: See the exact database queries created
- **Query explanations**: Understand why each query was generated
- **Confidence scores**: View how confident the system is in each query
- **Syntax highlighting**: Cypher queries displayed with proper formatting

### ⚙️ Configuration
Shows system configuration:
- **LLM Settings**: Provider, model, temperature, max tokens
- **RAG Options**: Reasoning steps, strict mode, temperature
- **Performance Metrics**: Execution time, confidence scores

### 📊 Context Info
Displays knowledge graph statistics:
- **Graph Nodes**: Total number of code entities in the graph
- **Files Indexed**: Number of source files processed
- **Sources Used**: Files referenced in the current response
- **Referenced Sources**: List of specific files used for the answer

## What You Can Learn

### Understanding Agent Behavior
- See how the agent breaks down complex questions
- Understand the reasoning process step-by-step
- Monitor which tools are used and why

### Query Optimization
- View generated Cypher queries to understand graph traversal
- See query confidence scores to assess reliability
- Learn about query patterns for different question types

### Performance Analysis
- Monitor execution times for different operations
- Understand the relationship between question complexity and processing time
- Identify bottlenecks in the reasoning process

### Context Awareness
- See how much of your codebase is being used
- Understand which files are most relevant to your questions
- Monitor the scope of graph traversal

## Debug Mode Benefits

1. **Transparency**: Complete visibility into AI decision-making
2. **Learning**: Understand how Graph RAG works internally
3. **Debugging**: Identify issues with queries or reasoning
4. **Optimization**: Fine-tune your questions for better results
5. **Trust**: Build confidence through explainable AI

## Example Debug Output

When you ask "How many functions are in this project?", debug mode shows:

**Reasoning Steps:**
1. **Thought**: "I need to count all functions in the project using a graph query"
2. **Action**: query_graph
3. **Input**: "Count all functions in the project"
4. **Observation**: Generated Cypher query and results

**Generated Query:**
```cypher
MATCH (f:Function) RETURN COUNT(f)
```

**Configuration:**
- Model: gpt-4o-mini
- Temperature: 0.1
- Execution Time: 1,234ms

This level of detail helps you understand exactly how your question was processed and answered.

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: FILTERING_FIX.md
================
# 🔧 Directory Filtering Fix - .venv and Ignored Directories Hidden

## 🚨 **Issue Identified and Fixed**

**Problem**: `.venv` and other ignored directories were still appearing in the Knowledge Graph despite filtering implementation.

**Root Cause**: The two-stage filtering was only filtering **file parsing**, but ignored directory **nodes** were still being created and displayed in the KG.

## ✅ **Solution Implemented**

### **Enhanced StructureProcessor**

#### **Directory Hiding Logic**
```typescript
// Added to StructureProcessor
private shouldHideDirectory(dirPath: string): boolean {
  const pathSegments = dirPath.split('/');
  
  // Check if any segment matches ignore patterns
  const hasIgnoredSegment = pathSegments.some(segment => 
    StructureProcessor.IGNORE_PATTERNS.has(segment.toLowerCase())
  );
  
  return hasIgnoredSegment || this.matchesAdditionalPatterns(dirPath);
}
```

#### **Filtered Node Creation**
```typescript
// Filter directories before creating nodes
const visibleDirectories = directories.filter(dir => !this.shouldHideDirectory(dir));
const hiddenDirectoriesCount = directories.length - visibleDirectories.length;

console.log(`StructureProcessor: Hiding ${hiddenDirectoriesCount} ignored directories from KG`);

// Create nodes only for visible directories
const directoryNodes = this.createDirectoryNodes(visibleDirectories);
```

#### **Smart Relationship Handling**
```typescript
// Handle files in hidden directories by connecting to nearest visible parent
private findVisibleParent(path: string, projectId: string): string {
  if (path === '') return projectId;
  
  const parentPath = this.getParentPath(path);
  const parentId = this.nodeIdMap.get(parentPath);
  
  if (parentId) {
    return parentId; // Found visible parent
  }
  
  // Recursively look for visible parent
  return this.findVisibleParent(parentPath, projectId);
}
```

## 🎯 **What's Now Hidden from KG**

### **Directories Completely Hidden**
- ✅ `.venv`, `venv`, `env`, `virtualenv` (Python virtual environments)
- ✅ `node_modules`, `bower_components` (Package dependencies)
- ✅ `.git`, `.svn`, `.hg` (Version control)
- ✅ `build`, `dist`, `out`, `target` (Build outputs)
- ✅ `.vs`, `.vscode`, `.idea` (IDE directories)
- ✅ `__pycache__`, `.pytest_cache` (Python cache)
- ✅ `coverage`, `.coverage` (Test coverage)
- ✅ `.cache`, `.next`, `.nuxt` (Framework cache)
- ✅ `tmp`, `temp`, `logs` (Temporary directories)

### **Special Handling**
- ✅ `.github` directory **remains visible** (important for workflows)
- ✅ Files in hidden directories connect to nearest visible parent
- ✅ Complete structure discovery still happens (for performance benefits)

## 📊 **Before vs After**

### **Before (The Problem)**
```
Knowledge Graph showing:
├── src/                 ✅ Visible
├── tests/               ✅ Visible  
├── .venv/               ❌ Unwanted visibility
├── node_modules/        ❌ Unwanted visibility
├── __pycache__/         ❌ Unwanted visibility
└── package.json         ✅ Visible
```

### **After (Fixed)**
```
Knowledge Graph showing:
├── src/                 ✅ Visible
├── tests/               ✅ Visible
├── .github/             ✅ Visible (important)
└── package.json         ✅ Visible

Hidden from view:
- .venv/ (and all contents)
- node_modules/ (and all contents)  
- __pycache__/ (and all contents)
```

## 🎯 **Technical Implementation**

### **Two-Level Filtering**
1. **StructureProcessor**: Hides directory **nodes** from KG
2. **ParsingProcessor**: Skips **file parsing** in ignored directories

### **Performance Benefits Maintained**
- ✅ **Complete Discovery**: Still discovers all paths for performance optimization
- ✅ **Smart Filtering**: Skips expensive parsing operations
- ✅ **Clean Visualization**: Users see only relevant directories
- ✅ **Accurate Relationships**: Files connect to appropriate visible parents

### **Logging Enhanced**
```
StructureProcessor: Found 1,247 directories and 892 files
StructureProcessor: Hiding 156 ignored directories from KG
StructureProcessor: Created 983 nodes total (156 directories hidden)
```

## 🚀 **Result**

**Perfect Fix!** Now:

1. **✅ .venv is Hidden**: No longer appears in Knowledge Graph
2. **✅ Clean Visualization**: Only relevant directories shown
3. **✅ Performance Maintained**: Still skip expensive parsing operations
4. **✅ Accurate Structure**: Files properly connected to visible parents
5. **✅ Comprehensive Coverage**: All common ignored directories hidden

The directory filtering is now **working correctly** and `.venv` (along with other ignored directories) will no longer clutter the Knowledge Graph! 🎉

================
File: GITNEXUS_README.md
================
# 🔍 CodeNexus - Edge Knowledge Graph Creator with Graph RAG

**Transform any codebase into an interactive knowledge graph in your browser. No servers, no setup - just instant Graph RAG-powered code intelligence.**

CodeNexus is a client-side knowledge graph creator that runs entirely in your browser. Drop in a GitHub repo or ZIP file, and get an interactive knowledge graph with AI-powered chat interface. Perfect for code exploration, documentation, and understanding complex codebases through Graph RAG (Retrieval-Augmented Generation).

## ✨ Features

### 📊 **Code Analysis & Visualization**
- **GitHub Integration**: Analyze any public GitHub repository directly from URL
- **ZIP File Support**: Upload and analyze local code archives
- **Interactive Knowledge Graph**: Visualize code structure with Cytoscape.js
- **Multi-language Support**: Currently optimized for Python with extensible architecture
- **Smart Filtering**: Directory and file pattern filters to focus analysis scope
- **Performance Optimization**: Configurable file limits with confirmation dialogs for large repositories

### 🤖 **AI-Powered Chat Interface**
- **Multiple LLM Providers**: OpenAI, Anthropic (Claude), Google Gemini
- **ReAct Agent Pattern**: Uses proper LangChain ReAct implementation for reasoning
- **Tool-Augmented Responses**: Graph queries, code retrieval, file search
- **Context-Aware**: Maintains conversation history with configurable memory

### 🔧 **Advanced Processing Pipeline**
- **3-Pass Ingestion Strategy**:
  1. **Structure Analysis**: Project hierarchy and file organization
  2. **Code Parsing**: AST-based extraction using Tree-sitter
  3. **Call Resolution**: Function/method call relationship mapping
- **Web Worker Processing**: Non-blocking UI with progress tracking
- **Intelligent Caching**: AST and processing result optimization
- **Error Resilience**: Comprehensive error boundaries and recovery mechanisms

### 🎨 **Modern UI/UX**
- **Responsive Design**: Adaptive layout for different screen sizes
- **Real-time Progress**: Live updates during repository processing
- **Interactive Graph**: Node selection, zooming, panning
- **Split-Panel Layout**: Graph visualization + AI chat interface
- **Settings Management**: Persistent configuration for API keys and preferences
- **Export Functionality**: Download knowledge graphs as JSON with metadata
- **Performance Controls**: File limits, filtering, and optimization settings

### 🛡️ **Reliability & Performance**
- **Error Boundaries**: Graceful error handling with user-friendly recovery options
- **Performance Monitoring**: Real-time processing statistics and export size calculation
- **Memory Management**: Efficient handling of large repositories with configurable limits
- **Progress Tracking**: Detailed progress indicators with phase-specific messaging
- **Confirmation Dialogs**: Smart warnings for potentially expensive operations

## 🏗️ Architecture

### **Frontend Stack**
- **React 18** with TypeScript
- **Vite** for fast development and building
- **Cytoscape.js** for graph visualization
- **Custom CSS** with modern design patterns
- **Error Boundaries** for robust error handling

### **Processing Engine**
- **Deno Runtime** for TypeScript execution
- **Tree-sitter WASM** for syntax parsing
- **Web Workers** for background processing
- **Comlink** for worker communication

### **AI Integration**
- **LangChain.js** with proper ReAct agent implementation
- **Multiple LLM Support**: OpenAI, Anthropic, Gemini
- **Tool-based Architecture**: Graph queries, code retrieval, file search
- **Cypher Query Generation**: Natural language to graph queries

### **Services Layer**
```
src/
├── services/           # External API integrations
│   ├── github.ts      # GitHub REST API client
│   └── zip.ts         # ZIP file processing
├── core/              # Core processing logic
│   ├── graph/         # Knowledge graph types
│   ├── ingestion/     # 3-pass processing pipeline
│   └── tree-sitter/   # Syntax parsing infrastructure
├── ai/                # AI and RAG components
│   ├── llm-service.ts # Multi-provider LLM client
│   ├── cypher-generator.ts # NL to Cypher translation
│   ├── orchestrator.ts     # Custom ReAct implementation
│   └── langchain-orchestrator.ts # Standard LangChain ReAct
├── workers/           # Web Worker implementations
├── ui/                # React components and pages
│   ├── components/    # Reusable UI components
│   │   ├── ErrorBoundary.tsx # Error handling component
│   │   ├── graph/     # Graph visualization components
│   │   └── chat/      # Chat interface components
│   └── pages/         # Application pages
├── lib/               # Shared utilities
│   └── export.ts      # Graph export functionality
└── App.tsx            # Main application entry point
```

## 🚀 Getting Started

### Prerequisites
- **Node.js 18+** and **npm/yarn**
- **Deno 1.40+** for development
- **API Keys** for AI features (OpenAI, Anthropic, or Gemini)

### Installation

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd gitnexus
   ```

2. **Install dependencies**
   ```bash
   npm install
   ```

3. **Start development server**
   ```bash
   npm run dev
   ```

4. **Open in browser**
   ```
   http://localhost:5173
   ```

### Configuration

1. **GitHub Token (Optional)**
   - Increases rate limit from 60 to 5,000 requests/hour
   - Generate at: https://github.com/settings/tokens
   - Requires no special permissions for public repos

2. **AI API Keys**
   - **OpenAI**: Get from https://platform.openai.com/api-keys
   - **Anthropic**: Get from https://console.anthropic.com/
   - **Gemini**: Get from https://makersuite.google.com/app/apikey

3. **Performance Settings**
   - **File Limit**: Configure maximum files to process (default: 500)
   - **Directory Filters**: Focus on specific directories (e.g., "src", "lib")
   - **File Patterns**: Filter by file types (e.g., "*.py", "*.js", "*.ts")

## 💡 Usage

### Analyzing a Repository

1. **GitHub Repository**
   ```
   1. Enter GitHub URL: https://github.com/owner/repo
   2. Optional: Set directory/file filters to focus analysis
   3. Click "Analyze"
   4. For large repos: Confirm processing or adjust filters
   5. Wait for processing (structure → parsing → call resolution)
   6. Explore the interactive graph
   ```

2. **ZIP File Upload**
   ```
   1. Click "Choose File" and select a .zip file
   2. Optional: Configure filters before processing
   3. Click "Analyze"
   4. Processing will extract and analyze text files
   5. Explore results in the graph visualization
   ```

### Performance Optimization

1. **Directory Filtering**
   ```
   - Enter directory names: "src", "lib", "components"
   - Focuses analysis on specific parts of the codebase
   - Reduces processing time and memory usage
   ```

2. **File Pattern Filtering**
   ```
   - Use patterns: "*.py", "*.js", "*.ts"
   - Supports wildcards: "test*.py", "*util*"
   - Comma-separated: "*.py,*.js,*.ts"
   ```

3. **File Limits**
   ```
   - Default limit: 500 files
   - Configurable in settings (50-2000 files)
   - Large repositories show confirmation dialog
   - Automatic truncation to limit if confirmed
   ```

### Using the AI Chat

1. **Configure API Key**
   ```
   1. Click the ⚙️ settings button
   2. Choose your preferred LLM provider
   3. Enter your API key
   4. Select model (e.g., gpt-4o-mini, claude-3-haiku)
   ```

2. **Ask Questions**
   ```
   - "What functions are in the main.py file?"
   - "Show me all classes that inherit from BaseClass"
   - "How does the authentication system work?"
   - "Find all functions that call the database"
   ```

### Exporting Data

1. **Export Knowledge Graph**
   ```
   1. Click the 📥 Export button after processing
   2. Downloads JSON file with graph data and metadata
   3. Includes processing statistics and timestamps
   4. File size shown in UI before export
   ```

2. **Export Format**
   ```json
   {
     "metadata": {
       "exportedAt": "2024-01-01T12:00:00.000Z",
       "version": "1.0.0",
       "nodeCount": 150,
       "relationshipCount": 200,
       "fileCount": 25,
       "processingDuration": 5000
     },
     "graph": {
       "nodes": [...],
       "relationships": [...]
     },
     "fileContents": {...}
   }
   ```

### Graph Interaction

- **Node Selection**: Click any node to highlight and view details
- **Zoom & Pan**: Mouse wheel to zoom, drag to pan
- **Node Types**: Different colors/shapes for files, functions, classes, etc.
- **Relationships**: Arrows show CONTAINS, CALLS, INHERITS relationships

## 🔧 Development

### Project Structure
```
GitNexus/
├── src/
│   ├── services/          # External integrations
│   ├── core/             # Processing pipeline
│   ├── ai/               # AI and RAG systems
│   ├── workers/          # Web Workers
│   ├── ui/               # React components
│   │   ├── components/   # Reusable components
│   │   │   ├── ErrorBoundary.tsx
│   │   │   ├── graph/    # Graph components
│   │   │   └── chat/     # Chat components
│   │   └── pages/        # Application pages
│   ├── lib/              # Utilities
│   │   └── export.ts     # Export functionality
│   └── App.tsx           # Main application
├── public/
│   └── wasm/             # Tree-sitter WASM files
├── package.json
├── vite.config.ts
└── tsconfig.json
```

### Key Components

#### **Error Handling**
```typescript
// ErrorBoundary component with recovery options
<ErrorBoundary
  onError={(error, errorInfo) => {
    console.error('Application error:', error);
  }}
>
  <App />
</ErrorBoundary>
```

#### **Performance Optimization**
```typescript
// File filtering and limits
const filterFiles = (files: any[]) => {
  return files
    .filter(file => matchesDirectoryFilter(file))
    .filter(file => matchesPatternFilter(file))
    .slice(0, maxFiles);
};
```

#### **Export Functionality**
```typescript
// Export with metadata
exportAndDownloadGraph(graph, {
  projectName: 'my-project',
  includeMetadata: true,
  prettyPrint: true
}, fileContents, { duration: 5000 });
```

#### **Processing Pipeline**
```typescript
// 3-pass ingestion strategy with progress tracking
const pipeline = new GraphPipeline();
const result = await pipeline.run({
  projectRoot: '/',
  projectName: 'MyProject',
  filePaths: ['src/main.py', 'src/utils.py'],
  fileContents: new Map([
    ['src/main.py', 'def main(): pass'],
    ['src/utils.py', 'def helper(): pass']
  ])
});
```

#### **AI Integration**
```typescript
// LangChain ReAct agent with error handling
const orchestrator = new LangChainRAGOrchestrator(llmService, cypherGenerator);
await orchestrator.setContext({ graph, fileContents }, llmConfig);
const response = await orchestrator.answerQuestion("How does auth work?");
```

#### **Graph Visualization**
```typescript
// Interactive graph component with error boundaries
<ErrorBoundary>
  <GraphExplorer
    graph={knowledgeGraph}
    onNodeSelect={(nodeId) => setSelectedNode(nodeId)}
  />
</ErrorBoundary>
```

### Adding New Features

1. **New Language Support**
   ```typescript
   // Add parser in core/tree-sitter/
   export const loadJavaScriptParser = async () => {
     // Load JS Tree-sitter grammar
   };
   ```

2. **Custom AI Tools**
   ```typescript
   // Add tools in ai/langchain-orchestrator.ts
   const customTool = tool(
     async (input: { query: string }) => {
       // Tool implementation
     },
     {
       name: "custom_tool",
       description: "Custom functionality",
       schema: z.object({ query: z.string() })
     }
   );
   ```

3. **Export Formats**
   ```typescript
   // Add new export formats in lib/export.ts
   export function exportToCSV(graph: KnowledgeGraph): string {
     // CSV export implementation
   }
   ```

## 🧪 Testing & Quality Assurance

### Error Handling
- **Error Boundaries**: Catch and display JavaScript errors gracefully
- **User Recovery**: Allow users to reset component state after errors
- **Detailed Logging**: Console logging for debugging and error reporting
- **Fallback UI**: User-friendly error messages with recovery options

### Performance Testing
1. **Large Repository Handling**
   - Test with repositories containing 1000+ files
   - Verify confirmation dialogs for file limits
   - Monitor memory usage during processing
   - Test filtering effectiveness

2. **UI Responsiveness**
   - Ensure non-blocking processing with Web Workers
   - Verify progress indicators update correctly
   - Test error recovery mechanisms
   - Validate export functionality with large graphs

3. **Error Scenarios**
   - Network failures during GitHub API calls
   - Corrupted ZIP files
   - Invalid API keys
   - Memory exhaustion scenarios

### Manual Testing Checklist
- [ ] GitHub repository analysis with various sizes
- [ ] ZIP file upload and extraction
- [ ] Directory and file pattern filtering
- [ ] Large repository confirmation dialog
- [ ] Export functionality with different options
- [ ] Error boundary activation and recovery
- [ ] API key validation for all providers
- [ ] Settings persistence across sessions
- [ ] Graph visualization interactions
- [ ] Chat interface with different LLM providers

## 🚀 Deployment

### Production Build
```bash
npm run build
npm run preview
```

### Environment Variables
```env
# Optional: Pre-configure API keys
VITE_OPENAI_API_KEY=sk-...
VITE_ANTHROPIC_API_KEY=sk-ant-...
VITE_GEMINI_API_KEY=...

# Performance settings
VITE_DEFAULT_MAX_FILES=500
VITE_ENABLE_DEBUG_LOGGING=false
```

### Docker Deployment
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "run", "preview", "--", "--host", "0.0.0.0"]
```

### Performance Monitoring
```javascript
// Add performance monitoring
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.entryType === 'measure') {
      console.log(`${entry.name}: ${entry.duration}ms`);
    }
  }
});
observer.observe({ entryTypes: ['measure'] });
```

## 🔒 Security & Privacy

- **Client-Side Processing**: All analysis happens in your browser
- **API Keys**: Stored locally, never transmitted to our servers
- **GitHub Access**: Uses public API, respects repository permissions
- **Data Privacy**: No code or analysis results are stored remotely
- **Error Logging**: Sensitive data excluded from error reports
- **Export Security**: User-controlled data export with no server interaction

## 🤝 Contributing

### Development Setup
1. Fork the repository
2. Create feature branch: `git checkout -b feature/amazing-feature`
3. Make changes and test thoroughly
4. Run the testing checklist above
5. Commit: `git commit -m 'Add amazing feature'`
6. Push: `git push origin feature/amazing-feature`
7. Open a Pull Request

### Code Style
- **TypeScript**: Strict mode enabled
- **ESLint**: Follow configured rules
- **Prettier**: Auto-formatting
- **Comments**: Minimal, only when necessary
- **Error Handling**: Comprehensive error boundaries and recovery
- **Performance**: Consider memory usage and processing time

### Testing Guidelines
- Test error scenarios and edge cases
- Verify performance with large datasets
- Ensure graceful degradation
- Test all export functionality
- Validate error boundary behavior

## 📚 Technical Details

### Knowledge Graph Schema
```typescript
interface KnowledgeGraph {
  nodes: GraphNode[];        // Code entities
  relationships: GraphRelationship[]; // Connections
}

// Node types: Project, Folder, File, Module, Class, Function, Method, Variable
// Relationship types: CONTAINS, CALLS, INHERITS, OVERRIDES, IMPORTS
```

### Export Format
```typescript
interface ExportedGraph {
  metadata: {
    exportedAt: string;
    version: string;
    nodeCount: number;
    relationshipCount: number;
    fileCount?: number;
    processingDuration?: number;
  };
  graph: KnowledgeGraph;
  fileContents?: Record<string, string>;
}
```

### Error Boundary Implementation
- **Component-Level**: Individual components wrapped for isolation
- **Application-Level**: Top-level boundary for catastrophic failures
- **Recovery Options**: Reset state, reload page, or continue with fallback
- **Error Reporting**: Detailed technical information for developers

### Performance Optimizations
- **Web Workers**: Non-blocking processing
- **AST Caching**: Reuse parsed syntax trees
- **Progressive Loading**: Stream results as available
- **Memory Management**: Efficient data structures
- **File Filtering**: Reduce processing scope
- **Confirmation Dialogs**: Prevent accidental expensive operations

### ReAct Agent Implementation
- **Standard LangChain**: Uses `createReactAgent` from `@langchain/langgraph/prebuilt`
- **Custom Implementation**: Manual ReAct loop for educational purposes
- **Tools**: Graph queries, code retrieval, file search
- **Memory**: Conversation persistence with thread management
- **Error Recovery**: Graceful handling of API failures

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- **Tree-sitter**: Syntax parsing infrastructure
- **LangChain.js**: AI agent framework
- **Cytoscape.js**: Graph visualization
- **React**: UI framework with error boundaries
- **Vite**: Build tool and dev server

---

**CodeNexus** - Edge Knowledge Graph Creator with instant Graph RAG. Zero setup, maximum insight. 🚀

*Browser-native code intelligence that runs anywhere, anytime - no servers required.*

================
File: gitnexus.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-09T23:45:24.964Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
CONVERSION_SUMMARY.md
eslint.config.js
GITNEXUS_README.md
index.html
package.json
project_guide.md
public/vite.svg
README.md
src/ai/cypher-generator.ts
src/ai/index.ts
src/ai/langchain-orchestrator.ts
src/ai/llm-service.ts
src/ai/orchestrator.ts
src/App.css
src/App.tsx
src/assets/react.svg
src/core/graph/query.ts
src/core/graph/types.ts
src/core/ingestion/call-processor.ts
src/core/ingestion/parsing-processor.ts
src/core/ingestion/pipeline.ts
src/core/ingestion/structure-processor.ts
src/core/tree-sitter/parser-loader.ts
src/index.css
src/lib/export.ts
src/lib/polyfills.ts
src/lib/preload.ts
src/lib/utils.ts
src/lib/workerUtils.ts
src/main.tsx
src/services/github.ts
src/services/ingestion.service.ts
src/services/zip.ts
src/ui/components/chat/ChatInterface.tsx
src/ui/components/chat/CodeAssistant.tsx
src/ui/components/chat/index.ts
src/ui/components/ErrorBoundary.tsx
src/ui/components/graph/GraphExplorer.tsx
src/ui/components/graph/index.ts
src/ui/components/graph/SourceViewer.tsx
src/ui/components/graph/Visualization.tsx
src/ui/components/index.ts
src/ui/index.ts
src/ui/pages/HomePage.tsx
src/ui/pages/index.ts
src/vite-env.d.ts
src/workers/ingestion.worker.ts
tsconfig.app.json
tsconfig.app.tsbuildinfo
tsconfig.json
tsconfig.node.json
tsconfig.node.tsbuildinfo
vite.config.ts

================================================================
Files
================================================================

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: CONVERSION_SUMMARY.md
================
# Deno to Node.js Conversion Summary

## Overview
Successfully converted the GitNexus repository from Deno to Node.js while maintaining all functionality.

## Changes Made

### 1. Configuration Files
- **Removed**: `deno.json`, `deno.lock`
- **Updated**: `package.json` with all dependencies from `deno.json`
  - Added all npm dependencies: jszip, axios, cytoscape, web-tree-sitter, langchain packages, etc.
  - Updated version to 1.0.0
  - Kept existing build scripts (Vite-based)

### 2. Import Statements
- **Removed**: All `npm:` prefixes from import statements
- **Removed**: All `@ts-expect-error` comments related to npm: imports
- **Files affected**: 13+ TypeScript files across the codebase

### 3. Dependencies Successfully Converted
- `react` & `react-dom` (already present)
- `jszip` for ZIP file processing
- `axios` for HTTP requests
- `cytoscape` & `cytoscape-dagre` for graph visualization
- `web-tree-sitter` for code parsing
- `comlink` for web workers
- `@langchain/*` packages for AI functionality
- `zod` for schema validation

### 4. Build System
- **Unchanged**: Vite configuration remains the same
- **Unchanged**: TypeScript configuration
- **Working**: Development server starts successfully on port 5173
- **Note**: Some TypeScript errors remain but don't prevent the dev server from running

## Current Status
✅ **Development server running** - The application starts and runs on Node.js
✅ **All dependencies installed** - npm install completed successfully  
✅ **Import statements fixed** - All Deno-style imports converted to Node.js style
⚠️ **TypeScript errors** - Some type errors remain but don't block functionality

## Next Steps (Optional)
The conversion is complete and functional, but to achieve a clean build:
1. Fix TypeScript errors in langchain imports
2. Update type definitions for cytoscape
3. Fix unused variable warnings
4. Address JSZip type compatibility issues

## Files Modified
- `package.json` - Added all dependencies
- 13+ TypeScript files - Removed npm: prefixes and Deno comments
- Removed `deno.json` and `deno.lock`

The repository is now fully converted to Node.js and ready for development!

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: GITNEXUS_README.md
================
# 🔍 CodeNexus - Edge Knowledge Graph Creator with Graph RAG

**Transform any codebase into an interactive knowledge graph in your browser. No servers, no setup - just instant Graph RAG-powered code intelligence.**

CodeNexus is a client-side knowledge graph creator that runs entirely in your browser. Drop in a GitHub repo or ZIP file, and get an interactive knowledge graph with AI-powered chat interface. Perfect for code exploration, documentation, and understanding complex codebases through Graph RAG (Retrieval-Augmented Generation).

## ✨ Features

### 📊 **Code Analysis & Visualization**
- **GitHub Integration**: Analyze any public GitHub repository directly from URL
- **ZIP File Support**: Upload and analyze local code archives
- **Interactive Knowledge Graph**: Visualize code structure with Cytoscape.js
- **Multi-language Support**: Currently optimized for Python with extensible architecture
- **Smart Filtering**: Directory and file pattern filters to focus analysis scope
- **Performance Optimization**: Configurable file limits with confirmation dialogs for large repositories

### 🤖 **AI-Powered Chat Interface**
- **Multiple LLM Providers**: OpenAI, Anthropic (Claude), Google Gemini
- **ReAct Agent Pattern**: Uses proper LangChain ReAct implementation for reasoning
- **Tool-Augmented Responses**: Graph queries, code retrieval, file search
- **Context-Aware**: Maintains conversation history with configurable memory

### 🔧 **Advanced Processing Pipeline**
- **3-Pass Ingestion Strategy**:
  1. **Structure Analysis**: Project hierarchy and file organization
  2. **Code Parsing**: AST-based extraction using Tree-sitter
  3. **Call Resolution**: Function/method call relationship mapping
- **Web Worker Processing**: Non-blocking UI with progress tracking
- **Intelligent Caching**: AST and processing result optimization
- **Error Resilience**: Comprehensive error boundaries and recovery mechanisms

### 🎨 **Modern UI/UX**
- **Responsive Design**: Adaptive layout for different screen sizes
- **Real-time Progress**: Live updates during repository processing
- **Interactive Graph**: Node selection, zooming, panning
- **Split-Panel Layout**: Graph visualization + AI chat interface
- **Settings Management**: Persistent configuration for API keys and preferences
- **Export Functionality**: Download knowledge graphs as JSON with metadata
- **Performance Controls**: File limits, filtering, and optimization settings

### 🛡️ **Reliability & Performance**
- **Error Boundaries**: Graceful error handling with user-friendly recovery options
- **Performance Monitoring**: Real-time processing statistics and export size calculation
- **Memory Management**: Efficient handling of large repositories with configurable limits
- **Progress Tracking**: Detailed progress indicators with phase-specific messaging
- **Confirmation Dialogs**: Smart warnings for potentially expensive operations

## 🏗️ Architecture

### **Frontend Stack**
- **React 18** with TypeScript
- **Vite** for fast development and building
- **Cytoscape.js** for graph visualization
- **Custom CSS** with modern design patterns
- **Error Boundaries** for robust error handling

### **Processing Engine**
- **Deno Runtime** for TypeScript execution
- **Tree-sitter WASM** for syntax parsing
- **Web Workers** for background processing
- **Comlink** for worker communication

### **AI Integration**
- **LangChain.js** with proper ReAct agent implementation
- **Multiple LLM Support**: OpenAI, Anthropic, Gemini
- **Tool-based Architecture**: Graph queries, code retrieval, file search
- **Cypher Query Generation**: Natural language to graph queries

### **Services Layer**
```
src/
├── services/           # External API integrations
│   ├── github.ts      # GitHub REST API client
│   └── zip.ts         # ZIP file processing
├── core/              # Core processing logic
│   ├── graph/         # Knowledge graph types
│   ├── ingestion/     # 3-pass processing pipeline
│   └── tree-sitter/   # Syntax parsing infrastructure
├── ai/                # AI and RAG components
│   ├── llm-service.ts # Multi-provider LLM client
│   ├── cypher-generator.ts # NL to Cypher translation
│   ├── orchestrator.ts     # Custom ReAct implementation
│   └── langchain-orchestrator.ts # Standard LangChain ReAct
├── workers/           # Web Worker implementations
├── ui/                # React components and pages
│   ├── components/    # Reusable UI components
│   │   ├── ErrorBoundary.tsx # Error handling component
│   │   ├── graph/     # Graph visualization components
│   │   └── chat/      # Chat interface components
│   └── pages/         # Application pages
├── lib/               # Shared utilities
│   └── export.ts      # Graph export functionality
└── App.tsx            # Main application entry point
```

## 🚀 Getting Started

### Prerequisites
- **Node.js 18+** and **npm/yarn**
- **Deno 1.40+** for development
- **API Keys** for AI features (OpenAI, Anthropic, or Gemini)

### Installation

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd gitnexus
   ```

2. **Install dependencies**
   ```bash
   npm install
   ```

3. **Start development server**
   ```bash
   npm run dev
   ```

4. **Open in browser**
   ```
   http://localhost:5173
   ```

### Configuration

1. **GitHub Token (Optional)**
   - Increases rate limit from 60 to 5,000 requests/hour
   - Generate at: https://github.com/settings/tokens
   - Requires no special permissions for public repos

2. **AI API Keys**
   - **OpenAI**: Get from https://platform.openai.com/api-keys
   - **Anthropic**: Get from https://console.anthropic.com/
   - **Gemini**: Get from https://makersuite.google.com/app/apikey

3. **Performance Settings**
   - **File Limit**: Configure maximum files to process (default: 500)
   - **Directory Filters**: Focus on specific directories (e.g., "src", "lib")
   - **File Patterns**: Filter by file types (e.g., "*.py", "*.js", "*.ts")

## 💡 Usage

### Analyzing a Repository

1. **GitHub Repository**
   ```
   1. Enter GitHub URL: https://github.com/owner/repo
   2. Optional: Set directory/file filters to focus analysis
   3. Click "Analyze"
   4. For large repos: Confirm processing or adjust filters
   5. Wait for processing (structure → parsing → call resolution)
   6. Explore the interactive graph
   ```

2. **ZIP File Upload**
   ```
   1. Click "Choose File" and select a .zip file
   2. Optional: Configure filters before processing
   3. Click "Analyze"
   4. Processing will extract and analyze text files
   5. Explore results in the graph visualization
   ```

### Performance Optimization

1. **Directory Filtering**
   ```
   - Enter directory names: "src", "lib", "components"
   - Focuses analysis on specific parts of the codebase
   - Reduces processing time and memory usage
   ```

2. **File Pattern Filtering**
   ```
   - Use patterns: "*.py", "*.js", "*.ts"
   - Supports wildcards: "test*.py", "*util*"
   - Comma-separated: "*.py,*.js,*.ts"
   ```

3. **File Limits**
   ```
   - Default limit: 500 files
   - Configurable in settings (50-2000 files)
   - Large repositories show confirmation dialog
   - Automatic truncation to limit if confirmed
   ```

### Using the AI Chat

1. **Configure API Key**
   ```
   1. Click the ⚙️ settings button
   2. Choose your preferred LLM provider
   3. Enter your API key
   4. Select model (e.g., gpt-4o-mini, claude-3-haiku)
   ```

2. **Ask Questions**
   ```
   - "What functions are in the main.py file?"
   - "Show me all classes that inherit from BaseClass"
   - "How does the authentication system work?"
   - "Find all functions that call the database"
   ```

### Exporting Data

1. **Export Knowledge Graph**
   ```
   1. Click the 📥 Export button after processing
   2. Downloads JSON file with graph data and metadata
   3. Includes processing statistics and timestamps
   4. File size shown in UI before export
   ```

2. **Export Format**
   ```json
   {
     "metadata": {
       "exportedAt": "2024-01-01T12:00:00.000Z",
       "version": "1.0.0",
       "nodeCount": 150,
       "relationshipCount": 200,
       "fileCount": 25,
       "processingDuration": 5000
     },
     "graph": {
       "nodes": [...],
       "relationships": [...]
     },
     "fileContents": {...}
   }
   ```

### Graph Interaction

- **Node Selection**: Click any node to highlight and view details
- **Zoom & Pan**: Mouse wheel to zoom, drag to pan
- **Node Types**: Different colors/shapes for files, functions, classes, etc.
- **Relationships**: Arrows show CONTAINS, CALLS, INHERITS relationships

## 🔧 Development

### Project Structure
```
GitNexus/
├── src/
│   ├── services/          # External integrations
│   ├── core/             # Processing pipeline
│   ├── ai/               # AI and RAG systems
│   ├── workers/          # Web Workers
│   ├── ui/               # React components
│   │   ├── components/   # Reusable components
│   │   │   ├── ErrorBoundary.tsx
│   │   │   ├── graph/    # Graph components
│   │   │   └── chat/     # Chat components
│   │   └── pages/        # Application pages
│   ├── lib/              # Utilities
│   │   └── export.ts     # Export functionality
│   └── App.tsx           # Main application
├── public/
│   └── wasm/             # Tree-sitter WASM files
├── package.json
├── vite.config.ts
└── tsconfig.json
```

### Key Components

#### **Error Handling**
```typescript
// ErrorBoundary component with recovery options
<ErrorBoundary
  onError={(error, errorInfo) => {
    console.error('Application error:', error);
  }}
>
  <App />
</ErrorBoundary>
```

#### **Performance Optimization**
```typescript
// File filtering and limits
const filterFiles = (files: any[]) => {
  return files
    .filter(file => matchesDirectoryFilter(file))
    .filter(file => matchesPatternFilter(file))
    .slice(0, maxFiles);
};
```

#### **Export Functionality**
```typescript
// Export with metadata
exportAndDownloadGraph(graph, {
  projectName: 'my-project',
  includeMetadata: true,
  prettyPrint: true
}, fileContents, { duration: 5000 });
```

#### **Processing Pipeline**
```typescript
// 3-pass ingestion strategy with progress tracking
const pipeline = new GraphPipeline();
const result = await pipeline.run({
  projectRoot: '/',
  projectName: 'MyProject',
  filePaths: ['src/main.py', 'src/utils.py'],
  fileContents: new Map([
    ['src/main.py', 'def main(): pass'],
    ['src/utils.py', 'def helper(): pass']
  ])
});
```

#### **AI Integration**
```typescript
// LangChain ReAct agent with error handling
const orchestrator = new LangChainRAGOrchestrator(llmService, cypherGenerator);
await orchestrator.setContext({ graph, fileContents }, llmConfig);
const response = await orchestrator.answerQuestion("How does auth work?");
```

#### **Graph Visualization**
```typescript
// Interactive graph component with error boundaries
<ErrorBoundary>
  <GraphExplorer
    graph={knowledgeGraph}
    onNodeSelect={(nodeId) => setSelectedNode(nodeId)}
  />
</ErrorBoundary>
```

### Adding New Features

1. **New Language Support**
   ```typescript
   // Add parser in core/tree-sitter/
   export const loadJavaScriptParser = async () => {
     // Load JS Tree-sitter grammar
   };
   ```

2. **Custom AI Tools**
   ```typescript
   // Add tools in ai/langchain-orchestrator.ts
   const customTool = tool(
     async (input: { query: string }) => {
       // Tool implementation
     },
     {
       name: "custom_tool",
       description: "Custom functionality",
       schema: z.object({ query: z.string() })
     }
   );
   ```

3. **Export Formats**
   ```typescript
   // Add new export formats in lib/export.ts
   export function exportToCSV(graph: KnowledgeGraph): string {
     // CSV export implementation
   }
   ```

## 🧪 Testing & Quality Assurance

### Error Handling
- **Error Boundaries**: Catch and display JavaScript errors gracefully
- **User Recovery**: Allow users to reset component state after errors
- **Detailed Logging**: Console logging for debugging and error reporting
- **Fallback UI**: User-friendly error messages with recovery options

### Performance Testing
1. **Large Repository Handling**
   - Test with repositories containing 1000+ files
   - Verify confirmation dialogs for file limits
   - Monitor memory usage during processing
   - Test filtering effectiveness

2. **UI Responsiveness**
   - Ensure non-blocking processing with Web Workers
   - Verify progress indicators update correctly
   - Test error recovery mechanisms
   - Validate export functionality with large graphs

3. **Error Scenarios**
   - Network failures during GitHub API calls
   - Corrupted ZIP files
   - Invalid API keys
   - Memory exhaustion scenarios

### Manual Testing Checklist
- [ ] GitHub repository analysis with various sizes
- [ ] ZIP file upload and extraction
- [ ] Directory and file pattern filtering
- [ ] Large repository confirmation dialog
- [ ] Export functionality with different options
- [ ] Error boundary activation and recovery
- [ ] API key validation for all providers
- [ ] Settings persistence across sessions
- [ ] Graph visualization interactions
- [ ] Chat interface with different LLM providers

## 🚀 Deployment

### Production Build
```bash
npm run build
npm run preview
```

### Environment Variables
```env
# Optional: Pre-configure API keys
VITE_OPENAI_API_KEY=sk-...
VITE_ANTHROPIC_API_KEY=sk-ant-...
VITE_GEMINI_API_KEY=...

# Performance settings
VITE_DEFAULT_MAX_FILES=500
VITE_ENABLE_DEBUG_LOGGING=false
```

### Docker Deployment
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build
EXPOSE 3000
CMD ["npm", "run", "preview", "--", "--host", "0.0.0.0"]
```

### Performance Monitoring
```javascript
// Add performance monitoring
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.entryType === 'measure') {
      console.log(`${entry.name}: ${entry.duration}ms`);
    }
  }
});
observer.observe({ entryTypes: ['measure'] });
```

## 🔒 Security & Privacy

- **Client-Side Processing**: All analysis happens in your browser
- **API Keys**: Stored locally, never transmitted to our servers
- **GitHub Access**: Uses public API, respects repository permissions
- **Data Privacy**: No code or analysis results are stored remotely
- **Error Logging**: Sensitive data excluded from error reports
- **Export Security**: User-controlled data export with no server interaction

## 🤝 Contributing

### Development Setup
1. Fork the repository
2. Create feature branch: `git checkout -b feature/amazing-feature`
3. Make changes and test thoroughly
4. Run the testing checklist above
5. Commit: `git commit -m 'Add amazing feature'`
6. Push: `git push origin feature/amazing-feature`
7. Open a Pull Request

### Code Style
- **TypeScript**: Strict mode enabled
- **ESLint**: Follow configured rules
- **Prettier**: Auto-formatting
- **Comments**: Minimal, only when necessary
- **Error Handling**: Comprehensive error boundaries and recovery
- **Performance**: Consider memory usage and processing time

### Testing Guidelines
- Test error scenarios and edge cases
- Verify performance with large datasets
- Ensure graceful degradation
- Test all export functionality
- Validate error boundary behavior

## 📚 Technical Details

### Knowledge Graph Schema
```typescript
interface KnowledgeGraph {
  nodes: GraphNode[];        // Code entities
  relationships: GraphRelationship[]; // Connections
}

// Node types: Project, Folder, File, Module, Class, Function, Method, Variable
// Relationship types: CONTAINS, CALLS, INHERITS, OVERRIDES, IMPORTS
```

### Export Format
```typescript
interface ExportedGraph {
  metadata: {
    exportedAt: string;
    version: string;
    nodeCount: number;
    relationshipCount: number;
    fileCount?: number;
    processingDuration?: number;
  };
  graph: KnowledgeGraph;
  fileContents?: Record<string, string>;
}
```

### Error Boundary Implementation
- **Component-Level**: Individual components wrapped for isolation
- **Application-Level**: Top-level boundary for catastrophic failures
- **Recovery Options**: Reset state, reload page, or continue with fallback
- **Error Reporting**: Detailed technical information for developers

### Performance Optimizations
- **Web Workers**: Non-blocking processing
- **AST Caching**: Reuse parsed syntax trees
- **Progressive Loading**: Stream results as available
- **Memory Management**: Efficient data structures
- **File Filtering**: Reduce processing scope
- **Confirmation Dialogs**: Prevent accidental expensive operations

### ReAct Agent Implementation
- **Standard LangChain**: Uses `createReactAgent` from `@langchain/langgraph/prebuilt`
- **Custom Implementation**: Manual ReAct loop for educational purposes
- **Tools**: Graph queries, code retrieval, file search
- **Memory**: Conversation persistence with thread management
- **Error Recovery**: Graceful handling of API failures

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- **Tree-sitter**: Syntax parsing infrastructure
- **LangChain.js**: AI agent framework
- **Cytoscape.js**: Graph visualization
- **React**: UI framework with error boundaries
- **Vite**: Build tool and dev server

---

**CodeNexus** - Edge Knowledge Graph Creator with instant Graph RAG. Zero setup, maximum insight. 🚀

*Browser-native code intelligence that runs anywhere, anytime - no servers required.*

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitNexus - Code Knowledge Graph Explorer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      
      #root {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "gitnexus",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@langchain/anthropic": "^0.1.21",
    "@langchain/core": "^0.3.66",
    "@langchain/google-genai": "^0.2.16",
    "@langchain/langgraph": "^0.0.26",
    "@langchain/openai": "^0.0.28",
    "@types/d3": "^7.4.3",
    "axios": "^1.6.0",
    "comlink": "^4.4.1",
    "d3": "^7.9.0",
    "jszip": "^3.10.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "uuid": "^11.1.0",
    "web-tree-sitter": "^0.20.8",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/js": "^9.11.1",
    "@types/react": "^18.3.10",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.2",
    "eslint": "^9.11.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.12",
    "globals": "^15.9.0",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.7.0",
    "vite": "^5.4.8"
  }
}

================
File: project_guide.md
================
# GitNexus: Edge-Based Code Knowledge Graph Generator for Deno - Step-by-Step Implementation Guide

This guide will walk you through building a fully edge-based code knowledge graph generator from scratch using Deno. I'll explain each concept before showing the implementation, so you understand **why** we're doing something, not just **how** to do it.

## Phase 1: Project Setup & Core Infrastructure

### Step 1: Project Structure and Tooling Setup

**Why this matters:** Before writing any code, we need to set up our development environment properly. A well-structured project makes it easier to add features later and keeps everything organized.

**Key concepts:**

- We're using Vite (a modern build tool) with React and TypeScript
- We need special configuration for WebAssembly (WASM) files
- A clear directory structure helps us scale to multiple languages later

**Implementation Steps:**

1. **Create the base project:**

```bash
# Create project root
mkdir GitNexus
cd GitNexus

# Initialize Vite project with React and TypeScript
npm create vite@latest . -- --template react-ts

# Initialize Deno project
deno init
```

2. **Create the application directory structure:**

```bash
# Create directories for our core components
mkdir -p src/{core,core/tree-sitter,core/graph,core/ingestion,services,ai,ai/agents,ai/prompts,ui,ui/components,ui/components/graph,ui/components/chat,ui/hooks,workers,lib,config,store}
```

**Why this structure?**

- `core/`: Contains the engine that builds the knowledge graph
- `services/`: Handles external interactions (GitHub API, ZIP processing)
- `ai/`: Contains the RAG and chat functionality
- `ui/`: All user interface components
- `workers/`: Web Workers for heavy processing (keeps UI responsive)
- `lib/`: Utility functions used throughout the app

### Step 2: Configure Build Tools for WASM

**Why this matters:** WebAssembly (WASM) is how we'll run the Tree-sitter parsers in the browser. We need special configuration to handle these binary files correctly.

**Key concepts:**

- WASM files are binary files that run at near-native speed in browsers
- Vite needs special configuration to handle them properly
- We want to avoid inlining large WASM files in our JavaScript bundles

**Implementation:**

1. **Update `vite.config.ts`:**

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
export default defineConfig({
  plugins: [react()],
  worker: {
    format: 'es'
  },
  assetsInclude: ['**/*.wasm'],
  build: {
    target: 'esnext',
    assetsInlineLimit: 0 // Don't inline WASM files
  }
})
```

**What this does:**

- `assetsInclude: ['**/*.wasm']` tells Vite to treat WASM files as assets
- `assetsInlineLimit: 0` ensures WASM files aren't inlined into JavaScript (they're too large)
- `worker: { format: 'es' }` configures Web Workers to use ES modules

2. **Configure TypeScript** with a `tsconfig.json` that has strict settings for better code quality.

**Why strict settings?** They help catch errors early and make the code more maintainable as the project grows.

### Step 3: Set Up WASM Parser Infrastructure

**Why this matters:** Tree-sitter is the engine that parses code into ASTs (Abstract Syntax Trees). We need to get these parsers working in the browser via WASM.

**Key concepts:**

- Tree-sitter parsers for different languages are written in C
- We compile them to WASM so they can run in browsers
- We need to load these parsers on demand

**Implementation:**

1. **Create a public directory for WASM files:**

```bash
mkdir -p public/wasm/python
```

2. **Download the Tree-sitter Python parser:**
   - Get `tree-sitter-python.wasm` from [tree-sitter-python releases](https://github.com/tree-sitter/tree-sitter-python/releases)
   - Place it in `public/wasm/python/`

**Why host WASM files separately?** Browsers can't access the user's file system directly for security reasons. We need to serve the WASM files from a URL.

3. **Create a loader for Tree-sitter parsers:**

```typescript
import WebTreeSitter from 'web-tree-sitter';
let parserInstance: WebTreeSitter | null = null;
const parserCache = new Map<string, WebTreeSitter.Language>();

export async function initTreeSitter() {
  if (parserInstance) return parserInstance;
  parserInstance = await WebTreeSitter.init();
  return parserInstance;
}

export async function loadPythonParser(): Promise<WebTreeSitter.Language> {
  if (parserCache.has('python')) {
    return parserCache.get('python')!;
  }
  const Parser = await initTreeSitter();
  const pythonLang = await Parser.Language.load(
    '/wasm/python/tree-sitter-python.wasm'
  );
  parserCache.set('python', pythonLang);
  return pythonLang;
}
```

**How this works:**

1. `initTreeSitter()` initializes the WebAssembly module once
2. `loadPythonParser()` loads the Python parser from the WASM file
3. We cache parsers to avoid reloading them multiple times

**Why cache parsers?** Loading WASM files is relatively slow, so we want to do it once and reuse the parsers.

## Phase 2: Code Acquisition Module

### Step 4: Implement GitHub API Integration

**Why this matters:** Users will want to analyze public GitHub repositories, so we need a way to fetch code from GitHub.

**Key concepts:**

- GitHub has a REST API for accessing repository contents
- We need to handle rate limits (GitHub limits how many requests you can make)
- We'll let users provide their own API tokens for higher limits

**Implementation:**

```typescript
export class GitHubService {
  private token: string | null = null;
  
  setToken(token: string) {
    this.token = token;
  }
  
  async getRepoContents(owner: string, repo: string, path = '') {
    const headers: HeadersInit = {
      'Accept': 'application/vnd.github.v3+json'
    };
    if (this.token) {
      headers['Authorization'] = `token ${this.token}`;
    }
  
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${path}`,
      { headers }
    );
  
    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status}`);
    }
  
    return response.json();
  }
}
```

**How this works:**

- `getRepoContents()` fetches the directory structure of a repository
- It uses the GitHub API with proper headers
- It handles authentication via a token

**Important note:** GitHub API has rate limits. For unauthenticated requests, it's about 60 requests/hour. With a token, it's 5,000/hour.

### Step 5: Implement ZIP Processing

**Why this matters:** Not all code is on GitHub. Users might want to analyze local code or private repositories by uploading a ZIP file.

**Key concepts:**

- JSZip is a library for handling ZIP files in JavaScript
- We need to extract files and their contents from the ZIP
- We'll use a Map to store file paths and contents

**Implementation:**

```typescript
import JSZip from 'jszip';

export class ZipService {
  async processZip(file: File): Promise<Map<string, string>> {
    const zip = await JSZip.loadAsync(file);
    const files = new Map<string, string>();
  
    for (const [filePath, zipEntry] of Object.entries(zip.files)) {
      if (!zipEntry.dir) {
        const content = await zipEntry.async('text');
        files.set(filePath, content);
      }
    }
  
    return files;
  }
}
```

**How this works:**

1. `JSZip.loadAsync(file)` loads the ZIP file
2. We iterate through all entries in the ZIP
3. For each file (not directory), we extract its content as text
4. We store the file path and content in a Map

**Why use a Map?** It provides O(1) lookups by file path, which is important when we need to find files during graph construction.

## Phase 3: Graph Construction Pipeline

### Step 6: Define Graph Data Structures

**Why this matters:** Before we can build a graph, we need to define what nodes and relationships look like.

**Key concepts:**

- A knowledge graph consists of nodes and relationships
- Nodes represent code elements (functions, classes, etc.)
- Relationships represent connections between elements (calls, contains, etc.)

**Implementation:**

```typescript
export type NodeLabel = 
  | 'Project' 
  | 'Package' 
  | 'Module' 
  | 'Folder' 
  | 'File' 
  | 'Class' 
  | 'Function' 
  | 'Method' 
  | 'Variable';

export interface GraphNode {
  id: string;
  label: NodeLabel;
  properties: Record<string, any>;
}

export type RelationshipType = 
  | 'CONTAINS'
  | 'CALLS'
  | 'INHERITS'
  | 'OVERRIDES'
  | 'IMPORTS';

export interface GraphRelationship {
  id: string;
  type: RelationshipType;
  source: string;
  target: string;
  properties?: Record<string, any>;
}

export interface KnowledgeGraph {
  nodes: GraphNode[];
  relationships: GraphRelationship[];
}
```

**Why these specific types?**

- `NodeLabel` defines all possible types of code elements we'll track
- `RelationshipType` defines how code elements connect to each other
- `KnowledgeGraph` is the complete structure we'll build

**Important relationships:**

- `CONTAINS`: A folder contains files, a file contains functions
- `CALLS`: A function calls another function
- `IMPORTS`: One module imports from another

### Step 7: Implement the 3-Pass Ingestion Pipeline

**Why this matters:** Building a complete knowledge graph requires multiple passes to handle cross-file references properly.

**Key concepts:**

- **Pass 1**: Identify the overall structure (folders, modules)
- **Pass 2**: Parse individual files and cache ASTs
- **Pass 3**: Process function calls across files (the hardest part)

This three-pass approach solves the "island problem" - where functions in different files appear disconnected.

#### Pass 1: Structure Identification

```typescript
export class StructureProcessor {
  private graph: KnowledgeGraph;
  private projectRoot: string;
  private projectName: string;
  
  constructor(graph: KnowledgeGraph, projectRoot: string, projectName: string) {
    this.graph = graph;
    this.projectRoot = projectRoot;
    this.projectName = projectName;
  }
  
  identifyStructure(filePaths: string[]): void {
    // Add Project node
    this.graph.nodes.push({
      id: `project:${this.projectName}`,
      label: 'Project',
      properties: { name: this.projectName }
    });
  
    // Track directory structure
    const directories = new Set<string>();
    for (const filePath of filePaths) {
      const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
      if (dirPath && !directories.has(dirPath)) {
        directories.add(dirPath);
        // Create Folder node
        this.graph.nodes.push({
          id: `folder:${dirPath}`,
          label: 'Folder',
          properties: { path: dirPath }
        });
      
        // Create CONTAINS relationship with parent
        if (dirPath.includes('/')) {
          const parentPath = dirPath.substring(0, dirPath.lastIndexOf('/'));
          this.graph.relationships.push({
            id: `rel:folder:${dirPath}:parent`,
            type: 'CONTAINS',
            source: `folder:${parentPath}`,
            target: `folder:${dirPath}`
          });
        } else {
          // Root folder connects to project
          this.graph.relationships.push({
            id: `rel:folder:${dirPath}:project`,
            type: 'CONTAINS',
            source: `project:${this.projectName}`,
            target: `folder:${dirPath}`
          });
        }
      }
    }
  }
}
```

**How this works:**

1. Creates a root Project node
2. Walks through all file paths to identify directories
3. Creates Folder nodes and CONTAINS relationships

**Why identify structure first?** We need to know the overall organization before parsing individual files.

#### Pass 2: File Parsing

```typescript
export class ParsingProcessor {
  private graph: KnowledgeGraph;
  private astCache = new Map<string, any>();
  
  constructor(graph: KnowledgeGraph) {
    this.graph = graph;
  }
  
  async parseFiles(filePaths: string[], fileContents: Map<string, string>): Promise<Map<string, any>> {
    for (const [filePath, content] of fileContents) {
      if (filePath.endsWith('.py')) {
        await this.parsePythonFile(filePath, content);
      }
    }
    return this.astCache;
  }
  
  private async parsePythonFile(filePath: string, content: string): Promise<void> {
    const parser = await loadPythonParser();
    const tree = parser.parse(content);
    // Cache the AST
    this.astCache.set(filePath, tree);
    // Extract definitions from the AST
    this.extractDefinitions(filePath, tree, content);
  }
  
  private extractDefinitions(filePath: string, tree: any, content: string): void {
    // Extract modules
    this.graph.nodes.push({
      id: `module:${filePath}`,
      label: 'Module',
      properties: { 
        path: filePath,
        name: filePath.split('/').pop()!.replace('.py', ''),
        extension: '.py'
      }
    });
  
    // Extract functions from the AST
    const rootNode = tree.rootNode;
    const functionDefs = rootNode.descendantsOfType('function_definition');
    for (const funcNode of functionDefs) {
      const nameNode = funcNode.childForFieldName('name');
      const name = nameNode ? nameNode.text : 'unknown';
    
      // Calculate position
      const startLine = funcNode.startPosition.row + 1;
    
      // Create function node
      this.graph.nodes.push({
        id: `function:${filePath}:${name}`,
        label: 'Function',
        properties: {
          name,
          qualified_name: `${this.getModuleName(filePath)}.${name}`,
          path: filePath,
          start_line: startLine
        }
      });
    
      // Create CONTAINS relationship with module
      this.graph.relationships.push({
        id: `rel:function:${filePath}:${name}:module`,
        type: 'CONTAINS',
        source: `module:${filePath}`,
        target: `function:${filePath}:${name}`
      });
    }
  }
}
```

**How this works:**

1. Parses each file with the appropriate Tree-sitter parser
2. Caches the AST for later use
3. Extracts definitions (functions, classes) from the AST
4. Creates nodes and relationships in the graph

**Why cache ASTs?** We need them in Pass 3 to resolve cross-file function calls.

#### Pass 3: Call Resolution

```typescript
export class CallProcessor {
  private graph: KnowledgeGraph;
  private astCache: Map<string, any>;
  private projectRoot: string;
  private projectName: string;
  
  constructor(
    graph: KnowledgeGraph,
    astCache: Map<string, any>,
    projectRoot: string,
    projectName: string
  ) {
    this.graph = graph;
    this.astCache = astCache;
    this.projectRoot = projectRoot;
    this.projectName = projectName;
  }
  
  processCalls(): void {
    for (const [filePath, tree] of this.astCache) {
      if (filePath.endsWith('.py')) {
        this.processPythonCalls(filePath, tree);
      }
    }
  }
  
  private processPythonCalls(filePath: string, tree: any): void {
    const rootNode = tree.rootNode;
    // Find all call expressions
    const callExpressions = rootNode.descendantsOfType('call');
    for (const callNode of callExpressions) {
      const functionNameNode = callNode.childForFieldName('function');
      if (!functionNameNode) continue;
    
      // Handle different types of function references
      let targetFunctionName = '';
      if (functionNameNode.type === 'identifier') {
        targetFunctionName = functionNameNode.text;
      } else if (functionNameNode.type === 'attribute') {
        // Handle method calls like obj.method()
        const attrNode = functionNameNode;
        const objectNode = attrNode.childForFieldName('object');
        const attrNameNode = attrNode.childForFieldName('attribute');
        if (objectNode && attrNameNode) {
          const objectName = objectNode.text;
          const methodName = attrNameNode.text;
          targetFunctionName = `${objectName}.${methodName}`;
        }
      }
    
      if (!targetFunctionName) continue;
    
      // Try to resolve the target function
      const targetNode = this.resolveTargetFunction(targetFunctionName, filePath);
      if (targetNode) {
        // Create CALLS relationship
        const callerId = this.getCallerId(callNode, filePath);
        this.graph.relationships.push({
          id: `rel:call:${callerId}:${targetNode.id}`,
          type: 'CALLS',
          source: callerId,
          target: targetNode.id
        });
      }
    }
  }
  
  private resolveTargetFunction(targetName: string, currentFilePath: string): { id: string; type: string } | null {
    // 1. Check if it's a built-in function
    if (this.isBuiltInFunction(targetName)) {
      return {
        id: `builtin:${targetName}`,
        type: 'builtin'
      };
    }
  
    // 2. Check if it's an imported function
    const importInfo = this.findImportForFunction(targetName, currentFilePath);
    if (importInfo) {
      const targetId = `function:${importInfo.sourceFile}:${importInfo.targetName}`;
      return {
        id: targetId,
        type: 'imported'
      };
    }
  
    // 3. Check if it's defined in the current file
    for (const node of this.graph.nodes) {
      if (node.label === 'Function' && 
          node.properties.name === targetName &&
          node.properties.path === currentFilePath) {
        return {
          id: node.id,
          type: 'local'
        };
      }
    }
  
    return null;
  }
}
```

**How this works:**

1. Finds all function calls in the AST
2. Determines what function is being called
3. Resolves the target function across files using imports
4. Creates CALLS relationships in the graph

**Why is this the hardest part?** Resolving cross-file references requires understanding:

- How imports work in the language
- How to map a simple name to a fully qualified name
- Handling edge cases like aliases (`import helper as h`)

### Step 8: Implement Web Workers for Performance

**Why this matters:** Parsing code and building graphs can be CPU-intensive. Web Workers keep the UI responsive.

**Key concepts:**

- Web Workers run JavaScript in background threads
- They can't access the DOM directly
- We use Comlink to simplify communication

**Implementation:**

```typescript
// src/workers/ingestion.worker.ts
import { expose } from 'comlink';
import { GraphPipeline } from '../core/ingestion/pipeline';

class IngestionWorker {
  async processRepository(
    projectRoot: string,
    projectName: string,
    filePaths: string[],
    fileContents: Record<string, string>
  ) {
    const pipeline = new GraphPipeline(projectRoot, projectName);
    return pipeline.run(filePaths, new Map(Object.entries(fileContents)));
  }
}

expose(new IngestionWorker());
```

**How this works:**

1. The worker runs the heavy processing in a background thread
2. We expose methods via Comlink to call them from the main thread
3. The main thread can call these methods without blocking the UI

**Why use Web Workers?** Without them, large repositories would freeze the browser tab while processing.

## Phase 4: Graph Visualization

### Step 9: Implement Graph Visualization Components

**Why this matters:** A knowledge graph is useless if users can't see and interact with it.

**Key concepts:**

- Cytoscape.js is a powerful graph visualization library
- We need to convert our graph data to Cytoscape's format
- Users need controls to filter and navigate the graph

**Implementation:**

```tsx
import React, { useEffect, useRef } from 'react';
import cytoscape from 'cytoscape';
import dagre from 'cytoscape-dagre';
import { KnowledgeGraph } from '@/core/graph/types';

cytoscape.use(dagre);

interface GraphVisualizationProps {
  graph: KnowledgeGraph;
  onNodeClick?: (nodeId: string) => void;
  filter?: (node: any) => boolean;
}

export const GraphVisualization: React.FC<GraphVisualizationProps> = ({ 
  graph, 
  onNodeClick,
  filter 
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const cyRef = useRef<cytoscape.Core | null>(null);
  
  useEffect(() => {
    if (!containerRef.current) return;
  
    // Clean up previous instance
    if (cyRef.current) {
      cyRef.current.destroy();
    }
  
    // Convert our graph to Cytoscape format
    const cyElements = convertToCytoscapeElements(graph, filter);
  
    const cy = cytoscape({
      container: containerRef.current,
      elements: cyElements,
      style: [
        {
          selector: 'node',
          style: {
            'label': 'data(label)',
            'width': 'mapData(size, 0, 100, 20, 80)',
            'height': 'mapData(size, 0, 100, 20, 80)',
            'background-color': 'data(color)',
            'text-valign': 'center',
            'text-halign': 'center',
            'font-size': '8px'
          }
        },
        {
          selector: 'edge',
          style: {
            'width': 2,
            'line-color': '#ccc',
            'target-arrow-color': '#ccc',
            'target-arrow-shape': 'triangle'
          }
        }
      ],
      layout: {
        name: 'dagre',
        rankDir: 'TB',
        padding: 20
      }
    });
  
    // Add interactions
    cy.on('tap', 'node', (event) => {
      const node = event.target;
      const nodeId = node.data('id');
      if (onNodeClick) {
        onNodeClick(nodeId);
      }
    });
  
    cyRef.current = cy;
  
    return () => {
      if (cyRef.current) {
        cyRef.current.destroy();
        cyRef.current = null;
      }
    };
  }, [graph, filter]);
  
  return (
    <div 
      ref={containerRef} 
      className="w-full h-full bg-white rounded-lg border border-gray-200"
    />
  );
};

function convertToCytoscapeElements(
  graph: KnowledgeGraph, 
  filter?: (node: any) => boolean
) {
  const elements: any[] = [];
  
  // Add nodes
  for (const node of graph.nodes) {
    if (filter && !filter(node)) continue;
    elements.push({
      data: {
        id: node.id,
        label: getNodeLabel(node),
        type: node.label,
        color: getNodeColor(node.label),
        size: getNodeSize(node)
      }
    });
  }
  
  // Add edges
  for (const rel of graph.relationships) {
    elements.push({
      data: {
        id: rel.id,
        source: rel.source,
        target: rel.target,
        label: rel.type
      }
    });
  }
  
  return elements;
}
```

**How this works:**

1. Converts our graph data to Cytoscape's format
2. Sets up visual styles based on node type
3. Applies a hierarchical layout (dagre)
4. Adds interaction handlers for node clicks

**Why use Cytoscape.js?** It's specifically designed for graph visualization with:

- Multiple layout algorithms
- Good performance for medium-sized graphs
- Extensive customization options

### Step 10: Create Source Code Viewer

**Why this matters:** Seeing the graph isn't enough - users need to see the actual code behind the nodes.

**Implementation:**

```tsx
import React, { useState, useEffect } from 'react';
import { KnowledgeGraph } from '@/core/graph/types';

interface SourceViewerProps {
  graph: KnowledgeGraph;
  selectedNodeId: string | null;
}

export const SourceViewer: React.FC<SourceViewerProps> = ({ graph, selectedNodeId }) => {
  const [sourceCode, setSourceCode] = useState<string>('');
  const [fileName, setFileName] = useState<string>('');
  const [lineNumber, setLineNumber] = useState<number | null>(null);
  
  useEffect(() => {
    if (!selectedNodeId) {
      setSourceCode('');
      setFileName('');
      setLineNumber(null);
      return;
    }
  
    // Find the node in the graph
    const node = graph.nodes.find(n => n.id === selectedNodeId);
    if (!node) return;
  
    // For functions, get the source code
    if (node.label === 'Function' || node.label === 'Method') {
      const filePath = node.properties.path;
      const startLine = node.properties.start_line;
    
      // In a real implementation, you'd have the source code available
      setFileName(filePath);
      setLineNumber(startLine);
      setSourceCode(`# Source code for ${node.properties.qualified_name}
# Line ${startLine} and following...`);
    }
  }, [graph, selectedNodeId]);
  
  if (!selectedNodeId || !sourceCode) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50">
        <p className="text-gray-500">Select a node to view source code</p>
      </div>
    );
  }
  
  return (
    <div className="flex flex-col h-full">
      <div className="p-2 bg-gray-100 border-b border-gray-200 flex justify-between items-center">
        <span className="text-sm font-medium text-gray-700 truncate">{fileName}</span>
        {lineNumber && (
          <span className="text-xs text-gray-500">Line {lineNumber}</span>
        )}
      </div>
      <div className="flex-1 overflow-auto p-2 font-mono text-sm bg-black text-white">
        <pre>{sourceCode}</pre>
      </div>
    </div>
  );
};
```

**How this works:**

1. When a node is selected, it finds the corresponding code element
2. It displays the source code with line numbers
3. It highlights the relevant part of the code

**Why is this important?** It bridges the gap between the abstract graph and the concrete code, helping users understand what they're seeing.

## Phase 5: RAG Chat Interface

### Step 11: Implement LLM Service

**Why this matters:** The chat interface needs to connect to LLMs (Large Language Models) to translate natural language to graph queries.

**Key concepts:**

- We'll support multiple LLM providers (OpenAI, Anthropic, Gemini)
- Users provide their own API keys (privacy-focused)
- We need a consistent interface for different providers

**Implementation:**

```typescript
import { ChatOpenAI } from 'langchain/chat_models/openai';
import { ChatAnthropic } from 'langchain/chat_models/anthropic';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';

export type LLMProvider = 'openai' | 'anthropic' | 'gemini';

export interface LLMConfig {
  provider: LLMProvider;
  apiKey: string;
  model?: string;
}

export class LLMService {
  private config: LLMConfig;
  
  constructor(config: LLMConfig) {
    this.config = config;
  }
  
  getChatModel() {
    switch (this.config.provider) {
      case 'openai':
        return new ChatOpenAI({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'gpt-4-turbo',
          temperature: 0
        });
      case 'anthropic':
        return new ChatAnthropic({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'claude-3-sonnet-20240229',
          temperature: 0
        });
      case 'gemini':
        return new ChatGoogleGenerativeAI({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'gemini-1.5-pro-latest',
          temperature: 0
        });
      default:
        throw new Error(`Unsupported LLM provider: ${this.config.provider}`);
    }
  }
}
```

**How this works:**

1. The service takes an LLM configuration (provider, API key, model)
2. It returns a consistent chat model interface regardless of provider
3. It handles provider-specific initialization

**Why support multiple providers?** Different users have different preferences and API key availability.

### Step 12: Implement Cypher Generator

**Why this matters:** The core of the RAG system - translating natural language questions to graph queries.

**Key concepts:**

- We use a system prompt to instruct the LLM
- The prompt includes our graph schema
- We clean the response to get a valid Cypher query

**Implementation:**

```typescript
import { BaseChatModel } from 'langchain/chat_models/base';
import { CYPHER_SYSTEM_PROMPT } from '../prompts/cypher';

export class CypherGenerator {
  private llm: BaseChatModel;
  
  constructor(llm: BaseChatModel) {
    this.llm = llm;
  }
  
  async generate(naturalLanguageQuery: string): Promise<string> {
    const response = await this.llm.call([
      { role: 'system', content: CYPHER_SYSTEM_PROMPT },
      { role: 'user', content: naturalLanguageQuery }
    ]);
  
    return this.cleanResponse(response.content);
  }
  
  private cleanResponse(response: string): string {
    // Remove markdown code blocks
    let cleaned = response.replace(/```cypher/g, '').replace(/```/g, '');
    // Ensure it ends with a semicolon
    if (!cleaned.trim().endsWith(';')) {
      cleaned = cleaned.trim() + ';';
    }
    return cleaned;
  }
}
```

**How this works:**

1. It sends the natural language query with a system prompt to the LLM
2. The system prompt teaches the LLM about our graph structure
3. It cleans the response to extract a valid Cypher query

**Why is the system prompt important?** It provides the LLM with the context it needs to generate correct queries. Without it, the LLM wouldn't know about our graph schema.

### Step 13: Implement RAG Orchestrator

**Why this matters:** This is the "brain" of the system that coordinates the query process.

**Key concepts:**

- It follows a ReAct (Reason + Act) pattern
- It plans steps, uses tools, observes results, and responds
- It prevents hallucination by sticking to tool results

**Implementation:**

```typescript
import { BaseChatModel } from 'langchain/chat_models/base';
import { RAG_ORCHESTRATOR_SYSTEM_PROMPT } from '../prompts/rag-orchestrator';

export class RAGOrchestrator {
  private llm: BaseChatModel;
  
  constructor(llm: BaseChatModel) {
    this.llm = llm;
  }
  
  async query(
    userQuery: string,
    queryGraph: (cypher: string) => Promise<any>,
    retrieveCode: (nodeId: string) => Promise<string>
  ) {
    // Start with the system prompt
    let conversation = [
      { role: 'system', content: RAG_ORCHESTRATOR_SYSTEM_PROMPT }
    ];
  
    // Add the user's question
    conversation.push({ role: 'user', content: userQuery });
  
    // Simple ReAct loop
    for (let i = 0; i < 5; i++) { // Max 5 steps
      const response = await this.llm.call(conversation);
      const responseContent = response.content;
    
      // Check if the response contains a tool call
      if (responseContent.includes('Action: query_graph')) {
        const match = responseContent.match(/Action Input: (.*)/);
        if (match) {
          const cypherQuery = match[1].trim();
        
          // Execute the query
          const queryResults = await queryGraph(cypherQuery);
        
          // Add the observation to the conversation
          conversation.push({
            role: 'assistant',
            content: responseContent
          });
        
          conversation.push({
            role: 'system',
            content: `Observation: ${JSON.stringify(queryResults)}`
          });
        
          // If we have results, we might be done
          if (queryResults.length > 0) {
            break;
          }
        }
      } 
      else if (responseContent.includes('Action: retrieve_code')) {
        // Similar handling for code retrieval
      }
      else {
        // This appears to be the final answer
        return responseContent;
      }
    }
  
    // If we got here without a final answer, generate one
    conversation.push({
      role: 'user',
      content: 'Please provide your final answer based on the information gathered.'
    });
  
    const finalResponse = await this.llm.call(conversation);
    return finalResponse.content;
  }
}
```

**How this works:**

1. It starts with a system prompt that defines the rules
2. It sends the user's query to the LLM
3. The LLM responds with either:
   - A tool call (query_graph or retrieve_code)
   - A final answer
4. If it's a tool call, it executes the tool and adds the result to the conversation
5. It repeats until it gets a final answer or hits the step limit

**Why the step limit?** To prevent infinite loops if the LLM gets stuck.

## Phase 6: Main Application Integration

### Step 14: Create Main Application Component

**Why this matters:** This brings all the pieces together into a cohesive UI.

**Implementation:**

```tsx
import React, { useState, useRef } from 'react';
import { GraphVisualization } from '@/ui/components/graph/Visualization';
import { GraphControls } from '@/ui/components/graph/Controls';
import { SourceViewer } from '@/ui/components/graph/SourceViewer';
import { ChatInterface } from '@/ui/components/chat/ChatInterface';
import { KnowledgeGraph } from '@/core/graph/types';
import { GitHubService } from '@/services/github';
import { ZipService } from '@/services/zip';
import { ingestionWorkerApi } from '@/lib/workerUtils';

export const HomePage = () => {
  const [graph, setGraph] = useState<KnowledgeGraph | null>(null);
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [repoUrl, setRepoUrl] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  const handleRepoSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!repoUrl.trim() || isLoading) return;
  
    setIsLoading(true);
    setError(null);
  
    try {
      // Parse the GitHub URL
      const urlMatch = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
      if (!urlMatch) {
        throw new Error('Invalid GitHub repository URL');
      }
    
      const owner = urlMatch[1];
      const repo = urlMatch[2].replace(/\.git$/, '');
    
      // Fetch repository contents
      const githubService = new GitHubService();
      const contents = await githubService.getRepoContents(owner, repo);
    
      // Filter for Python files
      const pythonFiles = contents
        .filter((item: any) => item.type === 'file' && item.name.endsWith('.py'))
        .map((item: any) => item.path);
    
      // Fetch file contents
      const fileContents: Record<string, string> = {};
      for (const filePath of pythonFiles) {
        fileContents[filePath] = await githubService.getFileContent(owner, repo, filePath);
      }
    
      // Process the repository
      const projectName = `${owner}/${repo}`;
      const processedGraph = await ingestionWorkerApi.processRepository(
        repoUrl,
        projectName,
        pythonFiles,
        fileContents
      );
    
      setGraph(processedGraph);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to process repository');
      console.error('Processing error:', err);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleQuery = async (query: string): Promise<string> => {
    if (!graph) {
      throw new Error('No graph available');
    }
  
    // In a real implementation, this would use the RAG orchestrator
    return `I found information related to "${query}" in the codebase.`;
  };
  
  return (
    <div className="h-screen flex flex-col">
      {/* Header with repository input */}
      <header className="p-4 bg-white border-b border-gray-200">
        <div className="max-w-7xl mx-auto flex flex-col sm:flex-row sm:items-center gap-4">
          <h1 className="text-2xl font-bold text-gray-900">GitNexus</h1>
        
          <div className="flex-1 flex gap-2">
            <form onSubmit={handleRepoSubmit} className="flex-1">
              <div className="flex gap-2">
                <input
                  type="text"
                  value={repoUrl}
                  onChange={(e) => setRepoUrl(e.target.value)}
                  placeholder="https://github.com/owner/repo.git"
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                />
                <button
                  type="submit"
                  disabled={isLoading}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
                >
                  {isLoading ? 'Processing...' : 'Analyze'}
                </button>
              </div>
            </form>
          
            <div className="flex items-center">
              <span className="text-gray-500 mx-2">or</span>
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleZipUpload}
                accept=".zip"
                className="hidden"
                id="zip-upload"
              />
              <label
                htmlFor="zip-upload"
                className="px-3 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 cursor-pointer"
              >
                Upload ZIP
              </label>
            </div>
          </div>
        </div>
      </header>
    
      <main className="flex-1 max-w-7xl mx-auto w-full flex gap-4 p-4">
        {/* Graph Visualization Pane */}
        <div className="flex-1 flex flex-col min-w-0">
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col">
            {graph ? (
              <>
                <GraphControls 
                  onFilterChange={() => {}} 
                  onLayoutChange={() => {}} 
                />
                <div className="flex-1 min-h-0">
                  <GraphVisualization 
                    graph={graph} 
                    onNodeClick={setSelectedNodeId}
                  />
                </div>
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                {isLoading ? (
                  <div className="text-center">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
                    <p>Processing repository...</p>
                  </div>
                ) : (
                  <p>Enter a repository URL or upload a ZIP to get started</p>
                )}
              </div>
            )}
          </div>
        </div>
      
        {/* Right Panel */}
        <div className="w-80 flex flex-col gap-4">
          {/* Source Viewer */}
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col h-[40%]">
            <div className="p-3 border-b border-gray-200 bg-gray-50">
              <h2 className="text-sm font-medium text-gray-700">Source Code</h2>
            </div>
            {graph ? (
              <SourceViewer graph={graph} selectedNodeId={selectedNodeId} />
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                <p>Select a node to view source</p>
              </div>
            )}
          </div>
        
          {/* Chat Interface */}
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col h-[60%]">
            <div className="p-3 border-b border-gray-200 bg-gray-50">
              <h2 className="text-sm font-medium text-gray-700">Ask About Code</h2>
            </div>
            {graph ? (
              <ChatInterface graph={graph} onQuery={handleQuery} />
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500 p-4">
                <p>Process a repository to ask questions about the code</p>
              </div>
            )}
          </div>
        </div>
      </main>
    </div>
  );
};
```

**How this works:**

1. The header has inputs for GitHub URLs and ZIP uploads
2. The main area has two panes:
   - Left: Graph visualization
   - Right: Source viewer and chat interface
3. When a repository is processed, the graph is displayed
4. Users can click nodes to see source code and ask questions

**Why this layout?** It provides a cohesive experience where users can:

- See the big picture (graph)
- Drill down to specific code (source viewer)
- Ask questions about what they're seeing (chat)

## Final Steps: Testing and Optimization

### Step 15: Add Error Boundaries

**Why this matters:** Inevitably, something will go wrong. We want to handle errors gracefully.

**Implementation:**

```tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="p-4 bg-red-50 border border-red-200 rounded-md">
          <h2 className="text-lg font-medium text-red-800 mb-2">Something went wrong</h2>
          <p className="text-red-700 mb-2">{this.state.error?.message}</p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            className="px-3 py-1 bg-red-100 text-red-700 rounded-md hover:bg-red-200"
          >
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**How this works:**

- It catches JavaScript errors in child components
- It displays a friendly error message instead of a blank screen
- It allows users to try again without losing their work

**Why use error boundaries?** They prevent a single error from breaking the entire application.

### Step 16: Implement Performance Optimizations

**Why this matters:** Large repositories can be slow to process. We need to keep the UI responsive.

**Key optimizations:**

1. **Web Workers**: Already implemented for graph processing
2. **Progress Indicators**: Show users what's happening
3. **File Filtering**: Only process relevant files
4. **Lazy Loading**: Load components as needed

**Implementation:**

```tsx
// Add to your GitHub processing function
const MAX_FILES = 500; // Limit for free tier
if (pythonFiles.length > MAX_FILES) {
  // Offer to filter by directory or file pattern
  const shouldFilter = window.confirm(
    `Repository has ${pythonFiles.length} Python files (max ${MAX_FILES}). ` +
    `Would you like to filter by directory or file pattern?`
  );
  if (shouldFilter) {
    const filterPattern = prompt(
      "Enter a directory path or file pattern to filter (e.g., 'src/', '*.py')",
      "src/"
    );
    if (filterPattern) {
      const filteredFiles = pythonFiles.filter(file => 
        file.includes(filterPattern) || file.endsWith(filterPattern)
      );
      pythonFiles = filteredFiles;
    }
  }
}
```

**Why limit file processing?** Processing too many files can:

- Freeze the browser tab
- Exceed GitHub API rate limits
- Use excessive memory

### Step 17: Add Export Functionality

**Why this matters:** Users might want to save or share their generated graphs.

**Implementation:**

```tsx
export function exportGraphToJson(graph: KnowledgeGraph): string {
  return JSON.stringify(graph, null, 2);
}

export function downloadGraph(graph: KnowledgeGraph, filename: string = 'gitnexus-graph.json') {
  const json = exportGraphToJson(graph);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
```

**How this works:**

1. Converts the graph to JSON
2. Creates a downloadable file
3. Triggers a download

**Why include export?** It allows users to:

- Save their work for later
- Share graphs with teammates
- Use the data in other tools

## Conclusion

This implementation guide has walked you through building a complete edge-based code knowledge graph generator using Deno. By following these steps, you'll create a privacy-focused tool that runs entirely in the user's browser.

**Key advantages of this approach:**

- **Zero server costs**: All processing happens in the user's browser
- **Strong privacy**: Code never leaves the user's machine
- **Modular architecture**: Easy to add more languages later
- **Clear separation of concerns**: Makes the codebase maintainable
- **Deno compatibility**: Modern runtime with built-in TypeScript support

Remember to start small (Python support only) and iterate, adding more features and language support as you validate the core functionality. The most important part is getting the graph construction pipeline working correctly - everything else builds on that foundation.

Good luck with your implementation of GitNexus!

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: README.md
================
# GitNexus: Edge-Based Code Knowledge Graph Generator for Deno - Step-by-Step Implementation Guide

This guide will walk you through building a fully edge-based code knowledge graph generator from scratch using Deno. I'll explain each concept before showing the implementation, so you understand **why** we're doing something, not just **how** to do it.

## Phase 1: Project Setup & Core Infrastructure

### Step 1: Project Structure and Tooling Setup

**Why this matters:** Before writing any code, we need to set up our development environment properly. A well-structured project makes it easier to add features later and keeps everything organized.

**Key concepts:**

- We're using Vite (a modern build tool) with React and TypeScript
- We need special configuration for WebAssembly (WASM) files
- A clear directory structure helps us scale to multiple languages later

**Implementation Steps:**

1. **Create the base project:**

```bash
# Create project root
mkdir GitNexus
cd GitNexus

# Initialize Vite project with React and TypeScript
npm create vite@latest . -- --template react-ts

# Initialize Deno project
deno init
```

2. **Create the application directory structure:**

```bash
# Create directories for our core components
mkdir -p src/{core,core/tree-sitter,core/graph,core/ingestion,services,ai,ai/agents,ai/prompts,ui,ui/components,ui/components/graph,ui/components/chat,ui/hooks,workers,lib,config,store}
```

**Why this structure?**

- `core/`: Contains the engine that builds the knowledge graph
- `services/`: Handles external interactions (GitHub API, ZIP processing)
- `ai/`: Contains the RAG and chat functionality
- `ui/`: All user interface components
- `workers/`: Web Workers for heavy processing (keeps UI responsive)
- `lib/`: Utility functions used throughout the app

### Step 2: Configure Build Tools for WASM

**Why this matters:** WebAssembly (WASM) is how we'll run the Tree-sitter parsers in the browser. We need special configuration to handle these binary files correctly.

**Key concepts:**

- WASM files are binary files that run at near-native speed in browsers
- Vite needs special configuration to handle them properly
- We want to avoid inlining large WASM files in our JavaScript bundles

**Implementation:**

1. **Update `vite.config.ts`:**

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
export default defineConfig({
  plugins: [react()],
  worker: {
    format: 'es'
  },
  assetsInclude: ['**/*.wasm'],
  build: {
    target: 'esnext',
    assetsInlineLimit: 0 // Don't inline WASM files
  }
})
```

**What this does:**

- `assetsInclude: ['**/*.wasm']` tells Vite to treat WASM files as assets
- `assetsInlineLimit: 0` ensures WASM files aren't inlined into JavaScript (they're too large)
- `worker: { format: 'es' }` configures Web Workers to use ES modules

2. **Configure TypeScript** with a `tsconfig.json` that has strict settings for better code quality.

**Why strict settings?** They help catch errors early and make the code more maintainable as the project grows.

### Step 3: Set Up WASM Parser Infrastructure

**Why this matters:** Tree-sitter is the engine that parses code into ASTs (Abstract Syntax Trees). We need to get these parsers working in the browser via WASM.

**Key concepts:**

- Tree-sitter parsers for different languages are written in C
- We compile them to WASM so they can run in browsers
- We need to load these parsers on demand

**Implementation:**

1. **Create a public directory for WASM files:**

```bash
mkdir -p public/wasm/python
```

2. **Download the Tree-sitter Python parser:**
   - Get `tree-sitter-python.wasm` from [tree-sitter-python releases](https://github.com/tree-sitter/tree-sitter-python/releases)
   - Place it in `public/wasm/python/`

**Why host WASM files separately?** Browsers can't access the user's file system directly for security reasons. We need to serve the WASM files from a URL.

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase - Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase - Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase - Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

3. **Create a loader for Tree-sitter parsers:**

```typescript
import WebTreeSitter from 'web-tree-sitter';
let parserInstance: WebTreeSitter | null = null;
const parserCache = new Map<string, WebTreeSitter.Language>();

export async function initTreeSitter() {
  if (parserInstance) return parserInstance;
  parserInstance = await WebTreeSitter.init();
  return parserInstance;
}

export async function loadPythonParser(): Promise<WebTreeSitter.Language> {
  if (parserCache.has('python')) {
    return parserCache.get('python')!;
  }
  const Parser = await initTreeSitter();
  const pythonLang = await Parser.Language.load(
    '/wasm/python/tree-sitter-python.wasm'
  );
  parserCache.set('python', pythonLang);
  return pythonLang;
}
```

**How this works:**

1. `initTreeSitter()` initializes the WebAssembly module once
2. `loadPythonParser()` loads the Python parser from the WASM file
3. We cache parsers to avoid reloading them multiple times

**Why cache parsers?** Loading WASM files is relatively slow, so we want to do it once and reuse the parsers.

## Phase 2: Code Acquisition Module

### Step 4: Implement GitHub API Integration

**Why this matters:** Users will want to analyze public GitHub repositories, so we need a way to fetch code from GitHub.

**Key concepts:**

- GitHub has a REST API for accessing repository contents
- We need to handle rate limits (GitHub limits how many requests you can make)
- We'll let users provide their own API tokens for higher limits

**Implementation:**

```typescript
export class GitHubService {
  private token: string | null = null;
  
  setToken(token: string) {
    this.token = token;
  }
  
  async getRepoContents(owner: string, repo: string, path = '') {
    const headers: HeadersInit = {
      'Accept': 'application/vnd.github.v3+json'
    };
    if (this.token) {
      headers['Authorization'] = `token ${this.token}`;
    }
  
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${path}`,
      { headers }
    );
  
    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status}`);
    }
  
    return response.json();
  }
}
```

**How this works:**

- `getRepoContents()` fetches the directory structure of a repository
- It uses the GitHub API with proper headers
- It handles authentication via a token

**Important note:** GitHub API has rate limits. For unauthenticated requests, it's about 60 requests/hour. With a token, it's 5,000/hour.

### Step 5: Implement ZIP Processing

**Why this matters:** Not all code is on GitHub. Users might want to analyze local code or private repositories by uploading a ZIP file.

**Key concepts:**

- JSZip is a library for handling ZIP files in JavaScript
- We need to extract files and their contents from the ZIP
- We'll use a Map to store file paths and contents

**Implementation:**

```typescript
import JSZip from 'jszip';

export class ZipService {
  async processZip(file: File): Promise<Map<string, string>> {
    const zip = await JSZip.loadAsync(file);
    const files = new Map<string, string>();
  
    for (const [filePath, zipEntry] of Object.entries(zip.files)) {
      if (!zipEntry.dir) {
        const content = await zipEntry.async('text');
        files.set(filePath, content);
      }
    }
  
    return files;
  }
}
```

**How this works:**

1. `JSZip.loadAsync(file)` loads the ZIP file
2. We iterate through all entries in the ZIP
3. For each file (not directory), we extract its content as text
4. We store the file path and content in a Map

**Why use a Map?** It provides O(1) lookups by file path, which is important when we need to find files during graph construction.

## Phase 3: Graph Construction Pipeline

### Step 6: Define Graph Data Structures

**Why this matters:** Before we can build a graph, we need to define what nodes and relationships look like.

**Key concepts:**

- A knowledge graph consists of nodes and relationships
- Nodes represent code elements (functions, classes, etc.)
- Relationships represent connections between elements (calls, contains, etc.)

**Implementation:**

```typescript
export type NodeLabel = 
  | 'Project' 
  | 'Package' 
  | 'Module' 
  | 'Folder' 
  | 'File' 
  | 'Class' 
  | 'Function' 
  | 'Method' 
  | 'Variable';

export interface GraphNode {
  id: string;
  label: NodeLabel;
  properties: Record<string, any>;
}

export type RelationshipType = 
  | 'CONTAINS'
  | 'CALLS'
  | 'INHERITS'
  | 'OVERRIDES'
  | 'IMPORTS';

export interface GraphRelationship {
  id: string;
  type: RelationshipType;
  source: string;
  target: string;
  properties?: Record<string, any>;
}

export interface KnowledgeGraph {
  nodes: GraphNode[];
  relationships: GraphRelationship[];
}
```

**Why these specific types?**

- `NodeLabel` defines all possible types of code elements we'll track
- `RelationshipType` defines how code elements connect to each other
- `KnowledgeGraph` is the complete structure we'll build

**Important relationships:**

- `CONTAINS`: A folder contains files, a file contains functions
- `CALLS`: A function calls another function
- `IMPORTS`: One module imports from another

### Step 7: Implement the 3-Pass Ingestion Pipeline

**Why this matters:** Building a complete knowledge graph requires multiple passes to handle cross-file references properly.

**Key concepts:**

- **Pass 1**: Identify the overall structure (folders, modules)
- **Pass 2**: Parse individual files and cache ASTs
- **Pass 3**: Process function calls across files (the hardest part)

This three-pass approach solves the "island problem" - where functions in different files appear disconnected.

#### Pass 1: Structure Identification

```typescript
export class StructureProcessor {
  private graph: KnowledgeGraph;
  private projectRoot: string;
  private projectName: string;
  
  constructor(graph: KnowledgeGraph, projectRoot: string, projectName: string) {
    this.graph = graph;
    this.projectRoot = projectRoot;
    this.projectName = projectName;
  }
  
  identifyStructure(filePaths: string[]): void {
    // Add Project node
    this.graph.nodes.push({
      id: `project:${this.projectName}`,
      label: 'Project',
      properties: { name: this.projectName }
    });
  
    // Track directory structure
    const directories = new Set<string>();
    for (const filePath of filePaths) {
      const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
      if (dirPath && !directories.has(dirPath)) {
        directories.add(dirPath);
        // Create Folder node
        this.graph.nodes.push({
          id: `folder:${dirPath}`,
          label: 'Folder',
          properties: { path: dirPath }
        });
      
        // Create CONTAINS relationship with parent
        if (dirPath.includes('/')) {
          const parentPath = dirPath.substring(0, dirPath.lastIndexOf('/'));
          this.graph.relationships.push({
            id: `rel:folder:${dirPath}:parent`,
            type: 'CONTAINS',
            source: `folder:${parentPath}`,
            target: `folder:${dirPath}`
          });
        } else {
          // Root folder connects to project
          this.graph.relationships.push({
            id: `rel:folder:${dirPath}:project`,
            type: 'CONTAINS',
            source: `project:${this.projectName}`,
            target: `folder:${dirPath}`
          });
        }
      }
    }
  }
}
```

**How this works:**

1. Creates a root Project node
2. Walks through all file paths to identify directories
3. Creates Folder nodes and CONTAINS relationships

**Why identify structure first?** We need to know the overall organization before parsing individual files.

#### Pass 2: File Parsing

```typescript
export class ParsingProcessor {
  private graph: KnowledgeGraph;
  private astCache = new Map<string, any>();
  
  constructor(graph: KnowledgeGraph) {
    this.graph = graph;
  }
  
  async parseFiles(filePaths: string[], fileContents: Map<string, string>): Promise<Map<string, any>> {
    for (const [filePath, content] of fileContents) {
      if (filePath.endsWith('.py')) {
        await this.parsePythonFile(filePath, content);
      }
    }
    return this.astCache;
  }
  
  private async parsePythonFile(filePath: string, content: string): Promise<void> {
    const parser = await loadPythonParser();
    const tree = parser.parse(content);
    // Cache the AST
    this.astCache.set(filePath, tree);
    // Extract definitions from the AST
    this.extractDefinitions(filePath, tree, content);
  }
  
  private extractDefinitions(filePath: string, tree: any, content: string): void {
    // Extract modules
    this.graph.nodes.push({
      id: `module:${filePath}`,
      label: 'Module',
      properties: { 
        path: filePath,
        name: filePath.split('/').pop()!.replace('.py', ''),
        extension: '.py'
      }
    });
  
    // Extract functions from the AST
    const rootNode = tree.rootNode;
    const functionDefs = rootNode.descendantsOfType('function_definition');
    for (const funcNode of functionDefs) {
      const nameNode = funcNode.childForFieldName('name');
      const name = nameNode ? nameNode.text : 'unknown';
    
      // Calculate position
      const startLine = funcNode.startPosition.row + 1;
    
      // Create function node
      this.graph.nodes.push({
        id: `function:${filePath}:${name}`,
        label: 'Function',
        properties: {
          name,
          qualified_name: `${this.getModuleName(filePath)}.${name}`,
          path: filePath,
          start_line: startLine
        }
      });
    
      // Create CONTAINS relationship with module
      this.graph.relationships.push({
        id: `rel:function:${filePath}:${name}:module`,
        type: 'CONTAINS',
        source: `module:${filePath}`,
        target: `function:${filePath}:${name}`
      });
    }
  }
}
```

**How this works:**

1. Parses each file with the appropriate Tree-sitter parser
2. Caches the AST for later use
3. Extracts definitions (functions, classes) from the AST
4. Creates nodes and relationships in the graph

**Why cache ASTs?** We need them in Pass 3 to resolve cross-file function calls.

#### Pass 3: Call Resolution

```typescript
export class CallProcessor {
  private graph: KnowledgeGraph;
  private astCache: Map<string, any>;
  private projectRoot: string;
  private projectName: string;
  
  constructor(
    graph: KnowledgeGraph,
    astCache: Map<string, any>,
    projectRoot: string,
    projectName: string
  ) {
    this.graph = graph;
    this.astCache = astCache;
    this.projectRoot = projectRoot;
    this.projectName = projectName;
  }
  
  processCalls(): void {
    for (const [filePath, tree] of this.astCache) {
      if (filePath.endsWith('.py')) {
        this.processPythonCalls(filePath, tree);
      }
    }
  }
  
  private processPythonCalls(filePath: string, tree: any): void {
    const rootNode = tree.rootNode;
    // Find all call expressions
    const callExpressions = rootNode.descendantsOfType('call');
    for (const callNode of callExpressions) {
      const functionNameNode = callNode.childForFieldName('function');
      if (!functionNameNode) continue;
    
      // Handle different types of function references
      let targetFunctionName = '';
      if (functionNameNode.type === 'identifier') {
        targetFunctionName = functionNameNode.text;
      } else if (functionNameNode.type === 'attribute') {
        // Handle method calls like obj.method()
        const attrNode = functionNameNode;
        const objectNode = attrNode.childForFieldName('object');
        const attrNameNode = attrNode.childForFieldName('attribute');
        if (objectNode && attrNameNode) {
          const objectName = objectNode.text;
          const methodName = attrNameNode.text;
          targetFunctionName = `${objectName}.${methodName}`;
        }
      }
    
      if (!targetFunctionName) continue;
    
      // Try to resolve the target function
      const targetNode = this.resolveTargetFunction(targetFunctionName, filePath);
      if (targetNode) {
        // Create CALLS relationship
        const callerId = this.getCallerId(callNode, filePath);
        this.graph.relationships.push({
          id: `rel:call:${callerId}:${targetNode.id}`,
          type: 'CALLS',
          source: callerId,
          target: targetNode.id
        });
      }
    }
  }
  
  private resolveTargetFunction(targetName: string, currentFilePath: string): { id: string; type: string } | null {
    // 1. Check if it's a built-in function
    if (this.isBuiltInFunction(targetName)) {
      return {
        id: `builtin:${targetName}`,
        type: 'builtin'
      };
    }
  
    // 2. Check if it's an imported function
    const importInfo = this.findImportForFunction(targetName, currentFilePath);
    if (importInfo) {
      const targetId = `function:${importInfo.sourceFile}:${importInfo.targetName}`;
      return {
        id: targetId,
        type: 'imported'
      };
    }
  
    // 3. Check if it's defined in the current file
    for (const node of this.graph.nodes) {
      if (node.label === 'Function' && 
          node.properties.name === targetName &&
          node.properties.path === currentFilePath) {
        return {
          id: node.id,
          type: 'local'
        };
      }
    }
  
    return null;
  }
}
```

**How this works:**

1. Finds all function calls in the AST
2. Determines what function is being called
3. Resolves the target function across files using imports
4. Creates CALLS relationships in the graph

**Why is this the hardest part?** Resolving cross-file references requires understanding:

- How imports work in the language
- How to map a simple name to a fully qualified name
- Handling edge cases like aliases (`import helper as h`)

### Step 8: Implement Web Workers for Performance

**Why this matters:** Parsing code and building graphs can be CPU-intensive. Web Workers keep the UI responsive.

**Key concepts:**

- Web Workers run JavaScript in background threads
- They can't access the DOM directly
- We use Comlink to simplify communication

**Implementation:**

```typescript
// src/workers/ingestion.worker.ts
import { expose } from 'comlink';
import { GraphPipeline } from '../core/ingestion/pipeline';

class IngestionWorker {
  async processRepository(
    projectRoot: string,
    projectName: string,
    filePaths: string[],
    fileContents: Record<string, string>
  ) {
    const pipeline = new GraphPipeline(projectRoot, projectName);
    return pipeline.run(filePaths, new Map(Object.entries(fileContents)));
  }
}

expose(new IngestionWorker());
```

**How this works:**

1. The worker runs the heavy processing in a background thread
2. We expose methods via Comlink to call them from the main thread
3. The main thread can call these methods without blocking the UI

**Why use Web Workers?** Without them, large repositories would freeze the browser tab while processing.

## Phase 4: Graph Visualization

### Step 9: Implement Graph Visualization Components

**Why this matters:** A knowledge graph is useless if users can't see and interact with it.

**Key concepts:**

- Cytoscape.js is a powerful graph visualization library
- We need to convert our graph data to Cytoscape's format
- Users need controls to filter and navigate the graph

**Implementation:**

```tsx
import React, { useEffect, useRef } from 'react';
import cytoscape from 'cytoscape';
import dagre from 'cytoscape-dagre';
import { KnowledgeGraph } from '@/core/graph/types';

cytoscape.use(dagre);

interface GraphVisualizationProps {
  graph: KnowledgeGraph;
  onNodeClick?: (nodeId: string) => void;
  filter?: (node: any) => boolean;
}

export const GraphVisualization: React.FC<GraphVisualizationProps> = ({ 
  graph, 
  onNodeClick,
  filter 
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const cyRef = useRef<cytoscape.Core | null>(null);
  
  useEffect(() => {
    if (!containerRef.current) return;
  
    // Clean up previous instance
    if (cyRef.current) {
      cyRef.current.destroy();
    }
  
    // Convert our graph to Cytoscape format
    const cyElements = convertToCytoscapeElements(graph, filter);
  
    const cy = cytoscape({
      container: containerRef.current,
      elements: cyElements,
      style: [
        {
          selector: 'node',
          style: {
            'label': 'data(label)',
            'width': 'mapData(size, 0, 100, 20, 80)',
            'height': 'mapData(size, 0, 100, 20, 80)',
            'background-color': 'data(color)',
            'text-valign': 'center',
            'text-halign': 'center',
            'font-size': '8px'
          }
        },
        {
          selector: 'edge',
          style: {
            'width': 2,
            'line-color': '#ccc',
            'target-arrow-color': '#ccc',
            'target-arrow-shape': 'triangle'
          }
        }
      ],
      layout: {
        name: 'dagre',
        rankDir: 'TB',
        padding: 20
      }
    });
  
    // Add interactions
    cy.on('tap', 'node', (event) => {
      const node = event.target;
      const nodeId = node.data('id');
      if (onNodeClick) {
        onNodeClick(nodeId);
      }
    });
  
    cyRef.current = cy;
  
    return () => {
      if (cyRef.current) {
        cyRef.current.destroy();
        cyRef.current = null;
      }
    };
  }, [graph, filter]);
  
  return (
    <div 
      ref={containerRef} 
      className="w-full h-full bg-white rounded-lg border border-gray-200"
    />
  );
};

function convertToCytoscapeElements(
  graph: KnowledgeGraph, 
  filter?: (node: any) => boolean
) {
  const elements: any[] = [];
  
  // Add nodes
  for (const node of graph.nodes) {
    if (filter && !filter(node)) continue;
    elements.push({
      data: {
        id: node.id,
        label: getNodeLabel(node),
        type: node.label,
        color: getNodeColor(node.label),
        size: getNodeSize(node)
      }
    });
  }
  
  // Add edges
  for (const rel of graph.relationships) {
    elements.push({
      data: {
        id: rel.id,
        source: rel.source,
        target: rel.target,
        label: rel.type
      }
    });
  }
  
  return elements;
}
```

**How this works:**

1. Converts our graph data to Cytoscape's format
2. Sets up visual styles based on node type
3. Applies a hierarchical layout (dagre)
4. Adds interaction handlers for node clicks

**Why use Cytoscape.js?** It's specifically designed for graph visualization with:

- Multiple layout algorithms
- Good performance for medium-sized graphs
- Extensive customization options

### Step 10: Create Source Code Viewer

**Why this matters:** Seeing the graph isn't enough - users need to see the actual code behind the nodes.

**Implementation:**

```tsx
import React, { useState, useEffect } from 'react';
import { KnowledgeGraph } from '@/core/graph/types';

interface SourceViewerProps {
  graph: KnowledgeGraph;
  selectedNodeId: string | null;
}

export const SourceViewer: React.FC<SourceViewerProps> = ({ graph, selectedNodeId }) => {
  const [sourceCode, setSourceCode] = useState<string>('');
  const [fileName, setFileName] = useState<string>('');
  const [lineNumber, setLineNumber] = useState<number | null>(null);
  
  useEffect(() => {
    if (!selectedNodeId) {
      setSourceCode('');
      setFileName('');
      setLineNumber(null);
      return;
    }
  
    // Find the node in the graph
    const node = graph.nodes.find(n => n.id === selectedNodeId);
    if (!node) return;
  
    // For functions, get the source code
    if (node.label === 'Function' || node.label === 'Method') {
      const filePath = node.properties.path;
      const startLine = node.properties.start_line;
    
      // In a real implementation, you'd have the source code available
      setFileName(filePath);
      setLineNumber(startLine);
      setSourceCode(`# Source code for ${node.properties.qualified_name}
# Line ${startLine} and following...`);
    }
  }, [graph, selectedNodeId]);
  
  if (!selectedNodeId || !sourceCode) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50">
        <p className="text-gray-500">Select a node to view source code</p>
      </div>
    );
  }
  
  return (
    <div className="flex flex-col h-full">
      <div className="p-2 bg-gray-100 border-b border-gray-200 flex justify-between items-center">
        <span className="text-sm font-medium text-gray-700 truncate">{fileName}</span>
        {lineNumber && (
          <span className="text-xs text-gray-500">Line {lineNumber}</span>
        )}
      </div>
      <div className="flex-1 overflow-auto p-2 font-mono text-sm bg-black text-white">
        <pre>{sourceCode}</pre>
      </div>
    </div>
  );
};
```

**How this works:**

1. When a node is selected, it finds the corresponding code element
2. It displays the source code with line numbers
3. It highlights the relevant part of the code

**Why is this important?** It bridges the gap between the abstract graph and the concrete code, helping users understand what they're seeing.

## Phase 5: RAG Chat Interface

### Step 11: Implement LLM Service

**Why this matters:** The chat interface needs to connect to LLMs (Large Language Models) to translate natural language to graph queries.

**Key concepts:**

- We'll support multiple LLM providers (OpenAI, Anthropic, Gemini)
- Users provide their own API keys (privacy-focused)
- We need a consistent interface for different providers

**Implementation:**

```typescript
import { ChatOpenAI } from 'langchain/chat_models/openai';
import { ChatAnthropic } from 'langchain/chat_models/anthropic';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';

export type LLMProvider = 'openai' | 'anthropic' | 'gemini';

export interface LLMConfig {
  provider: LLMProvider;
  apiKey: string;
  model?: string;
}

export class LLMService {
  private config: LLMConfig;
  
  constructor(config: LLMConfig) {
    this.config = config;
  }
  
  getChatModel() {
    switch (this.config.provider) {
      case 'openai':
        return new ChatOpenAI({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'gpt-4-turbo',
          temperature: 0
        });
      case 'anthropic':
        return new ChatAnthropic({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'claude-3-sonnet-20240229',
          temperature: 0
        });
      case 'gemini':
        return new ChatGoogleGenerativeAI({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'gemini-1.5-pro-latest',
          temperature: 0
        });
      default:
        throw new Error(`Unsupported LLM provider: ${this.config.provider}`);
    }
  }
}
```

**How this works:**

1. The service takes an LLM configuration (provider, API key, model)
2. It returns a consistent chat model interface regardless of provider
3. It handles provider-specific initialization

**Why support multiple providers?** Different users have different preferences and API key availability.

### Step 12: Implement Cypher Generator

**Why this matters:** The core of the RAG system - translating natural language questions to graph queries.

**Key concepts:**

- We use a system prompt to instruct the LLM
- The prompt includes our graph schema
- We clean the response to get a valid Cypher query

**Implementation:**

```typescript
import { BaseChatModel } from 'langchain/chat_models/base';
import { CYPHER_SYSTEM_PROMPT } from '../prompts/cypher';

export class CypherGenerator {
  private llm: BaseChatModel;
  
  constructor(llm: BaseChatModel) {
    this.llm = llm;
  }
  
  async generate(naturalLanguageQuery: string): Promise<string> {
    const response = await this.llm.call([
      { role: 'system', content: CYPHER_SYSTEM_PROMPT },
      { role: 'user', content: naturalLanguageQuery }
    ]);
  
    return this.cleanResponse(response.content);
  }
  
  private cleanResponse(response: string): string {
    // Remove markdown code blocks
    let cleaned = response.replace(/```cypher/g, '').replace(/```/g, '');
    // Ensure it ends with a semicolon
    if (!cleaned.trim().endsWith(';')) {
      cleaned = cleaned.trim() + ';';
    }
    return cleaned;
  }
}
```

**How this works:**

1. It sends the natural language query with a system prompt to the LLM
2. The system prompt teaches the LLM about our graph structure
3. It cleans the response to extract a valid Cypher query

**Why is the system prompt important?** It provides the LLM with the context it needs to generate correct queries. Without it, the LLM wouldn't know about our graph schema.

### Step 13: Implement RAG Orchestrator

**Why this matters:** This is the "brain" of the system that coordinates the query process.

**Key concepts:**

- It follows a ReAct (Reason + Act) pattern
- It plans steps, uses tools, observes results, and responds
- It prevents hallucination by sticking to tool results

**Implementation:**

```typescript
import { BaseChatModel } from 'langchain/chat_models/base';
import { RAG_ORCHESTRATOR_SYSTEM_PROMPT } from '../prompts/rag-orchestrator';

export class RAGOrchestrator {
  private llm: BaseChatModel;
  
  constructor(llm: BaseChatModel) {
    this.llm = llm;
  }
  
  async query(
    userQuery: string,
    queryGraph: (cypher: string) => Promise<any>,
    retrieveCode: (nodeId: string) => Promise<string>
  ) {
    // Start with the system prompt
    let conversation = [
      { role: 'system', content: RAG_ORCHESTRATOR_SYSTEM_PROMPT }
    ];
  
    // Add the user's question
    conversation.push({ role: 'user', content: userQuery });
  
    // Simple ReAct loop
    for (let i = 0; i < 5; i++) { // Max 5 steps
      const response = await this.llm.call(conversation);
      const responseContent = response.content;
    
      // Check if the response contains a tool call
      if (responseContent.includes('Action: query_graph')) {
        const match = responseContent.match(/Action Input: (.*)/);
        if (match) {
          const cypherQuery = match[1].trim();
        
          // Execute the query
          const queryResults = await queryGraph(cypherQuery);
        
          // Add the observation to the conversation
          conversation.push({
            role: 'assistant',
            content: responseContent
          });
        
          conversation.push({
            role: 'system',
            content: `Observation: ${JSON.stringify(queryResults)}`
          });
        
          // If we have results, we might be done
          if (queryResults.length > 0) {
            break;
          }
        }
      } 
      else if (responseContent.includes('Action: retrieve_code')) {
        // Similar handling for code retrieval
      }
      else {
        // This appears to be the final answer
        return responseContent;
      }
    }
  
    // If we got here without a final answer, generate one
    conversation.push({
      role: 'user',
      content: 'Please provide your final answer based on the information gathered.'
    });
  
    const finalResponse = await this.llm.call(conversation);
    return finalResponse.content;
  }
}
```

**How this works:**

1. It starts with a system prompt that defines the rules
2. It sends the user's query to the LLM
3. The LLM responds with either:
   - A tool call (query_graph or retrieve_code)
   - A final answer
4. If it's a tool call, it executes the tool and adds the result to the conversation
5. It repeats until it gets a final answer or hits the step limit

**Why the step limit?** To prevent infinite loops if the LLM gets stuck.

## Phase 6: Main Application Integration

### Step 14: Create Main Application Component

**Why this matters:** This brings all the pieces together into a cohesive UI.

**Implementation:**

```tsx
import React, { useState, useRef } from 'react';
import { GraphVisualization } from '@/ui/components/graph/Visualization';
import { GraphControls } from '@/ui/components/graph/Controls';
import { SourceViewer } from '@/ui/components/graph/SourceViewer';
import { ChatInterface } from '@/ui/components/chat/ChatInterface';
import { KnowledgeGraph } from '@/core/graph/types';
import { GitHubService } from '@/services/github';
import { ZipService } from '@/services/zip';
import { ingestionWorkerApi } from '@/lib/workerUtils';

export const HomePage = () => {
  const [graph, setGraph] = useState<KnowledgeGraph | null>(null);
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [repoUrl, setRepoUrl] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  const handleRepoSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!repoUrl.trim() || isLoading) return;
  
    setIsLoading(true);
    setError(null);
  
    try {
      // Parse the GitHub URL
      const urlMatch = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
      if (!urlMatch) {
        throw new Error('Invalid GitHub repository URL');
      }
    
      const owner = urlMatch[1];
      const repo = urlMatch[2].replace(/\.git$/, '');
    
      // Fetch repository contents
      const githubService = new GitHubService();
      const contents = await githubService.getRepoContents(owner, repo);
    
      // Filter for Python files
      const pythonFiles = contents
        .filter((item: any) => item.type === 'file' && item.name.endsWith('.py'))
        .map((item: any) => item.path);
    
      // Fetch file contents
      const fileContents: Record<string, string> = {};
      for (const filePath of pythonFiles) {
        fileContents[filePath] = await githubService.getFileContent(owner, repo, filePath);
      }
    
      // Process the repository
      const projectName = `${owner}/${repo}`;
      const processedGraph = await ingestionWorkerApi.processRepository(
        repoUrl,
        projectName,
        pythonFiles,
        fileContents
      );
    
      setGraph(processedGraph);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to process repository');
      console.error('Processing error:', err);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleQuery = async (query: string): Promise<string> => {
    if (!graph) {
      throw new Error('No graph available');
    }
  
    // In a real implementation, this would use the RAG orchestrator
    return `I found information related to "${query}" in the codebase.`;
  };
  
  return (
    <div className="h-screen flex flex-col">
      {/* Header with repository input */}
      <header className="p-4 bg-white border-b border-gray-200">
        <div className="max-w-7xl mx-auto flex flex-col sm:flex-row sm:items-center gap-4">
          <h1 className="text-2xl font-bold text-gray-900">GitNexus</h1>
        
          <div className="flex-1 flex gap-2">
            <form onSubmit={handleRepoSubmit} className="flex-1">
              <div className="flex gap-2">
                <input
                  type="text"
                  value={repoUrl}
                  onChange={(e) => setRepoUrl(e.target.value)}
                  placeholder="https://github.com/owner/repo.git"
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                />
                <button
                  type="submit"
                  disabled={isLoading}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
                >
                  {isLoading ? 'Processing...' : 'Analyze'}
                </button>
              </div>
            </form>
          
            <div className="flex items-center">
              <span className="text-gray-500 mx-2">or</span>
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleZipUpload}
                accept=".zip"
                className="hidden"
                id="zip-upload"
              />
              <label
                htmlFor="zip-upload"
                className="px-3 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 cursor-pointer"
              >
                Upload ZIP
              </label>
            </div>
          </div>
        </div>
      </header>
    
      <main className="flex-1 max-w-7xl mx-auto w-full flex gap-4 p-4">
        {/* Graph Visualization Pane */}
        <div className="flex-1 flex flex-col min-w-0">
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col">
            {graph ? (
              <>
                <GraphControls 
                  onFilterChange={() => {}} 
                  onLayoutChange={() => {}} 
                />
                <div className="flex-1 min-h-0">
                  <GraphVisualization 
                    graph={graph} 
                    onNodeClick={setSelectedNodeId}
                  />
                </div>
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                {isLoading ? (
                  <div className="text-center">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
                    <p>Processing repository...</p>
                  </div>
                ) : (
                  <p>Enter a repository URL or upload a ZIP to get started</p>
                )}
              </div>
            )}
          </div>
        </div>
      
        {/* Right Panel */}
        <div className="w-80 flex flex-col gap-4">
          {/* Source Viewer */}
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col h-[40%]">
            <div className="p-3 border-b border-gray-200 bg-gray-50">
              <h2 className="text-sm font-medium text-gray-700">Source Code</h2>
            </div>
            {graph ? (
              <SourceViewer graph={graph} selectedNodeId={selectedNodeId} />
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                <p>Select a node to view source</p>
              </div>
            )}
          </div>
        
          {/* Chat Interface */}
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col h-[60%]">
            <div className="p-3 border-b border-gray-200 bg-gray-50">
              <h2 className="text-sm font-medium text-gray-700">Ask About Code</h2>
            </div>
            {graph ? (
              <ChatInterface graph={graph} onQuery={handleQuery} />
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500 p-4">
                <p>Process a repository to ask questions about the code</p>
              </div>
            )}
          </div>
        </div>
      </main>
    </div>
  );
};
```

**How this works:**

1. The header has inputs for GitHub URLs and ZIP uploads
2. The main area has two panes:
   - Left: Graph visualization
   - Right: Source viewer and chat interface
3. When a repository is processed, the graph is displayed
4. Users can click nodes to see source code and ask questions

**Why this layout?** It provides a cohesive experience where users can:

- See the big picture (graph)
- Drill down to specific code (source viewer)
- Ask questions about what they're seeing (chat)

## Final Steps: Testing and Optimization

### Step 15: Add Error Boundaries

**Why this matters:** Inevitably, something will go wrong. We want to handle errors gracefully.

**Implementation:**

```tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="p-4 bg-red-50 border border-red-200 rounded-md">
          <h2 className="text-lg font-medium text-red-800 mb-2">Something went wrong</h2>
          <p className="text-red-700 mb-2">{this.state.error?.message}</p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            className="px-3 py-1 bg-red-100 text-red-700 rounded-md hover:bg-red-200"
          >
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**How this works:**

- It catches JavaScript errors in child components
- It displays a friendly error message instead of a blank screen
- It allows users to try again without losing their work

**Why use error boundaries?** They prevent a single error from breaking the entire application.

### Step 16: Implement Performance Optimizations

**Why this matters:** Large repositories can be slow to process. We need to keep the UI responsive.

**Key optimizations:**

1. **Web Workers**: Already implemented for graph processing
2. **Progress Indicators**: Show users what's happening
3. **File Filtering**: Only process relevant files
4. **Lazy Loading**: Load components as needed

**Implementation:**

```tsx
// Add to your GitHub processing function
const MAX_FILES = 500; // Limit for free tier
if (pythonFiles.length > MAX_FILES) {
  // Offer to filter by directory or file pattern
  const shouldFilter = window.confirm(
    `Repository has ${pythonFiles.length} Python files (max ${MAX_FILES}). ` +
    `Would you like to filter by directory or file pattern?`
  );
  if (shouldFilter) {
    const filterPattern = prompt(
      "Enter a directory path or file pattern to filter (e.g., 'src/', '*.py')",
      "src/"
    );
    if (filterPattern) {
      const filteredFiles = pythonFiles.filter(file => 
        file.includes(filterPattern) || file.endsWith(filterPattern)
      );
      pythonFiles = filteredFiles;
    }
  }
}
```

**Why limit file processing?** Processing too many files can:

- Freeze the browser tab
- Exceed GitHub API rate limits
- Use excessive memory

### Step 17: Add Export Functionality

**Why this matters:** Users might want to save or share their generated graphs.

**Implementation:**

```tsx
export function exportGraphToJson(graph: KnowledgeGraph): string {
  return JSON.stringify(graph, null, 2);
}

export function downloadGraph(graph: KnowledgeGraph, filename: string = 'gitnexus-graph.json') {
  const json = exportGraphToJson(graph);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
```

**How this works:**

1. Converts the graph to JSON
2. Creates a downloadable file
3. Triggers a download

**Why include export?** It allows users to:

- Save their work for later
- Share graphs with teammates
- Use the data in other tools

## Conclusion

This implementation guide has walked you through building a complete edge-based code knowledge graph generator using Deno. By following these steps, you'll create a privacy-focused tool that runs entirely in the user's browser.

**Key advantages of this approach:**

- **Zero server costs**: All processing happens in the user's browser
- **Strong privacy**: Code never leaves the user's machine
- **Modular architecture**: Easy to add more languages later
- **Clear separation of concerns**: Makes the codebase maintainable
- **Deno compatibility**: Modern runtime with built-in TypeScript support

Remember to start small (Python support only) and iterate, adding more features and language support as you validate the core functionality. The most important part is getting the graph construction pipeline working correctly - everything else builds on that foundation.

================
File: src/ai/cypher-generator.ts
================
import { HumanMessage, SystemMessage } from '@langchain/core/messages';
import type { LLMService, LLMConfig } from './llm-service.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface CypherQuery {
  cypher: string;
  explanation: string;
  confidence: number;
  warnings?: string[];
}

export interface CypherGenerationOptions {
  maxRetries?: number;
  includeExamples?: boolean;
  strictMode?: boolean;
}

export class CypherGenerator {
  private llmService: LLMService;
  private graphSchema: string = '';
  
  // Common Cypher patterns and examples
  private static readonly CYPHER_EXAMPLES = [
    {
      question: "What functions are in the main.py file?",
      cypher: "MATCH (f:File {name: 'main.py'})-[:CONTAINS]->(func:Function) RETURN func.name"
    },
    {
      question: "Which functions call the authenticate function?",
      cypher: "MATCH (caller)-[:CALLS]->(target:Function {name: 'authenticate'}) RETURN caller.name"
    },
    {
      question: "Show me all classes in the project",
      cypher: "MATCH (c:Class) RETURN c.name, c.filePath"
    },
    {
      question: "What modules import numpy?",
      cypher: "MATCH (m:Module)-[:IMPORTS]->(lib) WHERE lib.name CONTAINS 'numpy' RETURN m.name"
    }
  ];

  constructor(llmService: LLMService) {
    this.llmService = llmService;
  }

  /**
   * Update the graph schema for better query generation
   */
  public updateSchema(graph: KnowledgeGraph): void {
    this.graphSchema = this.generateSchemaDescription(graph);
  }

  /**
   * Generate a Cypher query from natural language
   */
  public async generateQuery(
    question: string,
    llmConfig: LLMConfig,
    options: CypherGenerationOptions = {}
  ): Promise<CypherQuery> {
    const { maxRetries = 2, includeExamples = true, strictMode = false } = options;
    
    let lastError: string | null = null;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const systemPrompt = this.buildSystemPrompt(includeExamples, strictMode, lastError);
        const userPrompt = this.buildUserPrompt(question);
        
        const messages = [
          new SystemMessage(systemPrompt),
          new HumanMessage(userPrompt)
        ];
        
        const response = await this.llmService.chat(llmConfig, messages);
        const result = this.parseResponse(response.content);
        
        // Validate the generated query
        const validation = this.validateQuery(result.cypher);
        if (!validation.isValid) {
          lastError = validation.error!;
          if (attempt < maxRetries) {
            console.warn(`Query validation failed (attempt ${attempt + 1}): ${validation.error}`);
            continue;
          }
        }
        
        return {
          ...result,
          warnings: validation.warnings
        };
        
      } catch (error) {
        lastError = error instanceof Error ? error.message : 'Unknown error';
        if (attempt < maxRetries) {
          console.warn(`Query generation failed (attempt ${attempt + 1}): ${lastError}`);
          continue;
        }
        
        throw new Error(`Failed to generate Cypher query after ${maxRetries + 1} attempts: ${lastError}`);
      }
    }
    
    throw new Error('Unexpected error in query generation');
  }

  /**
   * Build the system prompt with schema and examples
   */
  private buildSystemPrompt(includeExamples: boolean, strictMode: boolean, lastError?: string | null): string {
    let prompt = `You are a Cypher query expert for a code knowledge graph. Your task is to convert natural language questions into valid Cypher queries.

GRAPH SCHEMA:
${this.graphSchema}

NODE TYPES:
- Project: Root project node
- Folder: Directory containers
- File: Source code files
- Module: Python modules (.py files)
- Class: Class definitions
- Function: Function definitions
- Method: Class method definitions
- Variable: Variable declarations

RELATIONSHIP TYPES:
- CONTAINS: Hierarchical containment (Project->Folder, Folder->File, File->Function, etc.)
- CALLS: Function/method calls between code entities
- INHERITS: Class inheritance relationships
- IMPORTS: Module import relationships
- OVERRIDES: Method override relationships

IMPORTANT RULES:
1. Always use MATCH patterns to find nodes
2. Use WHERE clauses for filtering by properties
3. Node properties include: name, filePath, startLine, endLine, type
4. Return meaningful information, not just node IDs
5. Use case-insensitive matching when appropriate (e.g., WHERE toLower(n.name) CONTAINS toLower('search'))
6. Prefer specific node types over generic matches
7. Always return results in a readable format`;

    if (includeExamples) {
      prompt += `\n\nEXAMPLES:`;
      for (const example of CypherGenerator.CYPHER_EXAMPLES) {
        prompt += `\nQ: "${example.question}"\nA: ${example.cypher}\n`;
      }
    }

    if (strictMode) {
      prompt += `\n\nSTRICT MODE: Only generate queries that exactly match the schema. Do not make assumptions about node properties that aren't explicitly defined.`;
    }

    if (lastError) {
      prompt += `\n\nPREVIOUS ERROR: The last query attempt failed with: "${lastError}". Please fix this issue in your new query.`;
    }

    prompt += `\n\nRESPONSE FORMAT:
Provide your response in this exact JSON format:
{
  "cypher": "your cypher query here",
  "explanation": "brief explanation of what the query does",
  "confidence": 0.85
}

The confidence should be a number between 0 and 1 indicating how confident you are in the query.`;

    return prompt;
  }

  /**
   * Build the user prompt with the question
   */
  private buildUserPrompt(question: string): string {
    return `Please convert this question to a Cypher query: "${question}"`;
  }

  /**
   * Parse the LLM response to extract Cypher query
   */
  private parseResponse(response: string): { cypher: string; explanation: string; confidence: number } {
    try {
      // Try to extract JSON from the response
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          cypher: parsed.cypher || '',
          explanation: parsed.explanation || '',
          confidence: parsed.confidence || 0.5
        };
      }
      
      // Fallback: try to extract Cypher from code blocks
      const cypherMatch = response.match(/```(?:cypher)?\s*(.*?)\s*```/s);
      if (cypherMatch) {
        return {
          cypher: cypherMatch[1].trim(),
          explanation: 'Generated Cypher query',
          confidence: 0.7
        };
      }
      
      // Last resort: use the entire response as cypher
      return {
        cypher: response.trim(),
        explanation: 'Raw LLM response',
        confidence: 0.3
      };
      
    } catch (error) {
      throw new Error(`Failed to parse LLM response: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate the generated Cypher query
   */
  private validateQuery(cypher: string): { isValid: boolean; error?: string; warnings?: string[] } {
    const warnings: string[] = [];
    
    if (!cypher || cypher.trim().length === 0) {
      return { isValid: false, error: 'Empty query generated' };
    }
    
    // Basic syntax checks
    const upperCypher = cypher.toUpperCase();
    
    // Must have MATCH or CREATE or other valid starting keywords
    if (!upperCypher.match(/^\s*(MATCH|CREATE|MERGE|WITH|RETURN|CALL|SHOW)/)) {
      return { isValid: false, error: 'Query must start with a valid Cypher keyword (MATCH, CREATE, etc.)' };
    }
    
    // Check for balanced parentheses
    const openParens = (cypher.match(/\(/g) || []).length;
    const closeParens = (cypher.match(/\)/g) || []).length;
    if (openParens !== closeParens) {
      return { isValid: false, error: 'Unbalanced parentheses in query' };
    }
    
    // Check for balanced brackets
    const openBrackets = (cypher.match(/\[/g) || []).length;
    const closeBrackets = (cypher.match(/\]/g) || []).length;
    if (openBrackets !== closeBrackets) {
      return { isValid: false, error: 'Unbalanced brackets in query' };
    }
    
    // Check for balanced braces
    const openBraces = (cypher.match(/\{/g) || []).length;
    const closeBraces = (cypher.match(/\}/g) || []).length;
    if (openBraces !== closeBraces) {
      return { isValid: false, error: 'Unbalanced braces in query' };
    }
    
    // Warn about potentially expensive operations
    if (upperCypher.includes('MATCH ()') || upperCypher.includes('MATCH (*)')) {
      warnings.push('Query matches all nodes - this could be expensive');
    }
    
    if (!upperCypher.includes('RETURN') && !upperCypher.includes('DELETE') && !upperCypher.includes('SET')) {
      warnings.push('Query does not return results');
    }
    
    return { isValid: true, warnings };
  }

  /**
   * Generate a schema description from the knowledge graph
   */
  private generateSchemaDescription(graph: KnowledgeGraph): string {
    const nodeTypes = new Set<string>();
    const relationshipTypes = new Set<string>();
    const nodeProperties = new Map<string, Set<string>>();
    
    // Analyze nodes
    graph.nodes.forEach(node => {
      nodeTypes.add(node.label);
      
      if (!nodeProperties.has(node.label)) {
        nodeProperties.set(node.label, new Set());
      }
      
      Object.keys(node.properties).forEach(prop => {
        nodeProperties.get(node.label)!.add(prop);
      });
    });
    
    // Analyze relationships
    graph.relationships.forEach(rel => {
      relationshipTypes.add(rel.type);
    });
    
    let schema = `NODES (${graph.nodes.length} total):\n`;
    for (const nodeType of Array.from(nodeTypes).sort()) {
      const props = nodeProperties.get(nodeType);
      const propList = props ? Array.from(props).sort().join(', ') : 'none';
      const count = graph.nodes.filter(n => n.label === nodeType).length;
      schema += `- ${nodeType} (${count}): ${propList}\n`;
    }
    
    schema += `\nRELATIONSHIPS (${graph.relationships.length} total):\n`;
    for (const relType of Array.from(relationshipTypes).sort()) {
      const count = graph.relationships.filter(r => r.type === relType).length;
      schema += `- ${relType} (${count})\n`;
    }
    
    return schema;
  }

  /**
   * Get the current schema description
   */
  public getSchema(): string {
    return this.graphSchema;
  }

  /**
   * Clean and format a Cypher query
   */
  public cleanQuery(cypher: string): string {
    return cypher
      .trim()
      .replace(/\s+/g, ' ')
      .replace(/\s*([(),\[\]{}])\s*/g, '$1')
      .replace(/\s*([=<>!]+)\s*/g, ' $1 ')
      .replace(/\s+/g, ' ')
      .trim();
  }
}

================
File: src/ai/index.ts
================
export { LLMService, type LLMProvider, type LLMConfig, type ChatResponse } from './llm-service.ts';
export { CypherGenerator, type CypherQuery, type CypherGenerationOptions } from './cypher-generator.ts';
export { 
  RAGOrchestrator, 
  type RAGContext, 
  type RAGResponse, 
  type RAGOptions, 
  type ToolResult, 
  type ReasoningStep 
} from './orchestrator.ts';
export {
  LangChainRAGOrchestrator,
  type LangChainRAGContext,
  type LangChainRAGResponse,
  type LangChainRAGOptions
} from './langchain-orchestrator.ts';

================
File: src/ai/langchain-orchestrator.ts
================
import { createReactAgent } from '@langchain/langgraph/prebuilt';
import { MemorySaver } from '@langchain/langgraph';
import { DynamicStructuredTool } from '@langchain/core/tools';
import { z } from 'zod';
import { SystemMessage } from '@langchain/core/messages';
import type { LLMService, LLMConfig } from './llm-service.ts';
import type { CypherGenerator } from './cypher-generator.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface LangChainRAGContext {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
}

export interface ToolCall {
  tool: string;
  input: Record<string, unknown>;
  output: string;
}

export interface LangChainRAGResponse {
  answer: string;
  sources: string[];
  confidence: number;
  toolCalls: ToolCall[];
}

export interface LangChainRAGOptions {
  maxIterations?: number;
  temperature?: number;
  enableMemory?: boolean;
  threadId?: string;
}

type AgentType = ReturnType<typeof createReactAgent>;
type MemoryType = InstanceType<typeof MemorySaver>;

export class LangChainRAGOrchestrator {
  private llmService: LLMService;
  private cypherGenerator: CypherGenerator;
  private context: LangChainRAGContext | null = null;
  private agent: AgentType | null = null;
  private memory: MemoryType | null = null;

  constructor(llmService: LLMService, cypherGenerator: CypherGenerator) {
    this.llmService = llmService;
    this.cypherGenerator = cypherGenerator;
    this.memory = new MemorySaver();
  }

  /**
   * Set the current context and initialize the agent
   */
  public async setContext(context: LangChainRAGContext, llmConfig: LLMConfig): Promise<void> {
    this.context = context;
    this.cypherGenerator.updateSchema(context.graph);

    // Create LangChain-compliant tools
    const tools = this.createTools(llmConfig);

    // Get the LLM from our service
    const llm = this.llmService.getChatModel(llmConfig);

    // Create system message for ReAct behavior
    const systemMessage = this.buildSystemMessage();

    // Create the ReAct agent using LangGraph
    const graph = createReactAgent({
      llm: llm as any,
      tools: tools as any,
      // Optional system message
      messageModifier: systemMessage as any
    });
    
    this.agent = graph;
  }

  /**
   * Answer a question using the LangChain ReAct agent
   */
  public async answerQuestion(
    question: string,
    options: LangChainRAGOptions = {}
  ): Promise<LangChainRAGResponse> {
    if (!this.agent || !this.context) {
      throw new Error('Agent not initialized. Call setContext() first.');
    }

    const {
      maxIterations = 10,
      enableMemory = false,
      threadId = 'default'
    } = options;

    try {
      const config = enableMemory 
        ? { 
            configurable: { thread_id: threadId },
            recursionLimit: maxIterations
          }
        : { recursionLimit: maxIterations };

      // Stream the agent execution
      const stream = await this.agent.stream(
        { messages: [{ role: "user", content: question }] },
        config
      );

      let finalAnswer = '';
      const toolCalls: ToolCall[] = [];
      const sources: string[] = [];

      // Process the stream
      for await (const chunk of stream) {
        if (chunk.agent) {
          finalAnswer = chunk.agent.messages[chunk.agent.messages.length - 1].content;
        }
        
        if (chunk.tools) {
          const toolMessage = chunk.tools.messages[chunk.tools.messages.length - 1];
          if (toolMessage.tool_calls) {
            toolMessage.tool_calls.forEach((toolCall: { name: string; args: Record<string, unknown> }) => {
              toolCalls.push({
                tool: toolCall.name,
                input: toolCall.args,
                output: toolMessage.content || ''
              });
            });
          }
        }
      }

      // Calculate confidence based on successful tool usage
      const confidence = this.calculateConfidence(toolCalls);

      return {
        answer: finalAnswer || 'I was unable to find a complete answer to your question.',
        sources: Array.from(new Set(sources)),
        confidence,
        toolCalls
      };

    } catch (error) {
      throw new Error(`LangChain RAG orchestration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Create LangChain-compliant tools
   */
  private createTools(llmConfig: LLMConfig) {
    const queryGraphTool = new DynamicStructuredTool({
      name: "query_graph",
      description: "Query the code knowledge graph using natural language. Use this to find information about code structure, relationships, functions, classes, etc.",
      schema: z.object({
        question: z.string().describe("Natural language question about the codebase")
      }),
      func: async (input: { question: string }) => {
        try {
          const cypherQuery = await this.cypherGenerator.generateQuery(input.question, llmConfig);
          const mockResults = this.simulateGraphQuery(cypherQuery.cypher);
          
          return `Query: ${cypherQuery.cypher}\n\nResults:\n${mockResults}\n\nExplanation: ${cypherQuery.explanation}`;
        } catch (error) {
          return `Error generating graph query: ${error instanceof Error ? error.message : 'Unknown error'}`;
        }
      }
    });

    const getCodeContentTool = new DynamicStructuredTool({
      name: "get_code_content",
      description: "Retrieve the source code content of a specific file. Use this when you need to examine the actual code implementation.",
      schema: z.object({
        filePath: z.string().describe("The path to the file whose content you want to retrieve")
      }),
      func: async (input: { filePath: string }) => {
        if (!this.context) {
          return 'No context available';
        }

        const content = this.context.fileContents.get(input.filePath);
        if (!content) {
          // Try to find similar file paths
          const similarFiles = Array.from(this.context.fileContents.keys())
            .filter(path => path.includes(input.filePath) || input.filePath.includes(path))
            .slice(0, 3);

          if (similarFiles.length > 0) {
            return `File not found. Similar files available: ${similarFiles.join(', ')}`;
          }
          return 'File not found';
        }

        return `File: ${input.filePath}\n\n${content}`;
      }
    });

    const searchFilesTool = new DynamicStructuredTool({
      name: "search_files",
      description: "Search for files matching a pattern or containing specific text. Use this to find relevant files in the codebase.",
      schema: z.object({
        pattern: z.string().describe("Search pattern or text to look for in file names or content")
      }),
      func: async (input: { pattern: string }) => {
        if (!this.context) {
          return 'No context available';
        }

        const matchingFiles: string[] = [];
        const lowerPattern = input.pattern.toLowerCase();

        // Search in file paths
        for (const filePath of this.context.fileContents.keys()) {
          if (filePath.toLowerCase().includes(lowerPattern)) {
            matchingFiles.push(filePath);
          }
        }

        // Search in file contents
        for (const [filePath, content] of this.context.fileContents.entries()) {
          if (!matchingFiles.includes(filePath) && 
              content.toLowerCase().includes(lowerPattern)) {
            matchingFiles.push(filePath);
          }
        }

        return matchingFiles.length > 0 
          ? `Found ${matchingFiles.length} files:\n${matchingFiles.slice(0, 10).join('\n')}${matchingFiles.length > 10 ? '\n... and more' : ''}`
          : 'No files found matching the pattern';
      }
    });

    return [queryGraphTool, getCodeContentTool, searchFilesTool];
  }

  /**
   * Build system message for ReAct behavior
   */
  private buildSystemMessage(): SystemMessage {
    const systemPrompt = `You are an expert code analyst that helps users understand codebases by using available tools.

You have access to the following tools:
1. query_graph: Query the code knowledge graph using natural language
2. get_code_content: Retrieve the source code content of a specific file  
3. search_files: Search for files matching a pattern or containing specific text

IMPORTANT GUIDELINES:
- Always think step by step about what information you need
- Use tools to gather factual information before providing answers
- Base your responses ONLY on information retrieved from tools
- If you cannot find information, say so explicitly
- Provide helpful, accurate answers about the codebase structure and functionality
- When referencing code, always cite the specific files you examined

Your goal is to provide accurate, evidence-based answers about the codebase using the available tools.`;

    return new SystemMessage(systemPrompt);
  }

  /**
   * Simulate graph query execution (same as before)
   */
  private simulateGraphQuery(cypher: string): string {
    if (!this.context) return 'No context available';

    const upperCypher = cypher.toUpperCase();
    
    if (upperCypher.includes('FUNCTION') && upperCypher.includes('RETURN')) {
      const functions = this.context.graph.nodes
        .filter(n => n.label === 'Function')
        .slice(0, 5)
        .map(n => `${n.properties.name} (${n.properties.filePath})`)
        .join('\n');
      return functions || 'No functions found';
    }
    
    if (upperCypher.includes('CLASS') && upperCypher.includes('RETURN')) {
      const classes = this.context.graph.nodes
        .filter(n => n.label === 'Class')
        .slice(0, 5)
        .map(n => `${n.properties.name} (${n.properties.filePath})`)
        .join('\n');
      return classes || 'No classes found';
    }
    
    if (upperCypher.includes('FILE') && upperCypher.includes('RETURN')) {
      const files = this.context.graph.nodes
        .filter(n => n.label === 'File')
        .slice(0, 5)
        .map(n => n.properties.name)
        .join('\n');
      return files || 'No files found';
    }

    return 'Query executed successfully (simulated)';
  }

  /**
   * Calculate confidence based on tool usage
   */
  private calculateConfidence(toolCalls: ToolCall[]): number {
    if (toolCalls.length === 0) return 0.3;

    const successfulCalls = toolCalls.filter(call => 
      !call.output.includes('Error') && 
      !call.output.includes('not found') &&
      call.output.length > 10
    ).length;

    const baseConfidence = 0.5;
    const toolBonus = (successfulCalls / toolCalls.length) * 0.4;
    
    return Math.min(0.95, Math.max(0.1, baseConfidence + toolBonus));
  }

  /**
   * Get current context information
   */
  public getContextInfo(): { nodeCount: number; fileCount: number; hasContext: boolean; hasAgent: boolean } {
    return {
      nodeCount: this.context?.graph.nodes.length || 0,
      fileCount: this.context?.fileContents.size || 0,
      hasContext: !!this.context,
      hasAgent: !!this.agent
    };
  }

  /**
   * Clear memory for a specific thread
   */
  public async clearMemory(threadId: string): Promise<void> {
    if (this.memory) {
      // Note: MemorySaver doesn't have a direct clear method in the current API
      // This would need to be implemented based on the specific memory backend
      console.log(`Memory clearing not implemented for thread: ${threadId}`);
    }
  }
}

================
File: src/ai/llm-service.ts
================
import { ChatOpenAI } from '@langchain/openai';
import { AzureChatOpenAI } from '@langchain/openai';
import { ChatAnthropic } from '@langchain/anthropic';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';
import type { BaseMessage } from '@langchain/core/messages';
import type { BaseChatModel } from '@langchain/core/language_models/chat_models';
import { HumanMessage } from '@langchain/core/messages';

export type LLMProvider = 'openai' | 'azure-openai' | 'anthropic' | 'gemini';

export interface LLMConfig {
  provider: LLMProvider;
  apiKey: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  maxRetries?: number;
  // Azure OpenAI specific fields
  azureOpenAIEndpoint?: string;
  azureOpenAIApiVersion?: string;
  azureOpenAIDeploymentName?: string;
}

export interface ChatResponse {
  content: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  model?: string;
  finishReason?: string;
}

export class LLMService {
  private models: Map<string, BaseChatModel> = new Map();
  private defaultConfig: Partial<LLMConfig> = {
    temperature: 0.1,
    maxTokens: 4000,
    maxRetries: 3,
    azureOpenAIApiVersion: '2024-02-01' // Default Azure OpenAI API version
  };

  // Default models for each provider
  private static readonly DEFAULT_MODELS: Record<LLMProvider, string> = {
    openai: 'gpt-4o-mini',
    'azure-openai': 'gpt-4o-mini',
    anthropic: 'claude-3-haiku-20240307',
    gemini: 'gemini-2.5-flash'  // Use the latest 2.5 Flash model as default (2025)
  };

  constructor() {}

  /**
   * Initialize or get a chat model for the specified provider
   */
  public getChatModel(config: LLMConfig): any {
    const cacheKey = this.getCacheKey(config);
    
    if (this.models.has(cacheKey)) {
      return this.models.get(cacheKey)!;
    }

    const model = this.createChatModel(config);
    this.models.set(cacheKey, model);
    return model;
  }

  /**
   * Send a chat message and get a response
   */
  public async chat(
    config: LLMConfig,
    messages: BaseMessage[],
    options?: { stream?: boolean }
  ): Promise<ChatResponse> {
    try {
      const model = this.getChatModel(config);
      
      if (options?.stream) {
        // For streaming, we'd need to handle this differently
        // For now, we'll just use regular invoke
        console.warn('Streaming not implemented yet, falling back to regular invoke');
      }

      const response = await model.invoke(messages);
      
      return {
        content: response.content as string,
        usage: response.response_metadata?.usage ? {
          promptTokens: response.response_metadata.usage.prompt_tokens || 0,
          completionTokens: response.response_metadata.usage.completion_tokens || 0,
          totalTokens: response.response_metadata.usage.total_tokens || 0
        } : undefined,
        model: config.model || LLMService.DEFAULT_MODELS[config.provider],
        finishReason: response.response_metadata?.finish_reason
      };
    } catch (error) {
      throw new Error(`LLM chat failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate API key format for different providers
   */
  public validateApiKey(provider: LLMProvider, apiKey: string): boolean {
    if (!apiKey || apiKey.trim().length === 0) {
      return false;
    }

    switch (provider) {
      case 'openai':
        return apiKey.startsWith('sk-') && apiKey.length > 20;
      case 'azure-openai':
        // Azure OpenAI keys are typically 32 characters long and don't have a specific prefix
        return apiKey.length >= 20; // More flexible validation for Azure keys
      case 'anthropic':
        return apiKey.startsWith('sk-ant-') && apiKey.length > 20;
      case 'gemini':
        return apiKey.length > 20; // Google API keys don't have a consistent prefix
      default:
        return false;
    }
  }

  /**
   * Validate Azure OpenAI configuration
   */
  public validateAzureOpenAIConfig(config: LLMConfig): { valid: boolean; error?: string } {
    if (config.provider !== 'azure-openai') {
      return { valid: false, error: 'Provider must be azure-openai' };
    }

    if (!config.azureOpenAIEndpoint) {
      return { valid: false, error: 'Azure OpenAI endpoint is required' };
    }

    if (!config.azureOpenAIEndpoint.includes('openai.azure.com')) {
      return { valid: false, error: 'Invalid Azure OpenAI endpoint format. Should contain "openai.azure.com"' };
    }

    if (!config.azureOpenAIDeploymentName) {
      return { valid: false, error: 'Azure OpenAI deployment name is required' };
    }

    return { valid: true };
  }

  /**
   * Get available models for a provider
   */
  public getAvailableModels(provider: LLMProvider): string[] {
    switch (provider) {
      case 'openai':
        return [
          'gpt-4o',
          'gpt-4o-mini',
          'gpt-4-turbo',
          'gpt-4',
          'gpt-3.5-turbo'
        ];
      case 'azure-openai':
        return [
          'gpt-4o',
          'gpt-4o-mini', 
          'gpt-4.1-mini-v2', // Common deployment name
          'gpt-4-turbo',
          'gpt-4',
          'gpt-35-turbo', // Note: Azure uses gpt-35-turbo instead of gpt-3.5-turbo
          'gpt-4-32k'
        ];
      case 'anthropic':
        return [
          'claude-3-5-sonnet-20241022',
          'claude-3-5-haiku-20241022',
          'claude-3-opus-20240229',
          'claude-3-sonnet-20240229',
          'claude-3-haiku-20240307'
        ];
      case 'gemini':
        return [
          'gemini-2.5-flash',         // Latest and fastest (2025) - NEW DEFAULT
          'gemini-2.5-pro',           // Latest pro model (2025) - PREMIUM
          'gemini-1.5-flash',         // Most stable and widely available
          'gemini-1.5-pro',           // Stable pro model
          'gemini-1.0-pro',           // Legacy but very stable
          'gemini-1.5-flash-8b',      // Smaller, efficient version
          'gemini-2.0-flash',         // Newer model (may not be available to all users)
          'gemini-2.0-flash-lite'     // Lightweight version
        ];
      default:
        return [];
    }
  }

  /**
   * Get provider display name
   */
  public getProviderDisplayName(provider: LLMProvider): string {
    switch (provider) {
      case 'openai':
        return 'OpenAI';
      case 'azure-openai':
        return 'Azure OpenAI';
      case 'anthropic':
        return 'Anthropic';
      case 'gemini':
        return 'Google Gemini';
      default:
        return provider;
    }
  }

  /**
   * Test connection with the provider
   */
  public async testConnection(config: LLMConfig): Promise<{ success: boolean; error?: string }> {
    try {
      // Validate Azure OpenAI config if needed
      if (config.provider === 'azure-openai') {
        const validation = this.validateAzureOpenAIConfig(config);
        if (!validation.valid) {
          return {
            success: false,
            error: validation.error
          };
        }
      }

      const model = this.createChatModel(config);
      
      // Send a simple test message
      const testMessages = [
        new HumanMessage("Test connection")
      ];
      
      await model.invoke(testMessages);
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Connection test failed'
      };
    }
  }

  /**
   * Clear cached models (useful for updating API keys)
   */
  public clearCache(): void {
    this.models.clear();
  }

  /**
   * Create a chat model instance based on the provider
   */
  private createChatModel(config: LLMConfig): any {
    const mergedConfig = { ...this.defaultConfig, ...config };
    const model = mergedConfig.model || LLMService.DEFAULT_MODELS[config.provider];

    switch (config.provider) {
      case 'openai':
        return new ChatOpenAI({
          apiKey: config.apiKey,
          model,
          temperature: mergedConfig.temperature,
          maxTokens: mergedConfig.maxTokens,
          maxRetries: mergedConfig.maxRetries,
          timeout: 30000
        });

      case 'azure-openai':
        return new AzureChatOpenAI({
          azureOpenAIApiKey: config.apiKey,
          model: config.azureOpenAIDeploymentName, // Use deployment name as model
          temperature: mergedConfig.temperature,
          maxTokens: mergedConfig.maxTokens,
          maxRetries: mergedConfig.maxRetries,
          timeout: 30000,
          azureOpenAIApiInstanceName: config.azureOpenAIEndpoint?.replace('https://', '').split('.')[0],
          azureOpenAIApiVersion: config.azureOpenAIApiVersion,
          azureOpenAIApiDeploymentName: config.azureOpenAIDeploymentName
        });

      case 'anthropic':
        return new ChatAnthropic({
          model: config.model || 'claude-3-sonnet-20240229',
          anthropicApiKey: config.apiKey,
          maxTokens: config.maxTokens || 4096,
          temperature: config.temperature || 0.7
        });

      case 'gemini':
        return new ChatGoogleGenerativeAI({
          apiKey: config.apiKey,
          model,
          temperature: mergedConfig.temperature,
          maxOutputTokens: mergedConfig.maxTokens,
          maxRetries: mergedConfig.maxRetries
        });

      default:
        throw new Error(`Unsupported provider: ${config.provider}`);
    }
  }

  /**
   * Generate cache key for model instances
   */
  private getCacheKey(config: LLMConfig): string {
    const model = config.model || LLMService.DEFAULT_MODELS[config.provider];
    let baseKey = `${config.provider}:${model}:${config.apiKey.slice(-8)}:${config.temperature}:${config.maxTokens}`;
    
    // Add Azure OpenAI specific fields to cache key
    if (config.provider === 'azure-openai') {
      baseKey += `:${config.azureOpenAIEndpoint}:${config.azureOpenAIDeploymentName}:${config.azureOpenAIApiVersion}`;
    }
    
    return baseKey;
  }
}

================
File: src/ai/orchestrator.ts
================
import { HumanMessage, SystemMessage, AIMessage } from '@langchain/core/messages';
import type { LLMService, LLMConfig } from './llm-service.ts';
import type { CypherGenerator, CypherQuery } from './cypher-generator.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface RAGContext {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
}

export interface ToolResult {
  toolName: string;
  input: string;
  output: string;
  success: boolean;
  error?: string;
}

export interface ReasoningStep {
  step: number;
  thought: string;
  action: string;
  actionInput: string;
  observation: string;
  toolResult?: ToolResult;
}

export interface RAGResponse {
  answer: string;
  reasoning: ReasoningStep[];
  cypherQueries: CypherQuery[];
  confidence: number;
  sources: string[];
}

export interface RAGOptions {
  maxReasoningSteps?: number;
  includeReasoning?: boolean;
  strictMode?: boolean;
  temperature?: number;
}

export class RAGOrchestrator {
  private llmService: LLMService;
  private cypherGenerator: CypherGenerator;
  private context: RAGContext | null = null;

  constructor(llmService: LLMService, cypherGenerator: CypherGenerator) {
    this.llmService = llmService;
    this.cypherGenerator = cypherGenerator;
  }

  /**
   * Set the current context (graph and file contents)
   */
  public setContext(context: RAGContext): void {
    this.context = context;
    this.cypherGenerator.updateSchema(context.graph);
  }

  /**
   * Answer a question using ReAct pattern
   */
  public async answerQuestion(
    question: string,
    llmConfig: LLMConfig,
    options: RAGOptions = {}
  ): Promise<RAGResponse> {
    if (!this.context) {
      throw new Error('Context not set. Call setContext() first.');
    }

    const {
      maxReasoningSteps = 5,
      includeReasoning = true,
      strictMode = false,
      temperature = 0.1
    } = options;

    const reasoning: ReasoningStep[] = [];
    const cypherQueries: CypherQuery[] = [];
    const sources: string[] = [];

    // Enhanced LLM config for reasoning
    const reasoningConfig: LLMConfig = {
      ...llmConfig,
      temperature: temperature
    };

    let currentStep = 1;
    let finalAnswer = '';
    let confidence = 0.5;

    try {
      // Initial system prompt for ReAct
      const systemPrompt = this.buildReActSystemPrompt(strictMode);
      const conversation = [new SystemMessage(systemPrompt)];

      // Add the user question
      conversation.push(new HumanMessage(`Question: ${question}`));

      while (currentStep <= maxReasoningSteps) {
        // Get reasoning from LLM
        const response = await this.llmService.chat(reasoningConfig, conversation);
        const reasoning_step = this.parseReasoningStep(response.content, currentStep);

        reasoning.push(reasoning_step);

        // Check if we have a final answer
        if (reasoning_step.action.toLowerCase().includes('final_answer')) {
          finalAnswer = reasoning_step.actionInput;
          confidence = this.calculateConfidence(reasoning, cypherQueries);
          break;
        }

        // Execute the action
        let toolResult: ToolResult | null = null;
        
        try {
          if (reasoning_step.action.toLowerCase().includes('query_graph')) {
            toolResult = await this.executeGraphQuery(reasoning_step.actionInput, reasoningConfig);
            if (toolResult.success) {
              cypherQueries.push(...this.extractCypherQueries(toolResult));
            }
          } else if (reasoning_step.action.toLowerCase().includes('get_code')) {
            toolResult = await this.getCodeContent(reasoning_step.actionInput);
            if (toolResult.success) {
              sources.push(...this.extractSources(toolResult));
            }
          } else if (reasoning_step.action.toLowerCase().includes('search_files')) {
            toolResult = await this.searchFiles(reasoning_step.actionInput);
          } else {
            toolResult = {
              toolName: 'unknown',
              input: reasoning_step.actionInput,
              output: 'Unknown action type',
              success: false,
              error: `Unknown action: ${reasoning_step.action}`
            };
          }
        } catch (error) {
          toolResult = {
            toolName: reasoning_step.action,
            input: reasoning_step.actionInput,
            output: '',
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          };
        }

        // Update the reasoning step with tool result
        reasoning_step.observation = toolResult.output;
        reasoning_step.toolResult = toolResult;

        // Add the tool result to conversation
        conversation.push(new AIMessage(response.content));
        conversation.push(new HumanMessage(`Observation: ${toolResult.output}`));

        currentStep++;
      }

      // If we didn't get a final answer, generate one based on the reasoning
      if (!finalAnswer && reasoning.length > 0) {
        const summaryPrompt = this.buildSummaryPrompt(question, reasoning);
        conversation.push(new HumanMessage(summaryPrompt));
        
        const summaryResponse = await this.llmService.chat(reasoningConfig, conversation);
        finalAnswer = summaryResponse.content;
        confidence = Math.max(0.3, confidence - 0.2); // Lower confidence for incomplete reasoning
      }

      return {
        answer: finalAnswer || 'I was unable to find a complete answer to your question.',
        reasoning: includeReasoning ? reasoning : [],
        cypherQueries,
        confidence,
        sources: Array.from(new Set(sources)) // Remove duplicates
      };

    } catch (error) {
      throw new Error(`RAG orchestration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Build the ReAct system prompt
   */
  private buildReActSystemPrompt(strictMode: boolean): string {
    const prompt = `You are an expert code analyst using a ReAct (Reasoning + Acting) approach to answer questions about a codebase.

You have access to the following tools:
1. query_graph(question): Query the code knowledge graph using natural language
2. get_code(file_path): Retrieve the source code content of a specific file
3. search_files(pattern): Search for files matching a pattern or containing specific text

IMPORTANT INSTRUCTIONS:
- Always think step by step using the format: Thought: [your reasoning]
- Then specify an action using: Action: [tool_name]
- Provide the input using: Action Input: [input for the tool]
- After receiving an observation, continue reasoning or provide a final answer
- Use Final Answer: [your answer] when you have sufficient information
- Base your answers ONLY on the information retrieved from tools
- Do not make assumptions or hallucinate information
- If you cannot find information, say so explicitly

RESPONSE FORMAT:
Thought: [Your reasoning about what to do next]
Action: [query_graph, get_code, search_files, or Final Answer]
Action Input: [The input for the action]

After receiving an Observation, continue with:
Thought: [Your analysis of the observation]
Action: [Next action or Final Answer]
Action Input: [Input for next action or your final answer]

${strictMode ? '\nSTRICT MODE: Only use information explicitly found in the tools. Do not infer or assume anything.' : ''}

Remember: Your goal is to provide accurate, evidence-based answers about the codebase.`;

    return prompt;
  }

  /**
   * Parse a reasoning step from LLM response
   */
  private parseReasoningStep(response: string, stepNumber: number): ReasoningStep {
    const thoughtMatch = response.match(/Thought:\s*(.*?)(?=\n|Action:|$)/s);
    const actionMatch = response.match(/Action:\s*(.*?)(?=\n|Action Input:|$)/s);
    const inputMatch = response.match(/Action Input:\s*(.*?)(?=\n|$)/s);

    return {
      step: stepNumber,
      thought: thoughtMatch?.[1]?.trim() || 'No thought provided',
      action: actionMatch?.[1]?.trim() || 'unknown',
      actionInput: inputMatch?.[1]?.trim() || '',
      observation: '' // Will be filled after tool execution
    };
  }

  /**
   * Execute a graph query using the Cypher generator
   */
  private async executeGraphQuery(question: string, llmConfig: LLMConfig): Promise<ToolResult> {
    try {
      const cypherQuery = await this.cypherGenerator.generateQuery(question, llmConfig);
      
      // For now, we'll simulate query execution since we don't have a real graph database
      // In a real implementation, this would execute the Cypher query against Neo4j or similar
      const mockResults = this.simulateGraphQuery(cypherQuery.cypher);
      
      return {
        toolName: 'query_graph',
        input: question,
        output: `Query: ${cypherQuery.cypher}\n\nResults:\n${mockResults}\n\nExplanation: ${cypherQuery.explanation}`,
        success: true
      };
    } catch (error) {
      return {
        toolName: 'query_graph',
        input: question,
        output: '',
        success: false,
        error: error instanceof Error ? error.message : 'Query execution failed'
      };
    }
  }

  /**
   * Get code content from a file
   */
  private async getCodeContent(filePath: string): Promise<ToolResult> {
    if (!this.context) {
      return {
        toolName: 'get_code',
        input: filePath,
        output: '',
        success: false,
        error: 'No context available'
      };
    }

    const content = this.context.fileContents.get(filePath);
    if (!content) {
      // Try to find similar file paths
      const similarFiles = Array.from(this.context.fileContents.keys())
        .filter(path => path.includes(filePath) || filePath.includes(path))
        .slice(0, 3);

      if (similarFiles.length > 0) {
        return {
          toolName: 'get_code',
          input: filePath,
          output: `File not found. Similar files available: ${similarFiles.join(', ')}`,
          success: false,
          error: 'File not found'
        };
      }

      return {
        toolName: 'get_code',
        input: filePath,
        output: 'File not found',
        success: false,
        error: 'File not found'
      };
    }

    return {
      toolName: 'get_code',
      input: filePath,
      output: `File: ${filePath}\n\n${content}`,
      success: true
    };
  }

  /**
   * Search for files matching a pattern
   */
  private async searchFiles(pattern: string): Promise<ToolResult> {
    if (!this.context) {
      return {
        toolName: 'search_files',
        input: pattern,
        output: '',
        success: false,
        error: 'No context available'
      };
    }

    const matchingFiles: string[] = [];
    const lowerPattern = pattern.toLowerCase();

    // Search in file paths
    for (const filePath of this.context.fileContents.keys()) {
      if (filePath.toLowerCase().includes(lowerPattern)) {
        matchingFiles.push(filePath);
      }
    }

    // Search in file contents
    for (const [filePath, content] of this.context.fileContents.entries()) {
      if (!matchingFiles.includes(filePath) && 
          content.toLowerCase().includes(lowerPattern)) {
        matchingFiles.push(filePath);
      }
    }

    return {
      toolName: 'search_files',
      input: pattern,
      output: matchingFiles.length > 0 
        ? `Found ${matchingFiles.length} files:\n${matchingFiles.slice(0, 10).join('\n')}${matchingFiles.length > 10 ? '\n... and more' : ''}`
        : 'No files found matching the pattern',
      success: true
    };
  }

  /**
   * Simulate graph query execution (placeholder for real implementation)
   */
  private simulateGraphQuery(cypher: string): string {
    if (!this.context) return 'No context available';

    // Simple simulation based on common patterns
    const upperCypher = cypher.toUpperCase();
    
    if (upperCypher.includes('FUNCTION') && upperCypher.includes('RETURN')) {
      const functions = this.context.graph.nodes
        .filter(n => n.label === 'Function')
        .slice(0, 5)
        .map(n => `${n.properties.name} (${n.properties.filePath})`)
        .join('\n');
      return functions || 'No functions found';
    }
    
    if (upperCypher.includes('CLASS') && upperCypher.includes('RETURN')) {
      const classes = this.context.graph.nodes
        .filter(n => n.label === 'Class')
        .slice(0, 5)
        .map(n => `${n.properties.name} (${n.properties.filePath})`)
        .join('\n');
      return classes || 'No classes found';
    }
    
    if (upperCypher.includes('FILE') && upperCypher.includes('RETURN')) {
      const files = this.context.graph.nodes
        .filter(n => n.label === 'File')
        .slice(0, 5)
        .map(n => n.properties.name)
        .join('\n');
      return files || 'No files found';
    }

    return 'Query executed successfully (simulated)';
  }

  /**
   * Extract Cypher queries from tool results
   */
  private extractCypherQueries(toolResult: ToolResult): CypherQuery[] {
    const queries: CypherQuery[] = [];
    const queryMatch = toolResult.output.match(/Query: (.*?)(?=\n|$)/);
    
    if (queryMatch) {
      queries.push({
        cypher: queryMatch[1],
        explanation: 'Generated during reasoning',
        confidence: 0.8
      });
    }

    return queries;
  }

  /**
   * Extract sources from tool results
   */
  private extractSources(toolResult: ToolResult): string[] {
    const sources: string[] = [];
    const fileMatch = toolResult.output.match(/File: (.*?)(?=\n|$)/);
    
    if (fileMatch) {
      sources.push(fileMatch[1]);
    }

    return sources;
  }

  /**
   * Calculate confidence based on reasoning quality
   */
  private calculateConfidence(reasoning: ReasoningStep[], queries: CypherQuery[]): number {
    let confidence = 0.5;

    // Boost confidence for successful tool usage
    const successfulSteps = reasoning.filter(step => step.toolResult?.success).length;
    confidence += (successfulSteps / reasoning.length) * 0.3;

    // Boost confidence for high-quality queries
    const avgQueryConfidence = queries.length > 0 
      ? queries.reduce((sum, q) => sum + q.confidence, 0) / queries.length
      : 0.5;
    confidence += avgQueryConfidence * 0.2;

    // Cap at reasonable bounds
    return Math.min(0.95, Math.max(0.1, confidence));
  }

  /**
   * Build summary prompt for incomplete reasoning
   */
  private buildSummaryPrompt(question: string, reasoning: ReasoningStep[]): string {
    const observations = reasoning
      .map(step => `Step ${step.step}: ${step.observation}`)
      .join('\n');

    return `Based on the following observations from your reasoning process, please provide a final answer to the question: "${question}"

Observations:
${observations}

Final Answer:`;
  }

  /**
   * Get current context information
   */
  public getContextInfo(): { nodeCount: number; fileCount: number; hasContext: boolean } {
    if (!this.context) {
      return { nodeCount: 0, fileCount: 0, hasContext: false };
    }

    return {
      nodeCount: this.context.graph.nodes.length,
      fileCount: this.context.fileContents.size,
      hasContext: true
    };
  }
}

================
File: src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: src/App.tsx
================
import React from 'react';
import { HomePage, ErrorBoundary } from './ui/index.ts';

const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <HomePage />
    </ErrorBoundary>
  );
};

export default App;

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/core/graph/query.ts
================
import type { KnowledgeGraph, GraphNode, GraphRelationship } from './types.ts';

export type NodeFilter = {
  idEquals?: string | string[];
  labelIn?: Array<GraphNode['label']>;
  nameContains?: string;
  pathContains?: string;
  props?: Record<string, unknown>;
};

export type RelFilter = {
  typeIn?: Array<GraphRelationship['type']>;
  fromIdIn?: string[];
  toIdIn?: string[];
};

export type TraverseOptions = {
  depth?: number;
  direction?: 'out' | 'in' | 'both';
  relTypeIn?: Array<GraphRelationship['type']>;
  limitNodes?: number;
};

export type PathOptions = {
  relTypeIn?: Array<GraphRelationship['type']>;
  maxDepth?: number;
  maxPaths?: number;
};

export interface GraphIndex {
  nodeById: Map<string, GraphNode>;
  outAdjacency: Map<string, GraphRelationship[]>;
  inAdjacency: Map<string, GraphRelationship[]>;
}

export function indexGraph(graph: KnowledgeGraph): GraphIndex {
  const nodeById = new Map<string, GraphNode>();
  const outAdjacency = new Map<string, GraphRelationship[]>();
  const inAdjacency = new Map<string, GraphRelationship[]>();

  for (const node of graph.nodes) {
    nodeById.set(node.id, node);
  }

  for (const rel of graph.relationships) {
    if (!outAdjacency.has(rel.source)) outAdjacency.set(rel.source, []);
    if (!inAdjacency.has(rel.target)) inAdjacency.set(rel.target, []);
    outAdjacency.get(rel.source)!.push(rel);
    inAdjacency.get(rel.target)!.push(rel);
  }

  return { nodeById, outAdjacency, inAdjacency };
}

export function queryNodes(graph: KnowledgeGraph, filter: NodeFilter): GraphNode[] {
  const idSet = new Set(typeof filter.idEquals === 'string' ? [filter.idEquals] : filter.idEquals || []);
  const nameNeedle = filter.nameContains?.toLowerCase();
  const pathNeedle = filter.pathContains?.toLowerCase();

  return graph.nodes.filter((node) => {
    if (idSet.size > 0 && !idSet.has(node.id)) return false;
    if (filter.labelIn && filter.labelIn.length > 0 && !filter.labelIn.includes(node.label)) return false;

    if (nameNeedle) {
      const name = String(node.properties?.name || '').toLowerCase();
      if (!name.includes(nameNeedle)) return false;
    }

    if (pathNeedle) {
      const path = String(node.properties?.path || node.properties?.filePath || '').toLowerCase();
      if (!path.includes(pathNeedle)) return false;
    }

    if (filter.props) {
      for (const [key, expected] of Object.entries(filter.props)) {
        if ((node.properties as Record<string, unknown>)?.[key] !== expected) return false;
      }
    }

    return true;
  });
}

export function queryRelationships(graph: KnowledgeGraph, filter: RelFilter): GraphRelationship[] {
  const typeSet = new Set(filter.typeIn || []);
  const fromSet = new Set(filter.fromIdIn || []);
  const toSet = new Set(filter.toIdIn || []);

  return graph.relationships.filter((rel) => {
    if (typeSet.size > 0 && !typeSet.has(rel.type)) return false;
    if (fromSet.size > 0 && !fromSet.has(rel.source)) return false;
    if (toSet.size > 0 && !toSet.has(rel.target)) return false;
    return true;
  });
}

export function neighborsOf(
  graph: KnowledgeGraph,
  seedNodeIds: string[],
  options: TraverseOptions = {}
): KnowledgeGraph {
  const { depth = 1, direction = 'both', relTypeIn, limitNodes = 500 } = options;
  const { outAdjacency, inAdjacency, nodeById } = indexGraph(graph);

  const allowedRelTypes = relTypeIn ? new Set(relTypeIn) : null;
  const visitedNodes = new Set<string>(seedNodeIds);
  const resultNodes = new Set<string>(seedNodeIds);
  const resultRels: GraphRelationship[] = [];

  let frontier = [...seedNodeIds];
  let currentDepth = 0;

  while (frontier.length > 0 && currentDepth < depth && resultNodes.size < limitNodes) {
    const nextFrontier: string[] = [];
    for (const nodeId of frontier) {
      if (direction === 'out' || direction === 'both') {
        const outRels = outAdjacency.get(nodeId) || [];
        for (const rel of outRels) {
          if (allowedRelTypes && !allowedRelTypes.has(rel.type)) continue;
          resultRels.push(rel);
          if (!visitedNodes.has(rel.target)) {
            visitedNodes.add(rel.target);
            resultNodes.add(rel.target);
            nextFrontier.push(rel.target);
            if (resultNodes.size >= limitNodes) break;
          }
        }
      }
      if (resultNodes.size >= limitNodes) break;
      if (direction === 'in' || direction === 'both') {
        const inRels = inAdjacency.get(nodeId) || [];
        for (const rel of inRels) {
          if (allowedRelTypes && !allowedRelTypes.has(rel.type)) continue;
          resultRels.push(rel);
          if (!visitedNodes.has(rel.source)) {
            visitedNodes.add(rel.source);
            resultNodes.add(rel.source);
            nextFrontier.push(rel.source);
            if (resultNodes.size >= limitNodes) break;
          }
        }
      }
      if (resultNodes.size >= limitNodes) break;
    }
    frontier = nextFrontier;
    currentDepth++;
  }

  const nodes = Array.from(resultNodes).map((id) => nodeById.get(id)!).filter(Boolean);
  const relationships = dedupeRelationships(resultRels);
  return { nodes, relationships };
}

export function pathsBetween(
  graph: KnowledgeGraph,
  fromId: string,
  toId: string,
  options: PathOptions = {}
): KnowledgeGraph {
  const { maxDepth = 6, relTypeIn, maxPaths = 3 } = options;
  const { outAdjacency, nodeById } = indexGraph(graph);
  const allowedRelTypes = relTypeIn ? new Set(relTypeIn) : null;

  const queue: Array<{ nodeId: string; path: GraphRelationship[] }> = [{ nodeId: fromId, path: [] }];
  const visited = new Set<string>([fromId]);
  const foundPaths: GraphRelationship[][] = [];

  while (queue.length > 0 && foundPaths.length < maxPaths) {
    const { nodeId, path } = queue.shift()!;
    if (path.length > maxDepth) continue;
    if (nodeId === toId) {
      foundPaths.push(path);
      continue;
    }
    const outRels = outAdjacency.get(nodeId) || [];
    for (const rel of outRels) {
      if (allowedRelTypes && !allowedRelTypes.has(rel.type)) continue;
      const nextId = rel.target;
      if (!visited.has(nextId)) {
        visited.add(nextId);
        queue.push({ nodeId: nextId, path: [...path, rel] });
      }
    }
  }

  const relSet = new Set<GraphRelationship>();
  for (const p of foundPaths) for (const r of p) relSet.add(r);
  const nodeSet = new Set<string>();
  for (const r of relSet) {
    nodeSet.add(r.source);
    nodeSet.add(r.target);
  }

  const nodes = Array.from(nodeSet).map((id) => nodeById.get(id)!).filter(Boolean);
  const relationships = dedupeRelationships(Array.from(relSet));
  return { nodes, relationships };
}

export function subgraphFromNodesAndRels(graph: KnowledgeGraph, nodeIds: string[], rels: GraphRelationship[]): KnowledgeGraph {
  const nodeIdSet = new Set(nodeIds);
  const nodes = graph.nodes.filter((n) => nodeIdSet.has(n.id));
  const relationships = dedupeRelationships(rels);
  return { nodes, relationships };
}

export function summarizeSubgraph(subgraph: KnowledgeGraph): string {
  const counts = subgraph.nodes.reduce<Record<string, number>>((acc, n) => {
    acc[n.label] = (acc[n.label] || 0) + 1;
    return acc;
  }, {});
  const relCounts = subgraph.relationships.reduce<Record<string, number>>((acc, r) => {
    acc[r.type] = (acc[r.type] || 0) + 1;
    return acc;
  }, {});
  const parts: string[] = [];
  parts.push(`Nodes: ${subgraph.nodes.length} (${Object.entries(counts).map(([k, v]) => `${k}:${v}`).join(', ') || 'none'})`);
  parts.push(`Relationships: ${subgraph.relationships.length} (${Object.entries(relCounts).map(([k, v]) => `${k}:${v}`).join(', ') || 'none'})`);
  const examples = subgraph.nodes.slice(0, 5).map((n) => `${n.label}:${String(n.properties?.name || n.id)}`);
  if (examples.length > 0) parts.push(`Examples: ${examples.join(', ')}`);
  return parts.join('\n');
}

function dedupeRelationships(rels: GraphRelationship[]): GraphRelationship[] {
  const seen = new Set<string>();
  const out: GraphRelationship[] = [];
  for (const r of rels) {
    const key = `${r.type}|${r.source}|${r.target}`;
    if (!seen.has(key)) {
      seen.add(key);
      out.push(r);
    }
  }
  return out;
}

================
File: src/core/graph/types.ts
================
export type NodeLabel = 
  | 'Project' 
  | 'Package' 
  | 'Module' 
  | 'Folder' 
  | 'File' 
  | 'Class' 
  | 'Function' 
  | 'Method' 
  | 'Variable';

export interface GraphNode {
  id: string;
  label: NodeLabel;
  properties: Record<string, unknown>;
}

export type RelationshipType = 
  | 'CONTAINS' 
  | 'CALLS' 
  | 'INHERITS' 
  | 'OVERRIDES' 
  | 'IMPORTS';

export interface GraphRelationship {
  id: string;
  type: RelationshipType;
  source: string;
  target: string;
  properties?: Record<string, unknown>;
}

export interface KnowledgeGraph {
  nodes: GraphNode[];
  relationships: GraphRelationship[];
}

================
File: src/core/ingestion/call-processor.ts
================
import type { KnowledgeGraph, GraphNode, GraphRelationship } from '../graph/types.ts';
import { generateId } from '../../lib/utils.ts';
import type Parser from 'web-tree-sitter';

// Use web-tree-sitter types directly
type TreeSitterNode = Parser.SyntaxNode;
type TreeSitterAST = Parser.Tree;

export interface CallResolutionInput {
  graph: KnowledgeGraph;
  astCache: Map<string, TreeSitterAST>;
  fileContents: Map<string, string>;
}

interface FunctionCall {
  callerFilePath: string;
  callerFunction: string;
  calledName: string;
  callType: 'function' | 'method' | 'attribute' | 'super';
  line: number;
  column: number;
  isChained?: boolean;
  objectName?: string;
  superMethodName?: string;
  assignedToVariable?: string;
  chainedFromVariable?: string;
}

interface ImportInfo {
  filePath: string;
  importedName: string;
  alias?: string;
  fromModule: string;
  importType: 'function' | 'class' | 'module' | 'attribute';
}

interface VariableTypeInfo {
  variableName: string;
  inferredType: string;
  filePath: string;
  functionContext: string;
  line: number;
  confidence: 'high' | 'medium' | 'low';
  source: 'constructor' | 'method_return' | 'factory' | 'assignment' | 'parameter';
}

interface MethodReturnTypeInfo {
  methodId: string;
  methodName: string;
  className: string;
  returnType?: string;
  filePath: string;
}

// const BUILTIN_FUNCTIONS = new Set([
//   'print', 'len', 'str', 'int', 'float', 'bool', 'list', 'dict', 'tuple', 'set',
//   'range', 'enumerate', 'zip', 'map', 'filter', 'sum', 'max', 'min', 'abs',
//   'round', 'sorted', 'reversed', 'any', 'all', 'type', 'isinstance', 'hasattr',
//   'getattr', 'setattr', 'delattr', 'dir', 'vars', 'id', 'hash', 'repr',
//   'open', 'input', 'format', 'exec', 'eval', 'compile', 'globals', 'locals'
// ]);

export class CallProcessor {
  private importCache: Map<string, ImportInfo[]> = new Map();
  private functionNodes: Map<string, GraphNode> = new Map();
  private variableTypes: Map<string, VariableTypeInfo> = new Map();
  private methodReturnTypes: Map<string, MethodReturnTypeInfo> = new Map();
  private classConstructors: Map<string, GraphNode> = new Map();

  public async process(input: CallResolutionInput): Promise<void> {
    const { graph, astCache, fileContents } = input;
    
    // Build function node lookup for fast resolution
    this.buildFunctionNodeLookup(graph);
    
    console.log(`CallProcessor: Processing ${astCache.size} files with ASTs`);
    
    // Extract imports from all files first
    for (const [filePath, ast] of astCache) {
      if (this.isPythonFile(filePath)) {
        const content = fileContents.get(filePath);
        if (content && ast) {
          await this.extractImports(filePath, ast);
        }
      }
    }
    
    // For files without ASTs, try regex-based import extraction
    const pythonFiles = Array.from(fileContents.keys()).filter(path => this.isPythonFile(path));
    const filesWithoutAST = pythonFiles.filter(path => !astCache.has(path));
    
    if (filesWithoutAST.length > 0) {
      console.log(`CallProcessor: ${filesWithoutAST.length} files don't have ASTs, using regex fallback for imports`);
      for (const filePath of filesWithoutAST) {
        const content = fileContents.get(filePath);
        if (content) {
          await this.extractImportsRegex(filePath, content);
        }
      }
    }
    
    // Process function calls in all files
    for (const [filePath, ast] of astCache) {
      if (this.isPythonFile(filePath)) {
        const content = fileContents.get(filePath);
        if (content && ast) {
          await this.processFunctionCalls(graph, filePath, ast);
        }
      }
    }
    
    console.log(`CallProcessor: Found imports in ${this.importCache.size} files`);
    
    // Create import relationships between files
    this.createImportRelationships(graph);
  }

  private createImportRelationships(graph: KnowledgeGraph): void {
    let importRelationshipsCreated = 0;
    
    for (const [filePath, imports] of this.importCache) {
      const sourceFileNode = graph.nodes.find(node => 
        node.label === 'File' && node.properties.filePath === filePath
      );
      
      if (!sourceFileNode) continue;
      
      for (const importInfo of imports) {
        // Try to find the target file based on the module name
        const targetFileNode = this.findTargetFileForImport(graph, importInfo);
        
        if (targetFileNode) {
          // Create IMPORTS relationship
          const relationship: GraphRelationship = {
            id: generateId('relationship', `${sourceFileNode.id}-imports-${targetFileNode.id}`),
            type: 'IMPORTS',
            source: sourceFileNode.id,
            target: targetFileNode.id,
            properties: {
              importedName: importInfo.importedName,
              fromModule: importInfo.fromModule,
              importType: importInfo.importType
            }
          };
          
          // Check if relationship already exists
          const existingRel = graph.relationships.find(rel => 
            rel.source === sourceFileNode.id && 
            rel.target === targetFileNode.id && 
            rel.type === 'IMPORTS'
          );
          
          if (!existingRel) {
            graph.relationships.push(relationship);
            importRelationshipsCreated++;
          }
        }
      }
    }
    
    console.log(`CallProcessor: Created ${importRelationshipsCreated} import relationships`);
  }

  private findTargetFileForImport(graph: KnowledgeGraph, importInfo: ImportInfo): GraphNode | null {
    const moduleName = importInfo.fromModule;
    const importerFilePath = importInfo.filePath;
    
    // Try different strategies to find the target file
    const fileNodes = graph.nodes.filter(node => node.label === 'File');
    
    // Get the directory context of the importing file to handle relative imports
    const importerDir = importerFilePath.substring(0, importerFilePath.lastIndexOf('/'));
    const importerParts = importerDir.split('/');
    
    // For relative imports starting with 'app', try to resolve within the same service
    if (moduleName.startsWith('app.') || moduleName === 'app') {
      // Find the service root (look for common service patterns)
      let serviceRoot = '';
      for (let i = importerParts.length - 1; i >= 0; i--) {
        const potentialRoot = importerParts.slice(0, i + 1).join('/');
        // Check if this directory contains an app subdirectory
        const hasAppSubdir = fileNodes.some(node => {
          const filePath = node.properties.filePath as string;
          return filePath && filePath.startsWith(potentialRoot + '/app/');
        });
        if (hasAppSubdir) {
          serviceRoot = potentialRoot;
          break;
        }
      }
      
      if (serviceRoot) {
        const relativePath = moduleName.replace(/\./g, '/');
        const targetPath = `${serviceRoot}/${relativePath}`;
        
        // Try exact match first
        let targetFile = fileNodes.find(node => {
          const filePath = node.properties.filePath as string;
          return filePath === `${targetPath}.py`;
        });
        
        if (targetFile) return targetFile;
        
        // Try __init__.py in the directory
        targetFile = fileNodes.find(node => {
          const filePath = node.properties.filePath as string;
          return filePath === `${targetPath}/__init__.py`;
        });
        
        if (targetFile) return targetFile;
      }
    }

    // Strategy 1: Direct module name match (e.g., "utils" -> "utils.py")
    let targetFile = fileNodes.find(node => {
      const fileName = node.properties.name as string;
      return fileName === `${moduleName}.py`;
    });
    
    if (targetFile) return targetFile;
    
    // Strategy 2: Last part of module path (e.g., "myproject.utils" -> "utils.py")
    const lastPart = moduleName.split('.').pop();
    if (lastPart) {
      targetFile = fileNodes.find(node => {
        const fileName = node.properties.name as string;
        return fileName === `${lastPart}.py`;
      });
    }
    
    // Only return this match if it's in the same service context to avoid cross-service hallucinations
    if (targetFile) {
      const targetPath = targetFile.properties.filePath as string;
      // Check if both files are in the same top-level service directory
      const importerService = importerParts[0] + '/' + (importerParts[1] || '');
      const targetService = targetPath.split('/').slice(0, 2).join('/');
      
      if (importerService === targetService) {
        return targetFile;
      }
    }
    
    // Strategy 3: Check if module path matches file path
    targetFile = fileNodes.find(node => {
      const filePath = node.properties.filePath as string;
      if (!filePath) return false;
      
      // Only consider files in the same service context
      const importerService = importerParts[0] + '/' + (importerParts[1] || '');
      const targetService = filePath.split('/').slice(0, 2).join('/');
      
      if (importerService !== targetService) return false;
      
      return filePath.includes(moduleName.replace('.', '/'));
    });
    
    return targetFile || null;
  }

  private buildFunctionNodeLookup(graph: KnowledgeGraph): void {
    for (const node of graph.nodes) {
      if (node.label === 'Function' || node.label === 'Method') {
        const filePath = node.properties.filePath as string;
        const functionName = node.properties.name as string;
        
        // Create different keys for Functions vs Methods to avoid conflicts
        if (node.label === 'Method') {
          const parentClass = node.properties.parentClass as string;
          const methodKey = `${filePath}:method:${parentClass}.${functionName}`;
          this.functionNodes.set(methodKey, node);
          
          // Also add a general method key for resolution when class context is unknown
          const generalMethodKey = `${filePath}:method:${functionName}`;
          if (!this.functionNodes.has(generalMethodKey)) {
            this.functionNodes.set(generalMethodKey, node);
          }
          
          // Track method return type information
          this.buildMethodReturnTypeInfo(node, parentClass, functionName, filePath);
        } else {
          const functionKey = `${filePath}:function:${functionName}`;
          this.functionNodes.set(functionKey, node);
        }
      } else if (node.label === 'Class') {
        // Track class constructors for instantiation inference
        const className = node.properties.name as string;
        const filePath = node.properties.filePath as string;
        const classKey = `${filePath}:${className}`;
        this.classConstructors.set(classKey, node);
      }
    }
  }

  private buildMethodReturnTypeInfo(methodNode: GraphNode, className: string, methodName: string, filePath: string): void {
    const methodId = methodNode.id;
    
    // Infer return type based on method name and class context
    let returnType: string | undefined;
    
    // Constructor methods return the class instance
    if (methodName === '__init__' || methodName === '__new__') {
      returnType = className;
    }
    // Factory methods often return class instances
    else if (methodName.startsWith('create_') || methodName.startsWith('build_') || 
             methodName.startsWith('make_') || methodName.includes('factory')) {
      returnType = this.inferFactoryReturnType(methodName, className);
    }
    // Getter methods often return specific types
    else if (methodName.startsWith('get_')) {
      returnType = this.inferGetterReturnType(methodName);
    }
    // Property methods (decorated with @property) return the property type
    else if (methodNode.properties.decorators) {
      const decorators = methodNode.properties.decorators as string[];
      if (decorators.includes('property')) {
        returnType = this.inferPropertyReturnType(methodName);
      }
    }
    
    const returnTypeInfo: MethodReturnTypeInfo = {
      methodId,
      methodName,
      className,
      returnType,
      filePath
    };
    
    this.methodReturnTypes.set(methodId, returnTypeInfo);
  }

  private inferFactoryReturnType(methodName: string, className: string): string | undefined {
    // Factory methods like create_user, build_report, make_connection
    if (methodName.startsWith('create_')) {
      const typeName = methodName.substring(7); // Remove 'create_'
      return this.capitalizeFirstLetter(typeName);
    }
    if (methodName.startsWith('build_')) {
      const typeName = methodName.substring(6); // Remove 'build_'
      return this.capitalizeFirstLetter(typeName);
    }
    if (methodName.startsWith('make_')) {
      const typeName = methodName.substring(5); // Remove 'make_'
      return this.capitalizeFirstLetter(typeName);
    }
    
    // If it's a factory class, it might return instances of the main entity
    if (className.endsWith('Factory')) {
      const entityName = className.substring(0, className.length - 7); // Remove 'Factory'
      return entityName;
    }
    
    return undefined;
  }

  private inferGetterReturnType(methodName: string): string | undefined {
    // Common getter patterns
    if (methodName === 'get_name' || methodName === 'get_title') return 'str';
    if (methodName === 'get_id' || methodName === 'get_count') return 'int';
    if (methodName === 'get_price' || methodName === 'get_amount') return 'float';
    if (methodName === 'get_active' || methodName === 'get_enabled') return 'bool';
    if (methodName.includes('_list') || methodName.includes('_all')) return 'list';
    if (methodName.includes('_dict') || methodName.includes('_data')) return 'dict';
    
    return undefined;
  }

  private inferPropertyReturnType(methodName: string): string | undefined {
    // Property return type inference based on naming patterns
    if (methodName === 'name' || methodName === 'title' || methodName === 'description') return 'str';
    if (methodName === 'id' || methodName === 'count' || methodName === 'size') return 'int';
    if (methodName === 'price' || methodName === 'amount' || methodName === 'rate') return 'float';
    if (methodName === 'active' || methodName === 'enabled' || methodName === 'valid') return 'bool';
    
    return undefined;
  }

  private capitalizeFirstLetter(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private async extractImports(filePath: string, ast: TreeSitterAST): Promise<void> {
    const imports: ImportInfo[] = [];
    
    if (this.isPythonFile(filePath)) {
      // Python import processing
      this.traverseNode(ast.rootNode, (node: TreeSitterNode) => {
        if (node.type === 'import_statement') {
          this.processImportStatement(node, imports, filePath);
        } else if (node.type === 'import_from_statement') {
          this.processImportFromStatement(node, imports, filePath);
        }
      });
    } else if (this.isJavaScriptFile(filePath) || this.isTypeScriptFile(filePath)) {
      // JavaScript/TypeScript import processing
      this.traverseNode(ast.rootNode, (node: TreeSitterNode) => {
        if (node.type === 'import_statement') {
          this.processJSImportStatement(node, imports, filePath);
        } else if (node.type === 'variable_declaration') {
          // Handle CommonJS require: const foo = require('bar')
          this.processRequireStatement(node, imports, filePath);
        }
      });
    }
    
    this.importCache.set(filePath, imports);
  }

  private processImportStatement(node: TreeSitterNode, imports: ImportInfo[], filePath: string): void {
    const nameNode = node.childForFieldName('name');
    if (nameNode) {
      const moduleName = nameNode.text;
      
      // Handle aliased imports (import module as alias)
      const asNode = node.children.find((child: TreeSitterNode) => child.type === 'as_pattern');
      const alias = asNode ? asNode.childForFieldName('alias')?.text : undefined;
      
      imports.push({
        filePath,
        importedName: moduleName,
        alias,
        fromModule: moduleName,
        importType: 'module'
      });
    }
  }

  private processImportFromStatement(node: TreeSitterNode, imports: ImportInfo[], filePath: string): void {
    const moduleNameNode = node.childForFieldName('module_name');
    const importListNode = node.children.find((child: TreeSitterNode) => child.type === 'import_list');
    
    if (moduleNameNode && importListNode) {
      const moduleName = moduleNameNode.text;
      
      this.traverseNode(importListNode, (child: TreeSitterNode) => {
        if (child.type === 'dotted_name' || child.type === 'identifier') {
          const importedName = child.text;
          imports.push({
            filePath,
            importedName,
            fromModule: moduleName,
            importType: 'function' // Default assumption, could be refined
          });
        } else if (child.type === 'as_pattern') {
          const nameNode = child.childForFieldName('name');
          const aliasNode = child.childForFieldName('alias');
          
          if (nameNode && aliasNode) {
            imports.push({
              filePath,
              importedName: nameNode.text,
              alias: aliasNode.text,
              fromModule: moduleName,
              importType: 'function'
            });
          }
        }
      });
    }
  }

  private processJSImportStatement(node: TreeSitterNode, imports: ImportInfo[], filePath: string): void {
    // Handle ES6 imports: import { foo, bar } from 'module'
    // import foo from 'module'
    // import * as foo from 'module'
    
    let fromModule = '';
    const importedNames: string[] = [];
    
    this.traverseNode(node, (child: TreeSitterNode) => {
      if (child.type === 'string' && !fromModule) {
        // Extract module name from string literal
        fromModule = child.text.replace(/['"]/g, '');
      } else if (child.type === 'import_specifier') {
        // Handle named imports: { foo, bar as baz }
        const nameNode = child.childForFieldName('name');
        if (nameNode) {
          importedNames.push(nameNode.text);
        }
      } else if (child.type === 'identifier' && child.parent?.type === 'import_statement') {
        // Handle default imports: import foo from 'module'
        importedNames.push(child.text);
      } else if (child.type === 'namespace_import') {
        // Handle namespace imports: import * as foo from 'module'
        const aliasNode = child.childForFieldName('name');
        if (aliasNode) {
          importedNames.push(aliasNode.text);
        }
      }
    });
    
    // Create import info for each imported name
    for (const importedName of importedNames) {
      imports.push({
        filePath,
        importedName,
        fromModule,
        importType: 'function' // Default assumption for JS/TS
      });
    }
  }

  private processRequireStatement(node: TreeSitterNode, imports: ImportInfo[], filePath: string): void {
    // Handle CommonJS require: const foo = require('bar')
    // const { foo, bar } = require('module')
    
    this.traverseNode(node, (child: TreeSitterNode) => {
      if (child.type === 'variable_declarator') {
        const nameNode = child.childForFieldName('name');
        const valueNode = child.childForFieldName('value');
        
        if (valueNode && valueNode.type === 'call_expression') {
          // Check if it's a require() call
          const functionNode = valueNode.childForFieldName('function');
          if (functionNode && functionNode.type === 'identifier' && functionNode.text === 'require') {
            // Get the module name from the first argument
            const argsNode = valueNode.childForFieldName('arguments');
            if (argsNode) {
              let moduleName = '';
              this.traverseNode(argsNode, (argChild: TreeSitterNode) => {
                if (argChild.type === 'string' && !moduleName) {
                  moduleName = argChild.text.replace(/['"]/g, '');
                }
              });
              
              if (nameNode && moduleName) {
                if (nameNode.type === 'identifier') {
                  // const foo = require('module')
                  imports.push({
                    filePath,
                    importedName: nameNode.text,
                    fromModule: moduleName,
                    importType: 'module'
                  });
                } else if (nameNode.type === 'object_pattern') {
                  // const { foo, bar } = require('module')
                  this.traverseNode(nameNode, (patternChild: TreeSitterNode) => {
                    if (patternChild.type === 'shorthand_property_identifier_pattern') {
                      imports.push({
                        filePath,
                        importedName: patternChild.text,
                        fromModule: moduleName,
                        importType: 'function'
                      });
                    }
                  });
                }
              }
            }
          }
        }
      }
    });
  }

  private async processFunctionCalls(
    graph: KnowledgeGraph, 
    filePath: string, 
    ast: TreeSitterAST
  ): Promise<void> {
    const functionCalls: FunctionCall[] = [];
    let currentFunction: string | null = null;
    
    if (this.isPythonFile(filePath)) {
      // Python function call processing
      this.traverseNode(ast.rootNode, (node: TreeSitterNode) => {
        // Track current function context
        if (node.type === 'function_definition') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            currentFunction = nameNode.text;
          }
        }
        
        // Track variable assignments for type inference
        if (node.type === 'assignment') {
          this.processVariableAssignment(node, filePath, currentFunction);
        }
        
        // Find function calls
        if (node.type === 'call') {
          const callInfo = this.extractCallInfo(node, filePath, currentFunction);
          if (callInfo) {
            // Check if this call is part of an assignment
            const assignmentInfo = this.extractAssignmentInfo(node);
            if (assignmentInfo) {
              callInfo.assignedToVariable = assignmentInfo.variableName;
            }
            
            functionCalls.push(callInfo);
          }
        }
      });
    } else if (this.isJavaScriptFile(filePath) || this.isTypeScriptFile(filePath)) {
      // JavaScript/TypeScript function call processing
      this.traverseNode(ast.rootNode, (node: TreeSitterNode) => {
        // Track current function context
        if (node.type === 'function_declaration' || node.type === 'method_definition') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            currentFunction = nameNode.text;
          }
        }
        
        // Track variable assignments for type inference
        if (node.type === 'variable_declaration' || node.type === 'assignment_expression') {
          this.processJSVariableAssignment(node, filePath, currentFunction);
        }
        
        // Find function calls
        if (node.type === 'call_expression') {
          const callInfo = this.extractJSCallInfo(node, filePath, currentFunction);
          if (callInfo) {
            functionCalls.push(callInfo);
          }
        }
      });
    }
    
    // Resolve calls and create relationships
    for (const call of functionCalls) {
      await this.resolveAndCreateCallRelationship(graph, call);
      
      // Track variable type if this call is assigned to a variable
      if (call.assignedToVariable) {
        this.inferAndTrackVariableType(graph, call);
      }
    }
  }

  private processVariableAssignment(assignmentNode: TreeSitterNode, filePath: string, currentFunction: string | null): void {
    const leftNode = assignmentNode.childForFieldName('left');
    const rightNode = assignmentNode.childForFieldName('right');
    
    if (!leftNode || !rightNode) return;
    
    // Extract variable name from left side
    let variableName: string | null = null;
    if (leftNode.type === 'identifier') {
      variableName = leftNode.text;
    }
    
    if (!variableName) return;
    
    // Analyze right side for type inference
    if (rightNode.type === 'call') {
      // This will be handled in the call processing
      return;
    } else if (rightNode.type === 'identifier') {
      // Variable assignment from another variable
      const sourceVariable = rightNode.text;
      this.copyVariableType(filePath, currentFunction || '<module>', sourceVariable, variableName);
    }
  }

  private extractAssignmentInfo(callNode: TreeSitterNode): { variableName: string } | null {
    // Walk up the AST to find if this call is part of an assignment
    let parent = callNode.parent;
    
    while (parent) {
      if (parent.type === 'assignment') {
        const leftNode = parent.childForFieldName('left');
        if (leftNode && leftNode.type === 'identifier') {
          return { variableName: leftNode.text };
        }
      }
      parent = parent.parent;
    }
    
    return null;
  }

  private inferAndTrackVariableType(graph: KnowledgeGraph, call: FunctionCall): void {
    if (!call.assignedToVariable) return;
    
    let inferredType: string | undefined;
    let confidence: 'high' | 'medium' | 'low' = 'low';
    let source: VariableTypeInfo['source'] = 'assignment';
    
    // Try to infer type based on the call
    if (call.callType === 'function' || call.callType === 'method') {
      // Check if it's a class constructor call
      const constructorType = this.inferConstructorType(graph, call);
      if (constructorType) {
        inferredType = constructorType;
        confidence = 'high';
        source = 'constructor';
      } else {
        // Check if it's a method call with known return type
        const methodReturnType = this.inferMethodReturnType(graph, call);
        if (methodReturnType) {
          inferredType = methodReturnType.returnType;
          confidence = methodReturnType.confidence;
          source = 'method_return';
        }
      }
    }
    
    if (inferredType) {
      const variableKey = `${call.callerFilePath}:${call.callerFunction}:${call.assignedToVariable}`;
      const typeInfo: VariableTypeInfo = {
        variableName: call.assignedToVariable,
        inferredType,
        filePath: call.callerFilePath,
        functionContext: call.callerFunction,
        line: call.line,
        confidence,
        source
      };
      
      this.variableTypes.set(variableKey, typeInfo);
      this.logTypeInference(call, inferredType, confidence);
    }
  }

  private inferConstructorType(_graph: KnowledgeGraph, call: FunctionCall): string | undefined {
    // Try to infer the type from constructor calls like MyClass()
    const calledName = call.calledName;
    
    // Simple heuristic: if the called name starts with uppercase, it's likely a class
    if (calledName && calledName[0] === calledName[0].toUpperCase()) {
      return calledName;
    }
    
    return undefined;
  }

  private inferMethodReturnType(graph: KnowledgeGraph, call: FunctionCall): { returnType?: string, confidence: 'high' | 'medium' | 'low' } | null {
    // Find the method node that was called
    const targetNode = this.resolveMethodCall(graph, call) || this.resolveLocalFunction(call);
    
    if (targetNode && this.methodReturnTypes.has(targetNode.id)) {
      const returnTypeInfo = this.methodReturnTypes.get(targetNode.id)!;
      return {
        returnType: returnTypeInfo.returnType,
        confidence: returnTypeInfo.returnType ? 'medium' : 'low'
      };
    }
    
    return null;
  }

  private copyVariableType(filePath: string, functionContext: string, sourceVar: string, targetVar: string): void {
    const sourceKey = `${filePath}:${functionContext}:${sourceVar}`;
    const sourceType = this.variableTypes.get(sourceKey);
    
    if (sourceType) {
      const targetKey = `${filePath}:${functionContext}:${targetVar}`;
      const copiedType: VariableTypeInfo = {
        ...sourceType,
        variableName: targetVar
      };
      this.variableTypes.set(targetKey, copiedType);
    }
  }

  private logTypeInference(call: FunctionCall, inferredType: string, confidence: string): void {
    if (typeof process !== 'undefined' && process.env?.GITNEXUS_DEBUG_TYPES === 'true') {
      console.log(`Type inference: ${call.assignedToVariable} = ${call.calledName}() -> ${inferredType} (${confidence} confidence)`);
    }
  }

  private resolveMethodCall(_graph: KnowledgeGraph, _call: FunctionCall): GraphNode | null {
    // TODO: Implement method call resolution for JS/TS
    return null;
  }

  private resolveLocalFunction(_call: FunctionCall): GraphNode | null {
    // TODO: Implement local function resolution for JS/TS
    return null;
  }

  public getImportInfo(filePath: string): ImportInfo[] {
    return this.importCache.get(filePath) || [];
  }

  private isPythonFile(filePath: string): boolean {
    return filePath.endsWith('.py');
  }

  private isJavaScriptFile(filePath: string): boolean {
    return filePath.endsWith('.js') || filePath.endsWith('.jsx');
  }

  private isTypeScriptFile(filePath: string): boolean {
    return filePath.endsWith('.ts') || filePath.endsWith('.tsx');
  }

  private traverseNode(node: TreeSitterNode, callback: (node: TreeSitterNode) => void): void {
    // Implementation of DFS traversal over the tree-sitter AST
    const stack: TreeSitterNode[] = [node];
    while (stack.length > 0) {
      const current = stack.pop()!;
      callback(current);
      for (let i = current.childCount - 1; i >= 0; i--) {
        const child = current.child(i);
        if (child) stack.push(child);
      }
    }
  }

  private async extractImportsRegex(filePath: string, content: string): Promise<void> {
    const imports: ImportInfo[] = [];
    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      // Match: import module
      const importMatch = trimmedLine.match(/^import\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)/);
      if (importMatch) {
        const moduleName = importMatch[1];
        imports.push({
          filePath,
          importedName: moduleName,
          fromModule: moduleName,
          importType: 'module'
        });
      }
      
      // Match: from module import item
      const fromImportMatch = trimmedLine.match(/^from\s+([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)\s+import\s+([a-zA-Z_][a-zA-Z0-9_]*)/);
      if (fromImportMatch) {
        const moduleName = fromImportMatch[1];
        const importedName = fromImportMatch[2];
        imports.push({
          filePath,
          importedName,
          fromModule: moduleName,
          importType: 'function'
        });
      }
    }
    
    if (imports.length > 0) {
      this.importCache.set(filePath, imports);
      console.log(`Regex-extracted ${imports.length} imports from ${filePath}`);
    }
  }

  private extractCallInfo(
    callNode: TreeSitterNode, 
    filePath: string, 
    currentFunction: string | null
  ): FunctionCall | null {
    const functionNode = callNode.childForFieldName('function');
    if (!functionNode) return null;
    
    const position = callNode.startPosition;
    const line = position.row + 1;
    const column = position.column + 1;
    
    if (functionNode.type === 'identifier') {
      return {
        callerFilePath: filePath,
        callerFunction: currentFunction || '<module>',
        calledName: functionNode.text,
        callType: 'function',
        line,
        column
      };
    } else if (functionNode.type === 'attribute') {
      const objectNode = functionNode.childForFieldName('object');
      const attributeNode = functionNode.childForFieldName('attribute');
      
      if (objectNode && attributeNode) {
        return {
          callerFilePath: filePath,
          callerFunction: currentFunction || '<module>',
          calledName: attributeNode.text,
          callType: 'method',
          line,
          column,
          objectName: objectNode.text
        };
      }
    }
    
    return null;
  }

  private async resolveAndCreateCallRelationship(
    graph: KnowledgeGraph, 
    call: FunctionCall
  ): Promise<void> {
    const callerId = `${call.callerFilePath}:${call.callerFunction}`;
    const targetId = `${call.calledName}:external`;
    
    const relationship = {
      id: `call-${callerId}-${targetId}-${call.line}`,
      type: 'CALLS' as const,
      source: callerId,
      target: targetId,
      properties: {
        callType: call.callType,
        line: call.line,
        column: call.column
      }
    };
    
    graph.relationships.push(relationship);
  }

  public getCallStats(): { totalCalls: number; callTypes: Record<string, number> } {
    return {
      totalCalls: 0,
      callTypes: {
        function: 0,
        method: 0,
        builtin: 0,
        imported: 0,
        local: 0
      }
    };
  }

  private processJSVariableAssignment(assignmentNode: TreeSitterNode, filePath: string, currentFunction: string | null): void {
    // Handle JavaScript/TypeScript variable assignments for type inference
    this.traverseNode(assignmentNode, (node: TreeSitterNode) => {
      if (node.type === 'variable_declarator') {
        const nameNode = node.childForFieldName('name');
        const valueNode = node.childForFieldName('value');
        
        if (nameNode && valueNode) {
          const variableName = nameNode.text;
          
          // Check for constructor calls: new ClassName()
          if (valueNode.type === 'new_expression') {
            const constructorNode = valueNode.childForFieldName('constructor');
            if (constructorNode && constructorNode.type === 'identifier') {
              const className = constructorNode.text;
              this.variableTypes.set(`${filePath}:${currentFunction || 'global'}:${variableName}`, {
                variableName,
                inferredType: className,
                filePath,
                functionContext: currentFunction || 'global',
                line: node.startPosition.row + 1,
                confidence: 'high',
                source: 'constructor'
              });
            }
          }
        }
      }
    });
  }

  private extractJSCallInfo(
    callNode: TreeSitterNode, 
    filePath: string, 
    currentFunction: string | null
  ): FunctionCall | null {
    const functionNode = callNode.childForFieldName('function');
    if (!functionNode) return null;
    
    let calledName = '';
    let callType: 'function' | 'method' | 'attribute' | 'super' = 'function';
    let objectName: string | undefined;
    
    if (functionNode.type === 'identifier') {
      // Simple function call: foo()
      calledName = functionNode.text;
      callType = 'function';
    } else if (functionNode.type === 'member_expression') {
      // Method call: obj.method()
      const objectNode = functionNode.childForFieldName('object');
      const propertyNode = functionNode.childForFieldName('property');
      
      if (objectNode && propertyNode) {
        objectName = objectNode.text;
        calledName = propertyNode.text;
        callType = 'method';
      }
    }
    
    if (!calledName) return null;
    
    return {
      callerFilePath: filePath,
      callerFunction: currentFunction || 'global',
      calledName,
      callType,
      line: callNode.startPosition.row + 1,
      column: callNode.startPosition.column,
      objectName
    };
  }
}

================
File: src/core/ingestion/parsing-processor.ts
================
import type { KnowledgeGraph, GraphNode, GraphRelationship } from '../graph/types.ts';
import { initTreeSitter } from '../tree-sitter/parser-loader.ts';
import { generateId } from '../../lib/utils.ts';

import type Parser from 'web-tree-sitter';
// Add JS/TS loaders
import { loadJavaScriptParser, loadTypeScriptParser, loadTsxParser } from '../tree-sitter/parser-loader.ts';

export interface ParsingInput {
  filePaths: string[];
  fileContents: Map<string, string>;
}

interface ParsedDefinition {
  name: string;
  type: 'function' | 'class' | 'method';
  startLine: number;
  endLine: number;
  parentClass?: string;
  decorators?: string[];
  baseClasses?: string[];
}

export class ParsingProcessor {
  private parser: Parser | null = null;
  private astCache: Map<string, Parser.Tree> = new Map();
  private langPython: Parser.Language | null = null;
  private langJavaScript: Parser.Language | null = null;
  private langTypeScript: Parser.Language | null = null;
  private langTsx: Parser.Language | null = null;

  public async process(graph: KnowledgeGraph, input: ParsingInput): Promise<void> {
    const { filePaths, fileContents } = input;

    console.log('ParsingProcessor: Processing', filePaths.length, 'files');

    // Memory optimization: Process files in batches to prevent OOM
    const BATCH_SIZE = 10; // Process 10 files at a time
    const sourceFiles = filePaths.filter(path => this.isSourceFile(path));
    const configFiles = filePaths.filter(path => this.isConfigFile(path));
    const allProcessableFiles = [...sourceFiles, ...configFiles];
    
    console.log(`ParsingProcessor: Found ${sourceFiles.length} source files and ${configFiles.length} config files, processing in batches of ${BATCH_SIZE}`);

    // Enable tree-sitter parsing once WASM files are available
    try {
      await this.initializeParser();
      
      let successfullyParsed = 0;
      let failedToParse = 0;
      
      // Process files in batches
      for (let i = 0; i < allProcessableFiles.length; i += BATCH_SIZE) {
        const batch = allProcessableFiles.slice(i, i + BATCH_SIZE);
        console.log(`Processing batch ${Math.floor(i / BATCH_SIZE) + 1}/${Math.ceil(allProcessableFiles.length / BATCH_SIZE)} (${batch.length} files)`);
        
        for (const filePath of batch) {
          const fileContent = fileContents.get(filePath);
          if (!fileContent) {
            console.warn(`No content found for file: ${filePath}`);
            continue;
          }

          // Memory optimization: Skip very large files
          if (fileContent.length > 500000) { // Skip files larger than 500KB
            console.warn(`Skipping large file (${fileContent.length} chars): ${filePath}`);
            continue;
          }

          try {
            let definitions: ParsedDefinition[] = [];
            
            if (this.isSourceFile(filePath)) {
              definitions = this.parseFile(filePath, fileContent);
            } else if (this.isConfigFile(filePath)) {
              definitions = this.parseConfigFile(filePath, fileContent);
            }
            
            // Find the existing file node created by StructureProcessor
            const existingFileNode = graph.nodes.find(node => 
              node.label === 'File' && 
              (node.properties.path === filePath || node.properties.filePath === filePath)
            );
            
            if (existingFileNode) {
              // Update the existing file node with parsing results
              const extension = this.getFileExtension(filePath);
              const language = this.getLanguageFromExtension(extension);
              
              existingFileNode.properties.filePath = filePath; // Ensure filePath is set
              existingFileNode.properties.extension = extension;
              existingFileNode.properties.language = language;
              existingFileNode.properties.definitionCount = definitions.length;
              
              // Create definition nodes and relationships
              for (const definition of definitions) {
                const defNode = this.createDefinitionNode(filePath, definition);
                graph.nodes.push(defNode);
                
                // Create CONTAINS relationship from file to definition
                graph.relationships.push({
                  id: generateId('relationship', `${existingFileNode.id}-contains-${defNode.id}`),
                  type: 'CONTAINS',
                  source: existingFileNode.id,
                  target: defNode.id,
                  properties: {}
                });
              }
              
              // Create inheritance and override relationships
              this.createInheritanceRelationships(graph, filePath, definitions);
              
              if (definitions.length > 0) {
                successfullyParsed++;
                console.log(`✅ Successfully parsed ${filePath} - found ${definitions.length} definitions`);
              } else {
                console.log(`⚠️ No definitions found in ${filePath} (file may be empty or contain only imports)`);
              }
            } else {
              console.warn(`⚠️ File node not found for ${filePath}, creating new one`);
              
              // Fallback: create file node if StructureProcessor missed it
              const extension = this.getFileExtension(filePath);
              const language = this.getLanguageFromExtension(extension);
              
              const fileNode: GraphNode = {
                id: generateId('file', filePath),
                label: 'File',
                properties: {
                  name: filePath.split('/').pop() || filePath,
                  filePath,
                  extension,
                  language,
                  definitionCount: definitions.length
                }
              };
              graph.nodes.push(fileNode);
              
              // Create definition nodes and relationships
              for (const definition of definitions) {
                const defNode = this.createDefinitionNode(filePath, definition);
                graph.nodes.push(defNode);
                
                // Create CONTAINS relationship from file to definition
                graph.relationships.push({
                  id: generateId('relationship', `${fileNode.id}-contains-${defNode.id}`),
                  type: 'CONTAINS',
                  source: fileNode.id,
                  target: defNode.id,
                  properties: {}
                });
              }
              
              // Create inheritance and override relationships
              this.createInheritanceRelationships(graph, filePath, definitions);
            }
            
          } catch (parseError) {
            failedToParse++;
            console.error(`❌ Failed to parse ${filePath}:`, parseError);
            
            // Find existing file node and mark it as failed to parse
            const existingFileNode = graph.nodes.find(node => 
              node.label === 'File' && 
              (node.properties.path === filePath || node.properties.filePath === filePath)
            );
            
            if (existingFileNode) {
              existingFileNode.properties.parseError = true;
              existingFileNode.properties.definitionCount = 0;
            }
          }
          
          // Clear AST cache periodically to save memory
          if (this.astCache.size > 20) {
            const oldestKeys = Array.from(this.astCache.keys()).slice(0, 10);
            for (const key of oldestKeys) {
              this.astCache.delete(key);
            }
          }
        }
        
        // Small delay between batches to prevent overwhelming the system
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      
      console.log(`ParsingProcessor: Completed - ${successfullyParsed} successful, ${failedToParse} failed`);
    } catch (error) {
      console.warn('Tree-sitter parsing failed, falling back to basic file nodes:', error);
      
      // Fallback: create basic file nodes without parsing (also in batches)
      for (let i = 0; i < sourceFiles.length; i += BATCH_SIZE) {
        const batch = sourceFiles.slice(i, i + BATCH_SIZE);
        
        for (const filePath of batch) {
          const extension = this.getFileExtension(filePath);
          const language = this.getLanguageFromExtension(extension);
          
          const fileNode: GraphNode = {
            id: generateId('file', filePath),
            label: 'File',
            properties: {
              name: filePath.split('/').pop() || filePath,
              filePath,
              extension,
              language
            }
          };
          graph.nodes.push(fileNode);
        }
      }
    }

    console.log('ParsingProcessor: Created', graph.nodes.filter(n => n.label === 'File').length, 'file nodes');
  }

  private async initializeParser(): Promise<void> {
    if (this.parser) return;

    try {
      await initTreeSitter();
      this.parser = await initTreeSitter();
      // Eagerly try to load languages; missing WASMs will be tolerated
      try { this.langPython = await (await import('../tree-sitter/parser-loader.ts')).loadPythonParser(); } catch (e) { console.debug('Python grammar not available:', e); }
      try { this.langJavaScript = await loadJavaScriptParser(); } catch (e) { console.debug('JavaScript grammar not available:', e); }
      try { this.langTypeScript = await loadTypeScriptParser(); } catch (e) { console.debug('TypeScript grammar not available:', e); }
      try { this.langTsx = await loadTsxParser(); } catch (e) { console.debug('TSX grammar not available:', e); }
      // Don't set a fixed language here; we'll set per-file below
      console.log('Tree-sitter parser initialized successfully');
    } catch (error) {
      console.error('Failed to initialize parser:', error);
      throw new Error(`Parser initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private parseFile(filePath: string, fileContent: string): ParsedDefinition[] {
    const extension = this.getFileExtension(filePath);

    // Select language and parse per file using cached languages
    if (this.parser) {
      try {
        const lang = this.getCachedLanguageForExtension(extension);
        if (lang) this.parser.setLanguage(lang);
      } catch (e) {
        console.warn(`Language set failed for ${filePath} (${extension}):`, e);
      }
    }

    if (extension === '.py') {
      if (this.parser) {
        return this.parsePythonFile(filePath, fileContent);
      } else {
        return this.parsePythonFileRegex(filePath, fileContent);
      }
    }

    if (extension === '.js' || extension === '.mjs' || extension === '.cjs' || extension === '.jsx') {
      if (this.parser) {
        return this.parseJavaScriptFile(filePath, fileContent);
      }
      return [];
    }

    if (extension === '.ts') {
      if (this.parser) {
        return this.parseTypeScriptFile(filePath, fileContent);
      }
      return [];
    }

    if (extension === '.tsx') {
      if (this.parser) {
        return this.parseTsxFile(filePath, fileContent);
      }
      return [];
    }

    return [];
  }

  private parsePythonFileRegex(filePath: string, fileContent: string): ParsedDefinition[] {
    const definitions: ParsedDefinition[] = [];
    const lines = fileContent.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const lineNumber = i + 1;
      
      // Extract decorators for upcoming function/class definitions
      const decorators = this.extractDecoratorsRegex(lines, i);
      
      // Match function definitions: def function_name(
      const functionMatch = line.match(/^def\s+(\w+)\s*\(/);
      if (functionMatch) {
        definitions.push({
          name: functionMatch[1],
          type: 'function',
          startLine: lineNumber,
          endLine: lineNumber,
          decorators: decorators.length > 0 ? decorators : undefined
        });
      }
      
      // Match class definitions: class ClassName
      const classMatch = line.match(/^class\s+(\w+)(?:\s*\(.*\))?\s*:/);
      if (classMatch) {
        const baseClasses = this.extractBaseClassesRegex(line);
        definitions.push({
          name: classMatch[1],
          type: 'class',
          startLine: lineNumber,
          endLine: lineNumber,
          decorators: decorators.length > 0 ? decorators : undefined,
          baseClasses: baseClasses.length > 0 ? baseClasses : undefined
        });
      }
      
      // Match method definitions inside classes (indented def)
      const methodMatch = line.match(/^\s+def\s+(\w+)\s*\(/);
      if (methodMatch) {
        // Find the parent class by looking backwards
        let parentClass = 'UnknownClass';
        for (let j = i - 1; j >= 0; j--) {
          const prevLine = lines[j].trim();
          const classMatch = prevLine.match(/^class\s+(\w+)(?:\s*\(.*\))?\s*:/);
          if (classMatch) {
            parentClass = classMatch[1];
            break;
          }
          // Stop if we hit another function or class at root level
          if (prevLine.match(/^(def|class)\s+/)) {
            break;
          }
        }
        
        // Extract decorators for methods (look for indented decorators)
        const methodDecorators = this.extractMethodDecoratorsRegex(lines, i);
        
        definitions.push({
          name: methodMatch[1],
          type: 'method',
          startLine: lineNumber,
          endLine: lineNumber,
          parentClass,
          decorators: methodDecorators.length > 0 ? methodDecorators : undefined
        });
      }
    }
    
    console.log(`Regex-parsed ${definitions.length} Python definitions from ${filePath}`);
    return definitions;
  }

  private extractDecoratorsRegex(lines: string[], currentIndex: number): string[] {
    const decorators: string[] = [];
    
    // Look backwards for decorator lines
    for (let i = currentIndex - 1; i >= 0; i--) {
      const line = lines[i].trim();
      
      // Stop if we hit a non-decorator, non-empty line
      if (line && !line.startsWith('@')) {
        break;
      }
      
      if (line.startsWith('@')) {
        const decoratorName = this.parseDecoratorNameRegex(line);
        if (decoratorName) {
          decorators.unshift(decoratorName);
        }
      }
    }
    
    return decorators;
  }

  private extractMethodDecoratorsRegex(lines: string[], currentIndex: number): string[] {
    const decorators: string[] = [];
    
    // Look backwards for indented decorator lines
    for (let i = currentIndex - 1; i >= 0; i--) {
      const line = lines[i];
      const trimmedLine = line.trim();
      
      // Stop if we hit a non-decorator line that's not just whitespace
      if (trimmedLine && !trimmedLine.startsWith('@')) {
        break;
      }
      
      if (trimmedLine.startsWith('@') && line.match(/^\s+@/)) {
        const decoratorName = this.parseDecoratorNameRegex(trimmedLine);
        if (decoratorName) {
          decorators.unshift(decoratorName);
        }
      }
    }
    
    return decorators;
  }

  private extractBaseClassesRegex(classLine: string): string[] {
    const baseClasses: string[] = [];
    
    // Match class definition with parentheses: class Child(Parent1, Parent2):
    const match = classLine.match(/^class\s+\w+\s*\(([^)]+)\)\s*:/);
    if (match) {
      const baseClassesStr = match[1].trim();
      if (baseClassesStr) {
        // Split by comma and clean up each base class name
        const classes = baseClassesStr.split(',').map(cls => cls.trim());
        for (const cls of classes) {
          // Handle simple names and qualified names
          const cleanClass = cls.replace(/\s+/g, '');
          if (cleanClass && cleanClass.match(/^[a-zA-Z_][a-zA-Z0-9_.]*$/)) {
            baseClasses.push(cleanClass);
          }
        }
      }
    }
    
    return baseClasses;
  }

  private parseDecoratorNameRegex(decoratorLine: string): string | null {
    // Remove @ symbol and extract decorator name
    const withoutAt = decoratorLine.substring(1);
    
    // Handle simple decorators: @decorator_name
    const simpleMatch = withoutAt.match(/^([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)/);
    if (simpleMatch) {
      return simpleMatch[1];
    }
    
    // Handle decorators with arguments: @decorator_name(args)
    const withArgsMatch = withoutAt.match(/^([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*)\s*\(/);
    if (withArgsMatch) {
      return withArgsMatch[1];
    }
    
    return null;
  }

  private parsePythonFile(filePath: string, fileContent: string): ParsedDefinition[] {
    if (!this.parser) {
      console.warn('Parser not initialized. Cannot parse Python file:', filePath);
      return this.parsePythonFileRegex(filePath, fileContent);
    }

    try {
      const tree = this.parser.parse(fileContent);
      
      this.astCache.set(filePath, tree);
      
      const definitions: ParsedDefinition[] = [];
      const rootNode = tree.rootNode;
      const processedMethodNodes = new Set<string>(); // Use unique identifiers instead of node references

      // First pass: identify all methods inside classes and track their positions
      this.traverseNode(rootNode, (currentNode: Parser.SyntaxNode) => {
        if (currentNode.type === 'class_definition') {
          this.traverseNode(currentNode, (methodNode: Parser.SyntaxNode) => {
            if (methodNode.type === 'function_definition' && methodNode !== currentNode) {
              // Create unique identifier for this method node
              const methodId = `${methodNode.startPosition.row}-${methodNode.startPosition.column}-${methodNode.endPosition.row}-${methodNode.endPosition.column}`;
              processedMethodNodes.add(methodId);
            }
          });
        }
      });

      // Second pass: process all definitions, skipping methods that will be handled as class methods
      this.traverseNode(rootNode, (currentNode: Parser.SyntaxNode) => {
        if (currentNode.type === 'function_definition') {
          // Check if this function is actually a method inside a class
          const nodeId = `${currentNode.startPosition.row}-${currentNode.startPosition.column}-${currentNode.endPosition.row}-${currentNode.endPosition.column}`;
          if (processedMethodNodes.has(nodeId)) {
            // Skip this - it's a method that will be processed as part of a class
            return;
          }
          
          const nameNode = currentNode.childForFieldName('name');
          if (nameNode) {
            const decorators = this.extractDecorators(currentNode);
            definitions.push({
              name: nameNode.text,
              type: 'function',
              startLine: currentNode.startPosition.row + 1,
              endLine: currentNode.endPosition.row + 1,
              decorators: decorators.length > 0 ? decorators : undefined
            });
          }
        } else if (currentNode.type === 'class_definition') {
          const nameNode = currentNode.childForFieldName('name');
          if (nameNode) {
            const className = nameNode.text;
            const decorators = this.extractDecorators(currentNode);
            const baseClasses = this.extractBaseClasses(currentNode);
            definitions.push({
              name: className,
              type: 'class',
              startLine: currentNode.startPosition.row + 1,
              endLine: currentNode.endPosition.row + 1,
              decorators: decorators.length > 0 ? decorators : undefined,
              baseClasses: baseClasses.length > 0 ? baseClasses : undefined
            });
            
            const methods = this.extractMethodsFromClass(currentNode, className);
            definitions.push(...methods);
          }
        }
      });
      
      console.log(`Tree-sitter parsed ${definitions.length} Python definitions from ${filePath}`);
      return definitions;
    } catch (error) {
      console.error(`Error parsing Python file ${filePath}:`, error);
      console.log(`Falling back to regex parsing for ${filePath}`);
      return this.parsePythonFileRegex(filePath, fileContent);
    }
  }

  private createDefinitionNode(filePath: string, definition: ParsedDefinition): GraphNode {
    const nodeLabel = definition.type === 'function' ? 'Function' : 
                     (definition.type === 'method' ? 'Method' : 'Class');
    
    return {
      id: generateId(definition.type, `${filePath}:${definition.name}`),
      label: nodeLabel as 'Function' | 'Method' | 'Class',
      properties: {
        name: definition.name,
        filePath,
        startLine: definition.startLine,
        endLine: definition.endLine,
        ...(definition.parentClass && { parentClass: definition.parentClass }),
        ...(definition.decorators && { decorators: definition.decorators }),
        ...(definition.baseClasses && { baseClasses: definition.baseClasses })
      }
    };
  }

  private createInheritanceRelationships(
    graph: KnowledgeGraph,
    filePath: string,
    definitions: ParsedDefinition[]
  ): void {
    // Create INHERITS relationships for classes with base classes
    const classDefinitions = definitions.filter(def => def.type === 'class');
    
    for (const classDef of classDefinitions) {
      if (classDef.baseClasses && classDef.baseClasses.length > 0) {
        const childClassId = generateId('class', `${filePath}:${classDef.name}`);
        
        for (const baseClassName of classDef.baseClasses) {
          // Try to find the base class in the same file first
          let baseClassId = generateId('class', `${filePath}:${baseClassName}`);
          let baseClassExists = graph.nodes.some(node => node.id === baseClassId);
          
          if (!baseClassExists) {
            // If not found in same file, look for it in other files
            const baseClassNode = graph.nodes.find(node => 
              node.label === 'Class' && 
              node.properties.name === baseClassName
            );
            
            if (baseClassNode) {
              baseClassId = baseClassNode.id;
              baseClassExists = true;
            }
          }
          
          if (baseClassExists) {
            // Create INHERITS relationship
            const inheritanceRelationship: GraphRelationship = {
              id: generateId('relationship', `${childClassId}-inherits-${baseClassId}`),
              type: 'INHERITS',
              source: childClassId,
              target: baseClassId,
              properties: {}
            };
            
            graph.relationships.push(inheritanceRelationship);
            
            // Create OVERRIDES relationships for methods
            this.createOverrideRelationships(graph, filePath, classDef, baseClassName, definitions);
          }
        }
      }
    }
  }

  private createOverrideRelationships(
    graph: KnowledgeGraph,
    filePath: string,
    childClass: ParsedDefinition,
    baseClassName: string,
    allDefinitions: ParsedDefinition[]
  ): void {
    // Get all methods from the child class
    const childMethods = allDefinitions.filter(def => 
      def.type === 'method' && def.parentClass === childClass.name
    );
    
    for (const childMethod of childMethods) {
      // Look for a method with the same name in the base class
      const baseMethodId = this.findBaseClassMethod(graph, baseClassName, childMethod.name);
      
      if (baseMethodId) {
        const childMethodId = generateId('method', `${filePath}:${childMethod.name}`);
        
        // Create OVERRIDES relationship
        const overrideRelationship: GraphRelationship = {
          id: generateId('relationship', `${childMethodId}-overrides-${baseMethodId}`),
          type: 'OVERRIDES',
          source: childMethodId,
          target: baseMethodId,
          properties: {
            methodName: childMethod.name,
            childClass: childClass.name,
            baseClass: baseClassName
          }
        };
        
        graph.relationships.push(overrideRelationship);
      }
    }
  }

  private findBaseClassMethod(graph: KnowledgeGraph, baseClassName: string, methodName: string): string | null {
    // Look for a method with the given name in the base class
    const baseMethod = graph.nodes.find(node => 
      node.label === 'Method' && 
      node.properties.name === methodName &&
      node.properties.parentClass === baseClassName
    );
    
    return baseMethod ? baseMethod.id : null;
  }

  // Remove unused methods to fix linter warnings
  // private createDefinitionRelationships and extractDefinitions are not used

  private extractMethodsFromClass(classNode: Parser.SyntaxNode, className: string): ParsedDefinition[] {
    const methods: ParsedDefinition[] = [];
    
    this.traverseNode(classNode, (node: Parser.SyntaxNode) => {
      if (node.type === 'function_definition') {
        const nameNode = node.childForFieldName('name');
        if (nameNode) {
          const decorators = this.extractDecorators(node);
          methods.push({
            name: nameNode.text,
            type: 'method',
            startLine: node.startPosition.row + 1,
            endLine: node.endPosition.row + 1,
            parentClass: className,
            decorators: decorators.length > 0 ? decorators : undefined
          });
        }
      }
    });
    
    return methods;
  }

  private extractBaseClasses(classNode: Parser.SyntaxNode): string[] {
    const baseClasses: string[] = [];
    
    // Look for argument_list node which contains base classes
    const argumentList = classNode.childForFieldName('superclasses');
    if (argumentList) {
      this.traverseNode(argumentList, (node: Parser.SyntaxNode) => {
        if (node.type === 'identifier') {
          baseClasses.push(node.text);
        } else if (node.type === 'attribute') {
          // Handle qualified names like module.ClassName
          baseClasses.push(node.text);
        }
      });
    }
    
    return baseClasses;
  }

  private extractDecorators(node: Parser.SyntaxNode): string[] {
    const decorators: string[] = [];
    
    // Look for decorator nodes that are siblings before the function/class definition
    let currentNode = node.previousSibling;
    
    while (currentNode && currentNode.type === 'decorator') {
      const decoratorName = this.getDecoratorName(currentNode);
      if (decoratorName) {
        decorators.unshift(decoratorName); // Add to beginning to maintain order
      }
      currentNode = currentNode.previousSibling;
    }
    
    return decorators;
  }

  private getDecoratorName(decoratorNode: Parser.SyntaxNode): string | null {
    // Find the identifier or attribute after the '@' symbol
    for (let i = 0; i < decoratorNode.childCount; i++) {
      const child = decoratorNode.child(i);
      if (!child) continue;
      
      if (child.type === 'identifier') {
        return child.text;
      } else if (child.type === 'attribute') {
        // Handle dotted decorators like @app.route
        return child.text;
      } else if (child.type === 'call') {
        // Handle decorators with arguments like @retry(attempts=3)
        const functionNode = child.childForFieldName('function');
        if (functionNode) {
          if (functionNode.type === 'identifier') {
            return functionNode.text;
          } else if (functionNode.type === 'attribute') {
            return functionNode.text;
          }
        }
      }
    }
    
    return null;
  }

  private traverseNode(node: Parser.SyntaxNode, callback: (node: Parser.SyntaxNode) => void): void {
    callback(node);
    
    for (let i = 0; i < node.childCount; i++) {
      const child = node.child(i);
      if (child) {
        this.traverseNode(child, callback);
      }
    }
  }

  private isSourceFile(filePath: string): boolean {
    // Process Python source files and important Python files
    if (!filePath) return false;
    const fileName = filePath.split('/').pop() || '';
    
    // Include __init__.py files as they're essential for Python packages
    if (fileName === '__init__.py') return true;
    
    const extension = this.getFileExtension(filePath).toLowerCase();
    const sourceExtensions = new Set(['.py', '.js', '.jsx', '.ts', '.tsx']);
    return sourceExtensions.has(extension);
  }

  private isConfigFile(filePath: string): boolean {
    if (!filePath) return false;
    const fileName = filePath.split('/').pop() || '';
    
    const configFiles = new Set([
      'package.json', 'tsconfig.json', 'tsconfig.base.json',
      'vite.config.ts', 'vite.config.js',
      '.eslintrc', '.eslintrc.json', '.eslintrc.js',
      '.prettierrc', '.prettierrc.json',
      'docker-compose.yml', 'docker-compose.yaml',
      'dockerfile', 'Dockerfile',
      '.env', '.env.example', '.env.local',
      'pyproject.toml', 'setup.py', 'requirements.txt'
    ]);
    
    return configFiles.has(fileName.toLowerCase());
  }

  private parseConfigFile(filePath: string, fileContent: string): ParsedDefinition[] {
    const fileName = filePath.split('/').pop() || '';
    const definitions: ParsedDefinition[] = [];
    
    try {
      if (fileName === 'package.json') {
        const packageJson = JSON.parse(fileContent);
        
        // Extract scripts as functions
        if (packageJson.scripts) {
          for (const [scriptName] of Object.entries(packageJson.scripts)) {
            definitions.push({
              name: scriptName,
              type: 'function',
              startLine: 1,
              endLine: 1
            });
          }
        }
        
        // Extract dependencies as metadata (could be used for import resolution)
        const allDeps = {
          ...packageJson.dependencies,
          ...packageJson.devDependencies,
          ...packageJson.peerDependencies
        };
        
        for (const depName of Object.keys(allDeps)) {
          definitions.push({
            name: depName,
            type: 'class', // Treat dependencies as classes for graph purposes
            startLine: 1,
            endLine: 1
          });
        }
      }
      
      else if (fileName.startsWith('tsconfig')) {
        const tsConfig = JSON.parse(fileContent);
        
        // Extract compiler options as configuration metadata
        if (tsConfig.compilerOptions) {
          definitions.push({
            name: 'TypeScriptConfig',
            type: 'class',
            startLine: 1,
            endLine: 1
          });
        }
      }
      
      else if (fileName.toLowerCase().includes('docker')) {
        // Parse Dockerfile for FROM, COPY, RUN commands
        const lines = fileContent.split('\n');
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line.startsWith('FROM ')) {
            const baseImage = line.substring(5).trim();
            definitions.push({
              name: `FROM_${baseImage.replace(/[^a-zA-Z0-9]/g, '_')}`,
              type: 'class',
              startLine: i + 1,
              endLine: i + 1
            });
          }
        }
      }
      
      else if (fileName.startsWith('.env')) {
        // Parse environment variables
        const lines = fileContent.split('\n');
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line && !line.startsWith('#') && line.includes('=')) {
            const [varName] = line.split('=');
            if (varName) {
              definitions.push({
                name: varName.trim(),
                type: 'function', // Treat env vars as functions for graph purposes
                startLine: i + 1,
                endLine: i + 1
              });
            }
          }
        }
      }
      
    } catch (error) {
      console.warn(`Failed to parse config file ${filePath}:`, error);
    }
    
    return definitions;
  }

  private getFileExtension(filePath: string): string {
    if (!filePath) return '';
    const lastDotIndex = filePath.lastIndexOf('.');
    if (lastDotIndex === -1) {
      return '';
    }
    return filePath.substring(lastDotIndex);
  }

  private getLanguageFromExtension(extension: string): string {
    switch (extension.toLowerCase()) {
      case '.py':
      case '.pyx':
      case '.pyi':
        return 'python';
      case '.js':
      case '.mjs':
      case '.cjs':
      case '.jsx':
        return 'javascript';
      case '.ts':
        return 'typescript';
      case '.tsx':
        return 'tsx';
      default:
        return 'unknown';
    }
  }

  private getCachedLanguageForExtension(extension: string): Parser.Language | null {
    switch (extension) {
      case '.py':
        return this.langPython;
      case '.js':
      case '.mjs':
      case '.cjs':
      case '.jsx':
        return this.langJavaScript;
      case '.ts':
        return this.langTypeScript;
      case '.tsx':
        return this.langTsx;
      default:
        return null;
    }
  }

  private parseJavaScriptFile(filePath: string, fileContent: string): ParsedDefinition[] {
    if (!this.parser) {
      console.warn('Parser not initialized. Cannot parse JavaScript file:', filePath);
      return this.parseJavaScriptFileRegex(filePath, fileContent);
    }

    try {
      const tree = this.parser.parse(fileContent);
      this.astCache.set(filePath, tree);
      
      const definitions: ParsedDefinition[] = [];
      const rootNode = tree.rootNode;

      this.traverseNode(rootNode, (node: Parser.SyntaxNode) => {
        // Function declarations: function foo() {}
        if (node.type === 'function_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            definitions.push({
              name: nameNode.text,
              type: 'function',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
        
        // Arrow functions and function expressions: const foo = () => {}
        else if (node.type === 'variable_declarator') {
          const nameNode = node.childForFieldName('name');
          const valueNode = node.childForFieldName('value');
          
          if (nameNode && valueNode && 
              (valueNode.type === 'arrow_function' || valueNode.type === 'function_expression')) {
            definitions.push({
              name: nameNode.text,
              type: 'function',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
        
        // Class declarations: class Foo {}
        else if (node.type === 'class_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            const className = nameNode.text;
            
            // Extract base class if extends clause exists
            const baseClasses: string[] = [];
            const superClassNode = node.childForFieldName('superclass');
            if (superClassNode && superClassNode.type === 'identifier') {
              baseClasses.push(superClassNode.text);
            }
            
            definitions.push({
              name: className,
              type: 'class',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1,
              baseClasses: baseClasses.length > 0 ? baseClasses : undefined
            });
            
            // Extract methods from class body
            const methods = this.extractJSMethodsFromClass(node, className);
            definitions.push(...methods);
          }
        }
      });
      
      console.log(`Tree-sitter parsed ${definitions.length} JavaScript definitions from ${filePath}`);
      return definitions;
    } catch (error) {
      console.error(`Error parsing JavaScript file ${filePath}:`, error);
      console.log(`Falling back to regex parsing for ${filePath}`);
      return this.parseJavaScriptFileRegex(filePath, fileContent);
    }
  }

  private parseJavaScriptFileRegex(_filePath: string, fileContent: string): ParsedDefinition[] {
    const definitions: ParsedDefinition[] = [];
    const lines = fileContent.split('\n');
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const ln = i + 1;
      // function foo(
      const fnDecl = line.match(/\bfunction\s+([A-Za-z_$][\w$]*)\s*\(/);
      if (fnDecl) {
        definitions.push({ name: fnDecl[1], type: 'function', startLine: ln, endLine: ln });
        continue;
      }
      // const foo = (...) => or function expression
      const constFn = line.match(/\bconst\s+([A-Za-z_$][\w$]*)\s*=\s*(async\s*)?\(/);
      if (constFn) {
        definitions.push({ name: constFn[1], type: 'function', startLine: ln, endLine: ln });
        continue;
      }
      // class Foo
      const classDecl = line.match(/\bclass\s+([A-Za-z_$][\w$]*)\b/);
      if (classDecl) {
        definitions.push({ name: classDecl[1], type: 'class', startLine: ln, endLine: ln });
      }
    }
    return definitions;
  }

  private extractJSMethodsFromClass(classNode: Parser.SyntaxNode, className: string): ParsedDefinition[] {
    const methods: ParsedDefinition[] = [];
    
    // Find class body
    const classBody = classNode.childForFieldName('body');
    if (!classBody) return methods;
    
    this.traverseNode(classBody, (node: Parser.SyntaxNode) => {
      if (node.type === 'method_definition') {
        const nameNode = node.childForFieldName('name');
        if (nameNode) {
          methods.push({
            name: nameNode.text,
            type: 'method',
            startLine: node.startPosition.row + 1,
            endLine: node.endPosition.row + 1,
            parentClass: className
          });
        }
      }
    });
    
    return methods;
  }

  private parseTypeScriptFile(filePath: string, fileContent: string): ParsedDefinition[] {
    if (!this.parser) {
      console.warn('Parser not initialized. Cannot parse TypeScript file:', filePath);
      return this.parseTypeScriptFileRegex(filePath, fileContent);
    }

    try {
      const tree = this.parser.parse(fileContent);
      this.astCache.set(filePath, tree);
      
      const definitions: ParsedDefinition[] = [];
      const rootNode = tree.rootNode;

      this.traverseNode(rootNode, (node: Parser.SyntaxNode) => {
        // Function declarations: function foo() {}
        if (node.type === 'function_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            definitions.push({
              name: nameNode.text,
              type: 'function',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
        
        // Arrow functions and function expressions: const foo = () => {}
        else if (node.type === 'variable_declarator') {
          const nameNode = node.childForFieldName('name');
          const valueNode = node.childForFieldName('value');
          
          if (nameNode && valueNode && 
              (valueNode.type === 'arrow_function' || valueNode.type === 'function_expression')) {
            definitions.push({
              name: nameNode.text,
              type: 'function',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
        
        // Class declarations: class Foo {}
        else if (node.type === 'class_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            const className = nameNode.text;
            
            // Extract base class if extends clause exists
            const baseClasses: string[] = [];
            const superClassNode = node.childForFieldName('superclass');
            if (superClassNode && superClassNode.type === 'identifier') {
              baseClasses.push(superClassNode.text);
            }
            
            definitions.push({
              name: className,
              type: 'class',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1,
              baseClasses: baseClasses.length > 0 ? baseClasses : undefined
            });
            
            // Extract methods from class body
            const methods = this.extractTSMethodsFromClass(node, className);
            definitions.push(...methods);
          }
        }
        
        // Interface declarations: interface Foo {}
        else if (node.type === 'interface_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            definitions.push({
              name: nameNode.text,
              type: 'class', // Treat interfaces as classes for graph purposes
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
        
        // Type aliases: type Foo = string
        else if (node.type === 'type_alias_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            definitions.push({
              name: nameNode.text,
              type: 'class', // Treat type aliases as classes for graph purposes
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
        
        // Enum declarations: enum Foo {}
        else if (node.type === 'enum_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            definitions.push({
              name: nameNode.text,
              type: 'class', // Treat enums as classes for graph purposes
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
      });
      
      console.log(`Tree-sitter parsed ${definitions.length} TypeScript definitions from ${filePath}`);
      return definitions;
    } catch (error) {
      console.error(`Error parsing TypeScript file ${filePath}:`, error);
      console.log(`Falling back to regex parsing for ${filePath}`);
      return this.parseTypeScriptFileRegex(filePath, fileContent);
    }
  }

  private parseTypeScriptFileRegex(_filePath: string, fileContent: string): ParsedDefinition[] {
    // Fallback regex parsing for TypeScript
    const definitions: ParsedDefinition[] = [];
    const lines = fileContent.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const ln = i + 1;
      
      // function foo(
      const fnDecl = line.match(/\bfunction\s+([A-Za-z_$][\w$]*)\s*\(/);
      if (fnDecl) {
        definitions.push({ name: fnDecl[1], type: 'function', startLine: ln, endLine: ln });
        continue;
      }
      
      // const foo = (...) => or function expression
      const constFn = line.match(/\bconst\s+([A-Za-z_$][\w$]*)\s*=\s*(async\s*)?\(/);
      if (constFn) {
        definitions.push({ name: constFn[1], type: 'function', startLine: ln, endLine: ln });
        continue;
      }
      
      // class Foo
      const classDecl = line.match(/\bclass\s+([A-Za-z_$][\w$]*)\b/);
      if (classDecl) {
        definitions.push({ name: classDecl[1], type: 'class', startLine: ln, endLine: ln });
        continue;
      }
      
      // interface Foo
      const interfaceDecl = line.match(/\binterface\s+([A-Za-z_$][\w$]*)\b/);
      if (interfaceDecl) {
        definitions.push({ name: interfaceDecl[1], type: 'class', startLine: ln, endLine: ln });
        continue;
      }
      
      // type Foo =
      const typeDecl = line.match(/\btype\s+([A-Za-z_$][\w$]*)\s*=/);
      if (typeDecl) {
        definitions.push({ name: typeDecl[1], type: 'class', startLine: ln, endLine: ln });
        continue;
      }
      
      // enum Foo
      const enumDecl = line.match(/\benum\s+([A-Za-z_$][\w$]*)\b/);
      if (enumDecl) {
        definitions.push({ name: enumDecl[1], type: 'class', startLine: ln, endLine: ln });
      }
    }
    
    return definitions;
  }

  private extractTSMethodsFromClass(classNode: Parser.SyntaxNode, className: string): ParsedDefinition[] {
    const methods: ParsedDefinition[] = [];
    
    // Find class body
    const classBody = classNode.childForFieldName('body');
    if (!classBody) return methods;
    
    this.traverseNode(classBody, (node: Parser.SyntaxNode) => {
      if (node.type === 'method_definition' || node.type === 'method_signature') {
        const nameNode = node.childForFieldName('name');
        if (nameNode) {
          methods.push({
            name: nameNode.text,
            type: 'method',
            startLine: node.startPosition.row + 1,
            endLine: node.endPosition.row + 1,
            parentClass: className
          });
        }
      }
    });
    
    return methods;
  }

  private parseTsxFile(filePath: string, fileContent: string): ParsedDefinition[] {
    if (!this.parser) {
      console.warn('Parser not initialized. Cannot parse TSX file:', filePath);
      return this.parseTsxFileRegex(fileContent);
    }

    try {
      const tree = this.parser.parse(fileContent);
      this.astCache.set(filePath, tree);
      
      const definitions: ParsedDefinition[] = [];
      const rootNode = tree.rootNode;

      this.traverseNode(rootNode, (node: Parser.SyntaxNode) => {
        // Function declarations: function foo() {}
        if (node.type === 'function_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            definitions.push({
              name: nameNode.text,
              type: 'function',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
        
        // Arrow functions and function expressions: const foo = () => {}
        else if (node.type === 'variable_declarator') {
          const nameNode = node.childForFieldName('name');
          const valueNode = node.childForFieldName('value');
          
          if (nameNode && valueNode && 
              (valueNode.type === 'arrow_function' || valueNode.type === 'function_expression')) {
            definitions.push({
              name: nameNode.text,
              type: 'function',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
        
        // Class declarations: class Foo {}
        else if (node.type === 'class_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            const className = nameNode.text;
            
            // Extract base class if extends clause exists
            const baseClasses: string[] = [];
            const superClassNode = node.childForFieldName('superclass');
            if (superClassNode && superClassNode.type === 'identifier') {
              baseClasses.push(superClassNode.text);
            }
            
            definitions.push({
              name: className,
              type: 'class',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1,
              baseClasses: baseClasses.length > 0 ? baseClasses : undefined
            });
            
            // Extract methods from class body
            const methods = this.extractTSXMethodsFromClass(node, className);
            definitions.push(...methods);
          }
        }
        
        // Interface declarations: interface Foo {}
        else if (node.type === 'interface_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            definitions.push({
              name: nameNode.text,
              type: 'class',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
        
        // Type aliases: type Foo = string
        else if (node.type === 'type_alias_declaration') {
          const nameNode = node.childForFieldName('name');
          if (nameNode) {
            definitions.push({
              name: nameNode.text,
              type: 'class',
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1
            });
          }
        }
      });
      
      console.log(`Tree-sitter parsed ${definitions.length} TSX definitions from ${filePath}`);
      return definitions;
    } catch (error) {
      console.error(`Error parsing TSX file ${filePath}:`, error);
      console.log(`Falling back to regex parsing for ${filePath}`);
      return this.parseTsxFileRegex(fileContent);
    }
  }

  private parseTsxFileRegex(/* filePath: string, */ fileContent: string): ParsedDefinition[] {
    // Fallback regex parsing for TSX (similar to TypeScript but with React components)
    const definitions: ParsedDefinition[] = [];
    const lines = fileContent.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const ln = i + 1;
      
      // function foo(
      const fnDecl = line.match(/\bfunction\s+([A-Za-z_$][\w$]*)\s*\(/);
      if (fnDecl) {
        definitions.push({ name: fnDecl[1], type: 'function', startLine: ln, endLine: ln });
        continue;
      }
      
      // const foo = (...) => or function expression (React components)
      const constFn = line.match(/\bconst\s+([A-Za-z_$][\w$]*)\s*=\s*(async\s*)?\(/);
      if (constFn) {
        definitions.push({ name: constFn[1], type: 'function', startLine: ln, endLine: ln });
        continue;
      }
      
      // class Foo
      const classDecl = line.match(/\bclass\s+([A-Za-z_$][\w$]*)\b/);
      if (classDecl) {
        definitions.push({ name: classDecl[1], type: 'class', startLine: ln, endLine: ln });
        continue;
      }
      
      // interface Foo
      const interfaceDecl = line.match(/\binterface\s+([A-Za-z_$][\w$]*)\b/);
      if (interfaceDecl) {
        definitions.push({ name: interfaceDecl[1], type: 'class', startLine: ln, endLine: ln });
        continue;
      }
      
      // type Foo =
      const typeDecl = line.match(/\btype\s+([A-Za-z_$][\w$]*)\s*=/);
      if (typeDecl) {
        definitions.push({ name: typeDecl[1], type: 'class', startLine: ln, endLine: ln });
      }
    }
    
    return definitions;
  }

  private extractTSXMethodsFromClass(classNode: Parser.SyntaxNode, className: string): ParsedDefinition[] {
    const methods: ParsedDefinition[] = [];
    
    // Find class body
    const classBody = classNode.childForFieldName('body');
    if (!classBody) return methods;
    
    this.traverseNode(classBody, (node: Parser.SyntaxNode) => {
      if (node.type === 'method_definition' || node.type === 'method_signature') {
        const nameNode = node.childForFieldName('name');
        if (nameNode) {
          methods.push({
            name: nameNode.text,
            type: 'method',
            startLine: node.startPosition.row + 1,
            endLine: node.endPosition.row + 1,
            parentClass: className
          });
        }
      }
    });
    
    return methods;
  }

  public getAst(filePath: string): Parser.Tree | undefined {
    return this.astCache.get(filePath);
  }

  public getCachedAsts(): Map<string, Parser.Tree> {
    return new Map(this.astCache);
  }
}

================
File: src/core/ingestion/pipeline.ts
================
import type { KnowledgeGraph, GraphRelationship } from '../graph/types.ts';
import { StructureProcessor } from './structure-processor.ts';
import { ParsingProcessor } from './parsing-processor.ts';
import { CallProcessor } from './call-processor.ts';

export interface PipelineInput {
  projectRoot: string;
  projectName: string;
  filePaths: string[];
  fileContents: Map<string, string>;
}

export class GraphPipeline {
  private structureProcessor: StructureProcessor;
  private parsingProcessor: ParsingProcessor;
  private callProcessor: CallProcessor;

  constructor() {
    this.structureProcessor = new StructureProcessor();
    this.parsingProcessor = new ParsingProcessor();
    this.callProcessor = new CallProcessor();
  }

  public async run(input: PipelineInput): Promise<KnowledgeGraph> {
    const { projectRoot, projectName, filePaths, fileContents } = input;
    
    const graph: KnowledgeGraph = {
      nodes: [],
      relationships: []
    };

    console.log(`Starting 3-pass ingestion for project: ${projectName}`);
    
    // Pass 1: Structure Analysis
    console.log('Pass 1: Analyzing project structure...');
    await this.structureProcessor.process(graph, {
      projectRoot,
      projectName,
      filePaths
    });
    
    // Pass 2: Code Parsing and Definition Extraction
    console.log('Pass 2: Parsing code and extracting definitions...');
    await this.parsingProcessor.process(graph, {
      filePaths,
      fileContents
    });
    
    // Pass 3: Call Resolution
    console.log('Pass 3: Resolving function calls and references...');
    await this.callProcessor.process({
      graph,
      astCache: this.parsingProcessor.getCachedAsts(),
      fileContents
    });
    
    console.log(`Ingestion complete. Graph contains ${graph.nodes.length} nodes and ${graph.relationships.length} relationships.`);
    
    // Debug: Show graph structure
    const nodesByType = graph.nodes.reduce((acc, node) => {
      acc[node.label] = (acc[node.label] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    const relationshipsByType = graph.relationships.reduce((acc, rel) => {
      acc[rel.type] = (acc[rel.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    console.log('Node distribution:', nodesByType);
    console.log('Relationship distribution:', relationshipsByType);
    
    // Validate graph integrity
    this.validateGraph(graph);
    
    return graph;
  }

  private validateGraph(graph: KnowledgeGraph): void {
    const nodeIds = new Set(graph.nodes.map(node => node.id));
    const orphanedRelationships: GraphRelationship[] = [];
    
    for (const relationship of graph.relationships) {
      if (!nodeIds.has(relationship.source)) {
        console.warn(`Orphaned relationship: source node '${relationship.source}' not found for relationship '${relationship.id}'`);
        orphanedRelationships.push(relationship);
      }
      
      if (!nodeIds.has(relationship.target)) {
        console.warn(`Orphaned relationship: target node '${relationship.target}' not found for relationship '${relationship.id}'`);
        orphanedRelationships.push(relationship);
      }
    }
    
    // Remove orphaned relationships to prevent graph errors
    if (orphanedRelationships.length > 0) {
      console.warn(`Removing ${orphanedRelationships.length} orphaned relationships`);
      const orphanedIds = new Set(orphanedRelationships.map(rel => rel.id));
      graph.relationships = graph.relationships.filter(rel => !orphanedIds.has(rel.id));
    }
    
    console.log(`Graph validation complete. Final graph: ${graph.nodes.length} nodes, ${graph.relationships.length} relationships`);
  }

  public getStats(graph: KnowledgeGraph): { nodeStats: Record<string, number>; relationshipStats: Record<string, number> } {
    const nodeStats: Record<string, number> = {};
    const relationshipStats: Record<string, number> = {};
    
    for (const node of graph.nodes) {
      nodeStats[node.label] = (nodeStats[node.label] || 0) + 1;
    }
    
    for (const relationship of graph.relationships) {
      relationshipStats[relationship.type] = (relationshipStats[relationship.type] || 0) + 1;
    }
    
    return { nodeStats, relationshipStats };
  }

  public getCallStats(): { totalCalls: number; callTypes: Record<string, number> } {
    return this.callProcessor.getCallStats();
  }
}

================
File: src/core/ingestion/structure-processor.ts
================
import type { KnowledgeGraph, GraphNode, GraphRelationship } from '../graph/types.ts';
import { generateId } from '../../lib/utils.ts';

export interface StructureInput {
  projectRoot: string;
  projectName: string;
  filePaths: string[];
}

export class StructureProcessor {
  private nodeIdMap: Map<string, string> = new Map();

  public async process(graph: KnowledgeGraph, input: StructureInput): Promise<void> {
    const { projectRoot, projectName, filePaths } = input;
    
    // Create project root node
    const projectNode = this.createProjectNode(projectName, projectRoot);
    graph.nodes.push(projectNode);
    
    // Extract unique folder paths from file paths
    const folderPaths = this.extractFolderPaths(filePaths);
    
    // Create folder nodes and establish hierarchy
    const folderNodes = this.createFolderNodes(folderPaths);
    graph.nodes.push(...folderNodes);
    
    // Create file nodes
    const fileNodes = this.createFileNodes(filePaths);
    graph.nodes.push(...fileNodes);
    
    // Establish CONTAINS relationships
    this.createContainsRelationships(graph, projectNode.id, folderPaths, filePaths);
  }

  private createProjectNode(projectName: string, projectRoot: string): GraphNode {
    const id = generateId('project', projectName);
    this.nodeIdMap.set('', id); // Empty path represents project root
    
    return {
      id,
      label: 'Project',
      properties: {
        name: projectName,
        path: projectRoot,
        createdAt: new Date().toISOString()
      }
    };
  }

  private extractFolderPaths(filePaths: string[]): string[] {
    const folderSet = new Set<string>();
    
    for (const filePath of filePaths) {
      const pathParts = filePath.split('/');
      
      // Generate all parent folder paths
      for (let i = 1; i < pathParts.length; i++) {
        const folderPath = pathParts.slice(0, i).join('/');
        if (folderPath) {
          folderSet.add(folderPath);
        }
      }
    }
    
    return Array.from(folderSet).sort();
  }

  private createFolderNodes(folderPaths: string[]): GraphNode[] {
    const nodes: GraphNode[] = [];
    
    for (const folderPath of folderPaths) {
      const pathParts = folderPath.split('/');
      const folderName = pathParts[pathParts.length - 1];
      const id = generateId('folder', folderPath);
      
      this.nodeIdMap.set(folderPath, id);
      
      nodes.push({
        id,
        label: 'Folder',
        properties: {
          name: folderName,
          path: folderPath,
          depth: pathParts.length
        }
      });
    }
    
    return nodes;
  }

  private createFileNodes(filePaths: string[]): GraphNode[] {
    const nodes: GraphNode[] = [];
    
    for (const filePath of filePaths) {
      const pathParts = filePath.split('/');
      const fileName = pathParts[pathParts.length - 1];
      const fileExtension = this.getFileExtension(fileName);
      const id = generateId('file', filePath);
      
      this.nodeIdMap.set(filePath, id);
      
      nodes.push({
        id,
        label: 'File',
        properties: {
          name: fileName,
          filePath: filePath, // Use filePath consistently
          path: filePath, // Keep path for backward compatibility
          extension: fileExtension,
          isSourceFile: this.isSourceFile(fileExtension)
        }
      });
    }
    
    return nodes;
  }

  private createContainsRelationships(
    graph: KnowledgeGraph, 
    _projectId: string, 
    folderPaths: string[], 
    filePaths: string[]
  ): void {
    const relationships: GraphRelationship[] = [];
    
    // Folders contain subfolders
    for (const folderPath of folderPaths) {
      const parentPath = this.getParentPath(folderPath);
      const parentId = this.nodeIdMap.get(parentPath);
      const folderId = this.nodeIdMap.get(folderPath);
      
      if (parentId && folderId && parentPath !== folderPath) {
        relationships.push({
          id: generateId('relationship', `${parentId}-contains-${folderId}`),
          type: 'CONTAINS',
          source: parentId,
          target: folderId
        });
      }
    }
    
    // Folders and project contain files
    for (const filePath of filePaths) {
      const parentPath = this.getParentPath(filePath);
      const parentId = this.nodeIdMap.get(parentPath);
      const fileId = this.nodeIdMap.get(filePath);
      
      if (parentId && fileId) {
        relationships.push({
          id: generateId('relationship', `${parentId}-contains-${fileId}`),
          type: 'CONTAINS',
          source: parentId,
          target: fileId
        });
      }
    }
    
    graph.relationships.push(...relationships);
  }

  private getParentPath(path: string): string {
    const pathParts = path.split('/');
    if (pathParts.length <= 1) return '';
    return pathParts.slice(0, -1).join('/');
  }

  private getFileExtension(fileName: string): string {
    const lastDotIndex = fileName.lastIndexOf('.');
    return lastDotIndex !== -1 ? fileName.substring(lastDotIndex) : '';
  }

  private isSourceFile(extension: string): boolean {
    const sourceExtensions = new Set([
      '.py', '.js', '.ts', '.tsx', '.jsx', '.java', '.cpp', '.c', '.h', '.hpp',
      '.cs', '.php', '.rb', '.go', '.rs', '.swift', '.kt', '.scala'
    ]);
    return sourceExtensions.has(extension);
  }

  public getNodeId(path: string): string | undefined {
    return this.nodeIdMap.get(path);
  }
}

================
File: src/core/tree-sitter/parser-loader.ts
================
// Import tree-sitter explicitly to ensure Vite pre-optimizes it
import Parser from "web-tree-sitter";

let parserInstance: Parser | null = null;
const parserCache = new Map<string, Parser.Language>();

export async function initTreeSitter(): Promise<Parser> {
  if (parserInstance) return parserInstance;
  
  try {
    // Initialize WebAssembly with proper configuration
    await Parser.init({
      locateFile(scriptName: string, scriptDirectory: string) {
        // Return the correct path for WASM files
        if (scriptName.endsWith('.wasm')) {
          return `/wasm/${scriptName}`;
        }
        return scriptDirectory + scriptName;
      }
    });
    parserInstance = new Parser();
    return parserInstance;
  } catch (error) {
    console.error('Failed to initialize Tree-sitter:', error);
    throw new Error(`Tree-sitter initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function loadPythonParser(): Promise<Parser.Language> {
  if (parserCache.has('python')) {
    return parserCache.get('python')!;
  }
  
  try {
    // Load Python language from WASM file
    const wasmPath = '/wasm/python/tree-sitter-python.wasm';
    console.log('Loading Python parser from:', wasmPath);
    
    const pythonLang = await Parser.Language.load(wasmPath);
    
    parserCache.set('python', pythonLang);
    console.log('Python parser loaded successfully');
    return pythonLang;
  } catch (error) {
    console.error('Failed to load Python parser:', error);
    throw new Error(`Python parser loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function loadJavaScriptParser(): Promise<Parser.Language> {
  if (parserCache.has('javascript')) {
    return parserCache.get('javascript')!;
  }
  try {
    const wasmPath = '/wasm/javascript/tree-sitter-javascript.wasm';
    console.log('Loading JavaScript parser from:', wasmPath);
    const jsLang = await Parser.Language.load(wasmPath);
    parserCache.set('javascript', jsLang);
    console.log('JavaScript parser loaded successfully');
    return jsLang;
  } catch (error) {
    console.error('Failed to load JavaScript parser:', error);
    throw new Error(`JavaScript parser loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function loadTypeScriptParser(): Promise<Parser.Language> {
  if (parserCache.has('typescript')) {
    return parserCache.get('typescript')!;
  }
  try {
    const wasmPath = '/wasm/typescript/tree-sitter-typescript.wasm';
    console.log('Loading TypeScript parser from:', wasmPath);
    const tsLang = await Parser.Language.load(wasmPath);
    parserCache.set('typescript', tsLang);
    console.log('TypeScript parser loaded successfully');
    return tsLang;
  } catch (error) {
    console.error('Failed to load TypeScript parser:', error);
    throw new Error(`TypeScript parser loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function loadTsxParser(): Promise<Parser.Language> {
  if (parserCache.has('tsx')) {
    return parserCache.get('tsx')!;
  }
  try {
    const wasmPath = '/wasm/typescript/tree-sitter-tsx.wasm';
    console.log('Loading TSX parser from:', wasmPath);
    const tsxLang = await Parser.Language.load(wasmPath);
    parserCache.set('tsx', tsxLang);
    console.log('TSX parser loaded successfully');
    return tsxLang;
  } catch (error) {
    console.error('Failed to load TSX parser:', error);
    throw new Error(`TSX parser loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

================
File: src/index.css
================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

================
File: src/lib/export.ts
================
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface ExportOptions {
  filename?: string;
  includeMetadata?: boolean;
  prettyPrint?: boolean;
  includeTimestamp?: boolean;
}

export interface ExportMetadata {
  exportedAt: string;
  version: string;
  nodeCount: number;
  relationshipCount: number;
  fileCount?: number;
  processingDuration?: number;
}

export interface ExportedGraph {
  metadata: ExportMetadata;
  graph: KnowledgeGraph;
  fileContents?: Record<string, string>;
}

/**
 * Export a KnowledgeGraph to JSON format
 */
export function exportGraphToJSON(
  graph: KnowledgeGraph,
  options: ExportOptions = {},
  fileContents?: Map<string, string>,
  processingStats?: { duration: number }
): string {
  const {
    includeMetadata = true,
    prettyPrint = true,
    includeTimestamp = true
  } = options;

  let exportData: ExportedGraph | KnowledgeGraph;

  if (includeMetadata) {
    const metadata: ExportMetadata = {
      exportedAt: includeTimestamp ? new Date().toISOString() : '',
      version: '1.0.0',
      nodeCount: graph.nodes.length,
      relationshipCount: graph.relationships.length,
      fileCount: fileContents?.size,
      processingDuration: processingStats?.duration
    };

    exportData = {
      metadata,
      graph,
      ...(fileContents && { fileContents: Object.fromEntries(fileContents) })
    };
  } else {
    exportData = graph;
  }

  return JSON.stringify(exportData, null, prettyPrint ? 2 : 0);
}

/**
 * Trigger download of a JSON file
 */
export function downloadJSON(content: string, filename: string): void {
  try {
    // Create blob with JSON content
    const blob = new Blob([content], { type: 'application/json' });
    
    // Create download URL
    const url = URL.createObjectURL(blob);
    
    // Create temporary download link
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    // Add to DOM, click, and remove
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up URL
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('Failed to download JSON file:', error);
    throw new Error('Failed to download file. Please check your browser permissions.');
  }
}

/**
 * Generate a default filename for the export
 */
export function generateExportFilename(
  projectName?: string,
  includeTimestamp: boolean = true
): string {
  const baseName = projectName 
    ? `gitnexus-${projectName.replace(/[^a-zA-Z0-9-_]/g, '-')}`
    : 'gitnexus-graph';
  
  if (includeTimestamp) {
    const timestamp = new Date().toISOString()
      .replace(/[:.]/g, '-')
      .replace('T', '_')
      .split('.')[0]; // Remove milliseconds
    return `${baseName}_${timestamp}.json`;
  }
  
  return `${baseName}.json`;
}

/**
 * Export and download a KnowledgeGraph
 */
export function exportAndDownloadGraph(
  graph: KnowledgeGraph,
  options: ExportOptions & { projectName?: string } = {},
  fileContents?: Map<string, string>,
  processingStats?: { duration: number }
): void {
  const {
    filename,
    projectName,
    includeTimestamp = true,
    ...exportOptions
  } = options;

  try {
    // Generate filename if not provided
    const finalFilename = filename || generateExportFilename(projectName, includeTimestamp);
    
    // Export to JSON
    const jsonContent = exportGraphToJSON(graph, exportOptions, fileContents, processingStats);
    
    // Trigger download
    downloadJSON(jsonContent, finalFilename);
    
    console.log(`Successfully exported graph to ${finalFilename}`);
  } catch (error) {
    console.error('Export failed:', error);
    throw error;
  }
}

/**
 * Calculate export file size (approximate)
 */
export function calculateExportSize(
  graph: KnowledgeGraph,
  includeFileContents: boolean = false,
  fileContents?: Map<string, string>
): { sizeBytes: number; sizeFormatted: string } {
  // Create a sample export to measure size
  const sampleExport = exportGraphToJSON(
    graph,
    { includeMetadata: true, prettyPrint: false },
    includeFileContents ? fileContents : undefined
  );
  
  const sizeBytes = new Blob([sampleExport]).size;
  const sizeFormatted = formatFileSize(sizeBytes);
  
  return { sizeBytes, sizeFormatted };
}

/**
 * Format file size in human-readable format
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Validate if a graph can be exported
 */
export function validateGraphForExport(graph: KnowledgeGraph): {
  isValid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  // Check if graph exists
  if (!graph) {
    errors.push('Graph is null or undefined');
    return { isValid: false, errors, warnings };
  }
  
  // Check if graph has nodes
  if (!graph.nodes || graph.nodes.length === 0) {
    warnings.push('Graph has no nodes');
  }
  
  // Check if graph has relationships
  if (!graph.relationships || graph.relationships.length === 0) {
    warnings.push('Graph has no relationships');
  }
  
  // Check for invalid node IDs
  const nodeIds = new Set(graph.nodes.map(n => n.id));
  if (nodeIds.size !== graph.nodes.length) {
    errors.push('Graph contains duplicate node IDs');
  }
  
  // Check for invalid relationships
  graph.relationships.forEach((rel, index) => {
    if (!nodeIds.has(rel.source)) {
      errors.push(`Relationship ${index} has invalid source node ID: ${rel.source}`);
    }
    if (!nodeIds.has(rel.target)) {
      errors.push(`Relationship ${index} has invalid target node ID: ${rel.target}`);
    }
  });
  
  // Check for very large exports
  const approximateSize = JSON.stringify(graph).length;
  if (approximateSize > 50 * 1024 * 1024) { // 50MB
    warnings.push('Export file will be very large (>50MB). Consider filtering the data.');
  }
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Import a KnowledgeGraph from JSON string
 */
export function importGraphFromJSON(jsonString: string): {
  graph: KnowledgeGraph;
  metadata?: ExportMetadata;
  fileContents?: Map<string, string>;
} {
  try {
    const parsed = JSON.parse(jsonString);
    
    // Check if it's an exported graph with metadata
    if (parsed.metadata && parsed.graph) {
      const result: {
        graph: KnowledgeGraph;
        metadata: ExportMetadata;
        fileContents?: Map<string, string>;
      } = {
        graph: parsed.graph,
        metadata: parsed.metadata
      };
      
      // Convert file contents back to Map if present
      if (parsed.fileContents) {
        result.fileContents = new Map(Object.entries(parsed.fileContents));
      }
      
      return result;
    }
    
    // Assume it's a raw graph
    return { graph: parsed };
  } catch (error) {
    throw new Error(`Failed to import graph: ${error instanceof Error ? error.message : 'Invalid JSON'}`);
  }
}

/**
 * Create a filtered export of the graph
 */
export function createFilteredExport(
  graph: KnowledgeGraph,
  filters: {
    nodeTypes?: string[];
    relationshipTypes?: string[];
    filePatterns?: string[];
    maxNodes?: number;
  }
): KnowledgeGraph {
  const { nodeTypes, relationshipTypes, filePatterns, maxNodes } = filters;
  
  let filteredNodes = graph.nodes;
  let filteredRelationships = graph.relationships;
  
  // Filter by node types
  if (nodeTypes && nodeTypes.length > 0) {
    filteredNodes = filteredNodes.filter(node => nodeTypes.includes(node.label));
  }
  
  // Filter by file patterns
  if (filePatterns && filePatterns.length > 0) {
    filteredNodes = filteredNodes.filter(node => {
      const filePath = node.properties.filePath as string;
      if (!filePath) return true; // Keep nodes without file paths
      
      return filePatterns.some(pattern => {
        const regex = new RegExp(pattern.replace(/\*/g, '.*'), 'i');
        return regex.test(filePath);
      });
    });
  }
  
  // Limit number of nodes
  if (maxNodes && filteredNodes.length > maxNodes) {
    filteredNodes = filteredNodes.slice(0, maxNodes);
  }
  
  // Get filtered node IDs
  const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
  
  // Filter relationships to only include those between filtered nodes
  filteredRelationships = filteredRelationships.filter(rel => 
    filteredNodeIds.has(rel.source) && filteredNodeIds.has(rel.target)
  );
  
  // Filter by relationship types
  if (relationshipTypes && relationshipTypes.length > 0) {
    filteredRelationships = filteredRelationships.filter(rel => 
      relationshipTypes.includes(rel.type)
    );
  }
  
  return {
    nodes: filteredNodes,
    relationships: filteredRelationships
  };
}

================
File: src/lib/polyfills.ts
================
// Browser polyfill for Node.js AsyncLocalStorage
export class AsyncLocalStorage<T> {
  private storage = new Map<string, T>();
  private currentId = 0;

  constructor() {}

  run<R>(store: T, callback: () => R): R {
    const id = (++this.currentId).toString();
    this.storage.set(id, store);
    try {
      return callback();
    } finally {
      this.storage.delete(id);
    }
  }

  getStore(): T | undefined {
    // In browser context, we can't truly replicate AsyncLocalStorage
    // Return undefined as fallback
    return undefined;
  }
}

// Export as both named and default to match different import styles
export { AsyncLocalStorage as default };

// Polyfill for global async_hooks if not available
if (typeof globalThis !== 'undefined' && !(globalThis as any).AsyncLocalStorage) {
  (globalThis as any).AsyncLocalStorage = AsyncLocalStorage;
}

================
File: src/lib/preload.ts
================
// Preload all dependencies that might be loaded during processing
// This ensures Vite optimizes them during initial build rather than during runtime

import 'web-tree-sitter';
import 'comlink';

// Import all the processing modules to ensure their dependencies are discovered
import '../core/ingestion/pipeline';
import '../core/ingestion/parsing-processor';
import '../core/ingestion/call-processor';
import '../core/ingestion/structure-processor';
import '../core/tree-sitter/parser-loader';

console.log('Dependencies preloaded to prevent runtime optimization');

================
File: src/lib/utils.ts
================
export function generateId(type: string, identifier: string): string {
  const timestamp = Date.now();
  const hash = simpleHash(identifier);
  return `${type}_${hash}_${timestamp}`;
}

function simpleHash(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

================
File: src/lib/workerUtils.ts
================
// Worker utilities for handling different runtime environments
import * as Comlink from 'comlink';
import { IngestionWorker } from '../workers/ingestion.worker.ts';
import type { IngestionProgress, IngestionResult } from '../workers/ingestion.worker.ts';
import type { PipelineInput } from '../core/ingestion/pipeline.ts';

// Export types for external use
export type { IngestionProgress, IngestionResult };

export interface WorkerProxy {
  processRepository(input: PipelineInput): Promise<IngestionResult>;
  processFiles(projectName: string, files: { path: string; content: string }[]): Promise<IngestionResult>;
  validateRepository(input: PipelineInput): Promise<{ valid: boolean; errors: string[] }>;
  getWorkerInfo(): Promise<{ version: string; capabilities: string[] }>;
  setProgressCallback(callback: (progress: IngestionProgress) => void): Promise<void>;
  terminate(): Promise<void>;
}

export class IngestionWorkerManager {
  private worker: Worker | null = null;
  private workerProxy: WorkerProxy | null = null;
  private isInitialized = false;

  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      // Create the worker
      this.worker = new Worker(
        new URL('../workers/ingestion.worker.ts', import.meta.url).href,
        {
          type: 'module',
          name: 'ingestion-worker'
        }
      );

      // Wrap with Comlink
      this.workerProxy = Comlink.wrap<IngestionWorker>(this.worker) as WorkerProxy;
      
      this.isInitialized = true;
      console.log('Ingestion worker initialized successfully');
      
    } catch (error) {
      throw new Error(`Failed to initialize ingestion worker: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async processRepository(input: PipelineInput): Promise<IngestionResult> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.processRepository(input);
    } catch (error) {
      throw new Error(`Worker processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async processFiles(
    projectName: string, 
    files: { path: string; content: string }[]
  ): Promise<IngestionResult> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.processFiles(projectName, files);
    } catch (error) {
      throw new Error(`Worker file processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async validateRepository(input: PipelineInput): Promise<{ valid: boolean; errors: string[] }> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.validateRepository(input);
    } catch (error) {
      return {
        valid: false,
        errors: [`Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`]
      };
    }
  }

  public async setProgressCallback(callback: (progress: IngestionProgress) => void): Promise<void> {
    await this.ensureInitialized();
    
    try {
      // Wrap callback with Comlink.proxy to allow it to be called from worker
      const proxiedCallback = Comlink.proxy(callback);
      await this.workerProxy!.setProgressCallback(proxiedCallback);
    } catch (error) {
      console.warn('Failed to set progress callback:', error);
    }
  }

  public async getWorkerInfo(): Promise<{ version: string; capabilities: string[] }> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.getWorkerInfo();
    } catch (error) {
      throw new Error(`Failed to get worker info: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async terminate(): Promise<void> {
    if (!this.isInitialized || !this.worker) {
      return;
    }

    try {
      // Notify worker to cleanup
      if (this.workerProxy) {
        await this.workerProxy.terminate();
      }
      
      // Terminate the worker
      this.worker.terminate();
      
      // Cleanup references
      this.worker = null;
      this.workerProxy = null;
      this.isInitialized = false;
      
      console.log('Ingestion worker terminated');
      
    } catch (error) {
      console.warn('Error during worker termination:', error);
      
      // Force terminate if cleanup fails
      if (this.worker) {
        this.worker.terminate();
        this.worker = null;
        this.workerProxy = null;
        this.isInitialized = false;
      }
    }
  }

  public isWorkerReady(): boolean {
    return this.isInitialized && this.worker !== null && this.workerProxy !== null;
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.isInitialized) {
      await this.initialize();
    }
  }
}

// Singleton instance for easy access
let workerManager: IngestionWorkerManager | null = null;

export function getIngestionWorker(): IngestionWorkerManager {
  if (!workerManager) {
    workerManager = new IngestionWorkerManager();
  }
  return workerManager;
}

export async function createIngestionWorker(): Promise<IngestionWorkerManager> {
  const manager = new IngestionWorkerManager();
  await manager.initialize();
  return manager;
}

// Utility function for processing with automatic cleanup
export async function processWithWorker<T>(
  processor: (worker: IngestionWorkerManager) => Promise<T>
): Promise<T> {
  const worker = await createIngestionWorker();
  
  try {
    return await processor(worker);
  } finally {
    await worker.terminate();
  }
}

// Error handling utilities
export class WorkerError extends Error {
  constructor(message: string, public readonly cause?: Error) {
    super(message);
    this.name = 'WorkerError';
  }
}

export function isWorkerSupported(): boolean {
  try {
    return typeof Worker !== 'undefined';
  } catch {
    return false;
  }
}

================
File: src/main.tsx
================
import './lib/polyfills.ts';
import './lib/preload.ts';
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById('root')!).render(
  <App />
)

================
File: src/services/github.ts
================
import axios, { type AxiosInstance, type AxiosResponse } from 'axios';

interface GitHubFile {
  name: string;
  path: string;
  sha: string;
  size: number;
  url: string;
  html_url: string;
  git_url: string;
  download_url: string | null;
  type: 'file' | 'dir';
  content?: string;
  encoding?: string;
}

interface GitHubDirectory {
  name: string;
  path: string;
  sha: string;
  size: number;
  url: string;
  html_url: string;
  git_url: string;
  download_url: string | null;
  type: 'file' | 'dir';
}

interface RateLimitInfo {
  limit: number;
  remaining: number;
  reset: number;
  used: number;
}

interface GitHubError {
  message: string;
  documentation_url?: string;
}

export class GitHubService {
  private client: AxiosInstance;
  private baseURL = 'https://api.github.com';
  private rateLimitInfo: RateLimitInfo | null = null;

  constructor(token?: string) {
    this.client = axios.create({
      baseURL: this.baseURL,
      headers: {
        'Accept': 'application/vnd.github.v3+json',
        ...(token && { 'Authorization': `Bearer ${token}` })
      },
      timeout: 30000
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    this.client.interceptors.response.use(
      (response: AxiosResponse) => {
        this.updateRateLimitInfo(response);
        return response;
      },
      (error: { response?: AxiosResponse; message: string }) => {
        if (error.response) {
          this.updateRateLimitInfo(error.response);
          
          if (error.response.status === 403 && this.isRateLimited()) {
            const resetTime = new Date(this.rateLimitInfo!.reset * 1000);
            throw new Error(`GitHub API rate limit exceeded. Resets at ${resetTime.toISOString()}`);
          }
          
          if (error.response.status === 401) {
            throw new Error('GitHub API authentication failed. Please check your token.');
          }
          
          if (error.response.status === 404) {
            throw new Error('Repository or resource not found.');
          }
          
          const githubError: GitHubError = error.response.data;
          throw new Error(`GitHub API error: ${githubError.message}`);
        }
        
        throw new Error(`Network error: ${error.message}`);
      }
    );
  }

  private updateRateLimitInfo(response: AxiosResponse): void {
    const headers = response.headers;
    if (headers['x-ratelimit-limit']) {
      this.rateLimitInfo = {
        limit: parseInt(headers['x-ratelimit-limit'], 10),
        remaining: parseInt(headers['x-ratelimit-remaining'], 10),
        reset: parseInt(headers['x-ratelimit-reset'], 10),
        used: parseInt(headers['x-ratelimit-used'], 10)
      };
    }
  }

  private isRateLimited(): boolean {
    return this.rateLimitInfo !== null && this.rateLimitInfo.remaining === 0;
  }

  public getRateLimitInfo(): RateLimitInfo | null {
    return this.rateLimitInfo;
  }

  public async checkRateLimit(): Promise<void> {
    if (this.isRateLimited()) {
      const resetTime = new Date(this.rateLimitInfo!.reset * 1000);
      const now = new Date();
      
      if (now < resetTime) {
        const waitTime = Math.ceil((resetTime.getTime() - now.getTime()) / 1000);
        throw new Error(`Rate limit exceeded. Wait ${waitTime} seconds before making another request.`);
      }
    }
  }

  public async getRepositoryContents(
    owner: string, 
    repo: string, 
    path: string = ''
  ): Promise<(GitHubFile | GitHubDirectory)[]> {
    await this.checkRateLimit();
    
    try {
      const response = await this.client.get(`/repos/${owner}/${repo}/contents/${path}`);
      
      if (!Array.isArray(response.data)) {
        throw new Error('Expected directory contents, but received a single file.');
      }
      
      return response.data as (GitHubFile | GitHubDirectory)[];
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to fetch repository contents');
    }
  }

  public async getFileContent(
    owner: string, 
    repo: string, 
    path: string
  ): Promise<string> {
    await this.checkRateLimit();
    
    try {
      const response = await this.client.get(`/repos/${owner}/${repo}/contents/${path}`);
      const file = response.data as GitHubFile;
      
      if (file.type !== 'file') {
        throw new Error(`Path ${path} is not a file`);
      }
      
      // If content or encoding is missing, try to download directly
      if (!file.content || !file.encoding) {
        if (file.download_url) {
          console.warn(`File ${path} missing content/encoding, downloading directly`);
          return await this.downloadFileRaw(owner, repo, path);
        } else {
          throw new Error('File content, encoding, and download URL are all missing');
        }
      }
      
      if (file.encoding === 'base64') {
        try {
          return atob(file.content.replace(/\s/g, ''));
        } catch {
          throw new Error('Failed to decode base64 content');
        }
      }
      
      return file.content;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to fetch file content');
    }
  }

  public async downloadFileRaw(
    owner: string, 
    repo: string, 
    path: string
  ): Promise<string> {
    await this.checkRateLimit();
    
    try {
      const response = await this.client.get(`/repos/${owner}/${repo}/contents/${path}`);
      const file = response.data as GitHubFile;
      
      if (file.type !== 'file' || !file.download_url) {
        throw new Error(`Cannot download file: ${path}`);
      }
      
      const downloadResponse = await axios.get(file.download_url, {
        timeout: 30000
      });
      
      return downloadResponse.data;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to download file');
    }
  }

  public async getAllFilesRecursively(owner: string, repo: string, path: string = ''): Promise<GitHubFile[]> {
    const files: GitHubFile[] = [];
    
    try {
      const contents = await this.getRepositoryContents(owner, repo, path);
      
      for (const item of contents) {
        if (item.type === 'dir') {
          // Skip common directories that shouldn't be processed
          if (this.shouldSkipDirectory(item.path)) {
            console.log(`Skipping directory: ${item.path}`);
            continue;
          }
          
          // Recursively get files from subdirectories
          const subFiles = await this.getAllFilesRecursively(owner, repo, item.path);
          files.push(...subFiles);
        } else if (item.type === 'file') {
          // Only include files that should be processed
          if (this.shouldIncludeFile(item.path)) {
            files.push(item);
          } else {
            console.log(`Skipping file: ${item.path}`);
          }
        }
      }
    } catch (error) {
      console.error(`Error fetching contents for ${path}:`, error);
    }
    
    return files;
  }

  private shouldSkipDirectory(path: string): boolean {
    if (!path) return true; // Skip if path is undefined/null
    
    const skipDirs = [
      // Git version control
      '.git',
      // JavaScript dependencies (common in full-stack projects)
      'node_modules',
      // Python bytecode cache
      '__pycache__',
      // Python virtual environments
      'venv',
      'env', 
      '.venv',
      'envs',
      'virtualenv',
      // Build, distribution, and temporary directories
      'build',
      'dist', 
      'logs',
      'tmp',
      '.tmp',
      // Additional common directories to skip
      'coverage',
      '.coverage',
      'htmlcov',
      'vendor',
      'deps',
      '_build',
      '.gradle',
      'bin',
      'obj',
      '.vs',
      '.vscode',
      '.idea',
      'temp'
    ];
    
    // Check each directory component in the path
    const pathParts = path.split('/');
    for (const part of pathParts) {
      const dirName = part.toLowerCase();
      
      // Check for exact matches
      if (skipDirs.includes(dirName) || dirName.startsWith('.')) {
        return true;
      }
      
      // Check for .egg-info directories
      if (dirName.endsWith('.egg-info')) {
        return true;
      }
    }
    
    // Check for virtual environment patterns anywhere in the path
    const fullPathLower = path.toLowerCase();
    const venvPatterns = [
      '/.venv/',
      '/venv/',
      '/env/',
      '/.env/',
      '/envs/',
      '/virtualenv/',
      '/site-packages/',
      '/lib/python',
      '/lib64/python',
      '/scripts/',
      '/bin/python'
    ];
    
    if (venvPatterns.some(pattern => fullPathLower.includes(pattern))) {
      return true;
    }
    
    return false;
  }

  private shouldIncludeFile(path: string): boolean {
    if (!path) return false; // Skip if path is undefined/null
    
    const fileName = path.split('/').pop() || '';
    
    // Skip hidden files except specific config files
    if (fileName.startsWith('.') && !fileName.endsWith('.env.example')) {
      return false;
    }
    
    // Skip Python-specific file patterns
    const skipPatterns = [
      // Python compiled bytecode
      /\.pyc$/,
      /\.pyo$/,
      // Python extension modules (binary)
      /\.pyd$/,
      /\.so$/,
      // Python packages
      /\.egg$/,
      /\.whl$/,
      // Lock files
      /\.lock$/,
      /poetry\.lock$/,
      /Pipfile\.lock$/,
      // Editor swap files
      /\..*\.swp$/,
      /\..*\.swo$/,
      // OS metadata files
      /^Thumbs\.db$/,
      /^\.DS_Store$/,
      // General binary and archive files
      /\.zip$/,
      /\.tar$/,
      /\.rar$/,
      /\.7z$/,
      /\.gz$/,
      // Media files
      /\.(jpg|jpeg|png|gif|bmp|svg|ico)$/i,
      /\.(mp4|avi|mov|wmv|flv|webm)$/i,
      /\.(mp3|wav|flac|aac|ogg)$/i,
      // Document files
      /\.(pdf|doc|docx|xls|xlsx|ppt|pptx)$/i,
      // Other binary files
      /\.(exe|dll|dylib)$/i,
      // Minified files and source maps
      /\.min\.(js|css)$/,
      /\.map$/,
      // Log and temporary files
      /\.log$/,
      /\.tmp$/,
      /\.cache$/,
      /\.pid$/,
      /\.seed$/
    ];
    
    if (skipPatterns.some(pattern => pattern.test(fileName))) {
      return false;
    }
    
    // Include common source and important config files
    const extension = '.' + (fileName.split('.').pop() || '').toLowerCase();

    const includeSourceExts = new Set(['.py', '.js', '.jsx', '.ts', '.tsx']);
    if (includeSourceExts.has(extension)) {
      return true;
    }

    const importantConfigFiles = new Set([
      // Python
      'pyproject.toml', 'setup.py', 'requirements.txt', 'setup.cfg', 'tox.ini', 'pytest.ini', 'pipfile', 'poetry.toml',
      '__init__.py',
      // JS/TS ecosystem
      'package.json', 'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml',
      'tsconfig.json', 'tsconfig.base.json',
      'vite.config.ts', 'vite.config.js',
      '.eslintrc', '.eslintrc.json', '.eslintrc.js', '.prettierrc', '.prettierrc.json',
      // Docs/licenses
      'readme.md', 'license', 'changelog.md', 'manifest.in'
    ]);
    if (importantConfigFiles.has(fileName.toLowerCase())) {
      return true;
    }

    return false;
  }

  public getAuthenticationStatus(): { authenticated: boolean; rateLimitInfo: RateLimitInfo | null } {
    const authHeader = this.client.defaults.headers['Authorization'];
    return {
      authenticated: !!authHeader,
      rateLimitInfo: this.rateLimitInfo
    };
  }
}

================
File: src/services/ingestion.service.ts
================
import { GitHubService } from './github.ts';
import { ZipService } from './zip.ts';
import { getIngestionWorker, type IngestionProgress } from '../lib/workerUtils.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface IngestionOptions {
  directoryFilter?: string;
  fileExtensions?: string;
  onProgress?: (message: string) => void;
}

export interface IngestionResult {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
}

export class IngestionService {
  private githubService: GitHubService;
  private zipService: ZipService;

  constructor(githubToken?: string) {
    this.githubService = new GitHubService(githubToken);
    this.zipService = new ZipService();
  }

  async processGitHubRepo(
    githubUrl: string, 
    options: IngestionOptions = {}
  ): Promise<IngestionResult> {
    const { directoryFilter, fileExtensions, onProgress } = options;

    // Parse GitHub URL
    const match = githubUrl.match(/^https:\/\/github\.com\/([^/]+)\/([^/]+)(?:\/.*)?$/);
    if (!match) {
      throw new Error('Invalid GitHub repository URL');
    }

    const [, owner, repo] = match;
    
    onProgress?.('Fetching repository structure...');
    
    // Get all files from the repository
    const allFiles = await this.githubService.getAllFilesRecursively(owner, repo);
    
    // Filter files based on options
    const filteredFiles = this.filterFiles(allFiles, directoryFilter, fileExtensions);
    
    onProgress?.(`Found ${filteredFiles.length} files. Downloading content...`);
    
    // Download file contents
    const fileContents = new Map<string, string>();
    let processedFiles = 0;
    
    for (const file of filteredFiles) {
      try {
        const content = await this.githubService.getFileContent(owner, repo, file.path);
        if (content && content.length <= 1000000) { // Skip files larger than 1MB
          fileContents.set(file.path, content);
        }
        processedFiles++;
        
        if (processedFiles % 10 === 0) {
          onProgress?.(`Downloaded ${processedFiles}/${filteredFiles.length} files...`);
        }
      } catch (error) {
        console.warn(`Failed to download ${file.path}:`, error);
      }
    }

    onProgress?.('Processing files with knowledge graph engine...');
    
    // Process with ingestion worker
    const graph = await this.processWithWorker(
      fileContents,
      `${owner}/${repo}`,
      Array.from(fileContents.keys()),
      onProgress
    );

    return { graph, fileContents };
  }

  async processZipFile(
    file: File,
    options: IngestionOptions = {}
  ): Promise<IngestionResult> {
    const { directoryFilter, fileExtensions, onProgress } = options;

    onProgress?.('Extracting ZIP file...');
    
    // Extract ZIP contents
    const allFileContents = await this.zipService.extractTextFiles(file);
    
    // Filter files based on options
    const filteredFileContents = new Map<string, string>();
    const allPaths = Array.from(allFileContents.keys());
    const filteredPaths = this.filterPaths(allPaths, directoryFilter, fileExtensions);
    
    filteredPaths.forEach(path => {
      const content = allFileContents.get(path);
      if (content) {
        filteredFileContents.set(path, content);
      }
    });

    onProgress?.(`Extracted ${filteredFileContents.size} files. Processing...`);
    
    // Process with ingestion worker
    const projectName = file.name.replace(/\.zip$/i, '');
    const { normalizedContents, normalizedPaths } = this.normalizeZipPaths(filteredFileContents);
    const graph = await this.processWithWorker(
      normalizedContents,
      projectName,
      normalizedPaths,
      onProgress
    );

    return { graph, fileContents: filteredFileContents };
  }

  private async processWithWorker(
    fileContents: Map<string, string>,
    projectName: string,
    filePaths: string[],
    onProgress?: (message: string) => void
  ): Promise<KnowledgeGraph> {
    const worker = getIngestionWorker();
    
    try {
      await worker.initialize();
      
      // Set up progress callback
      await worker.setProgressCallback((progress: IngestionProgress) => {
        onProgress?.(progress.message);
      });

      onProgress?.('Building knowledge graph...');
      
      // Process repository
      const result = await worker.processRepository({
        projectRoot: '/',
        projectName,
        filePaths,
        fileContents
      });

      if (!result.success || !result.graph) {
        throw new Error(result.error || 'Failed to process repository');
      }

      return result.graph;
    } catch (error) {
      throw new Error(`Processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private filterFiles(files: any[], directoryFilter?: string, fileExtensions?: string): any[] {
    let filtered = files;

    // Filter by directory
    if (directoryFilter?.trim()) {
      const dirPatterns = directoryFilter.toLowerCase().split(',').map(p => p.trim());
      filtered = filtered.filter(file => 
        dirPatterns.some(pattern => file.path.toLowerCase().includes(pattern))
      );
    }

    // Filter by file extensions
    if (fileExtensions?.trim()) {
      const extensions = fileExtensions.toLowerCase().split(',').map(ext => ext.trim());
      filtered = filtered.filter(file => 
        extensions.some(ext => file.path.toLowerCase().endsWith(ext))
      );
    }

    return filtered;
  }

  private filterPaths(paths: string[], directoryFilter?: string, fileExtensions?: string): string[] {
    let filtered = paths;

    // Filter by directory
    if (directoryFilter?.trim()) {
      const dirPatterns = directoryFilter.toLowerCase().split(',').map(p => p.trim());
      filtered = filtered.filter(path => 
        dirPatterns.some(pattern => path.toLowerCase().includes(pattern))
      );
    }

    // Filter by file extensions
    if (fileExtensions?.trim()) {
      const extensions = fileExtensions.toLowerCase().split(',').map(ext => ext.trim());
      filtered = filtered.filter(path => 
        extensions.some(ext => path.toLowerCase().endsWith(ext))
      );
    }

    return filtered;
  }

  private normalizeZipPaths(fileContents: Map<string, string>): { normalizedContents: Map<string, string>; normalizedPaths: string[] } {
    const paths = Array.from(fileContents.keys());
    if (paths.length === 0) {
      return { normalizedContents: fileContents, normalizedPaths: [] };
    }
    // Determine common top-level segment
    const topSegments = new Set(paths.map(p => (p.includes('/') ? p.split('/')[0] : '')));
    if (topSegments.size !== 1 || topSegments.has('')) {
      // Either multiple roots or files at root; no normalization
      return { normalizedContents: fileContents, normalizedPaths: paths };
    }
    const root = Array.from(topSegments)[0];
    const normalized = new Map<string, string>();
    for (const [p, content] of fileContents.entries()) {
      const newPath = p.startsWith(root + '/') ? p.slice(root.length + 1) : p;
      normalized.set(newPath, content);
    }
    return { normalizedContents: normalized, normalizedPaths: Array.from(normalized.keys()) };
  }
}

================
File: src/services/zip.ts
================
import JSZip from 'jszip';

interface JSZipObjectWithData extends JSZip.JSZipObject {
  _data?: {
    uncompressedSize: number;
  };
}

interface ZipFileEntry {
  path: string;
  content: string;
  isDirectory: boolean;
  size: number;
  lastModified: Date;
}

interface ExtractionOptions {
  maxFileSize?: number;
  maxTotalSize?: number;
  allowedExtensions?: string[];
  excludeDirectories?: boolean;
}

export class ZipService {
  private static readonly DEFAULT_MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
  private static readonly DEFAULT_MAX_TOTAL_SIZE = 100 * 1024 * 1024; // 100MB
  private static readonly TEXT_EXTENSIONS = new Set([
    '.js', '.ts', '.tsx', '.jsx', '.py', '.java', '.cpp', '.c', '.h', '.hpp',
    '.cs', '.php', '.rb', '.go', '.rs', '.swift', '.kt', '.scala', '.clj',
    '.html', '.htm', '.xml', '.css', '.scss', '.sass', '.less', '.json',
    '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf', '.md', '.txt',
    '.sql', '.sh', '.bash', '.zsh', '.fish', '.ps1', '.bat', '.cmd',
    '.dockerfile', '.gitignore', '.gitattributes', '.env', '.properties'
  ]);

  constructor() {}

  public async extractTextFiles(
    file: File,
    options: ExtractionOptions = {}
  ): Promise<Map<string, string>> {
    const {
      maxFileSize = ZipService.DEFAULT_MAX_FILE_SIZE,
      maxTotalSize = ZipService.DEFAULT_MAX_TOTAL_SIZE,
      allowedExtensions = Array.from(ZipService.TEXT_EXTENSIONS),
      excludeDirectories = true
    } = options;

    if (!file) {
      throw new Error('No file provided');
    }

    if (file.type !== 'application/zip' && !file.name.toLowerCase().endsWith('.zip')) {
      throw new Error('File must be a ZIP archive');
    }

    try {
      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      const zipContent = await zip.loadAsync(arrayBuffer);
      
      const extractedFiles = new Map<string, string>();
      let totalExtractedSize = 0;
      
      const files = Object.keys(zipContent.files);
      
      for (const filePath of files) {
        const zipFile = zipContent.files[filePath];
        
        if (zipFile.dir && excludeDirectories) {
          continue;
        }
        
        if (zipFile.dir) {
          extractedFiles.set(filePath, '');
          continue;
        }
        
        // Skip directories and files that shouldn't be processed
        if (this.shouldSkipPath(filePath)) {
          console.log(`Skipping filtered path: ${filePath}`);
          continue;
        }
        
        if (!this.isTextFile(filePath, allowedExtensions)) {
          continue;
        }
        
        const zipFileWithData = zipFile as JSZipObjectWithData;
        if (zipFileWithData._data && zipFileWithData._data.uncompressedSize > maxFileSize) {
          console.warn(`Skipping file ${filePath}: exceeds maximum file size (${maxFileSize} bytes)`);
          continue;
        }
        
        if (totalExtractedSize + (zipFileWithData._data?.uncompressedSize || 0) > maxTotalSize) {
          console.warn(`Stopping extraction: total size would exceed maximum (${maxTotalSize} bytes)`);
          break;
        }
        
        try {
          const content = await zipFile.async('text');
          
          if (content.length > maxFileSize) {
            console.warn(`Skipping file ${filePath}: content exceeds maximum file size`);
            continue;
          }
          
          extractedFiles.set(filePath, content);
          totalExtractedSize += content.length;
          
        } catch (fileError) {
          console.warn(`Failed to extract file ${filePath}:`, fileError);
          continue;
        }
      }
      
      return extractedFiles;
      
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes('corrupt') || error.message.includes('invalid')) {
          throw new Error('ZIP file appears to be corrupted or invalid');
        }
        throw new Error(`Failed to extract ZIP file: ${error.message}`);
      }
      throw new Error('Unknown error occurred while extracting ZIP file');
    }
  }

  public async getZipFileInfo(file: File): Promise<ZipFileEntry[]> {
    if (!file) {
      throw new Error('No file provided');
    }

    try {
      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      const zipContent = await zip.loadAsync(arrayBuffer);
      
      const fileInfos: ZipFileEntry[] = [];
      
      for (const [path, zipFile] of Object.entries(zipContent.files)) {
        const file = zipFile as { dir: boolean; _data?: { uncompressedSize: number }; date?: Date };
        fileInfos.push({
          path,
          content: '', // Don't load content for info request
          isDirectory: file.dir,
          size: file._data?.uncompressedSize || 0,
          lastModified: file.date || new Date()
        });
      }
      
      return fileInfos.sort((a, b) => a.path.localeCompare(b.path));
      
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to read ZIP file info: ${error.message}`);
      }
      throw new Error('Unknown error occurred while reading ZIP file info');
    }
  }

  public async extractSpecificFiles(
    file: File,
    filePaths: string[]
  ): Promise<Map<string, string>> {
    if (!file) {
      throw new Error('No file provided');
    }

    if (!filePaths || filePaths.length === 0) {
      throw new Error('No file paths specified');
    }

    try {
      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      const zipContent = await zip.loadAsync(arrayBuffer);
      
      const extractedFiles = new Map<string, string>();
      
      for (const filePath of filePaths) {
        const zipFile = zipContent.files[filePath];
        
        if (!zipFile) {
          console.warn(`File not found in ZIP: ${filePath}`);
          continue;
        }
        
        if (zipFile.dir) {
          extractedFiles.set(filePath, '');
          continue;
        }
        
        try {
          const content = await zipFile.async('text');
          extractedFiles.set(filePath, content);
        } catch (fileError) {
          console.warn(`Failed to extract file ${filePath}:`, fileError);
          continue;
        }
      }
      
      return extractedFiles;
      
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to extract specific files from ZIP: ${error.message}`);
      }
      throw new Error('Unknown error occurred while extracting specific files');
    }
  }

  public isValidZipFile(file: File): boolean {
    if (!file) return false;
    
    return (
      file.type === 'application/zip' || 
      file.type === 'application/x-zip-compressed' ||
      file.name.toLowerCase().endsWith('.zip')
    );
  }

  private async fileToArrayBuffer(file: File): Promise<ArrayBuffer> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = () => {
        if (reader.result instanceof ArrayBuffer) {
          resolve(reader.result);
        } else {
          reject(new Error('Failed to read file as ArrayBuffer'));
        }
      };
      
      reader.onerror = () => {
        reject(new Error('Error reading file'));
      };
      
      reader.readAsArrayBuffer(file);
    });
  }

  private isTextFile(filePath: string, allowedExtensions: string[]): boolean {
    if (!filePath || filePath.endsWith('/')) {
      return false;
    }
    
    const extension = filePath.toLowerCase().split('.').pop();
    return extension ? allowedExtensions.includes(`.${extension}`) : false;
  }

  private shouldSkipPath(filePath: string): boolean {
    // Skip directories that shouldn't be processed
    if (this.shouldSkipDirectory(filePath)) {
      return true;
    }
    
    // Skip files that shouldn't be processed
    if (!this.shouldIncludeFile(filePath)) {
      return true;
    }
    
    return false;
  }

  private shouldSkipDirectory(path: string): boolean {
    if (!path) return true; // Skip if path is undefined/null
    
    const skipDirs = [
      // Git version control
      '.git',
      // JavaScript dependencies (common in full-stack projects)
      'node_modules',
      // Python bytecode cache
      '__pycache__',
      // Python virtual environments
      'venv',
      'env', 
      '.venv',
      'envs',
      'virtualenv',
      // Build, distribution, and temporary directories
      'build',
      'dist', 
      'logs',
      'tmp',
      '.tmp',
      // Additional common directories to skip
      'coverage',
      '.coverage',
      'htmlcov',
      'vendor',
      'deps',
      '_build',
      '.gradle',
      'bin',
      'obj',
      '.vs',
      '.vscode',
      '.idea',
      'temp'
    ];
    
    // Check each directory component in the path
    const pathParts = path.split('/');
    for (const part of pathParts) {
      const dirName = part.toLowerCase();
      
      // Check for exact matches
      if (skipDirs.includes(dirName) || dirName.startsWith('.')) {
        return true;
      }
      
      // Check for .egg-info directories
      if (dirName.endsWith('.egg-info')) {
        return true;
      }
    }
    
    // Check for virtual environment patterns anywhere in the path
    const fullPathLower = path.toLowerCase();
    const venvPatterns = [
      '/.venv/',
      '/venv/',
      '/env/',
      '/.env/',
      '/envs/',
      '/virtualenv/',
      '/site-packages/',
      '/lib/python',
      '/lib64/python',
      '/scripts/',
      '/bin/python'
    ];
    
    if (venvPatterns.some(pattern => fullPathLower.includes(pattern))) {
      return true;
    }
    
    return false;
  }

  private shouldIncludeFile(path: string): boolean {
    if (!path) return false; // Skip if path is undefined/null
    
    const fileName = path.split('/').pop() || '';
    
    // Skip hidden files except specific config files
    if (fileName.startsWith('.') && !fileName.endsWith('.env.example')) {
      return false;
    }
    
    // Skip common compiled/binary patterns
    const skipPatterns = [
      // Python compiled bytecode
      /\.pyc$/,
      /\.pyo$/,
      // Python extension modules (binary)
      /\.pyd$/,
      /\.so$/,
      // Python packages
      /\.egg$/,
      /\.whl$/,
      // Lock files
      /\.lock$/,
      /poetry\.lock$/,
      /Pipfile\.lock$/,
      // Editor swap files
      /\..*\.swp$/,
      /\..*\.swo$/,
      // OS metadata files
      /^Thumbs\.db$/,
      /^\.DS_Store$/,
      // General binary and archive files
      /\.zip$/,
      /\.tar$/,
      /\.rar$/,
      /\.7z$/,
      /\.gz$/,
      // Media files
      /\.(jpg|jpeg|png|gif|bmp|svg|ico)$/i,
      /\.(mp4|avi|mov|wmv|flv|webm)$/i,
      /\.(mp3|wav|flac|aac|ogg)$/i,
      // Document files
      /\.(pdf|doc|docx|xls|xlsx|ppt|pptx)$/i,
      // Other binary files
      /\.(exe|dll|dylib)$/i,
      // Minified files and source maps
      /\.min\.(js|css)$/,
      /\.map$/,
      // Log and temporary files
      /\.log$/,
      /\.tmp$/,
      /\.cache$/,
      /\.pid$/,
      /\.seed$/
    ];
    
    if (skipPatterns.some(pattern => pattern.test(fileName))) {
      return false;
    }
    
    // Include common source and important config files
    const extension = '.' + (fileName.split('.').pop() || '').toLowerCase();
    const includeSourceExts = new Set(['.py', '.js', '.jsx', '.ts', '.tsx']);
    if (includeSourceExts.has(extension)) {
      return true;
    }

    const importantConfigFiles = new Set([
      // Python
      'pyproject.toml', 'setup.py', 'requirements.txt', 'setup.cfg', 'tox.ini', 'pytest.ini', 'pipfile', 'poetry.toml',
      '__init__.py',
      // JS/TS ecosystem
      'package.json', 'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml',
      'tsconfig.json', 'tsconfig.base.json',
      'vite.config.ts', 'vite.config.js',
      '.eslintrc', '.eslintrc.json', '.eslintrc.js', '.prettierrc', '.prettierrc.json',
      // Docs/licenses
      'readme.md', 'license', 'changelog.md', 'manifest.in'
    ]);
    if (importantConfigFiles.has(fileName.toLowerCase())) {
      return true;
    }

    return false;
  }

  public getDefaultTextExtensions(): string[] {
    return Array.from(ZipService.TEXT_EXTENSIONS);
  }

  public async validateZipFile(file: File): Promise<{ valid: boolean; error?: string }> {
    try {
      if (!this.isValidZipFile(file)) {
        return { valid: false, error: 'File is not a valid ZIP archive' };
      }

      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      await zip.loadAsync(arrayBuffer);
      
      return { valid: true };
      
    } catch (error) {
      return { 
        valid: false, 
        error: error instanceof Error ? error.message : 'Unknown validation error' 
      };
    }
  }
}

================
File: src/ui/components/chat/ChatInterface.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import type { KnowledgeGraph } from '../../../core/graph/types.ts';
import { LLMService, type LLMProvider, type LLMConfig } from '../../../ai/llm-service.ts';
import { CypherGenerator } from '../../../ai/cypher-generator.ts';
import { RAGOrchestrator, type RAGResponse, type RAGOptions } from '../../../ai/orchestrator.ts';

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  metadata?: {
    cypherQueries?: Array<{ cypher: string; explanation: string }>;
    sources?: string[];
    confidence?: number;
    reasoning?: Array<{ step: number; thought: string; action: string }>;
  };
}

interface ChatInterfaceProps {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
  className?: string;
  style?: React.CSSProperties;
}

interface LLMSettings {
  provider: LLMProvider;
  apiKey: string;
  model: string;
  temperature: number;
  maxTokens: number;
  // Azure OpenAI specific fields
  azureOpenAIEndpoint?: string;
  azureOpenAIDeploymentName?: string;
  azureOpenAIApiVersion?: string;
}

const ChatInterface: React.FC<ChatInterfaceProps> = ({
  graph,
  fileContents,
  className = '',
  style = {}
}) => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showReasoning, setShowReasoning] = useState(false);
  
  // LLM Configuration
  const [llmSettings, setLLMSettings] = useState<LLMSettings>({
    provider: 'openai',
    apiKey: '',
    model: 'gpt-4o-mini',
    temperature: 0.1,
    maxTokens: 4000,
    azureOpenAIEndpoint: '',
    azureOpenAIDeploymentName: '',
    azureOpenAIApiVersion: '2024-02-01'
  });

  // Services
  const [llmService] = useState(new LLMService());
  const [cypherGenerator] = useState(new CypherGenerator(llmService));
  const [ragOrchestrator] = useState(new RAGOrchestrator(llmService, cypherGenerator));

  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  // Initialize RAG context when graph or fileContents change
  useEffect(() => {
    ragOrchestrator.setContext({ graph, fileContents });
  }, [graph, fileContents, ragOrchestrator]);

  // Load settings from localStorage on mount
  useEffect(() => {
    const savedProvider = localStorage.getItem('llm_provider') as LLMProvider;
    const savedApiKey = localStorage.getItem('llm_api_key');
    const savedAzureEndpoint = localStorage.getItem('azure_openai_endpoint');
    const savedAzureDeployment = localStorage.getItem('azure_openai_deployment');
    const savedAzureApiVersion = localStorage.getItem('azure_openai_api_version');

    if (savedProvider || savedApiKey || savedAzureEndpoint) {
      setLLMSettings(prev => ({
        ...prev,
        provider: savedProvider || prev.provider,
        apiKey: savedApiKey || prev.apiKey,
        azureOpenAIEndpoint: savedAzureEndpoint || prev.azureOpenAIEndpoint,
        azureOpenAIDeploymentName: savedAzureDeployment || prev.azureOpenAIDeploymentName,
        azureOpenAIApiVersion: savedAzureApiVersion || prev.azureOpenAIApiVersion,
        // For Azure OpenAI, use deployment name as model, otherwise use default model
        model: savedProvider === 'azure-openai' 
          ? (savedAzureDeployment || 'gpt-4.1-mini-v2')
          : (savedProvider ? llmService.getAvailableModels(savedProvider)[0] : prev.model)
      }));
    }
  }, [llmService]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputValue.trim() || isLoading) return;

    // Validate API key
    if (!llmSettings.apiKey.trim()) {
      alert('Please configure your API key in settings');
      setShowSettings(true);
      return;
    }

    if (!llmService.validateApiKey(llmSettings.provider, llmSettings.apiKey)) {
      alert('Invalid API key format. Please check your settings.');
      setShowSettings(true);
      return;
    }

    // Additional validation for Azure OpenAI
    if (llmSettings.provider === 'azure-openai') {
      if (!llmSettings.azureOpenAIEndpoint?.trim()) {
        alert('Please configure your Azure OpenAI endpoint in settings');
        setShowSettings(true);
        return;
      }
      if (!llmSettings.azureOpenAIDeploymentName?.trim()) {
        alert('Please configure your Azure OpenAI deployment name in settings');
        setShowSettings(true);
        return;
      }
    }

    const userMessage: ChatMessage = {
      id: generateId(),
      role: 'user',
      content: inputValue.trim(),
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInputValue('');
    setIsLoading(true);

    try {
      const llmConfig: LLMConfig = {
        provider: llmSettings.provider,
        apiKey: llmSettings.apiKey,
        model: llmSettings.model,
        temperature: llmSettings.temperature,
        maxTokens: llmSettings.maxTokens,
        // Azure OpenAI specific fields
        azureOpenAIEndpoint: llmSettings.azureOpenAIEndpoint,
        azureOpenAIDeploymentName: llmSettings.azureOpenAIDeploymentName,
        azureOpenAIApiVersion: llmSettings.azureOpenAIApiVersion
      };

      const ragOptions: RAGOptions = {
        maxReasoningSteps: 5,
        includeReasoning: showReasoning,
        strictMode: false,
        temperature: llmSettings.temperature
      };

      const response: RAGResponse = await ragOrchestrator.answerQuestion(
        userMessage.content,
        llmConfig,
        ragOptions
      );

      const assistantMessage: ChatMessage = {
        id: generateId(),
        role: 'assistant',
        content: response.answer,
        timestamp: new Date(),
        metadata: {
          cypherQueries: response.cypherQueries.map(q => ({
            cypher: q.cypher,
            explanation: q.explanation
          })),
          sources: response.sources,
          confidence: response.confidence,
          reasoning: showReasoning ? response.reasoning.map(r => ({
            step: r.step,
            thought: r.thought,
            action: r.action
          })) : undefined
        }
      };

      setMessages(prev => [...prev, assistantMessage]);

    } catch (error) {
      const errorMessage: ChatMessage = {
        id: generateId(),
        role: 'assistant',
        content: `I apologize, but I encountered an error while processing your question: ${error instanceof Error ? error.message : 'Unknown error'}`,
        timestamp: new Date()
      };

      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  // Handle key press in textarea
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e as any);
    }
  };

  // Clear conversation
  const clearConversation = () => {
    setMessages([]);
  };

  // Generate unique ID
  const generateId = () => {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  };

  // Get available models for current provider
  const getAvailableModels = () => {
    return llmService.getAvailableModels(llmSettings.provider);
  };

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    height: '600px',
    border: '1px solid #ddd',
    borderRadius: '8px',
    backgroundColor: '#fff',
    ...style
  };

  const headerStyle: React.CSSProperties = {
    padding: '16px',
    borderBottom: '1px solid #eee',
    backgroundColor: '#f8f9fa',
    borderRadius: '8px 8px 0 0',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center'
  };

  const messagesStyle: React.CSSProperties = {
    flex: 1,
    overflowY: 'auto',
    padding: '16px',
    display: 'flex',
    flexDirection: 'column',
    gap: '16px'
  };

  const inputAreaStyle: React.CSSProperties = {
    padding: '16px',
    borderTop: '1px solid #eee'
  };

  const messageStyle = (role: 'user' | 'assistant'): React.CSSProperties => ({
    padding: '12px 16px',
    borderRadius: '12px',
    maxWidth: '80%',
    alignSelf: role === 'user' ? 'flex-end' : 'flex-start',
    backgroundColor: role === 'user' ? '#007bff' : '#f1f3f4',
    color: role === 'user' ? '#fff' : '#333',
    wordWrap: 'break-word'
  });

  const buttonStyle: React.CSSProperties = {
    padding: '8px 16px',
    border: 'none',
    borderRadius: '4px',
    backgroundColor: '#007bff',
    color: '#fff',
    cursor: 'pointer',
    fontSize: '14px'
  };

  const textareaStyle: React.CSSProperties = {
    width: '100%',
    minHeight: '60px',
    padding: '12px',
    border: '1px solid #ddd',
    borderRadius: '4px',
    resize: 'vertical',
    fontSize: '14px',
    fontFamily: 'inherit'
  };

  return (
    <div className={`chat-interface ${className}`} style={containerStyle}>
      {/* Header */}
      <div style={headerStyle}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <span style={{ fontSize: '18px', fontWeight: '600' }}>💬</span>
          <span style={{ fontSize: '16px', fontWeight: '600' }}>Code Assistant</span>
          <span style={{ 
            fontSize: '12px', 
            color: '#666',
            backgroundColor: '#e9ecef',
            padding: '2px 8px',
            borderRadius: '12px'
          }}>
            {llmService.getProviderDisplayName(llmSettings.provider)}
          </span>
        </div>
        
        <div style={{ display: 'flex', gap: '8px' }}>
          <button
            onClick={() => setShowReasoning(!showReasoning)}
            style={{
              ...buttonStyle,
              backgroundColor: showReasoning ? '#28a745' : '#6c757d',
              fontSize: '12px',
              padding: '6px 12px'
            }}
            title="Toggle reasoning display"
          >
            🧠 Reasoning
          </button>
          <button
            onClick={() => setShowSettings(!showSettings)}
            style={{ ...buttonStyle, fontSize: '12px', padding: '6px 12px' }}
            title="Settings"
          >
            ⚙️
          </button>
          <button
            onClick={clearConversation}
            style={{
              ...buttonStyle,
              backgroundColor: '#dc3545',
              fontSize: '12px',
              padding: '6px 12px'
            }}
            title="Clear conversation"
          >
            🗑️
          </button>
        </div>
      </div>

      {/* Settings Panel */}
      {showSettings && (
        <div style={{
          padding: '16px',
          backgroundColor: '#f8f9fa',
          borderBottom: '1px solid #eee'
        }}>
          <h4 style={{ margin: '0 0 12px 0', fontSize: '14px' }}>LLM Configuration</h4>
          
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', marginBottom: '12px' }}>
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>Provider</label>
              <select
                value={llmSettings.provider}
                onChange={(e) => setLLMSettings(prev => ({
                  ...prev,
                  provider: e.target.value as LLMProvider,
                  model: llmService.getAvailableModels(e.target.value as LLMProvider)[0]
                }))}
                style={{ width: '100%', padding: '6px', fontSize: '14px' }}
              >
                <option value="openai">OpenAI</option>
                <option value="azure-openai">Azure OpenAI</option>
                <option value="anthropic">Anthropic</option>
                <option value="gemini">Google Gemini</option>
              </select>
            </div>
            
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>
                {llmSettings.provider === 'azure-openai' ? 'Deployment Name' : 'Model'}
              </label>
              {llmSettings.provider === 'azure-openai' ? (
                <input
                  type="text"
                  value={llmSettings.model}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, model: e.target.value }))}
                  placeholder="gpt-4.1-mini-v2"
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                />
              ) : (
                <select
                  value={llmSettings.model}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, model: e.target.value }))}
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                >
                  {getAvailableModels().map(model => (
                    <option key={model} value={model}>{model}</option>
                  ))}
                </select>
              )}
            </div>
          </div>

          <div style={{ marginBottom: '12px' }}>
            <label style={{ fontSize: '12px', color: '#666' }}>API Key</label>
            <input
              type="password"
              value={llmSettings.apiKey}
              onChange={(e) => setLLMSettings(prev => ({ ...prev, apiKey: e.target.value }))}
              placeholder={
                llmSettings.provider === 'azure-openai' ? 'Your Azure OpenAI key...' :
                llmSettings.provider === 'anthropic' ? 'sk-ant-...' :
                llmSettings.provider === 'gemini' ? 'Your Google API key...' : 'sk-...'
              }
              style={{ width: '100%', padding: '6px', fontSize: '14px' }}
            />
          </div>

          {/* Azure OpenAI Specific Fields */}
          {llmSettings.provider === 'azure-openai' && (
            <>
              <div style={{ marginBottom: '12px' }}>
                <label style={{ fontSize: '12px', color: '#666' }}>Azure OpenAI Endpoint</label>
                <input
                  type="text"
                  value={llmSettings.azureOpenAIEndpoint || ''}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, azureOpenAIEndpoint: e.target.value }))}
                  placeholder="https://your-resource.openai.azure.com"
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                />
              </div>

              <div style={{ marginBottom: '12px' }}>
                <label style={{ fontSize: '12px', color: '#666' }}>API Version</label>
                <input
                  type="text"
                  value={llmSettings.azureOpenAIApiVersion || '2024-02-01'}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, azureOpenAIApiVersion: e.target.value }))}
                  placeholder="2024-02-01"
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                />
              </div>
            </>
          )}

          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>
                Temperature: {llmSettings.temperature}
              </label>
              <input
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={llmSettings.temperature}
                onChange={(e) => setLLMSettings(prev => ({ ...prev, temperature: parseFloat(e.target.value) }))}
                style={{ width: '100%' }}
              />
            </div>
            
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>Max Tokens</label>
              <input
                type="number"
                min="100"
                max="8000"
                step="100"
                value={llmSettings.maxTokens}
                onChange={(e) => setLLMSettings(prev => ({ ...prev, maxTokens: parseInt(e.target.value) }))}
                style={{ width: '100%', padding: '6px', fontSize: '14px' }}
              />
            </div>
          </div>

          {/* Save Button */}
          <div style={{ marginTop: '16px', display: 'flex', justifyContent: 'flex-end', gap: '8px' }}>
            <button
              onClick={() => {
                // Save to localStorage
                localStorage.setItem('llm_provider', llmSettings.provider);
                localStorage.setItem('llm_api_key', llmSettings.apiKey);
                if (llmSettings.azureOpenAIEndpoint) {
                  localStorage.setItem('azure_openai_endpoint', llmSettings.azureOpenAIEndpoint);
                }
                // For Azure OpenAI, the model field contains the deployment name
                if (llmSettings.provider === 'azure-openai' && llmSettings.model) {
                  localStorage.setItem('azure_openai_deployment', llmSettings.model);
                }
                if (llmSettings.azureOpenAIApiVersion) {
                  localStorage.setItem('azure_openai_api_version', llmSettings.azureOpenAIApiVersion);
                }
                setShowSettings(false);
                alert('Settings saved successfully!');
              }}
              style={{
                ...buttonStyle,
                backgroundColor: '#28a745',
                fontSize: '12px',
                padding: '8px 16px'
              }}
            >
              💾 Save Settings
            </button>
            <button
              onClick={() => setShowSettings(false)}
              style={{
                ...buttonStyle,
                backgroundColor: '#6c757d',
                fontSize: '12px',
                padding: '8px 16px'
              }}
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Messages */}
      <div style={messagesStyle}>
        {messages.length === 0 && (
          <div style={{
            textAlign: 'center',
            color: '#666',
            fontSize: '14px',
            padding: '40px 20px'
          }}>
            <div style={{ fontSize: '48px', marginBottom: '16px', opacity: 0.3 }}>💬</div>
            <div>Ask me anything about the codebase!</div>
            <div style={{ fontSize: '12px', marginTop: '8px', color: '#999' }}>
              I can help you understand functions, classes, dependencies, and more.
            </div>
          </div>
        )}

        {messages.map((message) => (
          <div key={message.id}>
            <div style={messageStyle(message.role)}>
              <div style={{ marginBottom: message.metadata ? '8px' : '0' }}>
                {message.content}
              </div>
              
              {/* Metadata */}
              {message.metadata && (
                <div style={{ fontSize: '12px', opacity: 0.8 }}>
                  {message.metadata.confidence && (
                    <div style={{ marginBottom: '4px' }}>
                      Confidence: {Math.round(message.metadata.confidence * 100)}%
                    </div>
                  )}
                  
                  {message.metadata.sources && message.metadata.sources.length > 0 && (
                    <div style={{ marginBottom: '4px' }}>
                      Sources: {message.metadata.sources.join(', ')}
                    </div>
                  )}
                  
                  {message.metadata.cypherQueries && message.metadata.cypherQueries.length > 0 && (
                    <details style={{ marginTop: '8px' }}>
                      <summary style={{ cursor: 'pointer' }}>View Queries ({message.metadata.cypherQueries.length})</summary>
                      {message.metadata.cypherQueries.map((query, index) => (
                        <div key={index} style={{ 
                          marginTop: '4px', 
                          padding: '8px', 
                          backgroundColor: 'rgba(0,0,0,0.1)', 
                          borderRadius: '4px',
                          fontFamily: 'monospace',
                          fontSize: '11px'
                        }}>
                          <div><strong>Query:</strong> {query.cypher}</div>
                          <div><strong>Explanation:</strong> {query.explanation}</div>
                        </div>
                      ))}
                    </details>
                  )}

                  {message.metadata.reasoning && message.metadata.reasoning.length > 0 && (
                    <details style={{ marginTop: '8px' }}>
                      <summary style={{ cursor: 'pointer' }}>View Reasoning ({message.metadata.reasoning.length} steps)</summary>
                      {message.metadata.reasoning.map((step, index) => (
                        <div key={index} style={{ 
                          marginTop: '4px', 
                          padding: '8px', 
                          backgroundColor: 'rgba(0,0,0,0.1)', 
                          borderRadius: '4px',
                          fontSize: '11px'
                        }}>
                          <div><strong>Step {step.step}:</strong> {step.thought}</div>
                          <div><strong>Action:</strong> {step.action}</div>
                        </div>
                      ))}
                    </details>
                  )}
                </div>
              )}
            </div>
            
            <div style={{
              fontSize: '11px',
              color: '#999',
              textAlign: message.role === 'user' ? 'right' : 'left',
              marginTop: '4px'
            }}>
              {message.timestamp.toLocaleTimeString()}
            </div>
          </div>
        ))}

        {isLoading && (
          <div style={messageStyle('assistant')}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              <div style={{ 
                width: '16px', 
                height: '16px', 
                border: '2px solid #ccc',
                borderTop: '2px solid #007bff',
                borderRadius: '50%',
                animation: 'spin 1s linear infinite'
              }} />
              Thinking...
            </div>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Input Area */}
      <div style={inputAreaStyle}>
        <form onSubmit={handleSubmit} style={{ display: 'flex', gap: '8px' }}>
          <textarea
            ref={inputRef}
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Ask a question about the code..."
            style={textareaStyle}
            disabled={isLoading}
          />
          <button
            type="submit"
            disabled={isLoading || !inputValue.trim()}
            style={{
              ...buttonStyle,
              minWidth: '80px',
              opacity: (isLoading || !inputValue.trim()) ? 0.5 : 1
            }}
          >
            {isLoading ? '...' : 'Send'}
          </button>
        </form>
      </div>

      {/* CSS for spinner animation */}
      <style>{`
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `}</style>
    </div>
  );
};

export default ChatInterface;

================
File: src/ui/components/chat/CodeAssistant.tsx
================
import React, { useState } from 'react';
import ChatInterface from './ChatInterface.tsx';
import { GraphExplorer } from '../graph/index.ts';
import type { KnowledgeGraph } from '../../../core/graph/types.ts';

interface CodeAssistantProps {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
  className?: string;
  style?: React.CSSProperties;
}

type ViewMode = 'chat' | 'graph' | 'split';

const CodeAssistant: React.FC<CodeAssistantProps> = ({
  graph,
  fileContents,
  className = '',
  style = {}
}) => {
  const [viewMode, setViewMode] = useState<ViewMode>('split');

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    height: '800px',
    backgroundColor: '#f5f5f5',
    borderRadius: '8px',
    overflow: 'hidden',
    ...style
  };

  const headerStyle: React.CSSProperties = {
    padding: '16px',
    backgroundColor: '#fff',
    borderBottom: '1px solid #ddd',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center'
  };

  const contentStyle: React.CSSProperties = {
    flex: 1,
    display: 'flex',
    overflow: 'hidden'
  };

  const panelStyle: React.CSSProperties = {
    flex: 1,
    display: 'flex',
    flexDirection: 'column',
    overflow: 'hidden'
  };

  const buttonStyle = (active: boolean): React.CSSProperties => ({
    padding: '8px 16px',
    border: 'none',
    borderRadius: '4px',
    backgroundColor: active ? '#007bff' : '#6c757d',
    color: '#fff',
    cursor: 'pointer',
    fontSize: '14px',
    marginLeft: '8px'
  });

  const renderContent = () => {
    switch (viewMode) {
      case 'chat':
        return (
          <div style={panelStyle}>
            <ChatInterface
              graph={graph}
              fileContents={fileContents}
              style={{ height: '100%' }}
            />
          </div>
        );

      case 'graph':
        return (
          <div style={panelStyle}>
            <GraphExplorer 
              graph={graph}
              isLoading={false}
            />
          </div>
        );

      case 'split':
        return (
          <>
            <div style={{ ...panelStyle, marginRight: '8px' }}>
              <div style={{
                fontSize: '14px',
                fontWeight: '600',
                padding: '8px 12px',
                backgroundColor: '#e9ecef',
                borderRadius: '4px 4px 0 0',
                marginBottom: '8px'
              }}>
                💬 AI Assistant
              </div>
              <ChatInterface
                graph={graph}
                fileContents={fileContents}
                style={{ height: 'calc(100% - 40px)' }}
              />
            </div>
            
            <div style={{ ...panelStyle, marginLeft: '8px' }}>
              <div style={{
                fontSize: '14px',
                fontWeight: '600',
                padding: '8px 12px',
                backgroundColor: '#e9ecef',
                borderRadius: '4px 4px 0 0',
                marginBottom: '8px'
              }}>
                🕸️ Knowledge Graph
              </div>
              <GraphExplorer
                graph={graph}
                isLoading={false}
              />
            </div>
          </>
        );

      default:
        return null;
    }
  };

  const getStatsText = () => {
    const nodeCount = graph.nodes.length;
    const relationshipCount = graph.relationships.length;
    const fileCount = fileContents.size;
    
    return `${nodeCount} nodes • ${relationshipCount} relationships • ${fileCount} files`;
  };

  return (
    <div className={`code-assistant ${className}`} style={containerStyle}>
      {/* Header */}
      <div style={headerStyle}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <span style={{ fontSize: '20px', fontWeight: '600' }}>🤖</span>
          <div>
            <div style={{ fontSize: '18px', fontWeight: '600' }}>
              GitNexus Code Assistant
            </div>
            <div style={{ fontSize: '12px', color: '#666' }}>
              {getStatsText()}
            </div>
          </div>
        </div>

        <div style={{ display: 'flex', alignItems: 'center' }}>
          <span style={{ fontSize: '14px', color: '#666', marginRight: '12px' }}>
            View:
          </span>
          <button
            onClick={() => setViewMode('chat')}
            style={buttonStyle(viewMode === 'chat')}
          >
            💬 Chat Only
          </button>
          <button
            onClick={() => setViewMode('graph')}
            style={buttonStyle(viewMode === 'graph')}
          >
            🕸️ Graph Only
          </button>
          <button
            onClick={() => setViewMode('split')}
            style={buttonStyle(viewMode === 'split')}
          >
            📱 Split View
          </button>
        </div>
      </div>

      {/* Content */}
      <div style={contentStyle}>
        {renderContent()}
      </div>

      {/* Help Text */}
      {graph.nodes.length === 0 && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          textAlign: 'center',
          color: '#666',
          fontSize: '16px',
          zIndex: 10
        }}>
          <div style={{ fontSize: '64px', marginBottom: '16px', opacity: 0.3 }}>
            🤖
          </div>
          <div style={{ marginBottom: '8px' }}>
            No knowledge graph loaded
          </div>
          <div style={{ fontSize: '14px', color: '#999' }}>
            Please load a project to start using the AI assistant
          </div>
        </div>
      )}
    </div>
  );
};

export default CodeAssistant;

================
File: src/ui/components/chat/index.ts
================
export { default as ChatInterface } from './ChatInterface.tsx';
export { default as CodeAssistant } from './CodeAssistant.tsx';

================
File: src/ui/components/ErrorBoundary.tsx
================
import React, { Component, ReactNode } from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    // Update state so the next render will show the fallback UI
    return {
      hasError: true,
      error
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log the error to console for debugging
    console.error('ErrorBoundary caught an error:', error);
    console.error('Error info:', errorInfo);

    // Update state with error details
    this.setState({
      error,
      errorInfo
    });

    // Call optional error handler
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }

    // In a production app, you might want to log this to an error reporting service
    // logErrorToService(error, errorInfo);
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };

  render() {
    if (this.state.hasError) {
      // Custom fallback UI
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Default error UI
      return (
        <div style={containerStyle}>
          <div style={errorBoxStyle}>
            <div style={iconStyle}>⚠️</div>
            
            <h2 style={titleStyle}>Something went wrong</h2>
            
            <p style={messageStyle}>
              We encountered an unexpected error. This might be due to a temporary issue 
              or an incompatibility with your browser.
            </p>

            <div style={buttonContainerStyle}>
              <button
                onClick={this.handleReset}
                style={primaryButtonStyle}
              >
                Try Again
              </button>
              
              <button
                onClick={() => window.location.reload()}
                style={secondaryButtonStyle}
              >
                Reload Page
              </button>
            </div>

            {/* Error details (collapsible) */}
            <details style={detailsStyle}>
              <summary style={summaryStyle}>
                Technical Details (for developers)
              </summary>
              
              <div style={errorDetailsStyle}>
                <div style={errorSectionStyle}>
                  <strong>Error:</strong>
                  <pre style={preStyle}>
                    {this.state.error?.toString()}
                  </pre>
                </div>
                
                {this.state.errorInfo && (
                  <div style={errorSectionStyle}>
                    <strong>Component Stack:</strong>
                    <pre style={preStyle}>
                      {this.state.errorInfo.componentStack}
                    </pre>
                  </div>
                )}
                
                {this.state.error?.stack && (
                  <div style={errorSectionStyle}>
                    <strong>Stack Trace:</strong>
                    <pre style={preStyle}>
                      {this.state.error.stack}
                    </pre>
                  </div>
                )}
              </div>
            </details>

            <div style={helpTextStyle}>
              <p>
                <strong>What you can do:</strong>
              </p>
              <ul style={helpListStyle}>
                <li>Try refreshing the page</li>
                <li>Clear your browser cache and reload</li>
                <li>Try a different browser</li>
                <li>Check the console for additional error details</li>
              </ul>
              
              <p style={reportStyle}>
                If this problem persists, please report it with the technical details above.
              </p>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

// Styles
const containerStyle: React.CSSProperties = {
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  minHeight: '400px',
  padding: '20px',
  backgroundColor: '#f8f9fa',
  fontFamily: 'system-ui, -apple-system, sans-serif'
};

const errorBoxStyle: React.CSSProperties = {
  maxWidth: '600px',
  width: '100%',
  backgroundColor: '#fff',
  borderRadius: '8px',
  padding: '32px',
  boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
  border: '1px solid #e9ecef',
  textAlign: 'center'
};

const iconStyle: React.CSSProperties = {
  fontSize: '48px',
  marginBottom: '16px'
};

const titleStyle: React.CSSProperties = {
  fontSize: '24px',
  fontWeight: '600',
  color: '#dc3545',
  margin: '0 0 16px 0'
};

const messageStyle: React.CSSProperties = {
  fontSize: '16px',
  color: '#666',
  lineHeight: '1.5',
  margin: '0 0 24px 0'
};

const buttonContainerStyle: React.CSSProperties = {
  display: 'flex',
  gap: '12px',
  justifyContent: 'center',
  marginBottom: '24px'
};

const primaryButtonStyle: React.CSSProperties = {
  padding: '12px 24px',
  backgroundColor: '#007bff',
  color: '#fff',
  border: 'none',
  borderRadius: '4px',
  fontSize: '14px',
  fontWeight: '500',
  cursor: 'pointer',
  transition: 'background-color 0.2s ease'
};

const secondaryButtonStyle: React.CSSProperties = {
  padding: '12px 24px',
  backgroundColor: '#6c757d',
  color: '#fff',
  border: 'none',
  borderRadius: '4px',
  fontSize: '14px',
  fontWeight: '500',
  cursor: 'pointer',
  transition: 'background-color 0.2s ease'
};

const detailsStyle: React.CSSProperties = {
  textAlign: 'left',
  marginTop: '24px',
  border: '1px solid #dee2e6',
  borderRadius: '4px'
};

const summaryStyle: React.CSSProperties = {
  padding: '12px 16px',
  backgroundColor: '#f8f9fa',
  cursor: 'pointer',
  fontSize: '14px',
  fontWeight: '500',
  borderBottom: '1px solid #dee2e6'
};

const errorDetailsStyle: React.CSSProperties = {
  padding: '16px',
  fontSize: '12px'
};

const errorSectionStyle: React.CSSProperties = {
  marginBottom: '16px'
};

const preStyle: React.CSSProperties = {
  backgroundColor: '#f8f9fa',
  padding: '12px',
  borderRadius: '4px',
  overflow: 'auto',
  fontSize: '11px',
  fontFamily: 'Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace',
  color: '#e83e8c',
  border: '1px solid #dee2e6',
  marginTop: '8px'
};

const helpTextStyle: React.CSSProperties = {
  textAlign: 'left',
  marginTop: '24px',
  padding: '16px',
  backgroundColor: '#f8f9fa',
  borderRadius: '4px',
  fontSize: '14px'
};

const helpListStyle: React.CSSProperties = {
  margin: '8px 0',
  paddingLeft: '20px'
};

const reportStyle: React.CSSProperties = {
  fontSize: '12px',
  color: '#666',
  fontStyle: 'italic',
  marginTop: '12px'
};

export default ErrorBoundary;

================
File: src/ui/components/graph/GraphExplorer.tsx
================
import { useState } from 'react';
import GraphVisualization from './Visualization.tsx';
import type { KnowledgeGraph } from '../../../core/graph/types.ts';

interface GraphExplorerProps {
  graph: KnowledgeGraph | null;
  isLoading: boolean;
}

export default function GraphExplorer({ graph, isLoading }: GraphExplorerProps) {
  const [selectedNode, setSelectedNode] = useState<string | null>(null);

  const containerStyle: React.CSSProperties = {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    overflow: 'hidden'
  };

  const loadingStyle: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    height: '100%',
    fontSize: '16px',
    color: '#666'
  };

  if (isLoading) {
    return <div style={containerStyle}><div style={loadingStyle}>Loading graph...</div></div>;
  }

  if (!graph) {
    return <div style={containerStyle}><div style={loadingStyle}>No graph data available</div></div>;
  }

  return (
    <div style={containerStyle}>
      <GraphVisualization 
        graph={graph}
        onNodeSelect={setSelectedNode}
        selectedNodeId={selectedNode}
      />
    </div>
  );
}

================
File: src/ui/components/graph/index.ts
================
export { default as GraphVisualization } from './Visualization.tsx';
export { default as SourceViewer } from './SourceViewer.tsx';
export { default as GraphExplorer } from './GraphExplorer.tsx';

================
File: src/ui/components/graph/SourceViewer.tsx
================
import React, { useMemo } from 'react';
import type { KnowledgeGraph, GraphNode } from '../../../core/graph/types.ts';

interface SourceViewerProps {
  graph: KnowledgeGraph;
  selectedNodeId: string | null;
  fileContents?: Map<string, string>;
  className?: string;
  style?: React.CSSProperties;
}

interface SourceInfo {
  fileName: string;
  filePath: string;
  content: string;
  startLine?: number;
  endLine?: number;
  nodeType: string;
  nodeName: string;
  language?: string;
}

const SourceViewer: React.FC<SourceViewerProps> = ({
  graph,
  selectedNodeId,
  fileContents,
  className = '',
  style = {}
}) => {
  // Warm tone colors to match the new theme
  const colors = {
    background: '#FEF9F0', // Slightly warm white
    surface: '#FFFFFF',
    text: '#451A03', // Dark brown
    textSecondary: '#78350F', // Medium brown
    textMuted: '#A16207', // Light brown
    border: '#FED7AA', // Light orange
    borderLight: '#FEF3C7', // Very light orange
    primary: '#D97706', // Warm orange
    codeBackground: '#FDF6E3', // Warm cream for code
    lineNumbers: '#92400E' // Dark orange for line numbers
  };

  // Extract relevant content from a file for a specific function/class/method
  const extractRelevantContent = (fileContent: string, targetName: string, nodeType: string): string | null => {
    const lines = fileContent.split('\n');
    
    try {
      if (nodeType === 'Function') {
        // Look for function definition patterns
        const patterns = [
          new RegExp(`^\\s*def\\s+${targetName}\\s*\\(`),     // Python
          new RegExp(`^\\s*function\\s+${targetName}\\s*\\(`), // JavaScript
          new RegExp(`^\\s*const\\s+${targetName}\\s*=`),     // JavaScript const
          new RegExp(`^\\s*let\\s+${targetName}\\s*=`),       // JavaScript let
          new RegExp(`^\\s*export\\s+function\\s+${targetName}\\s*\\(`), // ES6 export
          new RegExp(`^\\s*(public|private|protected)?\\s*\\w*\\s*${targetName}\\s*\\(`) // Java/C#
        ];
        
        for (let i = 0; i < lines.length; i++) {
          if (patterns.some(pattern => pattern.test(lines[i]))) {
            // Found the function, now extract it with context
            const startLine = Math.max(0, i - 2); // Include 2 lines before for context
            let endLine = i + 1;
            
            // Find the end of the function (simple heuristic)
            let braceCount = 0;
            const indentLevel = lines[i].match(/^\s*/)?.[0].length || 0;
            
            for (let j = i + 1; j < lines.length; j++) {
              const line = lines[j];
              const currentIndent = line.match(/^\s*/)?.[0].length || 0;
              
              // For Python, use indentation
              if (lines[i].includes('def ')) {
                if (line.trim() && currentIndent <= indentLevel && !line.startsWith(' ')) {
                  break;
                }
                endLine = j;
              } 
              // For JavaScript/Java, use braces
              else {
                braceCount += (line.match(/\{/g) || []).length;
                braceCount -= (line.match(/\}/g) || []).length;
                endLine = j;
                if (braceCount === 0 && j > i) {
                  break;
                }
              }
              
              // Safety limit
              if (j - i > 100) break;
            }
            
            return lines.slice(startLine, endLine + 3).join('\n'); // Include 3 lines after
          }
        }
      }
      
      if (nodeType === 'Class') {
        const patterns = [
          new RegExp(`^\\s*class\\s+${targetName}\\b`),
          new RegExp(`^\\s*(public|private)?\\s*class\\s+${targetName}\\b`)
        ];
        
        for (let i = 0; i < lines.length; i++) {
          if (patterns.some(pattern => pattern.test(lines[i]))) {
            const startLine = Math.max(0, i - 2);
            const endLine = i + 20; // Show first 20 lines of class
            
            return lines.slice(startLine, Math.min(endLine, lines.length)).join('\n');
          }
        }
      }
      
      // If we can't extract specifically, return null to use full file
      return null;
    } catch (error) {
      console.warn('Error extracting content:', error);
      return null;
    }
  };

  // Generate mock source content based on node type
  const generateMockContent = (node: GraphNode): string => {
    try {
      const name = node.properties.name as string || 'unknown';
      
      switch (node.label) {
        case 'Function':
          return `def ${name}():
    """
    Function: ${name}
    """
    # Implementation here
    pass`;

        case 'Method': {
          const parentClass = node.properties.parentClass as string || 'UnknownClass';
          return `class ${parentClass}:
    def ${name}(self):
        """
        Method: ${name}
        Class: ${parentClass}
        """
        # Implementation here
        pass`;
        }

        case 'Class':
          return `class ${name}:
    """
    Class: ${name}
    """
    
    def __init__(self):
        # Constructor
        pass`;

        case 'Variable':
          return `# Variable: ${name}
${name} = None  # Initialize variable`;

        case 'File': {
          const path = node.properties.path as string || name;
          const extension = path.split('.').pop()?.toLowerCase() || 'txt';
          
          switch (extension) {
            case 'py':
              return `# File: ${path}
"""
Python module: ${name}
"""

def main():
    print("Hello from ${name}")

if __name__ == "__main__":
    main()`;
            
            case 'js':
            case 'ts':
              return `// File: ${path}
/**
 * JavaScript/TypeScript module: ${name}
 */

function main() {
    console.log("Hello from ${name}");
}

export default main;`;
            
            case 'java':
              return `// File: ${path}
/**
 * Java class: ${name}
 */
public class ${name.replace(/\.[^/.]+$/, "")} {
    public static void main(String[] args) {
        System.out.println("Hello from ${name}");
    }
}`;
            
            default:
              return `// File: ${path}
// Content of ${name}`;
          }
        }

        case 'Folder':
          return `# Directory: ${name}
# This is a folder containing other files and directories`;

        case 'Project':
          return `# Project: ${name}
# Root directory of the project`;

        default:
          return `# ${node.label}: ${name}
# No specific content available`;
      }
    } catch (error) {
      return `# Error generating content for ${node.label}
# ${error instanceof Error ? error.message : 'Unknown error'}`;
    }
  };

  // Generate content for built-in functions
  const generateBuiltinFunctionContent = (functionName: string): string => {
    switch (functionName) {
      case 'round':
        return `# Built-in Function: ${functionName}
"""
Rounds a number to the nearest integer.
"""

def round(number: float, ndigits: int = 0) -> float:
    """
    Rounds a number to the nearest integer.
    Args:
        number (float): The number to round.
        ndigits (int, optional): The number of decimal places to round to. Defaults to 0.
    Returns:
        float: The rounded number.
    """
    # Implementation here
    pass`;
      case 'len':
        return `# Built-in Function: ${functionName}
"""
Returns the number of items in an object.
"""

def len(obj: Any) -> int:
    """
    Returns the number of items in an object.
    Args:
        obj (Any): The object to get the length of.
    Returns:
        int: The number of items.
    """
    # Implementation here
    pass`;
      case 'print':
        return `# Built-in Function: ${functionName}
"""
Prints the given arguments to the standard output.
"""

def print(*args, sep: str = " ", end: str = "\\n") -> None:
    """
    Prints the given arguments to the standard output.
    Args:
        *args: The arguments to print.
        sep (str, optional): The separator between arguments. Defaults to " ".
        end (str, optional): The string to print at the end. Defaults to "\\n".
    """
    # Implementation here
    pass`;
      case 'input':
        return `# Built-in Function: ${functionName}
"""
Reads a line from the standard input.
"""

def input(prompt: str = "") -> str:
    """
    Reads a line from the standard input.
    Args:
        prompt (str, optional): The prompt to display. Defaults to "".
    Returns:
        str: The input string.
    """
    # Implementation here
    pass`;
      case 'open':
        return `# Built-in Function: ${functionName}
"""
Opens a file and returns a file object.
"""

def open(file: str, mode: str = "r", buffering: int = -1, encoding: str | None = None, errors: str | None = None, newline: str | None = None) -> Any:
    """
    Opens a file and returns a file object.
    Args:
        file (str): The path to the file.
        mode (str, optional): The mode in which the file is opened. Defaults to "r".
        buffering (int, optional): The buffering strategy. Defaults to -1.
        encoding (str | None, optional): The encoding to use. Defaults to None.
        errors (str | None, optional): How to handle encoding errors. Defaults to None.
        newline (str | None, optional): How to handle newlines. Defaults to None.
    Returns:
        Any: The file object.
    """
    # Implementation here
    pass`;
      case 'type':
        return `# Built-in Function: ${functionName}
"""
Returns the type of an object.
"""

def type(obj: Any) -> type:
    """
    Returns the type of an object.
    Args:
        obj (Any): The object to get the type of.
    Returns:
        type: The type of the object.
    """
    # Implementation here
    pass`;
      case 'isinstance':
        return `# Built-in Function: ${functionName}
"""
Checks if an object is an instance of a class or a tuple of classes.
"""

def isinstance(obj: Any, classinfo: type | tuple[type, ...]) -> bool:
    """
    Checks if an object is an instance of a class or a tuple of classes.
    Args:
        obj (Any): The object to check.
        classinfo (type | tuple[type, ...]): The class or tuple of classes to check against.
    Returns:
        bool: True if the object is an instance of the class or one of the classes in the tuple.
    """
    # Implementation here
    pass`;
      case 'hasattr':
        return `# Built-in Function: ${functionName}
"""
Checks if an object has an attribute.
"""

def hasattr(obj: Any, name: str) -> bool:
    """
    Checks if an object has an attribute.
    Args:
        obj (Any): The object to check.
        name (str): The name of the attribute to check for.
    Returns:
        bool: True if the object has the attribute, False otherwise.
    """
    # Implementation here
    pass`;
      default:
        return `# Built-in Function: ${functionName}
# No specific content available`;
    }
  };

  // Get source info for selected node
  const sourceInfo = useMemo((): SourceInfo | null => {
    if (!selectedNodeId || !graph?.nodes) return null;

    const node = graph.nodes.find(n => n.id === selectedNodeId);
    if (!node) return null;

    const nodeName = node.properties.name as string || node.id;
    
    // First, try to get the file path from the node's properties
    let filePath = node.properties.path as string || node.properties.filePath as string;
    
    // If the node doesn't have a direct file path, find it through graph relationships
    if (!filePath || filePath === nodeName) {
      console.log('SourceViewer - Finding file through graph relationships for:', nodeName);
      
      // Find the file that CONTAINS this node
      const containsRelationship = graph.relationships?.find(rel => 
        rel.type === 'CONTAINS' && rel.target === selectedNodeId
      );
      
      if (containsRelationship) {
        const fileNode = graph.nodes.find(n => n.id === containsRelationship.source);
        if (fileNode && fileNode.label === 'File') {
          filePath = fileNode.properties.path as string || fileNode.properties.filePath as string;
          console.log('SourceViewer - Found file through CONTAINS relationship:', filePath);
        }
      }
      
      // If still no file path, try reverse lookup by searching for the node name in file contents
      if (!filePath && fileContents) {
        console.log('SourceViewer - Searching file contents for node:', nodeName);
        
        // Try multiple search patterns for the function
        const searchPatterns = [
          `def ${nodeName}(`,           // Python function
          `def ${nodeName} (`,          // Python function with space
          `function ${nodeName}(`,      // JavaScript function
          `function ${nodeName} (`,     // JavaScript function with space
          `const ${nodeName} =`,        // JavaScript const
          `let ${nodeName} =`,          // JavaScript let
          `var ${nodeName} =`,          // JavaScript var
          `class ${nodeName}`,          // Class definition
          `${nodeName}:`,               // Object property or TypeScript type
          `export const ${nodeName}`,   // ES6 export
          `export function ${nodeName}`, // ES6 export function
          `public ${nodeName}(`,        // Java/C# method
          `private ${nodeName}(`,       // Java/C# method
          `protected ${nodeName}(`,     // Java/C# method
          // Also try with underscores and variations
          `def ${nodeName}_`,           // Python with underscore
          `function ${nodeName}_`,      // JavaScript with underscore
        ];
        
        for (const [path, content] of fileContents) {
          console.log(`SourceViewer - Checking file: ${path}`);
          
          // Check if any pattern matches
          const foundPattern = searchPatterns.find(pattern => {
            const found = content.includes(pattern);
            if (found) {
              console.log(`SourceViewer - Found pattern "${pattern}" in ${path}`);
            }
            return found;
          });
          
          if (foundPattern) {
            filePath = path;
            console.log('SourceViewer - Found file through content search:', filePath);
            break;
          }
        }
        
        // If still not found, try a more lenient search (case-insensitive)
        if (!filePath) {
          console.log('SourceViewer - Trying case-insensitive search for:', nodeName);
          for (const [path, content] of fileContents) {
            const lowerContent = content.toLowerCase();
            const lowerNodeName = nodeName.toLowerCase();
            
            if (lowerContent.includes(`def ${lowerNodeName}(`) || 
                lowerContent.includes(`function ${lowerNodeName}(`) ||
                lowerContent.includes(`const ${lowerNodeName} =`) ||
                lowerContent.includes(`class ${lowerNodeName}`)) {
              filePath = path;
              console.log('SourceViewer - Found file through case-insensitive search:', filePath);
              break;
            }
          }
        }
      }
    }

    const fileName = filePath ? filePath.split('/').pop() || filePath : nodeName;

    console.log('SourceViewer - Final node details:', {
      nodeId: selectedNodeId,
      nodeName,
      filePath,
      fileName,
      nodeLabel: node.label,
      nodeProperties: node.properties,
      fileContentsSize: fileContents?.size || 0,
      // Add detailed relationship debugging
      allRelationships: graph?.relationships?.length || 0,
      containsRelationships: graph?.relationships?.filter(rel => rel.type === 'CONTAINS').length || 0,
      relationshipsForThisNode: graph?.relationships?.filter(rel => rel.target === selectedNodeId || rel.source === selectedNodeId) || [],
      fileNodesInGraph: graph?.nodes?.filter(n => n.label === 'File').map(n => ({
        id: n.id,
        path: n.properties.path,
        filePath: n.properties.filePath,
        name: n.properties.name
      })) || [],
      availableFileContents: fileContents ? Array.from(fileContents.entries()).map(([path, content]) => ({
        path,
        size: content.length,
        firstLines: content.split('\n').slice(0, 3).join('\\n'),
        containsSub: content.includes('def sub(') || content.includes('function sub(')
      })) : []
    });

    // Try to get actual file content
    let content = '';
    
    if (filePath && fileContents && fileContents.has(filePath)) {
      content = fileContents.get(filePath)!;
      console.log('SourceViewer - Found file content for:', filePath);
      
      // For function/method/class nodes, try to extract just the relevant part
      if (node.label === 'Function' || node.label === 'Method' || node.label === 'Class') {
        const extractedContent = extractRelevantContent(content, nodeName, node.label);
        if (extractedContent) {
          content = extractedContent;
          console.log('SourceViewer - Extracted relevant content for:', nodeName);
        }
      }
    } else {
      console.log('SourceViewer - No file content found, checking if this is a built-in function');
      
      // Check if this is a built-in function
      if (node.id.includes('builtin_') || nodeName === 'round' || nodeName === 'len' || nodeName === 'print' || 
          ['round', 'len', 'str', 'int', 'float', 'bool', 'list', 'dict', 'tuple', 'set',
           'range', 'enumerate', 'zip', 'map', 'filter', 'sum', 'max', 'min', 'abs',
           'print', 'input', 'open', 'type', 'isinstance', 'hasattr'].includes(nodeName)) {
        
        content = generateBuiltinFunctionContent(nodeName);
        console.log('SourceViewer - Using built-in function content for:', nodeName);
      } else {
        console.log('SourceViewer - Using mock content for user-defined node:', nodeName);
        content = generateMockContent(node);
      }
    }

    // Detect language from file extension
    const extension = fileName.split('.').pop()?.toLowerCase();
    let language = 'text';
    switch (extension) {
      case 'js':
      case 'jsx':
        language = 'javascript';
        break;
      case 'ts':
      case 'tsx':
        language = 'typescript';
        break;
      case 'py':
        language = 'python';
        break;
      case 'java':
        language = 'java';
        break;
      case 'cpp':
      case 'cc':
      case 'cxx':
        language = 'cpp';
        break;
      case 'c':
        language = 'c';
        break;
      case 'cs':
        language = 'csharp';
        break;
      case 'php':
        language = 'php';
        break;
      case 'rb':
        language = 'ruby';
        break;
      case 'go':
        language = 'go';
        break;
      case 'rs':
        language = 'rust';
        break;
      case 'swift':
        language = 'swift';
        break;
      case 'kt':
        language = 'kotlin';
        break;
      case 'scala':
        language = 'scala';
        break;
      case 'html':
        language = 'html';
        break;
      case 'css':
        language = 'css';
        break;
      case 'scss':
        language = 'scss';
        break;
      case 'json':
        language = 'json';
        break;
      case 'xml':
        language = 'xml';
        break;
      case 'yaml':
      case 'yml':
        language = 'yaml';
        break;
      case 'md':
        language = 'markdown';
        break;
      case 'sh':
        language = 'bash';
        break;
      case 'sql':
        language = 'sql';
        break;
    }

    return {
      fileName,
      filePath: filePath || nodeName,
      content,
      nodeType: node.label,
      nodeName,
      language,
      startLine: node.properties.startLine as number,
      endLine: node.properties.endLine as number
    };
  }, [selectedNodeId, graph?.nodes, graph?.relationships, fileContents]);

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    width: '100%',
    backgroundColor: colors.background,
    overflow: 'hidden',
    ...style
  };

  const headerStyle: React.CSSProperties = {
    padding: '16px 20px',
    backgroundColor: colors.surface,
    borderBottom: `1px solid ${colors.borderLight}`,
    flexShrink: 0
  };

  const titleStyle: React.CSSProperties = {
    fontSize: '16px',
    fontWeight: '600',
    color: colors.text,
    marginBottom: '8px',
    display: 'flex',
    alignItems: 'center',
    gap: '8px'
  };

  const infoStyle: React.CSSProperties = {
    fontSize: '12px',
    color: colors.textMuted,
    display: 'flex',
    alignItems: 'center',
    gap: '16px',
    flexWrap: 'wrap'
  };

  const codeContainerStyle: React.CSSProperties = {
    flex: 1,
    overflow: 'auto',
    backgroundColor: colors.codeBackground,
    position: 'relative'
  };

  const codeStyle: React.CSSProperties = {
    fontFamily: "'Fira Code', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace",
    fontSize: '13px',
    lineHeight: '1.5',
    padding: '16px',
    margin: 0,
    backgroundColor: 'transparent',
    color: colors.text,
    whiteSpace: 'pre-wrap',
    wordBreak: 'break-word',
    border: 'none',
    outline: 'none',
    resize: 'none',
    width: '100%',
    minHeight: '100%',
    boxSizing: 'border-box'
  };

  const emptyStateStyle: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'column',
    height: '100%',
    color: colors.textMuted,
    fontSize: '14px',
    gap: '12px',
    padding: '32px'
  };

  const renderEmptyState = () => (
    <div style={emptyStateStyle}>
      <div style={{ fontSize: '48px', opacity: 0.3 }}>📝</div>
      <div style={{ textAlign: 'center' }}>
        Select a node in the graph to view its source code
      </div>
    </div>
  );

  const renderSourceContent = (info: SourceInfo) => {
    const lines = info.content.split('\n');

    return (
      <>
        <div style={headerStyle}>
          <div style={titleStyle}>
            <span>📝</span>
            <span>{info.fileName}</span>
          </div>
          <div style={infoStyle}>
            <span>📄 {info.nodeType}</span>
            <span>🏷️ {info.nodeName}</span>
            {info.language && <span>💻 {info.language}</span>}
            <span>📏 {lines.length} lines</span>
          </div>
        </div>
        
        <div style={codeContainerStyle}>
          <pre style={codeStyle}>
            {info.content}
          </pre>
        </div>
      </>
    );
  };

  return (
    <div className={`source-viewer ${className}`} style={containerStyle}>
      {sourceInfo ? renderSourceContent(sourceInfo) : renderEmptyState()}
    </div>
  );
};

export default SourceViewer;

================
File: src/ui/components/graph/Visualization.tsx
================
import React, { useEffect, useRef, useState } from 'react';
import * as d3 from 'd3';
import type { KnowledgeGraph, GraphNode, GraphRelationship } from '../../../core/graph/types.ts';

interface GraphVisualizationProps {
  graph: KnowledgeGraph;
  onNodeSelect?: (nodeId: string | null) => void;
  selectedNodeId?: string | null;
  className?: string;
  style?: React.CSSProperties;
}

interface D3Node extends d3.SimulationNodeDatum {
  id: string;
  label: string;
  nodeType: string;
  properties: Record<string, unknown>;
  color: string;
  size: number;
}

interface D3Link extends d3.SimulationLinkDatum<D3Node> {
  id: string;
  source: string | D3Node;
  target: string | D3Node;
  relationshipType: string;
  color: string;
  width: number;
}

const GraphVisualization: React.FC<GraphVisualizationProps> = ({
  graph,
  onNodeSelect,
  selectedNodeId,
  className = '',
  style = {}
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const simulationRef = useRef<d3.Simulation<D3Node, D3Link> | null>(null);
  const onNodeSelectRef = useRef(onNodeSelect);
  const [isReady, setIsReady] = useState(false);

  // Update the ref whenever onNodeSelect changes
  onNodeSelectRef.current = onNodeSelect;

  // Convert KnowledgeGraph to D3 format
  const convertToD3Format = (graph: KnowledgeGraph) => {
    const nodeIds = new Set<string>();
    
    // First pass: collect all node IDs and analyze the graph structure
    graph.nodes.forEach(node => nodeIds.add(node.id));
    
    // Calculate node metrics for intelligent sizing
    const nodeMetrics = new Map<string, {
      inDegree: number;
      outDegree: number;
      totalDegree: number;
      depth: number;
      isRoot: boolean;
      childrenCount: number;
    }>();
    
    // Initialize metrics
    graph.nodes.forEach(node => {
      nodeMetrics.set(node.id, {
        inDegree: 0,
        outDegree: 0,
        totalDegree: 0,
        depth: 0,
        isRoot: false,
        childrenCount: 0
      });
    });
    
    // Calculate degrees and relationships
    graph.relationships.forEach(rel => {
      const sourceMetrics = nodeMetrics.get(rel.source);
      const targetMetrics = nodeMetrics.get(rel.target);
      
      if (sourceMetrics && targetMetrics) {
        sourceMetrics.outDegree++;
        targetMetrics.inDegree++;
        
        // For CONTAINS relationships, count children
        if (rel.type.toLowerCase() === 'contains') {
          sourceMetrics.childrenCount++;
        }
      }
    });
    
    // Calculate total degree and identify root nodes
    nodeMetrics.forEach((metrics) => {
      metrics.totalDegree = metrics.inDegree + metrics.outDegree;
      // Root nodes typically have high out-degree and low/zero in-degree
      metrics.isRoot = metrics.inDegree === 0 && metrics.outDegree > 0;
    });
    
    // Calculate depth (simplified - could be more sophisticated)
    const calculateDepth = (nodeId: string, visited = new Set<string>()): number => {
      if (visited.has(nodeId)) return 0;
      visited.add(nodeId);
      
      const parentRels = graph.relationships.filter(rel => 
        rel.target === nodeId && rel.type.toLowerCase() === 'contains'
      );
      
      if (parentRels.length === 0) return 0; // Root level
      
      const parentDepths = parentRels.map(rel => calculateDepth(rel.source, new Set(visited)));
      return Math.max(...parentDepths, 0) + 1;
    };
    
    // Calculate depths for all nodes
    graph.nodes.forEach(node => {
      const metrics = nodeMetrics.get(node.id);
      if (metrics) {
        metrics.depth = calculateDepth(node.id);
      }
    });
    
    // Convert nodes with intelligent sizing
    const nodes: D3Node[] = graph.nodes.map((node: GraphNode) => {
      const metrics = nodeMetrics.get(node.id)!;
      
      // Determine base color and size based on type
      let color = '#69b3a2';
      let baseSize = 8;
      
      switch (node.label.toLowerCase()) {
        case 'project':
          color = '#2E7D32';
          baseSize = 25; // Largest - project root
          break;
        case 'folder':
          color = '#F57C00';
          baseSize = 16;
          break;
        case 'file':
          color = '#1976D2';
          baseSize = 12;
          break;
        case 'function':
          color = '#00796B';
          baseSize = 8;
          break;
        case 'method':
          color = '#00695C';
          baseSize = 7;
          break;
        case 'class':
          color = '#C2185B';
          baseSize = 12;
          break;
        case 'variable':
          color = '#546E7A';
          baseSize = 6;
          break;
        default:
          color = '#69b3a2';
          baseSize = 8;
      }
      
      // Calculate final size based on multiple factors
      let finalSize = baseSize;
      
      // Factor 1: Hierarchy depth (higher levels = bigger)
      const depthMultiplier = Math.max(0.7, 1.5 - (metrics.depth * 0.15));
      finalSize *= depthMultiplier;
      
      // Factor 2: Connection importance (more connections = bigger)
      if (metrics.totalDegree > 0) {
        const connectionMultiplier = 1 + Math.min(0.8, metrics.totalDegree * 0.1);
        finalSize *= connectionMultiplier;
      }
      
      // Factor 3: Container nodes (nodes with children) should be bigger
      if (metrics.childrenCount > 0) {
        const containerMultiplier = 1 + Math.min(0.6, metrics.childrenCount * 0.08);
        finalSize *= containerMultiplier;
      }
      
      // Factor 4: Root nodes get a boost
      if (metrics.isRoot) {
        finalSize *= 1.4;
      }
      
      // Factor 5: Special boost for hub nodes (high degree centrality)
      if (metrics.totalDegree > 10) {
        finalSize *= 1.3;
        color = adjustColorBrightness(color, 20); // Make hub nodes slightly brighter
      }
      
      // Ensure size bounds
      finalSize = Math.max(4, Math.min(35, finalSize));
      
      return {
        id: node.id,
        label: node.properties.name as string || node.id,
        nodeType: node.label.toLowerCase(),
        properties: node.properties,
        color,
        size: Math.round(finalSize),
        // Store metrics for potential future use
        metrics
      };
    });

    // Convert links with validation (unchanged)
    const links: D3Link[] = [];
    graph.relationships.forEach((rel: GraphRelationship) => {
      // Validate that both source and target nodes exist
      if (!nodeIds.has(rel.source) || !nodeIds.has(rel.target)) {
        console.warn(`Skipping invalid relationship: ${rel.source} -> ${rel.target}`);
        return;
      }
      
      // Skip self-loops
      if (rel.source === rel.target) {
        return;
      }

      // Determine link color and width based on type
      let color = '#999';
      let width = 1;
      
      switch (rel.type.toLowerCase()) {
        case 'contains':
          color = '#4CAF50';
          width = 2;
          break;
        case 'calls':
          color = '#F44336';
          width = 1;
          break;
        case 'imports':
          color = '#9C27B0';
          width = 1.5;
          break;
        case 'inherits':
          color = '#2196F3';
          width = 2;
          break;
        default:
          color = '#999';
          width = 1;
      }

      links.push({
        id: rel.id,
        source: rel.source,
        target: rel.target,
        relationshipType: rel.type.toLowerCase(),
        color,
        width
      });
    });

    return { nodes, links };
  };

  // Helper function to adjust color brightness
  const adjustColorBrightness = (hex: string, percent: number): string => {
    const num = parseInt(hex.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
      (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
      (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
  };

  // Initialize D3 visualization
  useEffect(() => {
    if (!svgRef.current || !graph) return;

    const svg = d3.select(svgRef.current);
    const container = svg.select('.graph-container');
    
    // Clear previous content
    container.selectAll('*').remove();

    const { nodes, links } = convertToD3Format(graph);

    // Get SVG dimensions
    const rect = svgRef.current.getBoundingClientRect();
    const width = rect.width || 800;
    const height = rect.height || 600;

    // Set up zoom behavior
    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        container.attr('transform', event.transform);
      });

    // Apply zoom behavior to SVG
    svg.call(zoom);

    // Reset zoom on double-click
    svg.on('dblclick.zoom', null);
    svg.on('dblclick', () => {
      svg.transition().duration(750).call(
        zoom.transform,
        d3.zoomIdentity
      );
    });

    // Create force simulation
    const simulation = d3.forceSimulation<D3Node>(nodes)
      .force('link', d3.forceLink<D3Node, D3Link>(links)
        .id((d: D3Node) => d.id)
        .distance((d: D3Link) => {
          switch (d.relationshipType) {
            case 'contains': return 60;
            case 'imports': return 100;
            case 'calls': return 80;
            default: return 90;
          }
        })
        .strength(0.7)
      )
      .force('charge', d3.forceManyBody()
        .strength((d: d3.SimulationNodeDatum) => {
          const node = d as D3Node;
          switch (node.nodeType) {
            case 'project': return -800;
            case 'folder': return -400;
            case 'file': return -300;
            default: return -200;
          }
        })
      )
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide()
        .radius((node: d3.SimulationNodeDatum) => {
          const d = node as D3Node;
          return d.size + 5;
        })
        .strength(0.7)
      )
      .alphaTarget(0.05)
      .alphaDecay(0.005);

    simulationRef.current = simulation;

    // Create links
    const link = container.append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(links)
      .enter().append('line')
      .attr('stroke', (d) => d.color)
      .attr('stroke-width', (d) => d.width)
      .attr('stroke-opacity', 0.8)
      .style('stroke-dasharray', (d) => {
        switch (d.relationshipType) {
          case 'calls': return '5,5';
          case 'imports': return '3,3';
          default: return 'none';
        }
      });

    // Create nodes
    const node = container.append('g')
      .attr('class', 'nodes')
      .selectAll('circle')
      .data(nodes)
      .enter().append('circle')
      .attr('r', (d) => d.size)
      .attr('fill', (d) => d.color)
      .attr('stroke', '#fff')
      .attr('stroke-width', 2)
      .style('cursor', 'pointer');

    // Use D3 drag with proper click distance to prevent sticking
    node.call(d3.drag<SVGCircleElement, D3Node>()
      .clickDistance(10) // Larger threshold to better distinguish clicks from drags
      .on('start', function(event) {
        // Only fix position if this is actually a drag (not a click)
        if (event.sourceEvent.type === 'mousedown') {
          // Don't fix position immediately - wait for actual drag
        }
      })
      .on('drag', function(event, d) {
        // This only fires on actual drags (beyond clickDistance)
        if (!d.fx && !d.fy) {
          // First drag event - fix position and restart simulation
          d.fx = d.x;
          d.fy = d.y;
          if (!event.active) simulation.alphaTarget(0.3).restart();
        }
        d.fx = event.x;
        d.fy = event.y;
      })
      .on('end', function(event, d) {
        if (!event.active) simulation.alphaTarget(0.05);
        // Release the node
        d.fx = null;
        d.fy = null;
      })
    );

    // Create labels
    const label = container.append('g')
      .attr('class', 'labels')
      .selectAll('text')
      .data(nodes)
      .enter().append('text')
      .text((d) => d.label)
      .attr('font-size', (d) => Math.max(8, d.size - 2))
      .attr('font-family', 'Inter, system-ui, sans-serif')
      .attr('font-weight', '500')
      .attr('fill', '#fff')
      .attr('text-anchor', 'middle')
      .attr('dy', '0.35em')
      .style('pointer-events', 'none')
      .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)');

    // Node click handler
    node.on('click', (event, d) => {
      
      // Ignore clicks if we're dragging or just finished dragging
      if (d.fx || d.fy) return; // Check if node is being dragged
      
      event.stopPropagation();
      
      // Remove previous selection
      node.classed('selected', false);
      node.attr('stroke-width', 2);
      
      // Add selection to clicked node
      d3.select(event.currentTarget)
        .classed('selected', true)
        .attr('stroke-width', 4)
        .attr('stroke', '#FFD54F');
      
      // Highlight connected elements
      const connectedNodeIds = new Set<string>();
      link.attr('stroke-opacity', 0.1);
      node.attr('opacity', 0.3);
      label.attr('opacity', 0.3);
      
      links.forEach(linkData => {
        const sourceId = typeof linkData.source === 'object' ? linkData.source.id : linkData.source;
        const targetId = typeof linkData.target === 'object' ? linkData.target.id : linkData.target;
        
        if (sourceId === d.id || targetId === d.id) {
          connectedNodeIds.add(sourceId);
          connectedNodeIds.add(targetId);
        }
      });
      
      // Highlight connected nodes and links
      link.filter(linkData => {
        const sourceId = typeof linkData.source === 'object' ? linkData.source.id : linkData.source;
        const targetId = typeof linkData.target === 'object' ? linkData.target.id : linkData.target;
        return sourceId === d.id || targetId === d.id;
      }).attr('stroke-opacity', 1);
      
      node.filter(nodeData => connectedNodeIds.has(nodeData.id))
        .attr('opacity', 1);
      
      label.filter(nodeData => connectedNodeIds.has(nodeData.id))
        .attr('opacity', 1);
      
      // Keep selected node fully visible
      d3.select(event.currentTarget).attr('opacity', 1);
      label.filter(nodeData => nodeData.id === d.id).attr('opacity', 1);
      
      if (onNodeSelectRef.current) {
        onNodeSelectRef.current(d.id);
      }
    });

    // Background click handler - clear selection when clicking empty space
    svg.on('click', (event) => {
      // Only handle clicks on the SVG background (not on nodes or other elements)
      if (event.target === event.currentTarget) {
        // Remove all selections and highlighting
        node.classed('selected', false);
        node.attr('stroke-width', 2).attr('stroke', '#fff').attr('opacity', 1);
        link.attr('stroke-opacity', 0.8);
        label.attr('opacity', 1);
        
        if (onNodeSelectRef.current) {
          onNodeSelectRef.current(null);
        }
      }
    });

    // Hover effects
    node.on('mouseover', (event, d) => {
      d3.select(event.currentTarget)
        .transition()
        .duration(200)
        .attr('r', d.size * 1.3);
    });

    node.on('mouseout', (event, d) => {
      d3.select(event.currentTarget)
        .transition()
        .duration(200)
        .attr('r', d.size);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
      link
        .attr('x1', (d) => (d.source as D3Node).x!)
        .attr('y1', (d) => (d.source as D3Node).y!)
        .attr('x2', (d) => (d.target as D3Node).x!)
        .attr('y2', (d) => (d.target as D3Node).y!);

      node
        .attr('cx', (d) => d.x!)
        .attr('cy', (d) => d.y!);

      label
        .attr('x', (d) => d.x!)
        .attr('y', (d) => d.y!);
    });

    setIsReady(true);

    // Cleanup function
    return () => {
      if (simulationRef.current) {
        simulationRef.current.stop();
        simulationRef.current = null;
      }
      setIsReady(false);
    };
  }, [graph]); // Removed onNodeSelect from dependencies to prevent re-renders

  // Handle selected node changes
  useEffect(() => {
    if (!svgRef.current || !isReady || !selectedNodeId) return;

    const svg = d3.select(svgRef.current);
    const nodes = svg.selectAll('.nodes circle');
    
    // Remove previous selection
    nodes.classed('selected', false);
    nodes.attr('stroke-width', 2).attr('stroke', '#fff');
    
    // Select the specified node
    nodes.filter(function(d) { return (d as D3Node).id === selectedNodeId; })
      .classed('selected', true)
      .attr('stroke-width', 4)
      .attr('stroke', '#FFD54F');
  }, [selectedNodeId, isReady]);

  const defaultStyle: React.CSSProperties = {
    width: '100%',
    height: '100%',
    minHeight: '400px',
    border: '1px solid #37474F',
    borderRadius: '8px',
    backgroundColor: '#263238',
    boxShadow: '0 4px 20px rgba(0,0,0,0.1)',
    ...style
  };

  return (
    <div className={`graph-visualization ${className}`} style={{ position: 'relative', width: '100%', height: '100%', minHeight: '400px' }}>
      <svg
        ref={svgRef}
        style={defaultStyle}
        className="d3-graph-container"
      >
        <g className="graph-container" />
      </svg>
      {!isReady && (
        <div
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: '#90A4AE',
            fontSize: '16px',
            fontFamily: 'Inter, system-ui, sans-serif',
            fontWeight: '500',
            zIndex: 10,
            display: 'flex',
            alignItems: 'center',
            gap: '12px'
          }}
        >
          <div
            style={{
              width: '20px',
              height: '20px',
              border: '2px solid #90A4AE',
              borderTop: '2px solid transparent',
              borderRadius: '50%',
              animation: 'spin 1s linear infinite'
            }}
          />
          Loading knowledge graph...
        </div>
      )}
      
      {/* Add navigation instructions */}
      <div
        style={{
          position: 'absolute',
          top: '10px',
          right: '16px',
          backgroundColor: 'rgba(0, 0, 0, 0.7)',
          color: '#fff',
          padding: '8px 12px',
          borderRadius: '4px',
          fontSize: '12px',
          fontFamily: 'Inter, system-ui, sans-serif',
          zIndex: 10,
          lineHeight: '1.4'
        }}
      >
        <div>🖱️ <strong>Navigation:</strong></div>
        <div>• Drag to pan</div>
        <div>• Scroll to zoom</div>
        <div>• Double-click to reset view</div>
        <div>• Drag nodes to reposition</div>
      </div>

      <style>{`
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        .d3-graph-container {
          font-family: 'Inter', system-ui, sans-serif;
          cursor: grab;
        }
        
        .d3-graph-container:active {
          cursor: grabbing;
        }
        
        .nodes circle.selected {
          filter: drop-shadow(0 0 10px rgba(255, 213, 79, 0.8));
        }
        
        .links line {
          transition: stroke-opacity 0.3s ease;
        }
        
        .nodes circle {
          transition: opacity 0.3s ease, r 0.2s ease;
        }
        
        .labels text {
          transition: opacity 0.3s ease;
        }
      `}</style>
    </div>
  );
};

export default GraphVisualization;

================
File: src/ui/components/index.ts
================
export * from './graph/index.ts';
export * from './chat/index.ts';
export { default as ErrorBoundary } from './ErrorBoundary.tsx';

================
File: src/ui/index.ts
================
export * from './components/index';
export * from './pages/index';

================
File: src/ui/pages/HomePage.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import ErrorBoundary from '../components/ErrorBoundary.tsx';
import { GraphExplorer } from '../components/graph/index.ts';
import { ChatInterface } from '../components/chat/index.ts';
import SourceViewer from '../components/graph/SourceViewer.tsx';
import type { KnowledgeGraph } from '../../core/graph/types.ts';
import { IngestionService } from '../../services/ingestion.service.ts';
import { LLMService, type LLMProvider } from '../../ai/llm-service.ts';
import { exportAndDownloadGraph } from '../../lib/export.ts';

interface AppState {
  // Data
  graph: KnowledgeGraph | null;
  fileContents: Map<string, string>;
  
  // UI State
  selectedNodeId: string | null;
  showWelcome: boolean;
  isLoading: boolean;
  
  // Input State
  githubUrl: string;
  directoryFilter: string;
  fileExtensions: string;
  
  // Processing State
  isProcessing: boolean;
  progress: string;
  error: string;
  
  // Settings
  llmProvider: LLMProvider;
  llmApiKey: string;
  // Azure OpenAI specific settings
  azureOpenAIEndpoint: string;
  azureOpenAIDeploymentName: string;
  azureOpenAIApiVersion: string;
  // GitHub settings
  githubToken: string;
  showSettings: boolean;
}

const initialState: AppState = {
  graph: null,
  fileContents: new Map(),
  selectedNodeId: null,
  showWelcome: true,
  isLoading: false,
  githubUrl: '',
  directoryFilter: 'src,lib,components,pages,utils',
  fileExtensions: '.ts,.tsx,.js,.jsx,.py,.java,.cpp,.c,.cs,.php,.rb,.go,.rs,.swift,.kt,.scala,.clj,.hs,.ml,.fs,.elm,.dart,.lua,.r,.m,.sh,.sql,.html,.css,.scss,.less,.vue,.svelte',
  isProcessing: false,
  progress: '',
  error: '',
  llmProvider: (localStorage.getItem('llm_provider') as LLMProvider) || 'openai',
  llmApiKey: localStorage.getItem('llm_api_key') || '',
  azureOpenAIEndpoint: localStorage.getItem('azure_openai_endpoint') || '',
  azureOpenAIDeploymentName: localStorage.getItem('azure_openai_deployment') || '',
  azureOpenAIApiVersion: localStorage.getItem('azure_openai_api_version') || '2024-02-01',
  githubToken: localStorage.getItem('github_token') || '',
  showSettings: false
};

const HomePage: React.FC = () => {
  const [state, setState] = useState<AppState>(initialState);
  const [services] = useState(() => ({
    ingestion: new IngestionService(),
    llm: new LLMService()
  }));

  const updateState = useCallback((updates: Partial<AppState>) => {
    setState(prev => ({ ...prev, ...updates }));
  }, []);

  // Save LLM settings to localStorage
  useEffect(() => {
    if (state.llmApiKey) {
      localStorage.setItem('llm_api_key', state.llmApiKey);
    }
    localStorage.setItem('llm_provider', state.llmProvider);
    if (state.azureOpenAIEndpoint) {
      localStorage.setItem('azure_openai_endpoint', state.azureOpenAIEndpoint);
    }
    if (state.azureOpenAIDeploymentName) {
      localStorage.setItem('azure_openai_deployment', state.azureOpenAIDeploymentName);
    }
    if (state.azureOpenAIApiVersion) {
      localStorage.setItem('azure_openai_api_version', state.azureOpenAIApiVersion);
    }
    if (state.githubToken) {
      localStorage.setItem('github_token', state.githubToken);
    }
  }, [state.llmApiKey, state.llmProvider, state.azureOpenAIEndpoint, state.azureOpenAIDeploymentName, state.azureOpenAIApiVersion, state.githubToken]);

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !file.name.endsWith('.zip')) {
      updateState({ error: 'Please select a valid ZIP file' });
      return;
    }

    try {
      updateState({ 
        isProcessing: true, 
        error: '', 
        progress: 'Reading ZIP file...',
        showWelcome: false
      });

      console.log('Starting ZIP processing...', file.name);

      const result = await services.ingestion.processZipFile(file, {
        directoryFilter: state.directoryFilter,
        fileExtensions: state.fileExtensions
      });

      console.log('ZIP processing completed:', {
        nodeCount: result.graph?.nodes?.length || 0,
        relationshipCount: result.graph?.relationships?.length || 0,
        fileCount: result.fileContents?.size || 0
      });

      updateState({
        graph: result.graph,
        fileContents: result.fileContents,
        isProcessing: false,
        progress: '',
        showWelcome: false // Ensure we stay in main interface
      });
    } catch (error) {
      console.error('ZIP processing error:', error);
      updateState({
        error: error instanceof Error ? error.message : 'Failed to process ZIP file',
        isProcessing: false,
        progress: '',
        showWelcome: true // Return to welcome screen on error
      });
    }
  };

  const handleGitHubProcess = async () => {
    if (!state.githubUrl.trim()) {
      updateState({ error: 'Please enter a GitHub repository URL' });
      return;
    }

    try {
      updateState({ 
        isProcessing: true, 
        error: '', 
        progress: 'Fetching repository...',
        showWelcome: false
      });

      console.log('Starting GitHub processing...', state.githubUrl);

      // Create ingestion service with GitHub token if provided
      const ingestionService = new IngestionService(state.githubToken || undefined);

      const result = await ingestionService.processGitHubRepo(state.githubUrl, {
        directoryFilter: state.directoryFilter,
        fileExtensions: state.fileExtensions,
        onProgress: (progress) => {
          console.log('Progress:', progress);
          updateState({ progress });
        }
      });

      console.log('GitHub processing completed:', {
        nodeCount: result.graph?.nodes?.length || 0,
        relationshipCount: result.graph?.relationships?.length || 0,
        fileCount: result.fileContents?.size || 0
      });

      updateState({
        graph: result.graph,
        fileContents: result.fileContents,
        isProcessing: false,
        progress: '',
        showWelcome: false // Ensure we stay in main interface
      });
    } catch (error) {
      console.error('GitHub processing error:', error);
      updateState({
        error: error instanceof Error ? error.message : 'Failed to process repository',
        isProcessing: false,
        progress: '',
        showWelcome: true // Return to welcome screen on error
      });
    }
  };

  const handleNewProject = () => {
    updateState(initialState);
  };

  const handleDownloadGraph = () => {
    if (!state.graph) {
      alert('No knowledge graph to download. Please process a repository first.');
      return;
    }

    try {
      const projectName = state.githubUrl 
        ? state.githubUrl.split('/').pop()?.replace('.git', '') || 'repository'
        : 'project';

      exportAndDownloadGraph(
        state.graph,
        { 
          projectName,
          includeTimestamp: true,
          prettyPrint: true,
          includeMetadata: true
        },
        state.fileContents
      );
      
      console.log('Knowledge graph exported successfully');
    } catch (error) {
      console.error('Failed to export graph:', error);
      alert('Failed to export knowledge graph. Please try again.');
    }
  };

  const isApiKeyValid = (() => {
    if (state.llmProvider === 'azure-openai') {
      // For Azure OpenAI, we need to validate all required fields
      return services.llm.validateApiKey(state.llmProvider, state.llmApiKey) &&
             state.azureOpenAIEndpoint.trim() !== '' &&
             state.azureOpenAIDeploymentName.trim() !== '';
    }
    return services.llm.validateApiKey(state.llmProvider, state.llmApiKey);
  })();
  const isGraphValid = state.graph && state.graph.nodes && Array.isArray(state.graph.nodes) && state.graph.relationships && Array.isArray(state.graph.relationships);

  // Warm tone color palette
  const colors = {
    background: '#FDF6E3', // Warm cream
    surface: '#FFFFFF',
    surfaceWarm: '#FEF9F0', // Slightly warm white
    primary: '#D97706', // Warm orange
    primaryLight: '#F59E0B', // Light orange
    secondary: '#92400E', // Dark orange
    accent: '#DC2626', // Warm red
    text: '#451A03', // Dark brown
    textSecondary: '#78350F', // Medium brown
    textMuted: '#A16207', // Light brown
    border: '#FED7AA', // Light orange
    borderLight: '#FEF3C7', // Very light orange
    success: '#059669', // Warm green
    warning: '#D97706', // Orange
    error: '#DC2626' // Red
  };

  // Modern styles with warm theme
  const styles = {
    container: {
      display: 'flex',
      flexDirection: 'column' as const,
      height: '100vh',
      width: '100vw',
      backgroundColor: colors.background,
      fontFamily: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
      overflow: 'hidden'
    },

    // Top navbar (only visible when project is loaded)
    navbar: {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: '12px 24px',
      backgroundColor: colors.surface,
      borderBottom: `1px solid ${colors.borderLight}`,
      boxShadow: '0 1px 3px rgba(0,0,0,0.05)',
      position: 'relative' as const
    },

    navbarContent: {
      display: 'flex',
      alignItems: 'center',
      gap: '16px',
      fontSize: '14px',
      fontWeight: '500',
      color: colors.textSecondary
    },

    navbarButton: {
      padding: '8px 16px',
      backgroundColor: colors.surfaceWarm,
      border: `1px solid ${colors.border}`,
      borderRadius: '8px',
      color: colors.text,
      fontSize: '14px',
      fontWeight: '500',
      cursor: 'pointer',
      transition: 'all 0.2s ease',
      display: 'flex',
      alignItems: 'center',
      gap: '8px'
    },

    // Welcome screen (center overlay)
    welcomeOverlay: {
      position: 'fixed' as const,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: colors.background,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 1000
    },

    welcomeCard: {
      backgroundColor: colors.surface,
      borderRadius: '20px',
      padding: '48px',
      boxShadow: '0 20px 40px rgba(0,0,0,0.1)',
      border: `1px solid ${colors.borderLight}`,
      maxWidth: '600px',
      width: '90%',
      textAlign: 'center' as const
    },

    welcomeTitle: {
      fontSize: '32px',
      fontWeight: '700',
      color: colors.text,
      marginBottom: '16px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '12px'
    },

    welcomeSubtitle: {
      fontSize: '18px',
      color: colors.textSecondary,
      marginBottom: '40px',
      lineHeight: '1.6'
    },

    inputSection: {
      display: 'flex',
      flexDirection: 'column' as const,
      gap: '24px',
      marginBottom: '32px'
    },

    inputGroup: {
      display: 'flex',
      flexDirection: 'column' as const,
      gap: '8px',
      textAlign: 'left' as const
    },

    label: {
      fontSize: '14px',
      fontWeight: '600',
      color: colors.text
    },

    input: {
      padding: '16px',
      border: `2px solid ${colors.border}`,
      borderRadius: '12px',
      fontSize: '16px',
      backgroundColor: colors.surfaceWarm,
      color: colors.text,
      transition: 'all 0.2s ease',
      outline: 'none'
    },

    primaryButton: {
      padding: '16px 32px',
      backgroundColor: colors.primary,
      border: 'none',
      borderRadius: '12px',
      color: 'white',
      fontSize: '16px',
      fontWeight: '600',
      cursor: 'pointer',
      transition: 'all 0.2s ease',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '8px'
    },

    secondaryButton: {
      padding: '12px 24px',
      backgroundColor: colors.surfaceWarm,
      border: `2px solid ${colors.border}`,
      borderRadius: '12px',
      color: colors.text,
      fontSize: '14px',
      fontWeight: '500',
      cursor: 'pointer',
      transition: 'all 0.2s ease'
    },

    orDivider: {
      display: 'flex',
      alignItems: 'center',
      gap: '16px',
      margin: '20px 0',
      color: colors.textMuted,
      fontSize: '14px',
      fontWeight: '500'
    },

    orLine: {
      flex: 1,
      height: '1px',
      backgroundColor: colors.border
    },

    // Main layout (when project is loaded)
    mainLayout: {
      display: 'flex',
      flex: 1,
      overflow: 'hidden'
    },

    // Left side - Knowledge Graph (70% width)
    leftPanel: {
      flex: '0 0 70%',
      backgroundColor: colors.surface,
      borderRight: `1px solid ${colors.borderLight}`,
      overflow: 'hidden'
    },

    // Right side - Chat and Source (30% width)
    rightPanel: {
      flex: '0 0 30%',
      display: 'flex',
      flexDirection: 'column' as const,
      backgroundColor: colors.surfaceWarm
    },

    // Right panel sections
    chatSection: {
      flex: '0 0 60%',
      borderBottom: `1px solid ${colors.borderLight}`,
      overflow: 'hidden'
    },

    sourceSection: {
      flex: '0 0 40%',
      overflow: 'hidden'
    },

    // Error and progress styles
    errorBanner: {
      backgroundColor: '#FEF2F2',
      border: `1px solid #FECACA`,
      color: colors.error,
      padding: '16px',
      borderRadius: '12px',
      margin: '16px 0',
      fontSize: '14px'
    },

    progressBanner: {
      backgroundColor: '#FEF3C7',
      border: `1px solid ${colors.border}`,
      color: colors.secondary,
      padding: '16px',
      borderRadius: '12px',
      margin: '16px 0',
      fontSize: '14px',
      display: 'flex',
      alignItems: 'center',
      gap: '12px'
    },

    spinner: {
      width: '20px',
      height: '20px',
      border: `2px solid ${colors.border}`,
      borderTop: `2px solid ${colors.primary}`,
      borderRadius: '50%',
      animation: 'spin 1s linear infinite'
    }
  };

  const renderWelcomeScreen = () => (
    <div style={styles.welcomeOverlay}>
      <div style={styles.welcomeCard}>
        <div style={styles.welcomeTitle}>
          <span>🔍</span>
          <span>GitNexus</span>
        </div>
        <div style={styles.welcomeSubtitle}>
          Transform your codebase into an interactive knowledge graph
        </div>

        {state.error && (
          <div style={styles.errorBanner}>
            {state.error}
          </div>
        )}

        {state.isProcessing && (
          <div style={styles.progressBanner}>
            <div style={styles.spinner}></div>
            {state.progress}
          </div>
        )}

        <div style={styles.inputSection}>
          <div style={styles.inputGroup}>
            <label style={styles.label}>GitHub Repository URL</label>
            <input
              type="text"
              value={state.githubUrl}
              onChange={(e) => updateState({ githubUrl: e.target.value })}
              placeholder="https://github.com/owner/repo"
              style={styles.input}
              disabled={state.isProcessing}
            />
            
            {/* GitHub Token Input - Optional */}
            <div style={{ marginTop: '12px' }}>
              <label style={{...styles.label, color: colors.textMuted}}>
                GitHub Personal Access Token (Optional)
              </label>
              <input
                type="password"
                value={state.githubToken}
                onChange={(e) => updateState({ githubToken: e.target.value })}
                placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
                style={{
                  ...styles.input,
                  borderColor: colors.borderLight,
                  backgroundColor: colors.surface
                }}
                disabled={state.isProcessing}
              />
              <div style={{ 
                fontSize: '11px', 
                color: colors.textMuted, 
                marginTop: '4px',
                lineHeight: '1.4'
              }}>
                Increases rate limit from 60 to 5,000 requests/hour. 
                <a href="https://github.com/settings/tokens" target="_blank" rel="noopener noreferrer" 
                   style={{ color: colors.primary, textDecoration: 'none', marginLeft: '4px' }}>
                  Generate token
                </a>
              </div>
            </div>
            
            {/* GitHub Token Status */}
            <div style={{
              fontSize: '12px',
              color: state.githubToken ? colors.success : colors.textMuted,
              marginTop: '8px',
              display: 'flex',
              alignItems: 'center',
              gap: '4px'
            }}>
              <span>{state.githubToken ? '🔑' : '⚠️'}</span>
              {state.githubToken 
                ? 'GitHub token configured (5,000 requests/hour)' 
                : 'No GitHub token (60 requests/hour limit)'}
            </div>
            
            <button
              onClick={handleGitHubProcess}
              disabled={state.isProcessing || !state.githubUrl.trim()}
              style={{
                ...styles.primaryButton,
                opacity: state.isProcessing || !state.githubUrl.trim() ? 0.5 : 1,
                marginTop: '16px'
              }}
            >
              <span>📊</span>
              Analyze Repository
            </button>
          </div>

          <div style={styles.orDivider}>
            <div style={styles.orLine}></div>
            <span>OR</span>
            <div style={styles.orLine}></div>
          </div>

          <div style={styles.inputGroup}>
            <label style={styles.label}>Upload ZIP File</label>
            <input
              type="file"
              accept=".zip"
              onChange={handleFileUpload}
              disabled={state.isProcessing}
              style={styles.input}
            />
          </div>
        </div>

        <button
          onClick={() => updateState({ showSettings: true })}
          style={styles.secondaryButton}
        >
          ⚙️ Settings
        </button>
      </div>
    </div>
  );

  const renderMainInterface = () => {
    // Double-check graph validity before rendering
    if (!isGraphValid) {
      console.warn('Attempted to render main interface with invalid graph:', state.graph);
      return renderWelcomeScreen();
    }

    return (
      <>
        {/* Top Navbar */}
        <div style={styles.navbar}>
          <div style={styles.navbarContent}>
            <span>🔍 GitNexus</span>
            <span>•</span>
            <span>{state.graph?.nodes.length || 0} nodes</span>
            <span>•</span>
            <span>{state.graph?.relationships.length || 0} relationships</span>
          </div>
          <div style={{ position: 'absolute', right: '24px', display: 'flex', gap: '12px' }}>
            <button
              onClick={handleDownloadGraph}
              style={{
                ...styles.navbarButton,
                backgroundColor: state.graph ? colors.primary : colors.border,
                color: state.graph ? '#fff' : colors.textMuted,
                cursor: state.graph ? 'pointer' : 'not-allowed',
                opacity: state.graph ? 1 : 0.6
              }}
              disabled={!state.graph}
            >
              <span>📥</span>
              Download KG
            </button>
            <button
              onClick={handleNewProject}
              style={styles.navbarButton}
            >
              <span>🔄</span>
              New Project
            </button>
          </div>
        </div>

        {/* Main Layout */}
        <div style={styles.mainLayout}>
          {/* Left Panel - Knowledge Graph */}
          <div style={styles.leftPanel}>
            <GraphExplorer
              graph={state.graph!}
              isLoading={state.isLoading}
            />
          </div>

          {/* Right Panel - Chat and Source */}
          <div style={styles.rightPanel}>
            {/* Chat Section */}
            <div style={styles.chatSection}>
              {isApiKeyValid ? (
                <ChatInterface
                  graph={state.graph!}
                  fileContents={state.fileContents}
                  style={{ height: '100%' }}
                />
              ) : (
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  height: '100%',
                  flexDirection: 'column',
                  gap: '16px',
                  padding: '24px',
                  textAlign: 'center',
                  color: colors.textMuted
                }}>
                  <div style={{ fontSize: '48px', opacity: 0.3 }}>🔑</div>
                  <div>Configure your API key to use the chat interface</div>
                  <button
                    onClick={() => updateState({ showSettings: true })}
                    style={styles.secondaryButton}
                  >
                    Open Settings
                  </button>
                </div>
              )}
            </div>

            {/* Source Section */}
            <div style={styles.sourceSection}>
              <SourceViewer
                graph={state.graph!}
                selectedNodeId={state.selectedNodeId}
                fileContents={state.fileContents}
                style={{ height: '100%' }}
              />
            </div>
          </div>
        </div>
      </>
    );
  };

  return (
    <ErrorBoundary>
      <div style={styles.container}>
        <style>{`
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          
          #root {
            height: 100vh;
            width: 100vw;
          }
          
          input:focus, textarea:focus {
            border-color: ${colors.primary} !important;
            box-shadow: 0 0 0 3px ${colors.primary}20 !important;
          }
          
          button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          }
          
          button:active:not(:disabled) {
            transform: translateY(0);
          }
        `}</style>

        {state.showWelcome || !isGraphValid ? renderWelcomeScreen() : renderMainInterface()}

        {/* Settings Modal */}
        {state.showSettings && (
          <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'rgba(0,0,0,0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 2000
          }}>
            <div style={{
              backgroundColor: colors.surface,
              borderRadius: '16px',
              padding: '32px',
              maxWidth: '600px',
              width: '90%',
              maxHeight: '80vh',
              overflow: 'auto'
            }}>
              <h2 style={{ color: colors.text, marginBottom: '24px', fontSize: '24px', fontWeight: '700' }}>
                ⚙️ Settings
              </h2>
              
              {/* GitHub Token Section */}
              <div style={{
                padding: '20px',
                borderRadius: '12px',
                backgroundColor: colors.surfaceWarm,
                border: `1px solid ${colors.borderLight}`,
                marginBottom: '24px'
              }}>
                <h3 style={{ color: colors.text, marginBottom: '16px', fontSize: '18px', fontWeight: '600' }}>
                  🔑 GitHub Configuration
                </h3>
                
                <div style={styles.inputGroup}>
                  <label style={styles.label}>
                    GitHub Personal Access Token (Optional)
                  </label>
                  <input
                    type="password"
                    value={state.githubToken}
                    onChange={(e) => updateState({ githubToken: e.target.value })}
                    placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
                    style={styles.input}
                  />
                  <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                    Increases rate limit from 60 to 5,000 requests/hour. Generate at: 
                    <a href="https://github.com/settings/tokens" target="_blank" rel="noopener noreferrer" 
                       style={{ color: colors.primary, textDecoration: 'none', marginLeft: '4px' }}>
                      github.com/settings/tokens
                    </a>
                  </div>
                </div>
              </div>

              {/* LLM Configuration Section */}
              <div style={{
                padding: '20px',
                borderRadius: '12px',
                backgroundColor: colors.surfaceWarm,
                border: `1px solid ${colors.borderLight}`
              }}>
                <h3 style={{ color: colors.text, marginBottom: '16px', fontSize: '18px', fontWeight: '600' }}>
                  🤖 LLM Configuration
                </h3>
              
              {/* Provider Selection */}
              <div style={styles.inputGroup}>
                <label style={styles.label}>LLM Provider</label>
                <select
                  value={state.llmProvider}
                  onChange={(e) => updateState({ llmProvider: e.target.value as LLMProvider })}
                  style={{
                    ...styles.input,
                    cursor: 'pointer'
                  }}
                >
                  <option value="openai">OpenAI</option>
                  <option value="azure-openai">Azure OpenAI</option>
                  <option value="anthropic">Anthropic</option>
                  <option value="gemini">Google Gemini</option>
                </select>
              </div>

              {/* API Key */}
              <div style={styles.inputGroup}>
                <label style={styles.label}>
                  {state.llmProvider === 'azure-openai' ? 'Azure OpenAI API Key' : 
                   state.llmProvider === 'anthropic' ? 'Anthropic API Key' :
                   state.llmProvider === 'gemini' ? 'Google API Key' : 'OpenAI API Key'}
                </label>
                <input
                  type="password"
                  value={state.llmApiKey}
                  onChange={(e) => updateState({ llmApiKey: e.target.value })}
                  placeholder={
                    state.llmProvider === 'azure-openai' ? 'Your Azure OpenAI key...' :
                    state.llmProvider === 'anthropic' ? 'sk-ant-...' :
                    state.llmProvider === 'gemini' ? 'Your Google API key...' : 'sk-...'
                  }
                  style={styles.input}
                />
              </div>

              {/* Azure OpenAI Specific Fields */}
              {state.llmProvider === 'azure-openai' && (
                <>
                  <div style={styles.inputGroup}>
                    <label style={styles.label}>Azure OpenAI Endpoint</label>
                    <input
                      type="text"
                      value={state.azureOpenAIEndpoint}
                      onChange={(e) => updateState({ azureOpenAIEndpoint: e.target.value })}
                      placeholder="https://your-resource.openai.azure.com"
                      style={styles.input}
                    />
                    <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                      Your Azure OpenAI resource endpoint
                    </div>
                  </div>

                  <div style={styles.inputGroup}>
                    <label style={styles.label}>Deployment Name</label>
                    <input
                      type="text"
                      value={state.azureOpenAIDeploymentName}
                      onChange={(e) => updateState({ azureOpenAIDeploymentName: e.target.value })}
                      placeholder="gpt-4o-mini"
                      style={styles.input}
                    />
                    <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                      The deployment name you created in Azure OpenAI Studio
                    </div>
                  </div>

                  <div style={styles.inputGroup}>
                    <label style={styles.label}>API Version</label>
                    <input
                      type="text"
                      value={state.azureOpenAIApiVersion}
                      onChange={(e) => updateState({ azureOpenAIApiVersion: e.target.value })}
                      placeholder="2024-02-01"
                      style={styles.input}
                    />
                    <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                      Azure OpenAI API version (e.g., 2024-02-01, 2025-01-01-preview)
                    </div>
                  </div>
                </>
              )}

              {/* Configuration Status */}
              <div style={{
                padding: '16px',
                borderRadius: '8px',
                backgroundColor: isApiKeyValid ? '#F0F9F0' : '#FFF5F5',
                border: `1px solid ${isApiKeyValid ? '#C6F6C6' : '#FED7D7'}`,
                marginTop: '16px'
              }}>
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  fontSize: '14px',
                  fontWeight: '500',
                  color: isApiKeyValid ? '#2F855A' : '#C53030'
                }}>
                  <span>{isApiKeyValid ? '✅' : '❌'}</span>
                  {isApiKeyValid ? 'Configuration Valid' : 'Configuration Invalid'}
                </div>
                {!isApiKeyValid && (
                  <div style={{ fontSize: '12px', color: '#C53030', marginTop: '4px' }}>
                    {state.llmProvider === 'azure-openai' 
                      ? 'Please provide API key, endpoint, and deployment name'
                      : 'Please provide a valid API key'}
                  </div>
                )}
              </div>

              {/* Provider Information */}
              <div style={{
                padding: '16px',
                borderRadius: '8px',
                backgroundColor: colors.background,
                border: `1px solid ${colors.borderLight}`,
                marginTop: '16px'
              }}>
                <div style={{ fontSize: '14px', fontWeight: '600', color: colors.text, marginBottom: '8px' }}>
                  📋 Provider Information
                </div>
                <div style={{ fontSize: '12px', color: colors.textMuted, lineHeight: '1.5' }}>
                  {state.llmProvider === 'openai' && 'Direct OpenAI API. Get your API key from platform.openai.com'}
                  {state.llmProvider === 'azure-openai' && 'Azure OpenAI Service. Requires Azure subscription and deployed model.'}
                  {state.llmProvider === 'anthropic' && 'Anthropic Claude API. Get your API key from console.anthropic.com'}
                  {state.llmProvider === 'gemini' && 'Google Gemini API. Get your API key from aistudio.google.com'}
                </div>
              </div>
              </div>

              <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>
                <button
                  onClick={() => {
                    // Save settings to localStorage
                    if (state.githubToken) {
                      localStorage.setItem('github_token', state.githubToken);
                    } else {
                      localStorage.removeItem('github_token');
                    }
                    localStorage.setItem('llm_provider', state.llmProvider);
                    localStorage.setItem('llm_api_key', state.llmApiKey);
                    if (state.llmProvider === 'azure-openai') {
                      localStorage.setItem('azure_openai_endpoint', state.azureOpenAIEndpoint);
                      localStorage.setItem('azure_openai_deployment', state.azureOpenAIDeploymentName);
                      localStorage.setItem('azure_openai_api_version', state.azureOpenAIApiVersion);
                    }
                    updateState({ showSettings: false });
                  }}
                  style={styles.primaryButton}
                >
                  💾 Save Settings
                </button>
                <button
                  onClick={() => updateState({ showSettings: false })}
                  style={styles.secondaryButton}
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </ErrorBoundary>
  );
};

export default HomePage;

================
File: src/ui/pages/index.ts
================
export { default as HomePage } from './HomePage.tsx';

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: src/workers/ingestion.worker.ts
================
import * as Comlink from 'comlink';
import { GraphPipeline, type PipelineInput } from '../core/ingestion/pipeline.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface IngestionProgress {
  phase: 'structure' | 'parsing' | 'calls' | 'complete';
  message: string;
  progress: number;
  timestamp: number;
}

export interface IngestionResult {
  success: boolean;
  graph?: KnowledgeGraph;
  error?: string;
  stats?: {
    nodeStats: Record<string, number>;
    relationshipStats: Record<string, number>;
    callStats: { totalCalls: number; callTypes: Record<string, number> };
  };
  duration: number;
}

export class IngestionWorker {
  private pipeline: GraphPipeline;
  private progressCallback?: (progress: IngestionProgress) => void;

  constructor() {
    this.pipeline = new GraphPipeline();
  }

  public setProgressCallback(callback: (progress: IngestionProgress) => void): void {
    this.progressCallback = callback;
  }

  public async processRepository(input: PipelineInput): Promise<IngestionResult> {
    const startTime = Date.now();
    
    try {
      console.log('IngestionWorker: Starting processing with', input.filePaths.length, 'files');
      
      // Memory optimization: Create a copy of file contents and clear originals gradually
      const fileContentsMap = new Map(input.fileContents);
      
      // Initialize pipeline
      if (!this.pipeline) {
        this.pipeline = new GraphPipeline();
      }
      
      // Progress tracking
      let currentProgress = 0;
      const totalSteps = 3; // structure, parsing, calls
      
      const updateProgress = (phase: IngestionProgress['phase'], message: string, stepProgress: number) => {
        const overallProgress = (currentProgress / totalSteps) * 100 + (stepProgress / totalSteps);
        if (this.progressCallback) {
          this.progressCallback({
            phase,
            message,
            progress: Math.min(overallProgress, 100),
            timestamp: Date.now()
          });
        }
      };

      // Run the pipeline with memory optimization
      updateProgress('structure', 'Analyzing project structure...', 0);
      const graph = await this.pipeline.run({
        ...input,
        fileContents: fileContentsMap
      });
      
      // Clear file contents to free memory after processing
      fileContentsMap.clear();
      
      const duration = Date.now() - startTime;
      
      console.log('IngestionWorker: Processing completed successfully');
      console.log(`Graph contains ${graph.nodes.length} nodes and ${graph.relationships.length} relationships`);
      
      // Calculate statistics
      const nodeStats: Record<string, number> = {};
      const relationshipStats: Record<string, number> = {};
      
      graph.nodes.forEach(node => {
        nodeStats[node.label] = (nodeStats[node.label] || 0) + 1;
      });
      
      graph.relationships.forEach(rel => {
        relationshipStats[rel.type] = (relationshipStats[rel.type] || 0) + 1;
      });

      return {
        success: true,
        graph,
        stats: {
          nodeStats,
          relationshipStats,
          callStats: { totalCalls: 0, callTypes: {} }
        },
        duration
      };
    } catch (error) {
      console.error('IngestionWorker: Processing failed:', error);
      
      const duration = Date.now() - startTime;
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred during processing',
        duration
      };
    }
  }

  public async processFiles(
    projectName: string,
    files: { path: string; content: string }[]
  ): Promise<IngestionResult> {
    const fileContents = new Map<string, string>();
    const filePaths: string[] = [];
    
    for (const file of files) {
      filePaths.push(file.path);
      fileContents.set(file.path, file.content);
    }
    
    const input: PipelineInput = {
      projectRoot: '/',
      projectName,
      filePaths,
      fileContents
    };
    
    return this.processRepository(input);
  }

  public async validateRepository(input: PipelineInput): Promise<{ valid: boolean; errors: string[] }> {
    const errors: string[] = [];
    
    try {
      this.validateInput(input);
      
      // Additional validation checks
      if (input.filePaths.length === 0) {
        errors.push('No files provided for processing');
      }
      
      if (input.fileContents.size === 0) {
        errors.push('No file contents provided');
      }
      
      // Check for source files (Python, JavaScript, TypeScript)
      const sourceFiles = input.filePaths.filter(path => 
        path.endsWith('.py') || 
        path.endsWith('.js') || 
        path.endsWith('.jsx') || 
        path.endsWith('.ts') || 
        path.endsWith('.tsx')
      );
      if (sourceFiles.length === 0) {
        errors.push('No source files found in the repository (Python, JavaScript, or TypeScript)');
      }
      
      // Validate file contents exist
      for (const filePath of input.filePaths) {
        if (!input.fileContents.has(filePath)) {
          errors.push(`Missing content for file: ${filePath}`);
        }
      }
      
      return {
        valid: errors.length === 0,
        errors
      };
      
    } catch (error) {
      errors.push(error instanceof Error ? error.message : 'Validation failed');
      return {
        valid: false,
        errors
      };
    }
  }

  public getWorkerInfo(): { version: string; capabilities: string[] } {
    return {
      version: '1.0.0',
      capabilities: [
        'python-parsing',
        'javascript-parsing',
        'typescript-parsing',
        'tsx-parsing',
        'structure-analysis',
        'call-resolution',
        'ast-caching',
        'progress-reporting',
        'config-file-parsing',
        'import-resolution'
      ]
    };
  }

  private validateInput(input: PipelineInput): void {
    if (!input.projectName || input.projectName.trim().length === 0) {
      throw new Error('Project name is required');
    }
    
    if (!input.projectRoot || input.projectRoot.trim().length === 0) {
      throw new Error('Project root is required');
    }
    
    if (!Array.isArray(input.filePaths)) {
      throw new Error('File paths must be an array');
    }
    
    if (!(input.fileContents instanceof Map)) {
      throw new Error('File contents must be a Map');
    }
  }

  public terminate(): void {
    // Cleanup resources if needed
    console.log('Ingestion worker terminated');
  }
}

// Expose the worker class via Comlink
const worker = new IngestionWorker();
Comlink.expose(worker);

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

================
File: tsconfig.app.tsbuildinfo
================
{"root":["./src/app.tsx","./src/main.tsx","./src/vite-env.d.ts","./src/ai/cypher-generator.ts","./src/ai/index.ts","./src/ai/langchain-orchestrator.ts","./src/ai/llm-service.ts","./src/ai/orchestrator.ts","./src/core/graph/query.ts","./src/core/graph/types.ts","./src/core/ingestion/call-processor.ts","./src/core/ingestion/parsing-processor.ts","./src/core/ingestion/pipeline.ts","./src/core/ingestion/structure-processor.ts","./src/core/tree-sitter/parser-loader.ts","./src/lib/export.ts","./src/lib/polyfills.ts","./src/lib/preload.ts","./src/lib/utils.ts","./src/lib/workerutils.ts","./src/services/github.ts","./src/services/ingestion.service.ts","./src/services/zip.ts","./src/ui/index.ts","./src/ui/components/errorboundary.tsx","./src/ui/components/index.ts","./src/ui/components/chat/chatinterface.tsx","./src/ui/components/chat/codeassistant.tsx","./src/ui/components/chat/index.ts","./src/ui/components/graph/graphexplorer.tsx","./src/ui/components/graph/sourceviewer.tsx","./src/ui/components/graph/visualization.tsx","./src/ui/components/graph/index.ts","./src/ui/pages/homepage.tsx","./src/ui/pages/index.ts","./src/workers/ingestion.worker.ts"],"version":"5.8.3"}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

================
File: tsconfig.node.tsbuildinfo
================
{"root":["./vite.config.ts"],"version":"5.8.3"}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  worker: {
    format: 'es'
  },
  assetsInclude: ['**/*.wasm'],
  server: {
    fs: {
      allow: ['..']
    },
    headers: {
      'Cross-Origin-Embedder-Policy': 'require-corp',
      'Cross-Origin-Opener-Policy': 'same-origin'
    },
    hmr: {
      overlay: false
    }
  },
  build: {
    target: 'esnext',
    assetsInlineLimit: 0,
    commonjsOptions: {
      include: [/node_modules/],
      transformMixedEsModules: true,
      defaultIsModuleExports: true
    }
  },
  define: {
    global: 'globalThis',
  },
  resolve: {
    alias: {
      'node:async_hooks': path.resolve(__dirname, 'src/lib/polyfills.ts'),
      'async_hooks': path.resolve(__dirname, 'src/lib/polyfills.ts')
    }
  },
  optimizeDeps: {
    exclude: ['@langchain/langgraph'],
    include: [
      'camelcase', 
      'decamelize', 
      'ansi-styles',
      'chalk',
      'supports-color',
      'p-queue',
      'p-retry',
      'semver',
      'base64-js',
      'num-sort',
      'binary-search',
      'js-tiktoken',
      'uuid',
      'ms',
      'retry',
      'p-timeout',
      'p-finally',
      'eventemitter3',
      'web-tree-sitter',
      'comlink'
    ],
    force: true,
    holdUntilCrawlEnd: true
  }
})

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GitNexus - Code Knowledge Graph Explorer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      
      #root {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: ISOLATED_NODES_FIX.md
================
# 🔧 Fixing Isolated Nodes in Graph Visualization

## Problem Description
You're seeing nodes "flying away" with no connections in the graph visualization. This indicates **isolated nodes** - nodes that have no relationships to other nodes in the graph.

## Root Causes

### 1. **File Parsing Failures** (Most Common)
- Files fail to parse during **Pass 2** of ingestion
- File nodes get created but no functions/classes are extracted
- Results in isolated file nodes

### 2. **Unsupported File Types**
- Files with extensions not recognized by the parser
- Configuration files, documentation, etc. without code content

### 3. **Syntax Errors**
- Malformed code that the AST parser can't understand
- Missing imports or exports
- Language-specific syntax issues

### 4. **Import Resolution Failures**
- **Pass 3** fails to resolve import relationships
- Files exist but aren't connected via imports

### 5. **Call Resolution Failures**
- **Pass 4** fails to find function calls between files
- Functions exist but no call relationships are created

## 🛠️ How to Diagnose

### Step 1: Use the New Diagnostic Tool
1. Load your repository in GitNexus
2. Click the **🩺 Diagnose** button in the chat interface
3. Check the statistics and follow the suggested steps

### Step 2: Check Browser Console
1. Open Developer Tools (F12)
2. Look for console warnings during ingestion:
   - `⚠️ Found X isolated nodes`
   - `⚠️ Found X files without definitions`
   - `Source files without definitions: [...]`

### Step 3: Review Console Logs
Look for these specific log messages:
```
📁 Pass 1: Analyzing project structure...
🔍 Pass 2: Parsing code and extracting definitions...
🔗 Pass 3: Resolving imports and building dependency map...
📞 Pass 4: Resolving function calls with 3-stage strategy...
```

## 🔍 Diagnostic Information

The enhanced pipeline now shows:
- **Node counts by type** (Project, Folder, File, Function, Class, etc.)
- **Relationship counts by type** (CONTAINS, CALLS, IMPORTS, etc.)
- **Isolated nodes** with examples
- **Files without definitions** 
- **Graph integrity issues**

## ✅ Recent Fixes Applied

### **1. Reduced Console Noise (Fixed)**
- **Issue**: Thousands of "Failed to resolve call" messages for Python built-ins like `int`, `str`, `len`, etc.
- **Fix**: Added `shouldIgnoreCall()` method to filter out Python built-in functions and standard library calls
- **Result**: Console output is now much cleaner and shows only relevant failures

### **2. Improved Python Import Resolution (Fixed)**
- **Issue**: Python imports weren't being resolved correctly, causing "No import relationships found"
- **Fix**: Enhanced `resolveModulePath()` with better pattern matching for complex project structures
- **Features Added**:
  - Multiple resolution patterns for Python modules
  - Partial path matching for complex project structures
  - Better handling of package imports
  - Enhanced debugging with import resolution statistics

### **3. Enhanced Diagnostic Reporting (Added)**
- **New**: Comprehensive graph integrity validation
- **New**: Import resolution success rate reporting
- **New**: Detailed breakdown of isolated nodes by type
- **New**: 🩺 Diagnose button in chat interface

## 🚀 Solutions

### For File Parsing Issues:
1. **Check file extensions**: Ensure files are `.js`, `.ts`, `.jsx`, `.tsx`, `.py`, etc.
2. **Verify syntax**: Make sure code files have valid syntax
3. **Check file size**: Very large files might timeout during parsing
4. **Review file content**: Empty files or files with only comments won't generate nodes

### For Import Issues (Now Improved):
1. **Check import syntax**: Ensure proper `import`/`export` or `require()` statements
2. **Verify file paths**: Relative imports should resolve correctly
3. **Check module resolution**: External libraries might not be resolved
4. **Monitor import resolution rate**: Should be >50% for healthy projects

### For Call Issues:
1. **Function calls**: Ensure functions are actually called between files
2. **Method calls**: Class methods should be invoked
3. **Export/import**: Functions need to be properly exported and imported

## 🔧 Quick Fixes

### 1. **Filter Out Non-Code Files**
Use GitNexus filtering options to exclude:
- Documentation files (`.md`, `.txt`)
- Configuration files (`.json`, `.yaml`, `.xml`)
- Asset files (`.png`, `.jpg`, `.css`)

### 2. **Focus on Core Directories**
- Include only `src/`, `lib/`, `app/` directories
- Exclude `node_modules/`, `.git/`, `dist/`, `build/`

### 3. **Check File Limits**
- Large repositories might hit processing limits
- Consider processing smaller subsets first

## 📊 Expected Results After Fixes

A healthy graph should show:
- **Project** → **Folders** → **Files** (CONTAINS relationships)
- **Files** → **Functions/Classes** (CONTAINS relationships)
- **Files** → **Files** (IMPORTS relationships) - **Now working better**
- **Functions** → **Functions** (CALLS relationships) - **Cleaner console output**

### **Typical Success Rates**:
- **Import Resolution**: 40-70% (up from 0%)
- **Call Resolution**: 20-30% (excluding built-ins)
- **File Parsing**: 80-95% for source files

## 🆘 Still Having Issues?

1. **Try the diagnostic tool**: Click 🩺 Diagnose button
2. **Check console output**: Look for specific error patterns
3. **Share diagnostic info**: Copy the improved console logs
4. **Test incrementally**: Try with smaller subsets of files

## 📈 What You Should See Now

After the fixes, your console output should show:
```
ImportProcessor: Found 45 imports, resolved 28 (62.2%)
CallProcessor: Success rate: 45.9% (excluding built-ins)
📊 Graph Statistics:
Relationships by type: {CONTAINS: 395, DECORATES: 48, IMPORTS: 13, CALLS: 47}
✅ Graph integrity validation passed
```

### **Latest Improvements (v2)**:
- **Expanded built-ins filtering**: Now ignores 100+ Python string methods, math functions, and third-party library calls
- **Better diagnostics**: Identifies source files with zero function calls (potential parsing issues)
- **Pattern-based filtering**: Automatically ignores dunder methods (`__init__`, `__str__`) and private methods

### **Expected Results After All Fixes**:
- **Console noise reduction**: 95%+ reduction in irrelevant error messages
- **Import relationships**: 10-20+ IMPORTS relationships created
- **Call resolution success**: 40-60% (realistic for complex codebases)
- **Failed calls**: Only legitimate issues (domain-specific functions, missing imports)

Instead of thousands of failed call resolutions, you'll see much cleaner output focused on actual issues that need attention! 

## 🎯 **FINAL STATUS - Issue Resolved!**

### **🔍 MAJOR DISCOVERY - Python Call Extraction Bug Found!**

**Latest diagnostic output revealed a critical issue:**
```
📊 Debug: config.py has 38 call nodes, 0 definitions
📊 Debug: assessment_db.py has 120 call nodes, 4 definitions
📊 Debug: sonar_analyzer.py has 30 call nodes, 2 definitions
```

**This shows that:**
- ✅ **AST parsing works perfectly** - files have hundreds of call nodes
- ❌ **Call extraction is broken** - 0 function calls extracted from files with 120+ call nodes
- 🔧 **Root cause identified** - Python call extraction logic needs fixes

### **🛠️ Latest Fix Applied**
- **Enhanced Python call extraction** with better node type handling
- **Comprehensive debugging** to identify what's being filtered vs extracted
- **Improved function name extraction** for complex Python call patterns
- **Added support for** subscript calls, nested calls, and more node types

### **✅ Latest Results (Your Console Output)**
```
✅ Parsing Success: 38 successful, 0 failed (100%)
✅ Import Resolution: 102 imports found, 61 resolved (59.8%)  
✅ Call Resolution: 129 calls processed, 56.6% success rate
✅ Graph Health: 367 nodes, 506 relationships
✅ Console Cleanliness: Only 56 legitimate failures (93% noise reduction)
```

### **🔍 Enhanced Diagnostics Added**
- **Zero-call file detection**: Identifies source files with parsing issues
- **AST node counting**: Shows `call` nodes vs definitions for debugging
- **Suspicious file flagging**: Highlights files with definitions but no calls
- **Comprehensive built-ins filtering**: 100+ Python functions ignored

### **📊 Your Graph is Now Healthy!**

**Before the fixes:**
- ❌ 814+ failed call messages (noise)
- ❌ No import relationships 
- ❌ Isolated nodes everywhere
- ❌ Unreadable console output

**After the fixes:**
- ✅ **56.6% call resolution success** (excellent!)
- ✅ **59.8% import resolution success** (great!)
- ✅ **13 IMPORTS relationships** created
- ✅ **47 CALLS relationships** created  
- ✅ **Clean, readable diagnostics**

### **🔬 Remaining Issues Are Expected**

#### **1. Zero-Call Files (Normal)**
Files showing "No function calls found" are often:
- **Model/config files**: Only contain class definitions
- **Pure data files**: Constants, configurations
- **Interface files**: Abstract base classes
- **Files with only imports**: Router configurations

#### **2. Failed Calls (Legitimate)**
The remaining 56 failed calls are **appropriate failures**:
- **External libraries**: LangGraph, FastAPI, Azure OpenAI
- **Domain-specific**: Business logic libraries (`ruleset`, `assert_fact`)
- **Custom models**: Application-specific classes

### **🎉 Problem Solved!**

Your **"nodes flying away with no connections"** issue is **fully resolved**:

1. ✅ **Files connect properly** via CONTAINS relationships
2. ✅ **Import relationships work** (13 created)
3. ✅ **Function calls connect** (47 relationships)
4. ✅ **Console is clean** and diagnostic
5. ✅ **Success rates are realistic** for complex codebases

### **🚀 What You Should See Now**

When you reload your repository, expect:
- **Significantly fewer isolated nodes**
- **Connected file clusters** via imports
- **Function-to-function connections** within files
- **Clean console output** focusing on real issues
- **Better graph connectivity** overall

The isolated nodes that remain will be:
- **Configuration files** (expected)
- **Documentation files** (expected)  
- **Empty or comment-only files** (expected)
- **External library references** (expected)

## **🏆 Mission Accomplished!**

Your graph now has proper connectivity with realistic success rates. The diagnostic tools will help you identify any remaining issues that need attention. The isolated nodes problem is **solved**! 🎯✨

## 🎛️ **NEW FEATURE: Hide External Libraries Toggle**

### **✨ What's New**
Added a **"Hide external libraries"** toggle in the graph visualization that lets you:
- ✅ **Clean view**: Hide isolated external library nodes for cleaner visualization
- ✅ **Full view**: Show all nodes including external dependencies for complete context
- ✅ **Smart filtering**: Automatically identifies external library patterns
- ✅ **Live counter**: Shows how many external nodes are hidden/visible

### **🎯 How It Works**
The toggle uses intelligent filtering to identify external library nodes:
- **Isolated nodes**: Nodes with no relationships (not connected to your code)
- **External patterns**: Recognizes common library functions like:
  - `when_all`, `ruleset` (durable rules)
  - `APIRouter`, `FastAPI` (FastAPI framework)
  - `StateGraph`, `AsyncAzureOpenAI` (AI libraries)
  - CamelCase patterns (often external classes)

### **🚀 When to Use Each Mode**

#### **Hide External Libraries (Clean View)**
**Best for:**
- 📊 **Architecture review** - Focus on your internal code structure
- 🔍 **Code navigation** - See relationships between your functions/classes
- 📈 **Presentations** - Clean, professional visualization
- 🎯 **Debugging** - Trace internal call paths without distractions

#### **Show External Libraries (Full View)**
**Best for:**
- 🔗 **Dependency analysis** - See what external libraries you use
- 🏗️ **System design** - Understand integration points
- 📋 **Documentation** - Complete picture of your tech stack
- 🔧 **Troubleshooting** - Identify external dependency issues

### **💡 Pro Tips**
- **Default state**: External libraries are **visible by default** for complete context
- **Toggle anytime**: Switch between views without reloading the graph
- **Persistent**: Your preference is remembered during the session
- **Smart counting**: See exactly how many external nodes are being hidden

This gives you the **best of both worlds** - clean focused views when you need them, and complete architectural context when you want it!

Instead of thousands of failed call resolutions, you'll see much cleaner output focused on actual issues that need attention!

================
File: jest.config.cjs
================
/**
 * Jest configuration for GitNexus
 */

module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: [
    '**/__tests__/**/*.test.ts',
    '**/?(*.)+(spec|test).ts'
  ],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/__tests__/**',
    '!src/**/*.test.ts',
  ],
  coverageDirectory: 'coverage',
  coverageReporters: [
    'text',
    'lcov',
    'html'
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70
    }
  },
  setupFilesAfterEnv: ['<rootDir>/src/__tests__/setup.ts'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  testTimeout: 10000,
  verbose: true
};

================
File: log.txt
================
Starting ZIP processing... trumio-cortex-core.zip
zip.ts:64 Starting complete ZIP extraction of: trumio-cortex-core.zip (27513697 bytes)
zip.ts:118 Skipping large file: trumio-cortex-core/.git/objects/pack/pack-4d5e84ce4d4c68c3dcdaf68f49c25a0693180f62.pack (27326542 bytes)
(anonymous) @ zip.ts:118
forEach @ jszip.js?v=7c98553f:349
extractCompleteStructure @ zip.ts:102
await in extractCompleteStructure
processZipFile @ ingestion.service.ts:94
handleFileUpload @ HomePage.tsx:118
callCallback2 @ chunk-YZVM2MHU.js?v=5b2c6c96:3674
invokeGuardedCallbackDev @ chunk-YZVM2MHU.js?v=5b2c6c96:3699
invokeGuardedCallback @ chunk-YZVM2MHU.js?v=5b2c6c96:3733
invokeGuardedCallbackAndCatchFirstError @ chunk-YZVM2MHU.js?v=5b2c6c96:3736
executeDispatch @ chunk-YZVM2MHU.js?v=5b2c6c96:7014
processDispatchQueueItemsInOrder @ chunk-YZVM2MHU.js?v=5b2c6c96:7034
processDispatchQueue @ chunk-YZVM2MHU.js?v=5b2c6c96:7043
dispatchEventsForPlugins @ chunk-YZVM2MHU.js?v=5b2c6c96:7051
(anonymous) @ chunk-YZVM2MHU.js?v=5b2c6c96:7174
batchedUpdates$1 @ chunk-YZVM2MHU.js?v=5b2c6c96:18913
batchedUpdates @ chunk-YZVM2MHU.js?v=5b2c6c96:3579
dispatchEventForPluginEventSystem @ chunk-YZVM2MHU.js?v=5b2c6c96:7173
dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay @ chunk-YZVM2MHU.js?v=5b2c6c96:5478
dispatchEvent @ chunk-YZVM2MHU.js?v=5b2c6c96:5472
dispatchDiscreteEvent @ chunk-YZVM2MHU.js?v=5b2c6c96:5449Understand this warning
zip.ts:146 ZIP: Discovered 271 total paths, 109 files with content
zip.ts:147 ZIP: Total extracted size: 401503 bytes
workerUtils.ts:43 Ingestion worker initialized successfully
ingestion.worker.ts?worker_file&type=module:15 IngestionWorker: Starting processing with 271 files
pipeline.ts:19 🚀 Starting 4-pass ingestion for project: trumio-cortex-core
pipeline.ts:20 📁 Pass 1: Analyzing project structure...
structure-processor.ts:71 StructureProcessor: Processing 271 complete paths
structure-processor.ts:75 StructureProcessor: Found 74 directories and 197 files
structure-processor.ts:79 StructureProcessor: Hiding 33 ignored directories from KG
structure-processor.ts:86 StructureProcessor: Hiding 82 files in ignored directories from KG
structure-processor.ts:227 StructureProcessor: Created 156 CONTAINS relationships
structure-processor.ts:92 StructureProcessor: Created 157 nodes total (115 items hidden)
pipeline.ts:26 🔍 Pass 2: Parsing code and extracting definitions...
parsing-processor.ts:40 ParsingProcessor: Processing 271 total paths
parsing-processor.ts:42 Memory status: 0MB used, 0 files cached
parsing-processor.ts:44 ParsingProcessor: After filtering: 32 files to parse
parsing-processor.ts:49 ParsingProcessor: Found 22 source files and 3 config files, processing in batches of 10
parser-loader.ts:65 Loading TypeScript parser from: /wasm/typescript/tree-sitter-typescript.wasm
parser-loader.ts:68 TypeScript parser loaded successfully
parsing-processor.ts:121 typescript parser loaded successfully.
parser-loader.ts:49 Loading JavaScript parser from: /wasm/javascript/tree-sitter-javascript.wasm
parser-loader.ts:52 JavaScript parser loaded successfully
parsing-processor.ts:121 javascript parser loaded successfully.
parser-loader.ts:33 Loading Python parser from: /wasm/python/tree-sitter-python.wasm
parser-loader.ts:36 Python parser loaded successfully
parsing-processor.ts:121 python parser loaded successfully.
parsing-processor.ts:131 No parser available for language: generic. Skipping file: trumio-cortex-core/docker-compose.yaml
parseFile @ parsing-processor.ts:203
(anonymous) @ parsing-processor.ts:112
await in (anonymous)
processAll @ shared-utils.ts:274
await in processAll
process @ parsing-processor.ts:122
await in process
run @ pipeline.ts:49
await in run
processRepository @ ingestion.worker.ts:68
callback @ comlink.js?v=4af0e45c:91Understand this warning
parsing-processor.ts:131 No parser available for language: generic. Skipping file: trumio-cortex-core/manifests/uat/deployment_cortex.yml
parseFile @ parsing-processor.ts:203
(anonymous) @ parsing-processor.ts:112
await in (anonymous)
processAll @ shared-utils.ts:274
await in processAll
process @ parsing-processor.ts:122
await in process
run @ pipeline.ts:49
await in run
processRepository @ ingestion.worker.ts:68
callback @ comlink.js?v=4af0e45c:91Understand this warning
parsing-processor.ts:131 No parser available for language: generic. Skipping file: trumio-cortex-core/manifests/uat/service_cortex.yml
parseFile @ parsing-processor.ts:203
(anonymous) @ parsing-processor.ts:112
await in (anonymous)
processAll @ shared-utils.ts:274
await in processAll
process @ parsing-processor.ts:122
await in process
run @ pipeline.ts:49
await in run
processRepository @ ingestion.worker.ts:68
callback @ comlink.js?v=4af0e45c:91Understand this warning
parsing-processor.ts:72 ParsingProcessor: Successfully processed 25 files
pipeline.ts:36 🔗 Pass 3: Resolving imports and building dependency map...
import-processor.ts:42 ImportProcessor: Starting import resolution...
import-processor.ts:52 ImportProcessor: Completed import resolution
import-processor.ts:53 ImportProcessor: Found 160 imports, resolved 90 (56.3%)
import-processor.ts:54 ImportProcessor: Built import map for 22 files
pipeline.ts:38 📞 Pass 4: Resolving function calls with 3-stage strategy...
call-processor.ts:33 CallProcessor: Starting call resolution with 3-stage strategy...
call-processor.ts:553 🔍 Filtered out: load_dotenv in check_prompt.py
2call-processor.ts:553 🔍 Filtered out: getenv in check_prompt.py
call-processor.ts:553 🔍 Filtered out: print in check_prompt.py
call-processor.ts:553 🔍 Filtered out: AsyncIOMotorClient in check_prompt.py
call-processor.ts:553 🔍 Filtered out: limit in check_prompt.py
call-processor.ts:553 🔍 Filtered out: sort in check_prompt.py
call-processor.ts:553 🔍 Filtered out: find in check_prompt.py
call-processor.ts:553 🔍 Filtered out: to_list in check_prompt.py
call-processor.ts:553 🔍 Filtered out: print in check_prompt.py
call-processor.ts:553 🔍 Filtered out: print in check_prompt.py
call-processor.ts:553 🔍 Filtered out: close in check_prompt.py
call-processor.ts:553 🔍 Filtered out: run in check_prompt.py
call-processor.ts:65 CallProcessor: Found 1 function calls in trumio-cortex-core/check_prompt.py
2call-processor.ts:553 🔍 Filtered out: getenv in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: AsyncIOMotorClient in debug_channel_messages.py
2call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: find_one in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: get in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: get in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: get in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: now in debug_channel_messages.py
call-processor.ts:65 CallProcessor: Found 5 function calls in trumio-cortex-core/debug_channel_messages.py
call-processor.ts:86 ❌ Failed to resolve call: count_documents in trumio-cortex-core/debug_channel_messages.py:24
call-processor.ts:86 ❌ Failed to resolve call: count_documents in trumio-cortex-core/debug_channel_messages.py:31
call-processor.ts:86 ❌ Failed to resolve call: timedelta in trumio-cortex-core/debug_channel_messages.py:49
call-processor.ts:86 ❌ Failed to resolve call: count_documents in trumio-cortex-core/debug_channel_messages.py:51
call-processor.ts:553 🔍 Filtered out: getLogger in mcp_auth_service.py
call-processor.ts:65 CallProcessor: Found 14 function calls in trumio-cortex-core/src/python/common_services/mcp_auth_service.py
call-processor.ts:86 ❌ Failed to resolve call: HTTPBaseModel in trumio-cortex-core/src/python/common_services/mcp_auth_service.py:32
call-processor.ts:86 ❌ Failed to resolve call: hexdigest in trumio-cortex-core/src/python/common_services/mcp_auth_service.py:99
call-processor.ts:86 ❌ Failed to resolve call: new in trumio-cortex-core/src/python/common_services/mcp_auth_service.py:99
call-processor.ts:86 ❌ Failed to resolve call: compare_digest in trumio-cortex-core/src/python/common_services/mcp_auth_service.py:130
call-processor.ts:86 ❌ Failed to resolve call: body in trumio-cortex-core/src/python/common_services/mcp_auth_service.py:227
call-processor.ts:553 🔍 Filtered out: getLogger in openai_service.py
call-processor.ts:553 🔍 Filtered out: getenv in openai_service.py
call-processor.ts:553 🔍 Filtered out: ValueError in openai_service.py
call-processor.ts:553 🔍 Filtered out: OpenAI in openai_service.py
call-processor.ts:65 CallProcessor: Found 12 function calls in trumio-cortex-core/src/python/common_services/openai_service.py
call-processor.ts:86 ❌ Failed to resolve call: retry in trumio-cortex-core/src/python/common_services/openai_service.py:30
call-processor.ts:86 ❌ Failed to resolve call: retry_if_exception_type in trumio-cortex-core/src/python/common_services/openai_service.py:31
call-processor.ts:86 ❌ Failed to resolve call: stop_after_attempt in trumio-cortex-core/src/python/common_services/openai_service.py:32
call-processor.ts:86 ❌ Failed to resolve call: wait_exponential in trumio-cortex-core/src/python/common_services/openai_service.py:33
call-processor.ts:86 ❌ Failed to resolve call: retry in trumio-cortex-core/src/python/common_services/openai_service.py:89
call-processor.ts:86 ❌ Failed to resolve call: retry_if_exception_type in trumio-cortex-core/src/python/common_services/openai_service.py:90
call-processor.ts:86 ❌ Failed to resolve call: stop_after_attempt in trumio-cortex-core/src/python/common_services/openai_service.py:91
call-processor.ts:86 ❌ Failed to resolve call: wait_exponential in trumio-cortex-core/src/python/common_services/openai_service.py:92
call-processor.ts:86 ❌ Failed to resolve call: retry in trumio-cortex-core/src/python/common_services/openai_service.py:122
call-processor.ts:86 ❌ Failed to resolve call: retry_if_exception_type in trumio-cortex-core/src/python/common_services/openai_service.py:123
call-processor.ts:86 ❌ Failed to resolve call: stop_after_attempt in trumio-cortex-core/src/python/common_services/openai_service.py:124
call-processor.ts:86 ❌ Failed to resolve call: wait_exponential in trumio-cortex-core/src/python/common_services/openai_service.py:125
call-processor.ts:553 🔍 Filtered out: getLogger in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: isinstance in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: TypeError in prompt_registry_service.py
2call-processor.ts:553 🔍 Filtered out: info in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: find_one in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: warning in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: ValueError in prompt_registry_service.py
2call-processor.ts:553 🔍 Filtered out: now in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: insert_one in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: info in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: str in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: info in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: find_one in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: info in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: limit in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: sort in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: find in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: to_list in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: info in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: error in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: ValueError in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: now in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: update_one in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: ObjectId in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: warning in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: info in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: info in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: delete_one in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: ObjectId in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: warning in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: info in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: info in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: find in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: to_list in prompt_registry_service.py
call-processor.ts:553 🔍 Filtered out: limit in prompt_registry_service.py
call-processor.ts:52 ⚠️ CallProcessor: No function calls found in source file: trumio-cortex-core/src/python/common_services/prompt_registry_service.py
call-processor.ts:58   📊 Debug: prompt_registry_service.py has 37 call nodes, 7 definitions
call-processor.ts:553 🔍 Filtered out: append in chat.py
call-processor.ts:553 🔍 Filtered out: abspath in chat.py
call-processor.ts:553 🔍 Filtered out: join in chat.py
call-processor.ts:553 🔍 Filtered out: dirname in chat.py
call-processor.ts:553 🔍 Filtered out: HTTPException in chat.py
call-processor.ts:553 🔍 Filtered out: str in chat.py
call-processor.ts:65 CallProcessor: Found 7 function calls in trumio-cortex-core/src/python/demo_app/app/api/v1/endpoints/chat.py
call-processor.ts:86 ❌ Failed to resolve call: APIRouter in trumio-cortex-core/src/python/demo_app/app/api/v1/endpoints/chat.py:15
call-processor.ts:86 ❌ Failed to resolve call: post in trumio-cortex-core/src/python/demo_app/app/api/v1/endpoints/chat.py:28
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/demo_app/app/api/v1/endpoints/chat.py:29
11call-processor.ts:553 🔍 Filtered out: Field in chat.py
call-processor.ts:52 ⚠️ CallProcessor: No function calls found in source file: trumio-cortex-core/src/python/demo_app/app/schemas/chat.py
call-processor.ts:58   📊 Debug: chat.py has 11 call nodes, 4 definitions
call-processor.ts:553 🔍 Filtered out: dirname in start-service.py
call-processor.ts:553 🔍 Filtered out: abspath in start-service.py
call-processor.ts:553 🔍 Filtered out: join in start-service.py
call-processor.ts:553 🔍 Filtered out: exists in start-service.py
call-processor.ts:553 🔍 Filtered out: load_dotenv in start-service.py
call-processor.ts:553 🔍 Filtered out: print in start-service.py
call-processor.ts:553 🔍 Filtered out: print in start-service.py
call-processor.ts:553 🔍 Filtered out: upper in start-service.py
call-processor.ts:553 🔍 Filtered out: getenv in start-service.py
call-processor.ts:553 🔍 Filtered out: basicConfig in start-service.py
call-processor.ts:553 🔍 Filtered out: StreamHandler in start-service.py
2call-processor.ts:553 🔍 Filtered out: getLogger in start-service.py
call-processor.ts:65 CallProcessor: Found 15 function calls in trumio-cortex-core/src/python/demo_app/start-service.py
call-processor.ts:86 ❌ Failed to resolve call: setLevel in trumio-cortex-core/src/python/demo_app/start-service.py:26
call-processor.ts:86 ❌ Failed to resolve call: setLevel in trumio-cortex-core/src/python/demo_app/start-service.py:27
call-processor.ts:86 ❌ Failed to resolve call: setLevel in trumio-cortex-core/src/python/demo_app/start-service.py:28
call-processor.ts:86 ❌ Failed to resolve call: exit in trumio-cortex-core/src/python/demo_app/start-service.py:37
call-processor.ts:86 ❌ Failed to resolve call: exit in trumio-cortex-core/src/python/demo_app/start-service.py:40
call-processor.ts:86 ❌ Failed to resolve call: setLevel in trumio-cortex-core/src/python/demo_app/start-service.py:43
call-processor.ts:86 ❌ Failed to resolve call: exit in trumio-cortex-core/src/python/demo_app/start-service.py:59
call-processor.ts:86 ❌ Failed to resolve call: exit in trumio-cortex-core/src/python/demo_app/start-service.py:62
call-processor.ts:86 ❌ Failed to resolve call: get_motor_client in trumio-cortex-core/src/python/demo_app/start-service.py:77
call-processor.ts:86 ❌ Failed to resolve call: compile_graphs in trumio-cortex-core/src/python/demo_app/start-service.py:87
call-processor.ts:86 ❌ Failed to resolve call: close_motor_client in trumio-cortex-core/src/python/demo_app/start-service.py:99
call-processor.ts:86 ❌ Failed to resolve call: exit in trumio-cortex-core/src/python/demo_app/start-service.py:132
call-processor.ts:86 ❌ Failed to resolve call: exit in trumio-cortex-core/src/python/demo_app/start-service.py:135
call-processor.ts:86 ❌ Failed to resolve call: RedirectResponse in trumio-cortex-core/src/python/demo_app/start-service.py:141
call-processor.ts:86 ❌ Failed to resolve call: get_swagger_ui_html in trumio-cortex-core/src/python/demo_app/start-service.py:145
call-processor.ts:553 🔍 Filtered out: append in interactions_endpoint.py
call-processor.ts:553 🔍 Filtered out: join in interactions_endpoint.py
call-processor.ts:553 🔍 Filtered out: dirname in interactions_endpoint.py
call-processor.ts:553 🔍 Filtered out: getLogger in interactions_endpoint.py
call-processor.ts:65 CallProcessor: Found 8 function calls in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/interactions_endpoint.py
call-processor.ts:86 ❌ Failed to resolve call: APIRouter in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/interactions_endpoint.py:14
call-processor.ts:86 ❌ Failed to resolve call: post in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/interactions_endpoint.py:16
call-processor.ts:86 ❌ Failed to resolve call: Query in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/interactions_endpoint.py:18
call-processor.ts:86 ❌ Failed to resolve call: Query in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/interactions_endpoint.py:19
call-processor.ts:86 ❌ Failed to resolve call: Query in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/interactions_endpoint.py:20
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/interactions_endpoint.py:21
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/interactions_endpoint.py:22
call-processor.ts:86 ❌ Failed to resolve call: fetch_and_process_project_chats_for_period in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/interactions_endpoint.py:32
call-processor.ts:553 🔍 Filtered out: append in mcp_auth.py
call-processor.ts:553 🔍 Filtered out: join in mcp_auth.py
call-processor.ts:553 🔍 Filtered out: dirname in mcp_auth.py
call-processor.ts:553 🔍 Filtered out: getLogger in mcp_auth.py
call-processor.ts:553 🔍 Filtered out: get in mcp_auth.py
call-processor.ts:65 CallProcessor: Found 8 function calls in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/mcp_auth.py
call-processor.ts:86 ❌ Failed to resolve call: APIRouter in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/mcp_auth.py:14
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/ms_teams_connector/app/api/v1/endpoints/mcp_auth.py:69
call-processor.ts:553 🔍 Filtered out: getLogger in config.py
9call-processor.ts:553 🔍 Filtered out: getenv in config.py
call-processor.ts:553 🔍 Filtered out: int in config.py
call-processor.ts:553 🔍 Filtered out: getenv in config.py
call-processor.ts:553 🔍 Filtered out: lower in config.py
call-processor.ts:553 🔍 Filtered out: getenv in config.py
3call-processor.ts:553 🔍 Filtered out: bool in config.py
call-processor.ts:553 🔍 Filtered out: info in config.py
call-processor.ts:553 🔍 Filtered out: warning in config.py
call-processor.ts:52 ⚠️ CallProcessor: No function calls found in source file: trumio-cortex-core/src/python/ms_teams_connector/app/config.py
call-processor.ts:58   📊 Debug: config.py has 19 call nodes, 0 definitions
10call-processor.ts:553 🔍 Filtered out: Field in processed_text_unit.py
call-processor.ts:52 ⚠️ CallProcessor: No function calls found in source file: trumio-cortex-core/src/python/ms_teams_connector/app/schemas/processed_text_unit.py
call-processor.ts:58   📊 Debug: processed_text_unit.py has 10 call nodes, 1 definitions
2call-processor.ts:553 🔍 Filtered out: Field in watermark.py
call-processor.ts:553 🔍 Filtered out: now in watermark.py
call-processor.ts:52 ⚠️ CallProcessor: No function calls found in source file: trumio-cortex-core/src/python/ms_teams_connector/app/schemas/watermark.py
call-processor.ts:58   📊 Debug: watermark.py has 3 call nodes, 2 definitions
call-processor.ts:553 🔍 Filtered out: getLogger in path_utils.py
call-processor.ts:553 🔍 Filtered out: abspath in path_utils.py
call-processor.ts:553 🔍 Filtered out: dirname in path_utils.py
call-processor.ts:553 🔍 Filtered out: dirname in path_utils.py
call-processor.ts:553 🔍 Filtered out: dirname in path_utils.py
call-processor.ts:553 🔍 Filtered out: abspath in path_utils.py
call-processor.ts:553 🔍 Filtered out: join in path_utils.py
call-processor.ts:553 🔍 Filtered out: append in path_utils.py
call-processor.ts:553 🔍 Filtered out: info in path_utils.py
call-processor.ts:52 ⚠️ CallProcessor: No function calls found in source file: trumio-cortex-core/src/python/ms_teams_connector/app/utils/path_utils.py
call-processor.ts:58   📊 Debug: path_utils.py has 9 call nodes, 1 definitions
2call-processor.ts:553 🔍 Filtered out: getenv in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: AsyncIOMotorClient in debug_channel_messages.py
3call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: aggregate in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: to_list in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: aggregate in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: to_list in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:553 🔍 Filtered out: print in debug_channel_messages.py
call-processor.ts:65 CallProcessor: Found 6 function calls in trumio-cortex-core/src/python/ms_teams_connector/debug_channel_messages.py
call-processor.ts:86 ❌ Failed to resolve call: count_documents in trumio-cortex-core/src/python/ms_teams_connector/debug_channel_messages.py:24
call-processor.ts:86 ❌ Failed to resolve call: count_documents in trumio-cortex-core/src/python/ms_teams_connector/debug_channel_messages.py:54
call-processor.ts:86 ❌ Failed to resolve call: count_documents in trumio-cortex-core/src/python/ms_teams_connector/debug_channel_messages.py:61
call-processor.ts:86 ❌ Failed to resolve call: timedelta in trumio-cortex-core/src/python/ms_teams_connector/debug_channel_messages.py:77
call-processor.ts:86 ❌ Failed to resolve call: count_documents in trumio-cortex-core/src/python/ms_teams_connector/debug_channel_messages.py:79
call-processor.ts:553 🔍 Filtered out: dirname in start-service.py
call-processor.ts:553 🔍 Filtered out: abspath in start-service.py
call-processor.ts:553 🔍 Filtered out: join in start-service.py
call-processor.ts:553 🔍 Filtered out: exists in start-service.py
call-processor.ts:553 🔍 Filtered out: load_dotenv in start-service.py
call-processor.ts:553 🔍 Filtered out: print in start-service.py
call-processor.ts:553 🔍 Filtered out: print in start-service.py
call-processor.ts:553 🔍 Filtered out: upper in start-service.py
call-processor.ts:553 🔍 Filtered out: getenv in start-service.py
call-processor.ts:553 🔍 Filtered out: basicConfig in start-service.py
call-processor.ts:553 🔍 Filtered out: StreamHandler in start-service.py
call-processor.ts:553 🔍 Filtered out: getLogger in start-service.py
call-processor.ts:553 🔍 Filtered out: info in start-service.py
call-processor.ts:553 🔍 Filtered out: info in start-service.py
call-processor.ts:65 CallProcessor: Found 5 function calls in trumio-cortex-core/src/python/ms_teams_connector/start-service.py
call-processor.ts:86 ❌ Failed to resolve call: connect_db_client in trumio-cortex-core/src/python/ms_teams_connector/start-service.py:44
call-processor.ts:86 ❌ Failed to resolve call: disconnect_db_client in trumio-cortex-core/src/python/ms_teams_connector/start-service.py:50
call-processor.ts:86 ❌ Failed to resolve call: is_motor_client_open in trumio-cortex-core/src/python/ms_teams_connector/start-service.py:79
call-processor.ts:553 🔍 Filtered out: append in mcp_auth.py
call-processor.ts:553 🔍 Filtered out: join in mcp_auth.py
call-processor.ts:553 🔍 Filtered out: dirname in mcp_auth.py
call-processor.ts:553 🔍 Filtered out: getLogger in mcp_auth.py
call-processor.ts:553 🔍 Filtered out: get in mcp_auth.py
call-processor.ts:65 CallProcessor: Found 8 function calls in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/mcp_auth.py
call-processor.ts:86 ❌ Failed to resolve call: APIRouter in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/mcp_auth.py:14
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/mcp_auth.py:69
call-processor.ts:553 🔍 Filtered out: append in quality_analyzer.py
call-processor.ts:553 🔍 Filtered out: join in quality_analyzer.py
call-processor.ts:553 🔍 Filtered out: dirname in quality_analyzer.py
call-processor.ts:553 🔍 Filtered out: critical in quality_analyzer.py
call-processor.ts:553 🔍 Filtered out: getLogger in quality_analyzer.py
call-processor.ts:553 🔍 Filtered out: error in quality_analyzer.py
call-processor.ts:553 🔍 Filtered out: HTTPException in quality_analyzer.py
call-processor.ts:553 🔍 Filtered out: warning in quality_analyzer.py
call-processor.ts:65 CallProcessor: Found 23 function calls in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py
call-processor.ts:86 ❌ Failed to resolve call: APIRouter in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:36
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:38
call-processor.ts:86 ❌ Failed to resolve call: compile_graphs in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:46
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:74
call-processor.ts:86 ❌ Failed to resolve call: is_motor_client_open in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:80
call-processor.ts:86 ❌ Failed to resolve call: calculate_date_range in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:100
call-processor.ts:86 ❌ Failed to resolve call: invoke_weekly_user_fetch_graph in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:104
call-processor.ts:86 ❌ Failed to resolve call: run_full_weekly_analysis in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:126
call-processor.ts:86 ❌ Failed to resolve call: post in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:148
call-processor.ts:86 ❌ Failed to resolve call: Query in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:157
call-processor.ts:86 ❌ Failed to resolve call: Query in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:158
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:159
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:160
call-processor.ts:86 ❌ Failed to resolve call: add_task in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:179
call-processor.ts:86 ❌ Failed to resolve call: add_task in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:187
call-processor.ts:86 ❌ Failed to resolve call: post in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:197
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:205
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:206
call-processor.ts:86 ❌ Failed to resolve call: add_task in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:214
call-processor.ts:86 ❌ Failed to resolve call: post in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:220
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:228
call-processor.ts:86 ❌ Failed to resolve call: Depends in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:229
call-processor.ts:86 ❌ Failed to resolve call: add_task in trumio-cortex-core/src/python/pr_quality_service/app/api/v1/endpoints/quality_analyzer.py:237
call-processor.ts:553 🔍 Filtered out: getLogger in config.py
call-processor.ts:553 🔍 Filtered out: int in config.py
call-processor.ts:553 🔍 Filtered out: getenv in config.py
call-processor.ts:553 🔍 Filtered out: upper in config.py
call-processor.ts:553 🔍 Filtered out: getenv in config.py
10call-processor.ts:553 🔍 Filtered out: getenv in config.py
call-processor.ts:553 🔍 Filtered out: strip in config.py
call-processor.ts:553 🔍 Filtered out: getenv in config.py
2call-processor.ts:553 🔍 Filtered out: getenv in config.py
call-processor.ts:553 🔍 Filtered out: int in config.py
call-processor.ts:553 🔍 Filtered out: getenv in config.py
5call-processor.ts:553 🔍 Filtered out: getenv in config.py
call-processor.ts:553 🔍 Filtered out: int in config.py
call-processor.ts:553 🔍 Filtered out: getenv in config.py
call-processor.ts:553 🔍 Filtered out: lower in config.py
call-processor.ts:553 🔍 Filtered out: getenv in config.py
6call-processor.ts:553 🔍 Filtered out: bool in config.py
call-processor.ts:553 🔍 Filtered out: info in config.py
call-processor.ts:553 🔍 Filtered out: warning in config.py
call-processor.ts:52 ⚠️ CallProcessor: No function calls found in source file: trumio-cortex-core/src/python/pr_quality_service/app/config.py
call-processor.ts:58   📊 Debug: config.py has 38 call nodes, 0 definitions
call-processor.ts:553 🔍 Filtered out: getLogger in path_utils.py
call-processor.ts:553 🔍 Filtered out: abspath in path_utils.py
call-processor.ts:553 🔍 Filtered out: dirname in path_utils.py
call-processor.ts:553 🔍 Filtered out: dirname in path_utils.py
call-processor.ts:553 🔍 Filtered out: dirname in path_utils.py
call-processor.ts:553 🔍 Filtered out: abspath in path_utils.py
call-processor.ts:553 🔍 Filtered out: join in path_utils.py
call-processor.ts:553 🔍 Filtered out: append in path_utils.py
call-processor.ts:553 🔍 Filtered out: info in path_utils.py
call-processor.ts:52 ⚠️ CallProcessor: No function calls found in source file: trumio-cortex-core/src/python/pr_quality_service/app/utils/path_utils.py
call-processor.ts:58   📊 Debug: path_utils.py has 9 call nodes, 1 definitions
call-processor.ts:553 🔍 Filtered out: dirname in start-service.py
call-processor.ts:553 🔍 Filtered out: abspath in start-service.py
call-processor.ts:553 🔍 Filtered out: join in start-service.py
call-processor.ts:553 🔍 Filtered out: exists in start-service.py
call-processor.ts:553 🔍 Filtered out: load_dotenv in start-service.py
call-processor.ts:553 🔍 Filtered out: print in start-service.py
call-processor.ts:553 🔍 Filtered out: print in start-service.py
call-processor.ts:553 🔍 Filtered out: upper in start-service.py
call-processor.ts:553 🔍 Filtered out: getenv in start-service.py
call-processor.ts:553 🔍 Filtered out: basicConfig in start-service.py
call-processor.ts:553 🔍 Filtered out: StreamHandler in start-service.py
call-processor.ts:553 🔍 Filtered out: getLogger in start-service.py
call-processor.ts:553 🔍 Filtered out: info in start-service.py
call-processor.ts:553 🔍 Filtered out: info in start-service.py
call-processor.ts:65 CallProcessor: Found 6 function calls in trumio-cortex-core/src/python/pr_quality_service/start-service.py
call-processor.ts:86 ❌ Failed to resolve call: connect_db_client in trumio-cortex-core/src/python/pr_quality_service/start-service.py:45
call-processor.ts:86 ❌ Failed to resolve call: disconnect_db_client in trumio-cortex-core/src/python/pr_quality_service/start-service.py:54
call-processor.ts:86 ❌ Failed to resolve call: is_motor_client_open in trumio-cortex-core/src/python/pr_quality_service/start-service.py:97
call-processor.ts:86 ❌ Failed to resolve call: get_database in trumio-cortex-core/src/python/pr_quality_service/start-service.py:104
call-processor.ts:553 🔍 Filtered out: dirname in prompt_test.py
call-processor.ts:553 🔍 Filtered out: dirname in prompt_test.py
call-processor.ts:553 🔍 Filtered out: abspath in prompt_test.py
call-processor.ts:553 🔍 Filtered out: join in prompt_test.py
call-processor.ts:553 🔍 Filtered out: exists in prompt_test.py
call-processor.ts:553 🔍 Filtered out: load_dotenv in prompt_test.py
call-processor.ts:553 🔍 Filtered out: append in prompt_test.py
6call-processor.ts:553 🔍 Filtered out: print in prompt_test.py
call-processor.ts:553 🔍 Filtered out: print in prompt_test.py
call-processor.ts:553 🔍 Filtered out: run in prompt_test.py
call-processor.ts:65 CallProcessor: Found 3 function calls in trumio-cortex-core/src/python/pr_quality_service/test/prompt_test.py
call-processor.ts:86 ❌ Failed to resolve call: get_weekly_prompts in trumio-cortex-core/src/python/pr_quality_service/test/prompt_test.py:31
call-processor.ts:723 📊 CallProcessor Resolution Statistics:
call-processor.ts:724   Total calls processed: 121
call-processor.ts:725   ✅ Exact matches (Stage 1): 11 (9.1%)
call-processor.ts:726   ✅ Same-file matches (Stage 2): 19 (15.7%)
call-processor.ts:727   🎯 Heuristic matches (Stage 3): 4 (3.3%)
call-processor.ts:728   ❌ Failed resolutions: 87 (71.9%)
call-processor.ts:729   Success rate: 28.1%
pipeline.ts:41 Ingestion complete. Graph contains 417 nodes and 446 relationships.
pipeline.ts:50 📊 Graph Statistics:
pipeline.ts:51 Nodes by type: {Project: 1, Folder: 41, File: 140, Import: 160, Function: 52, …}
pipeline.ts:52 Relationships by type: {CONTAINS: 156, DEFINES: 235, IMPORTS: 23, CALLS: 32}
pipeline.ts:60 ⚠️ Found 3 isolated nodes:
run @ pipeline.ts:60
await in run
processRepository @ :5173/src/workers/ingestion.worker.ts?worker_file&type=module:34
callback @ comlink.js?v=4af0e45c:91Understand this warning
pipeline.ts:65 Isolated nodes by type: {File: 3}
run @ pipeline.ts:65
await in run
processRepository @ :5173/src/workers/ingestion.worker.ts?worker_file&type=module:34
callback @ comlink.js?v=4af0e45c:91Understand this warning
pipeline.ts:66 Sample isolated nodes: (3) [{…}, {…}, {…}]
run @ pipeline.ts:66
await in run
processRepository @ :5173/src/workers/ingestion.worker.ts?worker_file&type=module:34
callback @ comlink.js?v=4af0e45c:91Understand this warning
pipeline.ts:82 ⚠️ Found 140 files without definitions:
run @ pipeline.ts:82
await in run
processRepository @ :5173/src/workers/ingestion.worker.ts?worker_file&type=module:34
callback @ comlink.js?v=4af0e45c:91Understand this warning
pipeline.ts:83 Files without content: (5) ['trumio-cortex-core/', 'trumio-cortex-core/.github/', 'trumio-cortex-core/.github/workflows/', 'trumio-cortex-core/.github/workflows/cortex-ci-cd.yml', 'trumio-cortex-core/.github/workflows/readme.md']
run @ pipeline.ts:83
await in run
processRepository @ :5173/src/workers/ingestion.worker.ts?worker_file&type=module:34
callback @ comlink.js?v=4af0e45c:91Understand this warning
pipeline.ts:94 🔍 Validating graph integrity...
pipeline.ts:130 Source files without definitions: (3) ['trumio-cortex-core/check_prompt.py', 'trumio-cortex-core/debug_channel_messages.py', 'trumio-cortex-core/src/python/common_services/mcp_auth_service.py']
validateGraphIntegrity @ pipeline.ts:130
run @ pipeline.ts:87
await in run
processRepository @ :5173/src/workers/ingestion.worker.ts?worker_file&type=module:34
callback @ comlink.js?v=4af0e45c:91Understand this warning
pipeline.ts:158 ⚠️ Graph integrity issues found:
validateGraphIntegrity @ pipeline.ts:158
run @ pipeline.ts:87
await in run
processRepository @ :5173/src/workers/ingestion.worker.ts?worker_file&type=module:34
callback @ comlink.js?v=4af0e45c:91Understand this warning
pipeline.ts:159   1. 25 files not connected to project structure
(anonymous) @ pipeline.ts:159
validateGraphIntegrity @ pipeline.ts:159
run @ pipeline.ts:87
await in run
processRepository @ :5173/src/workers/ingestion.worker.ts?worker_file&type=module:34
callback @ comlink.js?v=4af0e45c:91Understand this warning
pipeline.ts:159   2. 59 source files contain no parsed definitions
(anonymous) @ pipeline.ts:159
validateGraphIntegrity @ pipeline.ts:159
run @ pipeline.ts:87
await in run
processRepository @ :5173/src/workers/ingestion.worker.ts?worker_file&type=module:34
callback @ comlink.js?v=4af0e45c:91Understand this warning
pipeline.ts:159   3. 66 definitions not connected to files
(anonymous) @ pipeline.ts:159
validateGraphIntegrity @ pipeline.ts:159
run @ pipeline.ts:87
await in run
processRepository @ :5173/src/workers/ingestion.worker.ts?worker_file&type=module:34
callback @ comlink.js?v=4af0e45c:91Understand this warning
:5173/src/workers/ingestion.worker.ts?worker_file&type=module:40 IngestionWorker: Processing completed successfully
:5173/src/workers/ingestion.worker.ts?worker_file&type=module:41 Graph contains 417 nodes and 446 relationships
HomePage.tsx:123 ZIP processing completed: {nodeCount: 417, relationshipCount: 446, fileCount: 109}
:5173/src/workers/ingestion.worker.ts?worker_file&type=module:150 Ingestion worker terminated
workerUtils.ts:127 Ingestion worker terminate

================
File: package.json
================
{
  "name": "gitnexus",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --watchAll=false"
  },
  "dependencies": {
    "@langchain/anthropic": "^0.1.21",
    "@langchain/core": "^0.3.66",
    "@langchain/google-genai": "^0.2.16",
    "@langchain/langgraph": "^0.0.26",
    "@langchain/openai": "^0.0.28",
    "@types/d3": "^7.4.3",
    "axios": "^1.6.0",
    "comlink": "^4.4.1",
    "d3": "^7.9.0",
    "jszip": "^3.10.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-markdown": "^10.1.0",
    "rehype-highlight": "^7.0.2",
    "remark-gfm": "^4.0.1",
    "uuid": "^11.1.0",
    "web-tree-sitter": "^0.20.8",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/js": "^9.11.1",
    "@types/jest": "^29.5.12",
    "@types/node": "^20.12.12",
    "@types/react": "^18.3.10",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.2",
    "eslint": "^9.11.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.12",
    "globals": "^15.9.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.1.2",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.7.0",
    "vite": "^5.4.8"
  }
}

================
File: project_guide.md
================
# GitNexus Project Guide

This document provides a comprehensive technical overview of the GitNexus application, intended to give an LLM full context of the project's purpose, architecture, and implementation details.

## 1. Project Overview

GitNexus is a **client-side source code analysis tool** that runs entirely in the browser. It transforms a given codebase (from a public GitHub repository or an uploaded ZIP file) into an interactive **knowledge graph**.

The primary goal is to allow users to visually explore and understand complex codebases through two main interfaces:
1.  **A Graph Visualizer**: Displays the code structure as a network of nodes (files, classes, functions) and relationships (imports, calls, inheritance).
2.  **An AI Chat Interface**: A Retrieval-Augmented Generation (RAG) system that allows users to ask natural language questions about the code, which are answered by querying the knowledge graph.

Because it's fully client-side, no code is ever sent to a server, ensuring privacy and security.

## 2. Technology Stack

The project is built with a modern web technology stack:

- **Frontend Framework**: **React 18** with **TypeScript**.
- **Build Tool**: **Vite** for fast development and optimized builds.
- **Code Parsing**: **Tree-sitter** compiled to **WebAssembly (WASM)**. This allows for fast and accurate Abstract Syntax Tree (AST) parsing directly in the browser.
- **AI & RAG**: **LangChain.js** is used to orchestrate the AI agent, supporting multiple LLM providers (OpenAI, Anthropic, Google Gemini).
- **Concurrency**: **Web Workers** are used to run the entire code ingestion process in a background thread, preventing the UI from freezing. **Comlink** is used for simplifying communication with the worker.
- **Graph Visualization**: The UI likely uses a library like Cytoscape.js or D3.js to render the interactive graph (inferred from dependencies and functionality).
- **Styling**: A custom CSS-in-JS solution implemented directly within the `HomePage.tsx` component.

## 3. Architecture

The project follows a clean, modular architecture that separates concerns into distinct layers.

### `src/ui` - The Frontend Layer
- **Purpose**: Contains all React components, hooks, and pages.
- **Key Files**:
    - `pages/HomePage.tsx`: The main component that manages the application's state and orchestrates all user interactions. It handles user input, triggers the ingestion process, and displays the results.
    - `components/graph/GraphExplorer.tsx`: The React component responsible for rendering the interactive knowledge graph.
    - `components/chat/ChatInterface.tsx`: The component for the AI-powered chat.
    - `components/ErrorBoundary.tsx`: A crucial component for catching and gracefully handling runtime errors in the UI.

### `src/core` - The Core Logic Layer
- **Purpose**: This is the engine of the application where the knowledge graph is built.
- **Key Files**:
    - `ingestion/pipeline.ts`: Defines the `GraphPipeline`, which executes the multi-pass ingestion process.
    - `ingestion/structure-processor.ts`: **Pass 1**: Analyzes the file and directory structure.
    - `ingestion/parsing-processor.ts`: **Pass 2**: Uses Tree-sitter to parse source files into ASTs and extracts definitions (classes, functions, etc.).
    - `ingestion/import-processor.ts`: **Pass 3**: Resolves import statements between files.
    - `ingestion/call-processor.ts`: **Pass 4**: Resolves function and method calls between definitions.
    - `graph/graph.ts`: Defines the `SimpleKnowledgeGraph` class, the core data structure for the graph.
    - `tree-sitter/parser-loader.ts`: Manages the loading of the various language-specific Tree-sitter WASM parsers.

### `src/workers` - The Concurrency Layer
- **Purpose**: Offloads the intensive ingestion process from the main UI thread.
- **Key Files**:
    - `ingestion.worker.ts`: The entry point for the Web Worker. It receives file data from the UI, runs the `GraphPipeline`, and posts the resulting knowledge graph back to the main thread.

### `src/services` - The External Services Layer
- **Purpose**: Handles communication with external sources.
- **Key Files**:
    - `ingestion.service.ts`: Acts as a bridge between the UI (`HomePage.tsx`) and the `IngestionWorker`.
    - `github.ts`: Contains logic for fetching repository contents from the GitHub API.
    - `zip.ts`: Contains logic for reading and extracting files from an uploaded ZIP archive.

### `src/ai` - The Artificial Intelligence Layer
- **Purpose**: Manages the LLM interactions for the Graph RAG chat.
- **Key Files**:
    - `llm-service.ts`: A client that handles communication with the different supported LLM providers (OpenAI, etc.).
    - `langchain-orchestrator.ts`: Implements the ReAct agent logic using LangChain, defining the tools the agent can use (e.g., querying the graph).
    - `cypher-generator.ts`: Translates natural language questions into Cypher-like queries to be executed against the knowledge graph.

## 4. Core Concepts & Execution Flow

### The Knowledge Graph Data Model
The entire application revolves around the `KnowledgeGraph` object defined in `src/core/graph/graph.ts`. It's a simple structure containing two arrays:
- `nodes`: Represent code entities like `File`, `Folder`, `Class`, `Function`, etc.
- `relationships`: Represent the connections between nodes, such as `CONTAINS`, `IMPORTS`, `CALLS`.

### The Ingestion Pipeline
This is the central process for understanding code. When a user provides a repository, the following happens:
1.  **File Gathering**: The `IngestionService` fetches all file paths and their text content, either from GitHub or a ZIP file.
2.  **Worker Invocation**: The file data is passed to the `IngestionWorker`.
3.  **Pipeline Execution**: The worker runs the `GraphPipeline`, which executes its 4 passes sequentially on the `SimpleKnowledgeGraph` instance:
    - **Pass 1 (Structure)**: Creates `Project`, `Folder`, and `File` nodes, and links them with `CONTAINS` relationships.
    - **Pass 2 (Parsing)**: Parses the AST of each source file, creating `Function`, `Class`, and other code-level nodes. It links these nodes to their parent `File` node with `DEFINES` relationships.
    - **Pass 3 (Imports)**: Analyzes `import` statements and creates `IMPORTS` relationships between code entities.
    - **Pass 4 (Calls)**: Analyzes the code to find function and method calls, creating `CALLS` relationships between them.
4.  **Return to UI**: The completed graph is returned to the `HomePage.tsx` component, which updates its state and renders the visual graph.

This multi-pass approach ensures that the graph is built layer by layer, with each pass adding more detail and context.

## 5. Potential Issues & Areas for Improvement

This section details findings from a deep analysis of the codebase, highlighting areas for refactoring and potential bugs.

### 1. State Management in `HomePage.tsx`
- **Issue**: The component uses a single, large `useState` hook to manage the entire application state (`AppState`). Any small update, such as user input in a text field, triggers a re-render of the entire component and all its children.
- **Impact**: This can lead to a sluggish UI and poor performance, especially as the application grows in complexity.
- **Recommendation**: Refactor the state management. Use more granular `useState` hooks for simple, independent state. For state that needs to be shared across many components, consider using React's Context API or a lightweight state management library to prevent unnecessary re-renders.

### 2. Redundant `generateId` Function
- **Issue**: The file `src/core/ingestion/parsing-processor.ts` contains a local `generateId` function that uses a simple (and potentially collision-prone) hashing algorithm. A more robust, UUID-based `generateId` function already exists in `src/lib/utils.ts`.
- **Impact**: Code duplication and the risk of using an inferior ID generation method, which could lead to node ID collisions in the graph.
- **Recommendation**: Remove the local `generateId` function from `parsing-processor.ts` and update the file to import and use the centralized version from `src/lib/utils.ts`.

### 3. Inefficient Graph Integrity Checks
- **Issue**: The `validateGraphIntegrity` method in `src/core/ingestion/pipeline.ts` performs several distinct traversals (`filter`, `some`, `find`) over the entire graph to find issues like orphaned nodes or files without definitions. 
- **Impact**: On large codebases, this can significantly slow down the final phase of the ingestion process.
- **Recommendation**: Optimize these validation checks. Many of them can be combined into a single pass over the graph's nodes and relationships. Using a `Map` or `Set` for lookups within the pass would be much more performant than repeated array iterations.

### 4. Hardcoded Filtering Logic
- **Issue**: The `CallProcessor` in `src/core/ingestion/call-processor.ts` defines its own large, hardcoded `Set` of Python built-in functions to ignore during call resolution. This logic is disconnected from the centralized language configurations.
- **Impact**: This makes the list difficult to maintain and extend. It also violates the principle of single-source-of-truth, as language-specific knowledge should be centralized.
- **Recommendation**: Refactor the `CallProcessor` to use the `builtinFunctions` set from the `language-config.ts` file. This centralizes language-specific data and makes the processor more modular.

### 5. Mock/Incomplete Query Engine
- **Issue**: The `GraphQueryEngine` in `src/core/graph/query-engine.ts` is a mock implementation that uses regular expressions to parse Cypher-like queries. This approach is not robust and only supports a very limited subset of valid queries.
- **Impact**: This is a critical limitation for the AI chat feature. The `CypherGenerator` can produce complex queries that the engine cannot execute, leading to failed tool calls and inaccurate answers from the AI.
- **Recommendation**: This is a major area for future development. The regex-based parser should be replaced with a more robust solution. Options include:
    - Implementing a proper parser for a small, well-defined subset of Cypher.
    - Integrating a lightweight, in-browser graph database library that supports Cypher queries.

================
File: PRUNING_IMPLEMENTATION.md
================
# 🎯 Two-Stage Filtering Implementation - Complete

## 🚀 **Successfully Implemented!**

We have successfully implemented the sophisticated two-stage filtering architecture that decouples structural discovery from content analysis.

## 🏗️ **Architecture Overview**

### **Stage 1: Complete Structural Discovery**
- **✅ GitHub Service**: Discovers ALL files and directories (including `node_modules`, `.git`, etc.)
- **✅ ZIP Service**: Extracts ALL paths from archives (complete structure)
- **✅ StructureProcessor**: Creates nodes for EVERY path discovered
- **✅ Result**: Knowledge graph contains complete, accurate repository structure

### **Stage 2: Intelligent Pruning Before Parsing**
- **✅ ParsingProcessor**: Applies sophisticated filtering before content analysis
- **✅ Ignore Patterns**: Comprehensive list of directories to skip during parsing
- **✅ User Filters**: Directory and extension filters still work as before
- **✅ Result**: Only relevant files get their content parsed and analyzed

## 🎯 **Implementation Details**

### **Enhanced ParsingProcessor**

#### **Comprehensive Ignore Patterns**
```typescript
private static readonly IGNORE_PATTERNS = new Set([
  // Version Control
  '.git', '.svn', '.hg',
  
  // Package Managers & Dependencies
  'node_modules', 'bower_components', 'vendor', 'deps',
  
  // Python Virtual Environments & Cache
  'venv', 'env', '.venv', 'virtualenv', '__pycache__',
  
  // Build & Distribution
  'build', 'dist', 'out', 'target', 'bin', 'obj',
  
  // IDE & Editor Directories
  '.vs', '.vscode', '.idea', '.eclipse',
  
  // Temporary & Logs
  'tmp', 'temp', 'logs', 'log',
  
  // Coverage & Testing
  'coverage', '.coverage', 'htmlcov',
  
  // Cache Directories
  '.cache', '.next', '.nuxt'
]);
```

#### **Two-Stage Filtering Logic**
```typescript
private applyFiltering(allPaths: string[], fileContents: Map<string, string>, options?: FilterOptions): string[] {
  // STAGE 1: Prune ignored directories
  let filesToProcess = this.pruneIgnoredPaths(allPaths.filter(path => fileContents.has(path)));
  
  // STAGE 2: Apply user filters
  if (options?.directoryFilter) { /* existing user filter logic */ }
  if (options?.fileExtensions) { /* existing user filter logic */ }
  
  return filesToProcess;
}
```

#### **Intelligent Pruning**
```typescript
private pruneIgnoredPaths(filePaths: string[]): string[] {
  return filePaths.filter(path => {
    const pathSegments = path.split('/');
    
    // Check if any segment matches ignore patterns
    const hasIgnoredSegment = pathSegments.some(segment => 
      ParsingProcessor.IGNORE_PATTERNS.has(segment.toLowerCase())
    );
    
    return !hasIgnoredSegment && !this.matchesIgnorePatterns(path);
  });
}
```

### **Complete Structure Discovery**

#### **GitHub Service Enhancement**
- **Removed**: `shouldSkipDirectory()` checks in `collectPathsAndContent()`
- **Result**: Discovers ALL directories, including `node_modules`, `.git`, etc.

#### **ZIP Service Enhancement**
- **Removed**: `shouldSkipDirectory()` checks in `extractCompleteStructure()`
- **Result**: Extracts ALL paths from ZIP archives

## 📊 **Before vs After**

| Aspect | ❌ **Before** | ✅ **After** |
|--------|---------------|--------------|
| **Structure Discovery** | Filtered early, missed directories | Complete discovery of all paths |
| **node_modules Visibility** | Missing from KG | Visible as folder node |
| **Content Parsing** | Parsed everything discovered | Intelligently skips ignored directories |
| **Performance** | Slow (parsed dependencies) | Fast (skips massive directories) |
| **KG Accuracy** | Incomplete structure | Perfect mirror of repository |
| **User Experience** | Cluttered with dependencies | Clean, focused on source code |

## 🎯 **Benefits Achieved**

### **1. Complete Accurate Structure**
```
✅ Repository Structure in KG:
├── src/                    (visible, parsed)
├── tests/                  (visible, parsed)
├── node_modules/          (visible, NOT parsed) 🎯
├── .git/                  (visible, NOT parsed) 🎯
├── dist/                  (visible, NOT parsed) 🎯
└── package.json           (visible, parsed)
```

### **2. Performance Improvements**
- **⚡ Skip Massive Directories**: No parsing of `node_modules` (thousands of files)
- **⚡ Faster Processing**: Focus on actual source code
- **⚡ Smaller Graphs**: Fewer definition nodes to render
- **⚡ Better Memory Usage**: Avoid loading massive dependency files

### **3. Professional User Experience**
- **📊 Accurate Representation**: Users see complete project structure
- **🎯 Clean Analysis**: Focus on relevant code, not dependencies
- **🔍 Better Navigation**: Easy to distinguish project code from dependencies
- **📈 Trust**: KG accurately mirrors their actual repository

## 🔍 **Technical Highlights**

### **Sophisticated Pattern Matching**
- **Directory Segments**: Checks each path segment against ignore patterns
- **Pattern-Based**: Handles `.egg-info`, `site-packages`, etc.
- **Hidden Directories**: Smart handling of `.github` (keep) vs `.vscode` (ignore)

### **Logging & Visibility**
```
ParsingProcessor: Starting with 1,247 files with content
ParsingProcessor: After pruning ignored directories: 1,247 -> 89 files
ParsingProcessor: Directory filter applied: 89 -> 45 files
```

### **Browser Compatibility**
- **✅ No Node.js Dependencies**: Pure browser implementation
- **✅ Memory Efficient**: Batched processing with size limits
- **✅ Performance Optimized**: Skip expensive operations on ignored files

## 🚀 **Deployment Status**

- **✅ Build Success**: All TypeScript compilation passes
- **✅ Architecture Complete**: Two-stage filtering fully implemented
- **✅ Backward Compatible**: Existing functionality preserved
- **✅ Production Ready**: Ready for real-world repository analysis

## 🎉 **Result**

**Perfect Implementation!** We now have:

1. **Complete Structure Discovery**: Every directory appears in the KG
2. **Intelligent Content Filtering**: Skip parsing massive dependency directories
3. **Optimal Performance**: Fast processing focused on relevant code
4. **Professional UX**: Clean, accurate knowledge graphs

The two-stage filtering architecture is **successfully implemented** and ready for production! 🚀

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: quicksort.js
================
/**
 * Quicksort implementation in JavaScript
 * Time Complexity: O(n log n) average, O(n²) worst case
 * Space Complexity: O(log n) average, O(n) worst case
 */

function quicksort(arr) {
  // Base case: arrays with 0 or 1 element are already sorted
  if (arr.length <= 1) {
    return arr;
  }

  // Choose pivot (middle element to avoid worst case on sorted arrays)
  const pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr[pivotIndex];

  // Partition array into elements less than, equal to, and greater than pivot
  const left = [];
  const equal = [];
  const right = [];

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else if (arr[i] === pivot) {
      equal.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  // Recursively sort left and right partitions, then combine
  return [...quicksort(left), ...equal, ...quicksort(right)];
}

// In-place quicksort implementation (more memory efficient)
function quicksortInPlace(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = partition(arr, left, right);
    quicksortInPlace(arr, left, pivotIndex - 1);
    quicksortInPlace(arr, pivotIndex + 1, right);
  }
  return arr;
}

function partition(arr, left, right) {
  const pivot = arr[right];
  let i = left - 1;

  for (let j = left; j < right; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1;
}

// Example usage and testing
const testArray = [64, 34, 25, 12, 22, 11, 90];
console.log('Original array:', testArray);
console.log('Sorted array (functional):', quicksort([...testArray]));
console.log('Sorted array (in-place):', quicksortInPlace([...testArray]));

// Export for use in other modules
module.exports = { quicksort, quicksortInPlace };

================
File: README.md
================
# GitNexus: Edge-Based Code Knowledge Graph Generator for Deno - Step-by-Step Implementation Guide

This guide will walk you through building a fully edge-based code knowledge graph generator from scratch using Deno. I'll explain each concept before showing the implementation, so you understand **why** we're doing something, not just **how** to do it.

## Phase 1: Project Setup & Core Infrastructure

### Step 1: Project Structure and Tooling Setup

**Why this matters:** Before writing any code, we need to set up our development environment properly. A well-structured project makes it easier to add features later and keeps everything organized.

**Key concepts:**

- We're using Vite (a modern build tool) with React and TypeScript
- We need special configuration for WebAssembly (WASM) files
- A clear directory structure helps us scale to multiple languages later

**Implementation Steps:**

1. **Create the base project:**

```bash
# Create project root
mkdir GitNexus
cd GitNexus

# Initialize Vite project with React and TypeScript
npm create vite@latest . -- --template react-ts

# Initialize Deno project
deno init
```

2. **Create the application directory structure:**

```bash
# Create directories for our core components
mkdir -p src/{core,core/tree-sitter,core/graph,core/ingestion,services,ai,ai/agents,ai/prompts,ui,ui/components,ui/components/graph,ui/components/chat,ui/hooks,workers,lib,config,store}
```

**Why this structure?**

- `core/`: Contains the engine that builds the knowledge graph
- `services/`: Handles external interactions (GitHub API, ZIP processing)
- `ai/`: Contains the RAG and chat functionality
- `ui/`: All user interface components
- `workers/`: Web Workers for heavy processing (keeps UI responsive)
- `lib/`: Utility functions used throughout the app

### Step 2: Configure Build Tools for WASM

**Why this matters:** WebAssembly (WASM) is how we'll run the Tree-sitter parsers in the browser. We need special configuration to handle these binary files correctly.

**Key concepts:**

- WASM files are binary files that run at near-native speed in browsers
- Vite needs special configuration to handle them properly
- We want to avoid inlining large WASM files in our JavaScript bundles

**Implementation:**

1. **Update `vite.config.ts`:**

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
export default defineConfig({
  plugins: [react()],
  worker: {
    format: 'es'
  },
  assetsInclude: ['**/*.wasm'],
  build: {
    target: 'esnext',
    assetsInlineLimit: 0 // Don't inline WASM files
  }
})
```

**What this does:**

- `assetsInclude: ['**/*.wasm']` tells Vite to treat WASM files as assets
- `assetsInlineLimit: 0` ensures WASM files aren't inlined into JavaScript (they're too large)
- `worker: { format: 'es' }` configures Web Workers to use ES modules

2. **Configure TypeScript** with a `tsconfig.json` that has strict settings for better code quality.

**Why strict settings?** They help catch errors early and make the code more maintainable as the project grows.

### Step 3: Set Up WASM Parser Infrastructure

**Why this matters:** Tree-sitter is the engine that parses code into ASTs (Abstract Syntax Trees). We need to get these parsers working in the browser via WASM.

**Key concepts:**

- Tree-sitter parsers for different languages are written in C
- We compile them to WASM so they can run in browsers
- We need to load these parsers on demand

**Implementation:**

1. **Create a public directory for WASM files:**

```bash
mkdir -p public/wasm/python
```

2. **Download the Tree-sitter Python parser:**
   - Get `tree-sitter-python.wasm` from [tree-sitter-python releases](https://github.com/tree-sitter/tree-sitter-python/releases)
   - Place it in `public/wasm/python/`

**Why host WASM files separately?** Browsers can't access the user's file system directly for security reasons. We need to serve the WASM files from a URL.

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase 1
- Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase - Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase - Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

I'm building a Deno 2.4.1-based edge code knowledge graph generator called GitNexus. I've completed Phase 1 (project setup and core infrastructure) and now need to implement Phase 2 (Code Acquisition Module) with Deno 2.4.1 compatibility.

Please generate the following two services with these specific requirements:

## 1. GitHub Service (Deno 2.4.1 Implementation)

Create a GitHubService class in `src/services/github.ts` that:

- Uses Deno 2.4.1's native fetch API (no Node.js dependencies)
- Handles GitHub API authentication via personal access tokens
- Implements rate limit handling (GitHub allows 5,000 requests/hour with token)
- Includes methods to:
  * getRepoContents(owner: string, repo: string, path = '') - fetches directory structure
  * getFileContent(owner: string, repo: string, filePath: string) - fetches individual file content
- Properly handles GitHub API rate limits and errors
- Uses Deno 2.4.1-specific error handling patterns
- Includes TypeScript interfaces for return types
- Has comprehensive comments explaining key implementation choices

Important Deno 2.4.1 considerations:

- Use ES modules (no CommonJS)
- No Node.js-specific modules (use Deno's built-in APIs where possible)
- Handle fetch responses with proper Deno error patterns
- Include proper types for all functions
- Follow Deno 2.4.1's security model (permissions)

## 2. ZIP Processing Service (Deno 2.4.1 Implementation)

Create a ZipService class in `src/services/zip.ts` that:

- Uses Deno-compatible ZIP processing (use `https://deno.land/x/zip@v1.2.3/mod.ts` instead of JSZip)
- Processes uploaded ZIP files containing code repositories
- Extracts file paths and contents into a Map<string, string>
- Handles binary data properly in Deno 2.4.1 environment
- Includes error handling for corrupted ZIP files
- Has TypeScript interfaces for all types
- Includes comprehensive comments

Important Deno 2.4.1 considerations:

- Use Deno's file system APIs where appropriate
- Handle file reading with Deno.readFile()
- Process ZIP entries without blocking the event loop
- Use Deno's native text decoding for file contents
- Implement streaming where possible for large ZIP files
- Note that this is for a browser-based application, so the ZIP service should work with File objects from HTML inputs

## Additional Requirements

- All code must be Deno 2.4.1 compatible
- Use strict TypeScript with deno-lint directives where needed
- Include proper error messages that help with debugging
- Add unit test stubs for both services (using Deno's built-in test runner)
- Follow the same directory structure as Phase 1 (services directory already exists)
- Maintain the same coding style and patterns established in Phase - Include necessary imports from Deno's standard library
- Document any Deno-specific permissions required

3. **Create a loader for Tree-sitter parsers:**

```typescript
import WebTreeSitter from 'web-tree-sitter';
let parserInstance: WebTreeSitter | null = null;
const parserCache = new Map<string, WebTreeSitter.Language>();

export async function initTreeSitter() {
  if (parserInstance) return parserInstance;
  parserInstance = await WebTreeSitter.init();
  return parserInstance;
}

export async function loadPythonParser(): Promise<WebTreeSitter.Language> {
  if (parserCache.has('python')) {
    return parserCache.get('python')!;
  }
  const Parser = await initTreeSitter();
  const pythonLang = await Parser.Language.load(
    '/wasm/python/tree-sitter-python.wasm'
  );
  parserCache.set('python', pythonLang);
  return pythonLang;
}
```

**How this works:**

1. `initTreeSitter()` initializes the WebAssembly module once
2. `loadPythonParser()` loads the Python parser from the WASM file
3. We cache parsers to avoid reloading them multiple times

**Why cache parsers?** Loading WASM files is relatively slow, so we want to do it once and reuse the parsers.

## Phase 2: Code Acquisition Module

### Step 4: Implement GitHub API Integration

**Why this matters:** Users will want to analyze public GitHub repositories, so we need a way to fetch code from GitHub.

**Key concepts:**

- GitHub has a REST API for accessing repository contents
- We need to handle rate limits (GitHub limits how many requests you can make)
- We'll let users provide their own API tokens for higher limits

**Implementation:**

```typescript
export class GitHubService {
  private token: string | null = null;
  
  setToken(token: string) {
    this.token = token;
  }
  
  async getRepoContents(owner: string, repo: string, path = '') {
    const headers: HeadersInit = {
      'Accept': 'application/vnd.github.v3+json'
    };
    if (this.token) {
      headers['Authorization'] = `token ${this.token}`;
    }
  
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${path}`,
      { headers }
    );
  
    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status}`);
    }
  
    return response.json();
  }
}
```

**How this works:**

- `getRepoContents()` fetches the directory structure of a repository
- It uses the GitHub API with proper headers
- It handles authentication via a token

**Important note:** GitHub API has rate limits. For unauthenticated requests, it's about 60 requests/hour. With a token, it's 5,000/hour.

### Step 5: Implement ZIP Processing

**Why this matters:** Not all code is on GitHub. Users might want to analyze local code or private repositories by uploading a ZIP file.

**Key concepts:**

- JSZip is a library for handling ZIP files in JavaScript
- We need to extract files and their contents from the ZIP
- We'll use a Map to store file paths and contents

**Implementation:**

```typescript
import JSZip from 'jszip';

export class ZipService {
  async processZip(file: File): Promise<Map<string, string>> {
    const zip = await JSZip.loadAsync(file);
    const files = new Map<string, string>();
  
    for (const [filePath, zipEntry] of Object.entries(zip.files)) {
      if (!zipEntry.dir) {
        const content = await zipEntry.async('text');
        files.set(filePath, content);
      }
    }
  
    return files;
  }
}
```

**How this works:**

1. `JSZip.loadAsync(file)` loads the ZIP file
2. We iterate through all entries in the ZIP
3. For each file (not directory), we extract its content as text
4. We store the file path and content in a Map

**Why use a Map?** It provides O(1) lookups by file path, which is important when we need to find files during graph construction.

## Phase 3: Graph Construction Pipeline

### Step 6: Define Graph Data Structures

**Why this matters:** Before we can build a graph, we need to define what nodes and relationships look like.

**Key concepts:**

- A knowledge graph consists of nodes and relationships
- Nodes represent code elements (functions, classes, etc.)
- Relationships represent connections between elements (calls, contains, etc.)

**Implementation:**

```typescript
export type NodeLabel = 
  | 'Project' 
  | 'Package' 
  | 'Module' 
  | 'Folder' 
  | 'File' 
  | 'Class' 
  | 'Function' 
  | 'Method' 
  | 'Variable';

export interface GraphNode {
  id: string;
  label: NodeLabel;
  properties: Record<string, any>;
}

export type RelationshipType = 
  | 'CONTAINS'
  | 'CALLS'
  | 'INHERITS'
  | 'OVERRIDES'
  | 'IMPORTS';

export interface GraphRelationship {
  id: string;
  type: RelationshipType;
  source: string;
  target: string;
  properties?: Record<string, any>;
}

export interface KnowledgeGraph {
  nodes: GraphNode[];
  relationships: GraphRelationship[];
}
```

**Why these specific types?**

- `NodeLabel` defines all possible types of code elements we'll track
- `RelationshipType` defines how code elements connect to each other
- `KnowledgeGraph` is the complete structure we'll build

**Important relationships:**

- `CONTAINS`: A folder contains files, a file contains functions
- `CALLS`: A function calls another function
- `IMPORTS`: One module imports from another

### Step 7: Implement the 3-Pass Ingestion Pipeline

**Why this matters:** Building a complete knowledge graph requires multiple passes to handle cross-file references properly.

**Key concepts:**

- **Pass 1**: Identify the overall structure (folders, modules)
- **Pass 2**: Parse individual files and cache ASTs
- **Pass 3**: Process function calls across files (the hardest part)

This three-pass approach solves the "island problem" - where functions in different files appear disconnected.

#### Pass 1: Structure Identification

```typescript
export class StructureProcessor {
  private graph: KnowledgeGraph;
  private projectRoot: string;
  private projectName: string;
  
  constructor(graph: KnowledgeGraph, projectRoot: string, projectName: string) {
    this.graph = graph;
    this.projectRoot = projectRoot;
    this.projectName = projectName;
  }
  
  identifyStructure(filePaths: string[]): void {
    // Add Project node
    this.graph.nodes.push({
      id: `project:${this.projectName}`,
      label: 'Project',
      properties: { name: this.projectName }
    });
  
    // Track directory structure
    const directories = new Set<string>();
    for (const filePath of filePaths) {
      const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
      if (dirPath && !directories.has(dirPath)) {
        directories.add(dirPath);
        // Create Folder node
        this.graph.nodes.push({
          id: `folder:${dirPath}`,
          label: 'Folder',
          properties: { path: dirPath }
        });
      
        // Create CONTAINS relationship with parent
        if (dirPath.includes('/')) {
          const parentPath = dirPath.substring(0, dirPath.lastIndexOf('/'));
          this.graph.relationships.push({
            id: `rel:folder:${dirPath}:parent`,
            type: 'CONTAINS',
            source: `folder:${parentPath}`,
            target: `folder:${dirPath}`
          });
        } else {
          // Root folder connects to project
          this.graph.relationships.push({
            id: `rel:folder:${dirPath}:project`,
            type: 'CONTAINS',
            source: `project:${this.projectName}`,
            target: `folder:${dirPath}`
          });
        }
      }
    }
  }
}
```

**How this works:**

1. Creates a root Project node
2. Walks through all file paths to identify directories
3. Creates Folder nodes and CONTAINS relationships

**Why identify structure first?** We need to know the overall organization before parsing individual files.

#### Pass 2: File Parsing

```typescript
export class ParsingProcessor {
  private graph: KnowledgeGraph;
  private astCache = new Map<string, any>();
  
  constructor(graph: KnowledgeGraph) {
    this.graph = graph;
  }
  
  async parseFiles(filePaths: string[], fileContents: Map<string, string>): Promise<Map<string, any>> {
    for (const [filePath, content] of fileContents) {
      if (filePath.endsWith('.py')) {
        await this.parsePythonFile(filePath, content);
      }
    }
    return this.astCache;
  }
  
  private async parsePythonFile(filePath: string, content: string): Promise<void> {
    const parser = await loadPythonParser();
    const tree = parser.parse(content);
    // Cache the AST
    this.astCache.set(filePath, tree);
    // Extract definitions from the AST
    this.extractDefinitions(filePath, tree, content);
  }
  
  private extractDefinitions(filePath: string, tree: any, content: string): void {
    // Extract modules
    this.graph.nodes.push({
      id: `module:${filePath}`,
      label: 'Module',
      properties: { 
        path: filePath,
        name: filePath.split('/').pop()!.replace('.py', ''),
        extension: '.py'
      }
    });
  
    // Extract functions from the AST
    const rootNode = tree.rootNode;
    const functionDefs = rootNode.descendantsOfType('function_definition');
    for (const funcNode of functionDefs) {
      const nameNode = funcNode.childForFieldName('name');
      const name = nameNode ? nameNode.text : 'unknown';
    
      // Calculate position
      const startLine = funcNode.startPosition.row + 1;
    
      // Create function node
      this.graph.nodes.push({
        id: `function:${filePath}:${name}`,
        label: 'Function',
        properties: {
          name,
          qualified_name: `${this.getModuleName(filePath)}.${name}`,
          path: filePath,
          start_line: startLine
        }
      });
    
      // Create CONTAINS relationship with module
      this.graph.relationships.push({
        id: `rel:function:${filePath}:${name}:module`,
        type: 'CONTAINS',
        source: `module:${filePath}`,
        target: `function:${filePath}:${name}`
      });
    }
  }
}
```

**How this works:**

1. Parses each file with the appropriate Tree-sitter parser
2. Caches the AST for later use
3. Extracts definitions (functions, classes) from the AST
4. Creates nodes and relationships in the graph

**Why cache ASTs?** We need them in Pass 3 to resolve cross-file function calls.

#### Pass 3: Call Resolution

```typescript
export class CallProcessor {
  private graph: KnowledgeGraph;
  private astCache: Map<string, any>;
  private projectRoot: string;
  private projectName: string;
  
  constructor(
    graph: KnowledgeGraph,
    astCache: Map<string, any>,
    projectRoot: string,
    projectName: string
  ) {
    this.graph = graph;
    this.astCache = astCache;
    this.projectRoot = projectRoot;
    this.projectName = projectName;
  }
  
  processCalls(): void {
    for (const [filePath, tree] of this.astCache) {
      if (filePath.endsWith('.py')) {
        this.processPythonCalls(filePath, tree);
      }
    }
  }
  
  private processPythonCalls(filePath: string, tree: any): void {
    const rootNode = tree.rootNode;
    // Find all call expressions
    const callExpressions = rootNode.descendantsOfType('call');
    for (const callNode of callExpressions) {
      const functionNameNode = callNode.childForFieldName('function');
      if (!functionNameNode) continue;
    
      // Handle different types of function references
      let targetFunctionName = '';
      if (functionNameNode.type === 'identifier') {
        targetFunctionName = functionNameNode.text;
      } else if (functionNameNode.type === 'attribute') {
        // Handle method calls like obj.method()
        const attrNode = functionNameNode;
        const objectNode = attrNode.childForFieldName('object');
        const attrNameNode = attrNode.childForFieldName('attribute');
        if (objectNode && attrNameNode) {
          const objectName = objectNode.text;
          const methodName = attrNameNode.text;
          targetFunctionName = `${objectName}.${methodName}`;
        }
      }
    
      if (!targetFunctionName) continue;
    
      // Try to resolve the target function
      const targetNode = this.resolveTargetFunction(targetFunctionName, filePath);
      if (targetNode) {
        // Create CALLS relationship
        const callerId = this.getCallerId(callNode, filePath);
        this.graph.relationships.push({
          id: `rel:call:${callerId}:${targetNode.id}`,
          type: 'CALLS',
          source: callerId,
          target: targetNode.id
        });
      }
    }
  }
  
  private resolveTargetFunction(targetName: string, currentFilePath: string): { id: string; type: string } | null {
    // 1. Check if it's a built-in function
    if (this.isBuiltInFunction(targetName)) {
      return {
        id: `builtin:${targetName}`,
        type: 'builtin'
      };
    }
  
    // 2. Check if it's an imported function
    const importInfo = this.findImportForFunction(targetName, currentFilePath);
    if (importInfo) {
      const targetId = `function:${importInfo.sourceFile}:${importInfo.targetName}`;
      return {
        id: targetId,
        type: 'imported'
      };
    }
  
    // 3. Check if it's defined in the current file
    for (const node of this.graph.nodes) {
      if (node.label === 'Function' && 
          node.properties.name === targetName &&
          node.properties.path === currentFilePath) {
        return {
          id: node.id,
          type: 'local'
        };
      }
    }
  
    return null;
  }
}
```

**How this works:**

1. Finds all function calls in the AST
2. Determines what function is being called
3. Resolves the target function across files using imports
4. Creates CALLS relationships in the graph

**Why is this the hardest part?** Resolving cross-file references requires understanding:

- How imports work in the language
- How to map a simple name to a fully qualified name
- Handling edge cases like aliases (`import helper as h`)

### Step 8: Implement Web Workers for Performance

**Why this matters:** Parsing code and building graphs can be CPU-intensive. Web Workers keep the UI responsive.

**Key concepts:**

- Web Workers run JavaScript in background threads
- They can't access the DOM directly
- We use Comlink to simplify communication

**Implementation:**

```typescript
// src/workers/ingestion.worker.ts
import { expose } from 'comlink';
import { GraphPipeline } from '../core/ingestion/pipeline';

class IngestionWorker {
  async processRepository(
    projectRoot: string,
    projectName: string,
    filePaths: string[],
    fileContents: Record<string, string>
  ) {
    const pipeline = new GraphPipeline(projectRoot, projectName);
    return pipeline.run(filePaths, new Map(Object.entries(fileContents)));
  }
}

expose(new IngestionWorker());
```

**How this works:**

1. The worker runs the heavy processing in a background thread
2. We expose methods via Comlink to call them from the main thread
3. The main thread can call these methods without blocking the UI

**Why use Web Workers?** Without them, large repositories would freeze the browser tab while processing.

## Phase 4: Graph Visualization

### Step 9: Implement Graph Visualization Components

**Why this matters:** A knowledge graph is useless if users can't see and interact with it.

**Key concepts:**

- Cytoscape.js is a powerful graph visualization library
- We need to convert our graph data to Cytoscape's format
- Users need controls to filter and navigate the graph

**Implementation:**

```tsx
import React, { useEffect, useRef } from 'react';
import cytoscape from 'cytoscape';
import dagre from 'cytoscape-dagre';
import { KnowledgeGraph } from '@/core/graph/types';

cytoscape.use(dagre);

interface GraphVisualizationProps {
  graph: KnowledgeGraph;
  onNodeClick?: (nodeId: string) => void;
  filter?: (node: any) => boolean;
}

export const GraphVisualization: React.FC<GraphVisualizationProps> = ({ 
  graph, 
  onNodeClick,
  filter 
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const cyRef = useRef<cytoscape.Core | null>(null);
  
  useEffect(() => {
    if (!containerRef.current) return;
  
    // Clean up previous instance
    if (cyRef.current) {
      cyRef.current.destroy();
    }
  
    // Convert our graph to Cytoscape format
    const cyElements = convertToCytoscapeElements(graph, filter);
  
    const cy = cytoscape({
      container: containerRef.current,
      elements: cyElements,
      style: [
        {
          selector: 'node',
          style: {
            'label': 'data(label)',
            'width': 'mapData(size, 0, 100, 20, 80)',
            'height': 'mapData(size, 0, 100, 20, 80)',
            'background-color': 'data(color)',
            'text-valign': 'center',
            'text-halign': 'center',
            'font-size': '8px'
          }
        },
        {
          selector: 'edge',
          style: {
            'width': 2,
            'line-color': '#ccc',
            'target-arrow-color': '#ccc',
            'target-arrow-shape': 'triangle'
          }
        }
      ],
      layout: {
        name: 'dagre',
        rankDir: 'TB',
        padding: 20
      }
    });
  
    // Add interactions
    cy.on('tap', 'node', (event) => {
      const node = event.target;
      const nodeId = node.data('id');
      if (onNodeClick) {
        onNodeClick(nodeId);
      }
    });
  
    cyRef.current = cy;
  
    return () => {
      if (cyRef.current) {
        cyRef.current.destroy();
        cyRef.current = null;
      }
    };
  }, [graph, filter]);
  
  return (
    <div 
      ref={containerRef} 
      className="w-full h-full bg-white rounded-lg border border-gray-200"
    />
  );
};

function convertToCytoscapeElements(
  graph: KnowledgeGraph, 
  filter?: (node: any) => boolean
) {
  const elements: any[] = [];
  
  // Add nodes
  for (const node of graph.nodes) {
    if (filter && !filter(node)) continue;
    elements.push({
      data: {
        id: node.id,
        label: getNodeLabel(node),
        type: node.label,
        color: getNodeColor(node.label),
        size: getNodeSize(node)
      }
    });
  }
  
  // Add edges
  for (const rel of graph.relationships) {
    elements.push({
      data: {
        id: rel.id,
        source: rel.source,
        target: rel.target,
        label: rel.type
      }
    });
  }
  
  return elements;
}
```

**How this works:**

1. Converts our graph data to Cytoscape's format
2. Sets up visual styles based on node type
3. Applies a hierarchical layout (dagre)
4. Adds interaction handlers for node clicks

**Why use Cytoscape.js?** It's specifically designed for graph visualization with:

- Multiple layout algorithms
- Good performance for medium-sized graphs
- Extensive customization options

### Step 10: Create Source Code Viewer

**Why this matters:** Seeing the graph isn't enough - users need to see the actual code behind the nodes.

**Implementation:**

```tsx
import React, { useState, useEffect } from 'react';
import { KnowledgeGraph } from '@/core/graph/types';

interface SourceViewerProps {
  graph: KnowledgeGraph;
  selectedNodeId: string | null;
}

export const SourceViewer: React.FC<SourceViewerProps> = ({ graph, selectedNodeId }) => {
  const [sourceCode, setSourceCode] = useState<string>('');
  const [fileName, setFileName] = useState<string>('');
  const [lineNumber, setLineNumber] = useState<number | null>(null);
  
  useEffect(() => {
    if (!selectedNodeId) {
      setSourceCode('');
      setFileName('');
      setLineNumber(null);
      return;
    }
  
    // Find the node in the graph
    const node = graph.nodes.find(n => n.id === selectedNodeId);
    if (!node) return;
  
    // For functions, get the source code
    if (node.label === 'Function' || node.label === 'Method') {
      const filePath = node.properties.path;
      const startLine = node.properties.start_line;
    
      // In a real implementation, you'd have the source code available
      setFileName(filePath);
      setLineNumber(startLine);
      setSourceCode(`# Source code for ${node.properties.qualified_name}
# Line ${startLine} and following...`);
    }
  }, [graph, selectedNodeId]);
  
  if (!selectedNodeId || !sourceCode) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50">
        <p className="text-gray-500">Select a node to view source code</p>
      </div>
    );
  }
  
  return (
    <div className="flex flex-col h-full">
      <div className="p-2 bg-gray-100 border-b border-gray-200 flex justify-between items-center">
        <span className="text-sm font-medium text-gray-700 truncate">{fileName}</span>
        {lineNumber && (
          <span className="text-xs text-gray-500">Line {lineNumber}</span>
        )}
      </div>
      <div className="flex-1 overflow-auto p-2 font-mono text-sm bg-black text-white">
        <pre>{sourceCode}</pre>
      </div>
    </div>
  );
};
```

**How this works:**

1. When a node is selected, it finds the corresponding code element
2. It displays the source code with line numbers
3. It highlights the relevant part of the code

**Why is this important?** It bridges the gap between the abstract graph and the concrete code, helping users understand what they're seeing.

## Phase 5: RAG Chat Interface

### Step 11: Implement LLM Service

**Why this matters:** The chat interface needs to connect to LLMs (Large Language Models) to translate natural language to graph queries.

**Key concepts:**

- We'll support multiple LLM providers (OpenAI, Anthropic, Gemini)
- Users provide their own API keys (privacy-focused)
- We need a consistent interface for different providers

**Implementation:**

```typescript
import { ChatOpenAI } from 'langchain/chat_models/openai';
import { ChatAnthropic } from 'langchain/chat_models/anthropic';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';

export type LLMProvider = 'openai' | 'anthropic' | 'gemini';

export interface LLMConfig {
  provider: LLMProvider;
  apiKey: string;
  model?: string;
}

export class LLMService {
  private config: LLMConfig;
  
  constructor(config: LLMConfig) {
    this.config = config;
  }
  
  getChatModel() {
    switch (this.config.provider) {
      case 'openai':
        return new ChatOpenAI({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'gpt-4-turbo',
          temperature: 0
        });
      case 'anthropic':
        return new ChatAnthropic({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'claude-3-sonnet-20240229',
          temperature: 0
        });
      case 'gemini':
        return new ChatGoogleGenerativeAI({
          apiKey: this.config.apiKey,
          modelName: this.config.model || 'gemini-1.5-pro-latest',
          temperature: 0
        });
      default:
        throw new Error(`Unsupported LLM provider: ${this.config.provider}`);
    }
  }
}
```

**How this works:**

1. The service takes an LLM configuration (provider, API key, model)
2. It returns a consistent chat model interface regardless of provider
3. It handles provider-specific initialization

**Why support multiple providers?** Different users have different preferences and API key availability.

### Step 12: Implement Cypher Generator

**Why this matters:** The core of the RAG system - translating natural language questions to graph queries.

**Key concepts:**

- We use a system prompt to instruct the LLM
- The prompt includes our graph schema
- We clean the response to get a valid Cypher query

**Implementation:**

```typescript
import { BaseChatModel } from 'langchain/chat_models/base';
import { CYPHER_SYSTEM_PROMPT } from '../prompts/cypher';

export class CypherGenerator {
  private llm: BaseChatModel;
  
  constructor(llm: BaseChatModel) {
    this.llm = llm;
  }
  
  async generate(naturalLanguageQuery: string): Promise<string> {
    const response = await this.llm.call([
      { role: 'system', content: CYPHER_SYSTEM_PROMPT },
      { role: 'user', content: naturalLanguageQuery }
    ]);
  
    return this.cleanResponse(response.content);
  }
  
  private cleanResponse(response: string): string {
    // Remove markdown code blocks
    let cleaned = response.replace(/```cypher/g, '').replace(/```/g, '');
    // Ensure it ends with a semicolon
    if (!cleaned.trim().endsWith(';')) {
      cleaned = cleaned.trim() + ';';
    }
    return cleaned;
  }
}
```

**How this works:**

1. It sends the natural language query with a system prompt to the LLM
2. The system prompt teaches the LLM about our graph structure
3. It cleans the response to extract a valid Cypher query

**Why is the system prompt important?** It provides the LLM with the context it needs to generate correct queries. Without it, the LLM wouldn't know about our graph schema.

### Step 13: Implement RAG Orchestrator

**Why this matters:** This is the "brain" of the system that coordinates the query process.

**Key concepts:**

- It follows a ReAct (Reason + Act) pattern
- It plans steps, uses tools, observes results, and responds
- It prevents hallucination by sticking to tool results

**Implementation:**

```typescript
import { BaseChatModel } from 'langchain/chat_models/base';
import { RAG_ORCHESTRATOR_SYSTEM_PROMPT } from '../prompts/rag-orchestrator';

export class RAGOrchestrator {
  private llm: BaseChatModel;
  
  constructor(llm: BaseChatModel) {
    this.llm = llm;
  }
  
  async query(
    userQuery: string,
    queryGraph: (cypher: string) => Promise<any>,
    retrieveCode: (nodeId: string) => Promise<string>
  ) {
    // Start with the system prompt
    let conversation = [
      { role: 'system', content: RAG_ORCHESTRATOR_SYSTEM_PROMPT }
    ];
  
    // Add the user's question
    conversation.push({ role: 'user', content: userQuery });
  
    // Simple ReAct loop
    for (let i = 0; i < 5; i++) { // Max 5 steps
      const response = await this.llm.call(conversation);
      const responseContent = response.content;
    
      // Check if the response contains a tool call
      if (responseContent.includes('Action: query_graph')) {
        const match = responseContent.match(/Action Input: (.*)/);
        if (match) {
          const cypherQuery = match[1].trim();
        
          // Execute the query
          const queryResults = await queryGraph(cypherQuery);
        
          // Add the observation to the conversation
          conversation.push({
            role: 'assistant',
            content: responseContent
          });
        
          conversation.push({
            role: 'system',
            content: `Observation: ${JSON.stringify(queryResults)}`
          });
        
          // If we have results, we might be done
          if (queryResults.length > 0) {
            break;
          }
        }
      } 
      else if (responseContent.includes('Action: retrieve_code')) {
        // Similar handling for code retrieval
      }
      else {
        // This appears to be the final answer
        return responseContent;
      }
    }
  
    // If we got here without a final answer, generate one
    conversation.push({
      role: 'user',
      content: 'Please provide your final answer based on the information gathered.'
    });
  
    const finalResponse = await this.llm.call(conversation);
    return finalResponse.content;
  }
}
```

**How this works:**

1. It starts with a system prompt that defines the rules
2. It sends the user's query to the LLM
3. The LLM responds with either:
   - A tool call (query_graph or retrieve_code)
   - A final answer
4. If it's a tool call, it executes the tool and adds the result to the conversation
5. It repeats until it gets a final answer or hits the step limit

**Why the step limit?** To prevent infinite loops if the LLM gets stuck.

## Phase 6: Main Application Integration

### Step 14: Create Main Application Component

**Why this matters:** This brings all the pieces together into a cohesive UI.

**Implementation:**

```tsx
import React, { useState, useRef } from 'react';
import { GraphVisualization } from '@/ui/components/graph/Visualization';
import { GraphControls } from '@/ui/components/graph/Controls';
import { SourceViewer } from '@/ui/components/graph/SourceViewer';
import { ChatInterface } from '@/ui/components/chat/ChatInterface';
import { KnowledgeGraph } from '@/core/graph/types';
import { GitHubService } from '@/services/github';
import { ZipService } from '@/services/zip';
import { ingestionWorkerApi } from '@/lib/workerUtils';

export const HomePage = () => {
  const [graph, setGraph] = useState<KnowledgeGraph | null>(null);
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [repoUrl, setRepoUrl] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  const handleRepoSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!repoUrl.trim() || isLoading) return;
  
    setIsLoading(true);
    setError(null);
  
    try {
      // Parse the GitHub URL
      const urlMatch = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
      if (!urlMatch) {
        throw new Error('Invalid GitHub repository URL');
      }
    
      const owner = urlMatch[1];
      const repo = urlMatch[2].replace(/\.git$/, '');
    
      // Fetch repository contents
      const githubService = new GitHubService();
      const contents = await githubService.getRepoContents(owner, repo);
    
      // Filter for Python files
      const pythonFiles = contents
        .filter((item: any) => item.type === 'file' && item.name.endsWith('.py'))
        .map((item: any) => item.path);
    
      // Fetch file contents
      const fileContents: Record<string, string> = {};
      for (const filePath of pythonFiles) {
        fileContents[filePath] = await githubService.getFileContent(owner, repo, filePath);
      }
    
      // Process the repository
      const projectName = `${owner}/${repo}`;
      const processedGraph = await ingestionWorkerApi.processRepository(
        repoUrl,
        projectName,
        pythonFiles,
        fileContents
      );
    
      setGraph(processedGraph);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to process repository');
      console.error('Processing error:', err);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleQuery = async (query: string): Promise<string> => {
    if (!graph) {
      throw new Error('No graph available');
    }
  
    // In a real implementation, this would use the RAG orchestrator
    return `I found information related to "${query}" in the codebase.`;
  };
  
  return (
    <div className="h-screen flex flex-col">
      {/* Header with repository input */}
      <header className="p-4 bg-white border-b border-gray-200">
        <div className="max-w-7xl mx-auto flex flex-col sm:flex-row sm:items-center gap-4">
          <h1 className="text-2xl font-bold text-gray-900">GitNexus</h1>
        
          <div className="flex-1 flex gap-2">
            <form onSubmit={handleRepoSubmit} className="flex-1">
              <div className="flex gap-2">
                <input
                  type="text"
                  value={repoUrl}
                  onChange={(e) => setRepoUrl(e.target.value)}
                  placeholder="https://github.com/owner/repo.git"
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                />
                <button
                  type="submit"
                  disabled={isLoading}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
                >
                  {isLoading ? 'Processing...' : 'Analyze'}
                </button>
              </div>
            </form>
          
            <div className="flex items-center">
              <span className="text-gray-500 mx-2">or</span>
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleZipUpload}
                accept=".zip"
                className="hidden"
                id="zip-upload"
              />
              <label
                htmlFor="zip-upload"
                className="px-3 py-2 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 cursor-pointer"
              >
                Upload ZIP
              </label>
            </div>
          </div>
        </div>
      </header>
    
      <main className="flex-1 max-w-7xl mx-auto w-full flex gap-4 p-4">
        {/* Graph Visualization Pane */}
        <div className="flex-1 flex flex-col min-w-0">
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col">
            {graph ? (
              <>
                <GraphControls 
                  onFilterChange={() => {}} 
                  onLayoutChange={() => {}} 
                />
                <div className="flex-1 min-h-0">
                  <GraphVisualization 
                    graph={graph} 
                    onNodeClick={setSelectedNodeId}
                  />
                </div>
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                {isLoading ? (
                  <div className="text-center">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"></div>
                    <p>Processing repository...</p>
                  </div>
                ) : (
                  <p>Enter a repository URL or upload a ZIP to get started</p>
                )}
              </div>
            )}
          </div>
        </div>
      
        {/* Right Panel */}
        <div className="w-80 flex flex-col gap-4">
          {/* Source Viewer */}
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col h-[40%]">
            <div className="p-3 border-b border-gray-200 bg-gray-50">
              <h2 className="text-sm font-medium text-gray-700">Source Code</h2>
            </div>
            {graph ? (
              <SourceViewer graph={graph} selectedNodeId={selectedNodeId} />
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                <p>Select a node to view source</p>
              </div>
            )}
          </div>
        
          {/* Chat Interface */}
          <div className="bg-white rounded-lg border border-gray-200 overflow-hidden flex-1 flex flex-col h-[60%]">
            <div className="p-3 border-b border-gray-200 bg-gray-50">
              <h2 className="text-sm font-medium text-gray-700">Ask About Code</h2>
            </div>
            {graph ? (
              <ChatInterface graph={graph} onQuery={handleQuery} />
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500 p-4">
                <p>Process a repository to ask questions about the code</p>
              </div>
            )}
          </div>
        </div>
      </main>
    </div>
  );
};
```

**How this works:**

1. The header has inputs for GitHub URLs and ZIP uploads
2. The main area has two panes:
   - Left: Graph visualization
   - Right: Source viewer and chat interface
3. When a repository is processed, the graph is displayed
4. Users can click nodes to see source code and ask questions

**Why this layout?** It provides a cohesive experience where users can:

- See the big picture (graph)
- Drill down to specific code (source viewer)
- Ask questions about what they're seeing (chat)

## Final Steps: Testing and Optimization

### Step 15: Add Error Boundaries

**Why this matters:** Inevitably, something will go wrong. We want to handle errors gracefully.

**Implementation:**

```tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="p-4 bg-red-50 border border-red-200 rounded-md">
          <h2 className="text-lg font-medium text-red-800 mb-2">Something went wrong</h2>
          <p className="text-red-700 mb-2">{this.state.error?.message}</p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            className="px-3 py-1 bg-red-100 text-red-700 rounded-md hover:bg-red-200"
          >
            Try again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**How this works:**

- It catches JavaScript errors in child components
- It displays a friendly error message instead of a blank screen
- It allows users to try again without losing their work

**Why use error boundaries?** They prevent a single error from breaking the entire application.

### Step 16: Implement Performance Optimizations

**Why this matters:** Large repositories can be slow to process. We need to keep the UI responsive.

**Key optimizations:**

1. **Web Workers**: Already implemented for graph processing
2. **Progress Indicators**: Show users what's happening
3. **File Filtering**: Only process relevant files
4. **Lazy Loading**: Load components as needed

**Implementation:**

```tsx
// Add to your GitHub processing function
const MAX_FILES = 500; // Limit for free tier
if (pythonFiles.length > MAX_FILES) {
  // Offer to filter by directory or file pattern
  const shouldFilter = window.confirm(
    `Repository has ${pythonFiles.length} Python files (max ${MAX_FILES}). ` +
    `Would you like to filter by directory or file pattern?`
  );
  if (shouldFilter) {
    const filterPattern = prompt(
      "Enter a directory path or file pattern to filter (e.g., 'src/', '*.py')",
      "src/"
    );
    if (filterPattern) {
      const filteredFiles = pythonFiles.filter(file => 
        file.includes(filterPattern) || file.endsWith(filterPattern)
      );
      pythonFiles = filteredFiles;
    }
  }
}
```

**Why limit file processing?** Processing too many files can:

- Freeze the browser tab
- Exceed GitHub API rate limits
- Use excessive memory

### Step 17: Add Export Functionality

**Why this matters:** Users might want to save or share their generated graphs.

**Implementation:**

```tsx
export function exportGraphToJson(graph: KnowledgeGraph): string {
  return JSON.stringify(graph, null, 2);
}

export function downloadGraph(graph: KnowledgeGraph, filename: string = 'gitnexus-graph.json') {
  const json = exportGraphToJson(graph);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
```

**How this works:**

1. Converts the graph to JSON
2. Creates a downloadable file
3. Triggers a download

**Why include export?** It allows users to:

- Save their work for later
- Share graphs with teammates
- Use the data in other tools

## Conclusion

This implementation guide has walked you through building a complete edge-based code knowledge graph generator using Deno. By following these steps, you'll create a privacy-focused tool that runs entirely in the user's browser.

**Key advantages of this approach:**

- **Zero server costs**: All processing happens in the user's browser
- **Strong privacy**: Code never leaves the user's machine
- **Modular architecture**: Easy to add more languages later
- **Clear separation of concerns**: Makes the codebase maintainable
- **Deno compatibility**: Modern runtime with built-in TypeScript support

Remember to start small (Python support only) and iterate, adding more features and language support as you validate the core functionality. The most important part is getting the graph construction pipeline working correctly - everything else builds on that foundation.

================
File: src/__tests__/error-handler.test.ts
================
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { 
  GitNexusError, 
  ValidationError, 
  NetworkError, 
  MemoryError, 
  ErrorRecoveryService,
  createSafeAsync,
  createSafe
} from '../lib/error-handler';

describe('Error Classes', () => {
  it('should create a GitNexusError with correct properties', () => {
    const error = new GitNexusError('Test', 'TEST_CODE', false, { a: 1 });
    expect(error).toBeInstanceOf(Error);
    expect(error.message).toBe('Test');
    expect(error.code).toBe('TEST_CODE');
    expect(error.isRecoverable).toBe(false);
    expect(error.context).toEqual({ a: 1 });
  });
});

describe('ErrorRecoveryService', () => {
  let service: ErrorRecoveryService;

  beforeEach(() => {
    (ErrorRecoveryService as any).instance = undefined;
    service = ErrorRecoveryService.getInstance();
  });

  it('should get a singleton instance', () => {
    const instance2 = ErrorRecoveryService.getInstance();
    expect(service).toBe(instance2);
  });

  describe('executeWithRetry', () => {
    it('should return value on success', async () => {
      const op = jest.fn<() => Promise<string>>().mockResolvedValue('ok');
      const result = await service.executeWithRetry(op, 'test');
      expect(result).toBe('ok');
    });

    it('should retry on failure', async () => {
      const op = jest.fn<() => Promise<string>>()
        .mockRejectedValueOnce(new NetworkError('failed'))
        .mockResolvedValue('ok');
      await service.executeWithRetry(op, 'test', { initialDelay: 1 });
      expect(op).toHaveBeenCalledTimes(2);
    });
  });

  describe('executeWithFallback', () => {
    it('should return primary result', async () => {
      const primary = jest.fn<() => Promise<string>>().mockResolvedValue('primary');
      const fallback = jest.fn<() => Promise<string>>().mockResolvedValue('fallback');
      const result = await service.executeWithFallback(primary, fallback, 'test');
      expect(result).toBe('primary');
    });

    it('should use fallback on failure', async () => {
      const primary = jest.fn<() => Promise<string>>().mockRejectedValue(new Error('failed'));
      const fallback = jest.fn<() => Promise<string>>().mockResolvedValue('fallback');
      const result = await service.executeWithFallback(primary, fallback, 'test');
      expect(result).toBe('fallback');
    });
  });
});

describe('createSafeAsync', () => {
  it('should wrap an async function', async () => {
    const fn = createSafeAsync(async (a: number) => a * 2);
    const result = await fn(2);
    expect(result).toBe(4);
  });
});

describe('createSafe', () => {
  it('should wrap a sync function', () => {
    const fn = createSafe((a: number) => a * 2);
    const result = fn(2);
    expect(result).toBe(4);
  });
});

================
File: src/__tests__/health-monitor.test.ts
================
import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { HealthMonitor } from '../services/health-monitor';

describe('HealthMonitor', () => {
  let monitor: HealthMonitor;

  beforeEach(() => {
    (HealthMonitor as any).instance = undefined;
    monitor = HealthMonitor.getInstance();
  });

  afterEach(() => {
    monitor.stop();
  });

  it('should return a singleton instance', () => {
    const instance1 = HealthMonitor.getInstance();
    const instance2 = HealthMonitor.getInstance();
    expect(instance1).toBe(instance2);
  });

  it('should record a metric', () => {
    monitor.recordMetric('test_metric', 10);
    const metrics = monitor.getMetrics('test_metric');
    expect(metrics).toHaveLength(1);
    expect(metrics[0].value).toBe(10);
  });

  it('should record file processing', () => {
    monitor.recordFileProcessing('test.js', true, 100);
    const status = monitor.getHealthStatus();
    expect(status.processing.totalFiles).toBe(1);
    expect(status.processing.successfulFiles).toBe(1);
  });

  it('should increment and decrement connections', () => {
    monitor.incrementConnections();
    let status = monitor.getHealthStatus();
    expect(status.system.activeConnections).toBe(1);

    monitor.decrementConnections();
    status = monitor.getHealthStatus();
    expect(status.system.activeConnections).toBe(0);
  });

  it('should get health status', () => {
    const status = monitor.getHealthStatus();
    expect(status).toBeDefined();
    expect(status.uptime).toBeGreaterThanOrEqual(0);
  });
});

================
File: src/__tests__/memory-manager.test.ts
================
import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { MemoryManager } from '../services/memory-manager';

describe('MemoryManager', () => {
  let memoryManager: MemoryManager;

  beforeEach(() => {
    (MemoryManager as any).instance = undefined;
    memoryManager = MemoryManager.getInstance();
  });

  afterEach(() => {
    memoryManager.destroy();
  });

  it('should return a singleton instance', () => {
    const instance1 = MemoryManager.getInstance();
    const instance2 = MemoryManager.getInstance();
    expect(instance1).toBe(instance2);
  });

  it('should cache a file', () => {
    const result = memoryManager.cacheFile('test.js', 'console.log("hello")');
    expect(result).toBe(true);
    expect(memoryManager.getStats().fileCount).toBe(1);
  });

  it('should not cache a file that is too large', () => {
    memoryManager.configure({ maxFileSizeMB: 1 });
    const largeContent = 'a'.repeat(2 * 1024 * 1024);
    const result = memoryManager.cacheFile('large.js', largeContent);
    expect(result).toBe(false);
    expect(memoryManager.getStats().fileCount).toBe(0);
  });

  it('should retrieve a cached file', () => {
    memoryManager.cacheFile('test.js', 'console.log("hello")');
    const content = memoryManager.getFile('test.js');
    expect(content).toBe('console.log("hello")');
  });

  it('should return null for a non-cached file', () => {
    const content = memoryManager.getFile('non-existent.js');
    expect(content).toBeNull();
  });

  it('should remove a file from the cache', () => {
    memoryManager.cacheFile('test.js', 'console.log("hello")');
    memoryManager.removeFile('test.js');
    const content = memoryManager.getFile('test.js');
    expect(content).toBeNull();
  });

  it('should clear the cache', () => {
    memoryManager.cacheFile('test1.js', 'content1');
    memoryManager.cacheFile('test2.js', 'content2');
    memoryManager.clearCache();
    expect(memoryManager.getStats().fileCount).toBe(0);
  });

  it('should perform cleanup when memory is high', () => {
    memoryManager.configure({ cleanupThresholdMB: 1, maxMemoryMB: 2 });
    memoryManager.cacheFile('test1.js', 'a'.repeat(1.5 * 1024 * 1024));
    memoryManager.forceCleanup();
    expect(memoryManager.getStats().fileCount).toBe(0);
  });
});

================
File: src/__tests__/setup.ts
================
/**
 * Test setup file for Jest
 */

import { jest } from '@jest/globals';

// Global test setup
beforeAll(() => {
  // Suppress console output during tests
  jest.spyOn(console, 'log').mockImplementation(() => {});
  jest.spyOn(console, 'warn').mockImplementation(() => {});
  jest.spyOn(console, 'error').mockImplementation(() => {});
  jest.spyOn(console, 'info').mockImplementation(() => {});
});

afterAll(() => {
  // Restore console methods
  jest.restoreAllMocks();
});

// Reset singletons between tests
beforeEach(() => {
  // Reset singleton instances
  const singletons = [
    'ConfigService',
    'MemoryManager',
    'ErrorRecoveryService',
    'HealthMonitor',
    'StreamingProcessor'
  ];

  singletons.forEach(singleton => {
    const modulePath = `../${singleton.toLowerCase().replace(/([A-Z])/g, '-$1').substring(1)}`;
    try {
      const module = require(modulePath);
      if (module[singleton]) {
        module[singleton].instance = undefined;
      }
    } catch (e) {
      // Module might not exist, skip
    }
  });
});

// Mock window for Node.js environment
if (typeof window === 'undefined') {
  (global as any).window = {
    setInterval: setInterval,
    clearInterval: clearInterval
  };
}

// Mock Node.js built-ins
import { TextEncoder, TextDecoder } from 'util';

global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder as any;

// Mock crypto for Node.js environment
if (!global.crypto) {
  (global as any).crypto = {
    randomUUID: () => 'test-uuid-' + Math.random().toString(36).substring(2, 15)
  };
}

// Mock performance for Node.js environment
if (!global.performance) {
  (global as any).performance = {
    now: () => Date.now(),
    timeOrigin: Date.now()
  };
}

// Environment variable setup
process.env.NODE_ENV = 'test';
process.env.MEMORY_MAX_MB = '512';
process.env.PROCESSING_MAX_RETRIES = '3';
process.env.MONITORING_INTERVAL = '1000';

// Cleanup function
export const cleanup = () => {
  // Clean up any test artifacts
  jest.clearAllTimers();
  jest.clearAllMocks();
};

================
File: src/__tests__/streaming-processor.test.ts
================
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { StreamingProcessor } from '../lib/streaming-processor';
import { Readable } from 'stream';

describe('StreamingProcessor', () => {
  let processor: StreamingProcessor;

  beforeEach(() => {
    (StreamingProcessor as any).instance = undefined;
    processor = StreamingProcessor.getInstance();
  });

  it('should get a singleton instance', () => {
    const instance2 = StreamingProcessor.getInstance();
    expect(processor).toBe(instance2);
  });

  describe('processFile', () => {
    it('should process a file and return data', async () => {
      const mockReadStream = new Readable();
      mockReadStream.push('line 1\n');
      mockReadStream.push('line 2\n');
      mockReadStream.push(null);

      jest.spyOn(require('fs'), 'createReadStream').mockReturnValue(mockReadStream);
      jest.spyOn(require('fs/promises'), 'stat').mockResolvedValue({ size: 100 });

      const result = await processor.processFile('test.txt', async (line) => line);
      expect(result.data).toEqual(['line 1', 'line 2']);
    });
  });

  describe('processFilesParallel', () => {
    it('should process files in parallel', async () => {
      const fileProcessor = jest.fn<() => Promise<string>>().mockResolvedValue('processed');
      const results = await processor.processFilesParallel(['a.txt', 'b.txt'], fileProcessor);
      expect(results.length).toBe(2);
      expect(fileProcessor).toHaveBeenCalledTimes(2);
    });
  });

  describe('processInBatches', () => {
    it('should process data in batches', async () => {
      const batchProcessor = jest.fn<() => Promise<string[]>>().mockResolvedValue(['processed']);
      const results = await processor.processInBatches([1, 2, 3, 4, 5], batchProcessor, 2);
      expect(results.length).toBe(3);
      expect(batchProcessor).toHaveBeenCalledTimes(3);
    });
  });
});

================
File: src/__tests__/utils.test.ts
================
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { ValidationService } from '../lib/validation';
import { ConfigService } from '../config/config';

describe('ValidationService', () => {
  it('should validate a valid node', () => {
    const validNode = {
      id: 'test-id',
      label: 'Function',
      properties: {
        name: 'testFunction',
        path: '/test/path.js',
        type: 'function',
        startLine: 10,
        endLine: 20
      }
    };
    const result = ValidationService.validateNode(validNode);
    expect(result.id).toBe('test-id');
  });

  it('should throw for an invalid node', () => {
    const invalidNode = { id: '', label: 'Invalid', properties: {} };
    expect(() => ValidationService.validateNode(invalidNode)).toThrow();
  });
});

describe('ConfigService', () => {
  let configService: ConfigService;

  beforeEach(() => {
    (ConfigService as any).instance = undefined;
    configService = ConfigService.getInstance();
  });

  it('should load default config', () => {
    const config = configService.getConfiguration();
    expect(config.memory.maxMemoryMB).toBe(512);
  });

  it('should update config', () => {
    configService.updateConfig({ memory: { maxMemoryMB: 1024 } } as any);
    const config = configService.getConfiguration();
    expect(config.memory.maxMemoryMB).toBe(1024);
  });
});

================
File: src/ai/cypher-generator.ts
================
import { HumanMessage, SystemMessage } from '@langchain/core/messages';
import type { LLMService, LLMConfig } from './llm-service.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface CypherQuery {
  cypher: string;
  explanation: string;
  confidence: number;
  warnings?: string[];
}

export interface CypherGenerationOptions {
  maxRetries?: number;
  includeExamples?: boolean;
  strictMode?: boolean;
}

export class CypherGenerator {
  private llmService: LLMService;
  private graphSchema: string = '';
  
  // Common Cypher patterns and examples
  private static readonly CYPHER_EXAMPLES = [
    {
      question: "What functions are in the main.py file?",
      cypher: "MATCH (f:File {name: 'main.py'})-[:CONTAINS]->(func:Function) RETURN func.name, func.startLine"
    },
    {
      question: "Which functions call the authenticate function?",
      cypher: "MATCH (caller)-[:CALLS]->(target:Function {name: 'authenticate'}) RETURN caller.name, caller.filePath"
    },
    {
      question: "Show me all classes in the project",
      cypher: "MATCH (c:Class) RETURN c.name, c.filePath"
    },
    {
      question: "What classes inherit from BaseService?",
      cypher: "MATCH (child:Class)-[:INHERITS]->(parent:Class {name: 'BaseService'}) RETURN child.name, child.filePath"
    },
    {
      question: "Find all methods in the UserService class",
      cypher: "MATCH (c:Class {name: 'UserService'})-[:CONTAINS]->(m:Method) RETURN m.name, m.startLine"
    },
    {
      question: "Which methods override the save method?",
      cypher: "MATCH (child:Method)-[:OVERRIDES]->(parent:Method {name: 'save'}) RETURN child.name, child.parentClass"
    },
    {
      question: "Show all interfaces and the classes that implement them",
      cypher: "MATCH (c:Class)-[:IMPLEMENTS]->(i:Interface) RETURN i.name, c.name"
    },
    {
      question: "Find functions decorated with @app.route",
      cypher: "MATCH (d:Decorator {name: 'app.route'})-[:DECORATES]->(f:Function) RETURN f.name, f.filePath"
    },
    {
      question: "What files import the requests module?",
      cypher: "MATCH (f:File)-[:IMPORTS]->(target) WHERE target.name CONTAINS 'requests' RETURN f.name"
    },
    {
      question: "Show the call chain from main to database functions",
      cypher: "MATCH (main:Function {name: 'main'})-[:CALLS*1..3]->(db:Function) WHERE db.name CONTAINS 'db' OR db.name CONTAINS 'database' RETURN main.name, db.name"
    },
    {
      question: "Find all functions containing 'user' in their name",
      cypher: "MATCH (f:Function) WHERE f.name CONTAINS 'user' RETURN f.name, f.filePath"
    },
    {
      question: "What functions are called through a chain of 2-4 calls from the main function?",
      cypher: "MATCH (main:Function {name: 'main'})-[:CALLS*2..4]->(target:Function) RETURN main.name, target.name"
    },
    {
      question: "How many classes are in each file?",
      cypher: "MATCH (f:File)-[:CONTAINS]->(c:Class) RETURN f.name, COUNT(c)"
    },
    {
      question: "Count all functions in the project",
      cypher: "MATCH (f:Function) RETURN COUNT(f)"
    },
    {
      question: "List all function names in alphabetical order",
      cypher: "MATCH (f:Function) RETURN COLLECT(f.name)"
    },
    {
      question: "Find files that contain both classes and functions",
      cypher: "MATCH (f:File)-[:CONTAINS]->(c:Class) WHERE EXISTS((f)-[:CONTAINS]->(:Function)) RETURN f.name"
    },
    {
      question: "Show methods that start with 'get'",
      cypher: "MATCH (m:Method) WHERE m.name CONTAINS 'get' RETURN m.name, m.filePath"
    },
    {
      question: "Find all indirect dependencies (functions that call functions that call a target)",
      cypher: "MATCH (caller:Function)-[:CALLS*2..2]->(target:Function {name: 'database_query'}) RETURN caller.name, target.name"
    }
  ];

  constructor(llmService: LLMService) {
    this.llmService = llmService;
  }

  /**
   * Update the graph schema for better query generation
   */
  public updateSchema(graph: KnowledgeGraph): void {
    this.graphSchema = this.generateSchemaDescription(graph);
  }

  /**
   * Generate a Cypher query from natural language
   */
  public async generateQuery(
    question: string,
    llmConfig: LLMConfig,
    options: CypherGenerationOptions = {}
  ): Promise<CypherQuery> {
    const { maxRetries = 2, includeExamples = true, strictMode = false } = options;
    
    let lastError: string | null = null;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const systemPrompt = this.buildSystemPrompt(includeExamples, strictMode, lastError);
        const userPrompt = this.buildUserPrompt(question);
        
        const messages = [
          new SystemMessage(systemPrompt),
          new HumanMessage(userPrompt)
        ];
        
        const response = await this.llmService.chat(llmConfig, messages);
        const result = this.parseResponse(String(response.content || ''));
        
        // Validate the generated query
        const validation = this.validateQuery(result.cypher);
        if (!validation.isValid) {
          lastError = validation.error!;
          if (attempt < maxRetries) {
            console.warn(`Query validation failed (attempt ${attempt + 1}): ${validation.error}`);
            continue;
          }
        }
        
        return {
          ...result,
          warnings: validation.warnings
        };
        
      } catch (error) {
        lastError = error instanceof Error ? error.message : 'Unknown error';
        if (attempt < maxRetries) {
          console.warn(`Query generation failed (attempt ${attempt + 1}): ${lastError}`);
          continue;
        }
        
        throw new Error(`Failed to generate Cypher query after ${maxRetries + 1} attempts: ${lastError}`);
      }
    }
    
    throw new Error('Unexpected error in query generation');
  }

  /**
   * Build the system prompt with schema and examples
   */
  private buildSystemPrompt(includeExamples: boolean, strictMode: boolean, lastError?: string | null): string {
    let prompt = `You are a Cypher query expert for a code knowledge graph. Your task is to convert natural language questions into valid Cypher queries.

GRAPH SCHEMA:
${this.graphSchema}

NODE TYPES:
- Project: Root project node
- Folder: Directory containers  
- File: Source code files
- Module: Python modules (.py files)
- Class: Class definitions
- Function: Function definitions
- Method: Class method definitions
- Variable: Variable declarations

RELATIONSHIP TYPES:
- CONTAINS: Hierarchical containment (Project->Folder, Folder->File, File->Function, etc.)
- CALLS: Function/method calls between code entities
- INHERITS: Class inheritance relationships
- IMPORTS: Module import relationships
- OVERRIDES: Method override relationships
- IMPLEMENTS: Interface implementation
- DECORATES: Decorator relationships

QUERY PATTERNS SUPPORTED:

1. SIMPLE MATCH: Find nodes by label and properties
   Pattern: MATCH (n:Label {property: 'value'}) RETURN n.property
   
2. WHERE CLAUSE: Filter nodes with complex conditions
   Pattern: MATCH (n:Label) WHERE n.property CONTAINS 'text' RETURN n.property
   
3. RELATIONSHIP TRAVERSAL: Follow direct relationships
   Pattern: MATCH (a)-[:RELATIONSHIP]->(b:Label) RETURN a.name, b.name
   
4. VARIABLE-LENGTH PATHS: Multi-hop relationships
   Pattern: MATCH (a)-[:RELATIONSHIP*1..3]->(b) RETURN a.name, b.name
   
5. AGGREGATION: Count, collect, or summarize data
   Pattern: MATCH (n:Label) RETURN COUNT(n)
   Pattern: MATCH (n:Label) RETURN COLLECT(n.name)

QUERY SELECTION GUIDELINES:

- Use SIMPLE MATCH for direct property lookups
- Use WHERE for text search, pattern matching, or complex conditions  
- Use RELATIONSHIP TRAVERSAL for direct connections
- Use VARIABLE-LENGTH PATHS for call chains, dependency analysis
- Use AGGREGATION for counting, statistics, or collecting lists

IMPORTANT RULES:
1. Always use MATCH patterns to find nodes
2. Use WHERE clauses for filtering by text content or complex conditions
3. Node properties include: name, filePath, startLine, endLine, type, qualifiedName
4. Return meaningful information, not just node IDs
5. Use case-insensitive matching: WHERE toLower(n.name) CONTAINS toLower('search')
6. Prefer specific node types over generic matches
7. Always return results in a readable format
8. Use variable-length paths (*1..3) for call chains and dependency analysis
9. Use aggregation functions (COUNT, COLLECT) for statistics and summaries
10. Limit variable-length path depth to avoid performance issues (max *1..5)`;

    if (includeExamples) {
      prompt += `\n\nEXAMPLES:`;
      for (const example of CypherGenerator.CYPHER_EXAMPLES) {
        prompt += `\nQ: "${example.question}"\nA: ${example.cypher}\n`;
      }
    }

    if (strictMode) {
      prompt += `\n\nSTRICT MODE: Only generate queries that exactly match the schema. Do not make assumptions about node properties that aren't explicitly defined.`;
    }

    if (lastError) {
      prompt += `\n\nPREVIOUS ERROR: The last query attempt failed with: "${lastError}". Please fix this issue in your new query.`;
    }

    prompt += `\n\nRESPONSE FORMAT:
Provide your response in this exact JSON format:
{
  "cypher": "your cypher query here",
  "explanation": "brief explanation of what the query does and why this pattern was chosen",
  "confidence": 0.85
}

The confidence should be a number between 0 and 1 indicating how confident you are in the query.`;

    return prompt;
  }

  /**
   * Build the user prompt with the question
   */
  private buildUserPrompt(question: string): string {
    return `Please convert this question to a Cypher query: "${question}"`;
  }

  /**
   * Parse the LLM response to extract Cypher query
   */
  private parseResponse(response: string): { cypher: string; explanation: string; confidence: number } {
    try {
      // Try to extract JSON from the response
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return {
          cypher: parsed.cypher || '',
          explanation: parsed.explanation || '',
          confidence: parsed.confidence || 0.5
        };
      }
      
      // Fallback: try to extract Cypher from code blocks
      const cypherMatch = response.match(/```(?:cypher)?\s*(.*?)\s*```/s);
      if (cypherMatch) {
        return {
          cypher: cypherMatch[1].trim(),
          explanation: 'Generated Cypher query',
          confidence: 0.7
        };
      }
      
      // Last resort: use the entire response as cypher
      return {
        cypher: response.trim(),
        explanation: 'Raw LLM response',
        confidence: 0.3
      };
      
    } catch (error) {
      throw new Error(`Failed to parse LLM response: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate the generated Cypher query
   */
  private validateQuery(cypher: string): { isValid: boolean; error?: string; warnings?: string[] } {
    const warnings: string[] = [];
    
    if (!cypher || cypher.trim().length === 0) {
      return { isValid: false, error: 'Empty query generated' };
    }
    
    // Basic syntax checks
    const upperCypher = cypher.toUpperCase();
    
    // Must have MATCH or CREATE or other valid starting keywords
    if (!upperCypher.match(/^\s*(MATCH|CREATE|MERGE|WITH|RETURN|CALL|SHOW)/)) {
      return { isValid: false, error: 'Query must start with a valid Cypher keyword (MATCH, CREATE, etc.)' };
    }
    
    // Check for balanced parentheses
    const openParens = (cypher.match(/\(/g) || []).length;
    const closeParens = (cypher.match(/\)/g) || []).length;
    if (openParens !== closeParens) {
      return { isValid: false, error: 'Unbalanced parentheses in query' };
    }
    
    // Check for balanced brackets
    const openBrackets = (cypher.match(/\[/g) || []).length;
    const closeBrackets = (cypher.match(/\]/g) || []).length;
    if (openBrackets !== closeBrackets) {
      return { isValid: false, error: 'Unbalanced brackets in query' };
    }
    
    // Check for balanced braces
    const openBraces = (cypher.match(/\{/g) || []).length;
    const closeBraces = (cypher.match(/\}/g) || []).length;
    if (openBraces !== closeBraces) {
      return { isValid: false, error: 'Unbalanced braces in query' };
    }
    
    // Warn about potentially expensive operations
    if (upperCypher.includes('MATCH ()') || upperCypher.includes('MATCH (*)')) {
      warnings.push('Query matches all nodes - this could be expensive');
    }
    
    if (!upperCypher.includes('RETURN') && !upperCypher.includes('DELETE') && !upperCypher.includes('SET')) {
      warnings.push('Query does not return results');
    }
    
    return { isValid: true, warnings };
  }

  /**
   * Generate a schema description from the knowledge graph
   */
  private generateSchemaDescription(graph: KnowledgeGraph): string {
    const nodeTypes = new Set<string>();
    const relationshipTypes = new Set<string>();
    const nodeProperties = new Map<string, Set<string>>();
    
    // Analyze nodes
    graph.nodes.forEach(node => {
      nodeTypes.add(node.label);
      
      if (!nodeProperties.has(node.label)) {
        nodeProperties.set(node.label, new Set());
      }
      
      Object.keys(node.properties).forEach(prop => {
        nodeProperties.get(node.label)!.add(prop);
      });
    });
    
    // Analyze relationships
    graph.relationships.forEach(rel => {
      relationshipTypes.add(rel.type);
    });
    
    let schema = `NODES (${graph.nodes.length} total):\n`;
    for (const nodeType of Array.from(nodeTypes).sort()) {
      const props = nodeProperties.get(nodeType);
      const propList = props ? Array.from(props).sort().join(', ') : 'none';
      const count = graph.nodes.filter(n => n.label === nodeType).length;
      schema += `- ${nodeType} (${count}): ${propList}\n`;
    }
    
    schema += `\nRELATIONSHIPS (${graph.relationships.length} total):\n`;
    for (const relType of Array.from(relationshipTypes).sort()) {
      const count = graph.relationships.filter(r => r.type === relType).length;
      schema += `- ${relType} (${count})\n`;
    }
    
    return schema;
  }

  /**
   * Get the current schema description
   */
  public getSchema(): string {
    return this.graphSchema;
  }

  /**
   * Clean and format a Cypher query
   */
  public cleanQuery(cypher: string): string {
    return cypher
      .trim()
      .replace(/\s+/g, ' ')
      .replace(/\s*([(),\[\]{}])\s*/g, '$1')
      .replace(/\s*([=<>!]+)\s*/g, ' $1 ')
      .replace(/\s+/g, ' ')
      .trim();
  }
}

================
File: src/ai/index.ts
================
export { LLMService, type LLMProvider, type LLMConfig, type ChatResponse } from './llm-service.ts';
export { CypherGenerator, type CypherQuery, type CypherGenerationOptions } from './cypher-generator.ts';
export { 
  RAGOrchestrator, 
  type RAGContext, 
  type RAGResponse, 
  type RAGOptions, 
  type ToolResult, 
  type ReasoningStep 
} from './orchestrator.ts';
export {
  LangChainRAGOrchestrator,
  type LangChainRAGContext,
  type LangChainRAGResponse,
  type LangChainRAGOptions
} from './langchain-orchestrator.ts';

================
File: src/ai/langchain-orchestrator.ts
================
import { createReactAgent } from '@langchain/langgraph/prebuilt';
import { MemorySaver } from '@langchain/langgraph';
import { DynamicStructuredTool } from '@langchain/core/tools';
import { z } from 'zod';
import { SystemMessage } from '@langchain/core/messages';
import type { LLMService, LLMConfig } from './llm-service.ts';
import type { CypherGenerator } from './cypher-generator.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';
import type { GraphNode } from '../core/graph/types.ts';

export interface LangChainRAGContext {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
}

export interface ToolCall {
  tool: string;
  input: Record<string, unknown>;
  output: string;
}

export interface LangChainRAGResponse {
  answer: string;
  sources: string[];
  confidence: number;
  toolCalls: ToolCall[];
}

export interface LangChainRAGOptions {
  maxIterations?: number;
  temperature?: number;
  enableMemory?: boolean;
  threadId?: string;
}

type AgentType = ReturnType<typeof createReactAgent>;
type MemoryType = InstanceType<typeof MemorySaver>;

export class LangChainRAGOrchestrator {
  private llmService: LLMService;
  private cypherGenerator: CypherGenerator;
  private context: LangChainRAGContext | null = null;
  private agent: AgentType | null = null;
  private memory: MemoryType | null = null;

  constructor(llmService: LLMService, cypherGenerator: CypherGenerator) {
    this.llmService = llmService;
    this.cypherGenerator = cypherGenerator;
    this.memory = new MemorySaver();
  }

  /**
   * Set the current context and initialize the agent
   */
  public async setContext(context: LangChainRAGContext, llmConfig: LLMConfig): Promise<void> {
    this.context = context;
    this.cypherGenerator.updateSchema(context.graph);

    // Create LangChain-compliant tools
    const tools = this.createTools(llmConfig);

    // Get the LLM from our service
    const llm = this.llmService.getChatModel(llmConfig);

    // Create system message for ReAct behavior
    const systemMessage = this.buildSystemMessage();

    // Create the ReAct agent using LangGraph
    const graph = createReactAgent({
      llm: llm as any,
      tools: tools as any,
      // Optional system message
      messageModifier: systemMessage as any
    });
    
    this.agent = graph;
  }

  /**
   * Answer a question using the LangChain ReAct agent
   */
  public async answerQuestion(
    question: string,
    options: LangChainRAGOptions = {}
  ): Promise<LangChainRAGResponse> {
    if (!this.agent || !this.context) {
      throw new Error('Agent not initialized. Call setContext() first.');
    }

    const {
      maxIterations = 10,
      enableMemory = false,
      threadId = 'default'
    } = options;

    try {
      const config = enableMemory 
        ? { 
            configurable: { thread_id: threadId },
            recursionLimit: maxIterations
          }
        : { recursionLimit: maxIterations };

      // Stream the agent execution
      const stream = await this.agent.stream(
        { messages: [{ role: "user", content: question }] },
        config
      );

      let finalAnswer = '';
      const toolCalls: ToolCall[] = [];
      const sources: string[] = [];

      // Process the stream
      for await (const chunk of stream) {
        if (chunk.agent) {
          finalAnswer = chunk.agent.messages[chunk.agent.messages.length - 1].content;
        }
        
        if (chunk.tools) {
          const toolMessage = chunk.tools.messages[chunk.tools.messages.length - 1];
          if (toolMessage.tool_calls) {
            toolMessage.tool_calls.forEach((toolCall: { name: string; args: Record<string, unknown> }) => {
              toolCalls.push({
                tool: toolCall.name,
                input: toolCall.args,
                output: toolMessage.content || ''
              });
            });
          }
        }
      }

      // Calculate confidence based on successful tool usage
      const confidence = this.calculateConfidence(toolCalls);

      return {
        answer: finalAnswer || 'I was unable to find a complete answer to your question.',
        sources: Array.from(new Set(sources)),
        confidence,
        toolCalls
      };

    } catch (error) {
      throw new Error(`LangChain RAG orchestration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Create LangChain-compliant tools
   */
  private createTools(llmConfig: LLMConfig) {
    const queryGraphTool = new DynamicStructuredTool({
      name: "query_graph",
      description: "Query the code knowledge graph using natural language. Use this to find information about code structure, relationships, functions, classes, etc.",
      schema: z.object({
        question: z.string().describe("Natural language question about the codebase")
      }),
      func: async (input: { question: string }) => {
        try {
          const cypherQuery = await this.cypherGenerator.generateQuery(input.question, llmConfig);
          const mockResults = await this.executeGraphQuery(cypherQuery.cypher);
          
          return `Query: ${cypherQuery.cypher}\n\nResults:\n${mockResults}\n\nExplanation: ${cypherQuery.explanation}`;
        } catch (error) {
          return `Error generating graph query: ${error instanceof Error ? error.message : 'Unknown error'}`;
        }
      }
    });

    const getCodeContentTool = new DynamicStructuredTool({
      name: "get_code_content",
      description: "Retrieve the source code content of a specific file. Use this when you need to examine the actual code implementation.",
      schema: z.object({
        filePath: z.string().describe("The path to the file whose content you want to retrieve")
      }),
      func: async (input: { filePath: string }) => {
        if (!this.context) {
          return 'No context available';
        }

        const content = this.context.fileContents.get(input.filePath);
        if (!content) {
          // Try to find similar file paths
          const similarFiles = Array.from(this.context.fileContents.keys())
            .filter(path => path.includes(input.filePath) || input.filePath.includes(path))
            .slice(0, 3);

          if (similarFiles.length > 0) {
            return `File not found. Similar files available: ${similarFiles.join(', ')}`;
          }
          return 'File not found';
        }

        return `File: ${input.filePath}\n\n${content}`;
      }
    });

    const searchFilesTool = new DynamicStructuredTool({
      name: "search_files",
      description: "Search for files matching a pattern or containing specific text. Use this to find relevant files in the codebase.",
      schema: z.object({
        pattern: z.string().describe("Search pattern or text to look for in file names or content")
      }),
      func: async (input: { pattern: string }) => {
        if (!this.context) {
          return 'No context available';
        }

        const matchingFiles: string[] = [];
        const lowerPattern = input.pattern.toLowerCase();

        // Search in file paths
        for (const filePath of this.context.fileContents.keys()) {
          if (filePath.toLowerCase().includes(lowerPattern)) {
            matchingFiles.push(filePath);
          }
        }

        // Search in file contents
        for (const [filePath, content] of this.context.fileContents.entries()) {
          if (!matchingFiles.includes(filePath) && 
              content.toLowerCase().includes(lowerPattern)) {
            matchingFiles.push(filePath);
          }
        }

        return matchingFiles.length > 0 
          ? `Found ${matchingFiles.length} files:\n${matchingFiles.slice(0, 10).join('\n')}${matchingFiles.length > 10 ? '\n... and more' : ''}`
          : 'No files found matching the pattern';
      }
    });

    return [queryGraphTool, getCodeContentTool, searchFilesTool];
  }

  /**
   * Build system message for ReAct behavior
   */
  private buildSystemMessage(): SystemMessage {
    const systemPrompt = `You are an expert code analyst that helps users understand codebases by using available tools.

You have access to the following tools:
1. query_graph: Query the code knowledge graph using natural language
2. get_code_content: Retrieve the source code content of a specific file  
3. search_files: Search for files matching a pattern or containing specific text

IMPORTANT GUIDELINES:
- Always think step by step about what information you need
- Use tools to gather factual information before providing answers
- Base your responses ONLY on information retrieved from tools
- If you cannot find information, say so explicitly
- Provide helpful, accurate answers about the codebase structure and functionality
- When referencing code, always cite the specific files you examined

Your goal is to provide accurate, evidence-based answers about the codebase using the available tools.`;

    return new SystemMessage(systemPrompt);
  }

  /**
   * Execute graph query using the real GraphQueryEngine
   */
  private async executeGraphQuery(cypher: string): Promise<string> {
    if (!this.context) return 'No context available';

    try {
      // Import and use the real GraphQueryEngine
      const { GraphQueryEngine } = await import('../core/graph/query-engine.ts');
      const queryEngine = new GraphQueryEngine(this.context.graph);
      
      // Execute the actual Cypher query
      const queryResult = queryEngine.executeQuery(cypher, { limit: 10 });
      
      // Format the results for the LLM
      if (queryResult.data.length > 0) {
        return queryResult.data.map((row, index) => {
          const entries = Object.entries(row);
          if (entries.length === 0) return `Result ${index + 1}: (no data)`;
          
          return entries.map(([key, value]) => {
            if (typeof value === 'object' && value !== null && 'properties' in value) {
              // This is a node object
              const node = value as GraphNode;
              return `${key}: ${node.label} "${node.properties.name || node.properties.filePath || node.id}"`;
            }
            return `${key}: ${value}`;
          }).join(', ');
        }).join('\n');
      } else {
        return 'No results found';
      }
    } catch (error) {
      console.error('Graph query execution failed:', error);
      return `Query execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
    }
  }

  /**
   * Calculate confidence based on tool usage
   */
  private calculateConfidence(toolCalls: ToolCall[]): number {
    if (toolCalls.length === 0) return 0.3;

    const successfulCalls = toolCalls.filter(call => 
      !call.output.includes('Error') && 
      !call.output.includes('not found') &&
      call.output.length > 10
    ).length;

    const baseConfidence = 0.5;
    const toolBonus = (successfulCalls / toolCalls.length) * 0.4;
    
    return Math.min(0.95, Math.max(0.1, baseConfidence + toolBonus));
  }

  /**
   * Get current context information
   */
  public getContextInfo(): { nodeCount: number; fileCount: number; hasContext: boolean; hasAgent: boolean } {
    return {
      nodeCount: this.context?.graph.nodes.length || 0,
      fileCount: this.context?.fileContents.size || 0,
      hasContext: !!this.context,
      hasAgent: !!this.agent
    };
  }

  /**
   * Clear memory for a specific thread
   */
  public async clearMemory(threadId: string): Promise<void> {
    if (this.memory) {
      // Note: MemorySaver doesn't have a direct clear method in the current API
      // This would need to be implemented based on the specific memory backend
      console.log(`Memory clearing not implemented for thread: ${threadId}`);
    }
  }
}

================
File: src/ai/llm-service.ts
================
import { ChatOpenAI } from '@langchain/openai';
import { AzureChatOpenAI } from '@langchain/openai';
import { ChatAnthropic } from '@langchain/anthropic';
import { ChatGoogleGenerativeAI } from '@langchain/google-genai';
import type { BaseMessage } from '@langchain/core/messages';
import type { BaseChatModel } from '@langchain/core/language_models/chat_models';
import { HumanMessage } from '@langchain/core/messages';

export type LLMProvider = 'openai' | 'azure-openai' | 'anthropic' | 'gemini';

export interface LLMConfig {
  provider: LLMProvider;
  apiKey: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  maxRetries?: number;
  // Azure OpenAI specific fields
  azureOpenAIEndpoint?: string;
  azureOpenAIApiVersion?: string;
  azureOpenAIDeploymentName?: string;
}

export interface ChatResponse {
  content: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  model?: string;
  finishReason?: string;
}

export class LLMService {
  private models: Map<string, BaseChatModel> = new Map();
  private defaultConfig: Partial<LLMConfig> = {
    temperature: 0.1,
    maxTokens: 4000,
    maxRetries: 3,
    azureOpenAIApiVersion: '2024-02-01' // Default Azure OpenAI API version
  };

  // Default models for each provider
  private static readonly DEFAULT_MODELS: Record<LLMProvider, string> = {
    openai: 'gpt-4o-mini',
    'azure-openai': 'gpt-4o-mini',
    anthropic: 'claude-3-haiku-20240307',
    gemini: 'gemini-2.5-flash'  // Use the latest 2.5 Flash model as default (2025)
  };

  constructor() {}

  /**
   * Initialize or get a chat model for the specified provider
   */
  public getChatModel(config: LLMConfig): any {
    const cacheKey = this.getCacheKey(config);
    
    if (this.models.has(cacheKey)) {
      return this.models.get(cacheKey)!;
    }

    const model = this.createChatModel(config);
    this.models.set(cacheKey, model);
    return model;
  }

  /**
   * Send a chat message and get a response
   */
  public async chat(
    config: LLMConfig,
    messages: BaseMessage[],
    options?: { stream?: boolean }
  ): Promise<ChatResponse> {
    try {
      const model = this.getChatModel(config);
      
      if (options?.stream) {
        // For streaming, we'd need to handle this differently
        // For now, we'll just use regular invoke
        console.warn('Streaming not implemented yet, falling back to regular invoke');
      }

      const response = await model.invoke(messages);
      
      return {
        content: response.content as string,
        usage: response.response_metadata?.usage ? {
          promptTokens: response.response_metadata.usage.prompt_tokens || 0,
          completionTokens: response.response_metadata.usage.completion_tokens || 0,
          totalTokens: response.response_metadata.usage.total_tokens || 0
        } : undefined,
        model: config.model || LLMService.DEFAULT_MODELS[config.provider],
        finishReason: response.response_metadata?.finish_reason
      };
    } catch (error) {
      throw new Error(`LLM chat failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validate API key format for different providers
   */
  public validateApiKey(provider: LLMProvider, apiKey: string): boolean {
    if (!apiKey || apiKey.trim().length === 0) {
      return false;
    }

    switch (provider) {
      case 'openai':
        return apiKey.startsWith('sk-') && apiKey.length > 20;
      case 'azure-openai':
        // Azure OpenAI keys are typically 32 characters long and don't have a specific prefix
        return apiKey.length >= 20; // More flexible validation for Azure keys
      case 'anthropic':
        return apiKey.startsWith('sk-ant-') && apiKey.length > 20;
      case 'gemini':
        return apiKey.length > 20; // Google API keys don't have a consistent prefix
      default:
        return false;
    }
  }

  /**
   * Validate Azure OpenAI configuration
   */
  public validateAzureOpenAIConfig(config: LLMConfig): { valid: boolean; error?: string } {
    if (config.provider !== 'azure-openai') {
      return { valid: false, error: 'Provider must be azure-openai' };
    }

    if (!config.azureOpenAIEndpoint) {
      return { valid: false, error: 'Azure OpenAI endpoint is required' };
    }

    if (!config.azureOpenAIEndpoint.includes('openai.azure.com')) {
      return { valid: false, error: 'Invalid Azure OpenAI endpoint format. Should contain "openai.azure.com"' };
    }

    if (!config.azureOpenAIDeploymentName) {
      return { valid: false, error: 'Azure OpenAI deployment name is required' };
    }

    return { valid: true };
  }

  /**
   * Get available models for a provider
   */
  public getAvailableModels(provider: LLMProvider): string[] {
    switch (provider) {
      case 'openai':
        return [
          'gpt-4o',
          'gpt-4o-mini',
          'gpt-4-turbo',
          'gpt-4',
          'gpt-3.5-turbo'
        ];
      case 'azure-openai':
        return [
          'gpt-4o',
          'gpt-4o-mini', 
          'gpt-4.1-mini-v2', // Common deployment name
          'gpt-4-turbo',
          'gpt-4',
          'gpt-35-turbo', // Note: Azure uses gpt-35-turbo instead of gpt-3.5-turbo
          'gpt-4-32k'
        ];
      case 'anthropic':
        return [
          'claude-3-5-sonnet-20241022',
          'claude-3-5-haiku-20241022',
          'claude-3-opus-20240229',
          'claude-3-sonnet-20240229',
          'claude-3-haiku-20240307'
        ];
      case 'gemini':
        return [
          'gemini-2.5-flash',         // Latest and fastest (2025) - NEW DEFAULT
          'gemini-2.5-pro',           // Latest pro model (2025) - PREMIUM
          'gemini-1.5-flash',         // Most stable and widely available
          'gemini-1.5-pro',           // Stable pro model
          'gemini-1.0-pro',           // Legacy but very stable
          'gemini-1.5-flash-8b',      // Smaller, efficient version
          'gemini-2.0-flash',         // Newer model (may not be available to all users)
          'gemini-2.0-flash-lite'     // Lightweight version
        ];
      default:
        return [];
    }
  }

  /**
   * Get provider display name
   */
  public getProviderDisplayName(provider: LLMProvider): string {
    switch (provider) {
      case 'openai':
        return 'OpenAI';
      case 'azure-openai':
        return 'Azure OpenAI';
      case 'anthropic':
        return 'Anthropic';
      case 'gemini':
        return 'Google Gemini';
      default:
        return provider;
    }
  }

  /**
   * Test connection with the provider
   */
  public async testConnection(config: LLMConfig): Promise<{ success: boolean; error?: string }> {
    try {
      // Validate Azure OpenAI config if needed
      if (config.provider === 'azure-openai') {
        const validation = this.validateAzureOpenAIConfig(config);
        if (!validation.valid) {
          return {
            success: false,
            error: validation.error
          };
        }
      }

      const model = this.createChatModel(config);
      
      // Send a simple test message
      const testMessages = [
        new HumanMessage("Test connection")
      ];
      
      await model.invoke(testMessages);
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Connection test failed'
      };
    }
  }

  /**
   * Clear cached models (useful for updating API keys)
   */
  public clearCache(): void {
    this.models.clear();
  }

  /**
   * Create a chat model instance based on the provider
   */
  private createChatModel(config: LLMConfig): any {
    const mergedConfig = { ...this.defaultConfig, ...config };
    const model = mergedConfig.model || LLMService.DEFAULT_MODELS[config.provider];

    switch (config.provider) {
      case 'openai':
        return new ChatOpenAI({
          apiKey: config.apiKey,
          model,
          temperature: mergedConfig.temperature,
          maxTokens: mergedConfig.maxTokens,
          maxRetries: mergedConfig.maxRetries,
          timeout: 30000
        });

      case 'azure-openai':
        return new AzureChatOpenAI({
          azureOpenAIApiKey: config.apiKey,
          model: config.azureOpenAIDeploymentName, // Use deployment name as model
          temperature: mergedConfig.temperature,
          maxTokens: mergedConfig.maxTokens,
          maxRetries: mergedConfig.maxRetries,
          timeout: 30000,
          azureOpenAIApiInstanceName: config.azureOpenAIEndpoint?.replace('https://', '').split('.')[0],
          azureOpenAIApiVersion: config.azureOpenAIApiVersion,
          azureOpenAIApiDeploymentName: config.azureOpenAIDeploymentName
        });

      case 'anthropic':
        return new ChatAnthropic({
          model: config.model || 'claude-3-sonnet-20240229',
          anthropicApiKey: config.apiKey,
          maxTokens: config.maxTokens || 4096,
          temperature: config.temperature || 0.7
        });

      case 'gemini':
        return new ChatGoogleGenerativeAI({
          apiKey: config.apiKey,
          model,
          temperature: mergedConfig.temperature,
          maxOutputTokens: mergedConfig.maxTokens,
          maxRetries: mergedConfig.maxRetries
        });

      default:
        throw new Error(`Unsupported provider: ${config.provider}`);
    }
  }

  /**
   * Generate cache key for model instances
   */
  private getCacheKey(config: LLMConfig): string {
    const model = config.model || LLMService.DEFAULT_MODELS[config.provider];
    let baseKey = `${config.provider}:${model}:${config.apiKey.slice(-8)}:${config.temperature}:${config.maxTokens}`;
    
    // Add Azure OpenAI specific fields to cache key
    if (config.provider === 'azure-openai') {
      baseKey += `:${config.azureOpenAIEndpoint}:${config.azureOpenAIDeploymentName}:${config.azureOpenAIApiVersion}`;
    }
    
    return baseKey;
  }
}

================
File: src/ai/orchestrator.ts
================
import { HumanMessage, SystemMessage, AIMessage } from '@langchain/core/messages';
import type { LLMService, LLMConfig } from './llm-service.ts';
import type { CypherGenerator, CypherQuery } from './cypher-generator.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';
import type { GraphNode } from '../core/graph/types.ts';

export interface RAGContext {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
}

export interface ToolResult {
  toolName: string;
  input: string;
  output: string;
  success: boolean;
  error?: string;
}

export interface ReasoningStep {
  step: number;
  thought: string;
  action: string;
  actionInput: string;
  observation: string;
  toolResult?: ToolResult;
}

export interface RAGResponse {
  answer: string;
  reasoning: ReasoningStep[];
  cypherQueries: CypherQuery[];
  confidence: number;
  sources: string[];
}

export interface RAGOptions {
  maxReasoningSteps?: number;
  includeReasoning?: boolean;
  strictMode?: boolean;
  temperature?: number;
}

export class RAGOrchestrator {
  private llmService: LLMService;
  private cypherGenerator: CypherGenerator;
  private context: RAGContext | null = null;

  constructor(llmService: LLMService, cypherGenerator: CypherGenerator) {
    this.llmService = llmService;
    this.cypherGenerator = cypherGenerator;
  }

  /**
   * Set the current context (graph and file contents)
   */
  public setContext(context: RAGContext): void {
    this.context = context;
    this.cypherGenerator.updateSchema(context.graph);
  }

  /**
   * Answer a question using ReAct pattern
   */
  public async answerQuestion(
    question: string,
    llmConfig: LLMConfig,
    options: RAGOptions = {}
  ): Promise<RAGResponse> {
    if (!this.context) {
      throw new Error('Context not set. Call setContext() first.');
    }

    const {
      maxReasoningSteps = 5,
      includeReasoning = true,
      strictMode = false,
      temperature = 0.1
    } = options;

    const reasoning: ReasoningStep[] = [];
    const cypherQueries: CypherQuery[] = [];
    const sources: string[] = [];

    // Enhanced LLM config for reasoning
    const reasoningConfig: LLMConfig = {
      ...llmConfig,
      temperature: temperature
    };

    let currentStep = 1;
    let finalAnswer = '';
    let confidence = 0.5;

    try {
      // Initial system prompt for ReAct
      const systemPrompt = this.buildReActSystemPrompt(strictMode);
      const conversation = [new SystemMessage(systemPrompt)];

      // Add the user question
      conversation.push(new HumanMessage(`Question: ${question}`));

      while (currentStep <= maxReasoningSteps) {
        // Get reasoning from LLM
        const response = await this.llmService.chat(reasoningConfig, conversation);
        const reasoning_step = this.parseReasoningStep(String(response.content || ''), currentStep);

        reasoning.push(reasoning_step);

        // Check if we have a final answer
        if (reasoning_step.action.toLowerCase().includes('final_answer')) {
          finalAnswer = reasoning_step.actionInput;
          confidence = this.calculateConfidence(reasoning, cypherQueries);
          break;
        }

        // Execute the action
        let toolResult: ToolResult | null = null;
        
        try {
          if (reasoning_step.action.toLowerCase().includes('query_graph')) {
            toolResult = await this.executeGraphQuery(reasoning_step.actionInput, reasoningConfig);
            if (toolResult.success) {
              cypherQueries.push(...this.extractCypherQueries(toolResult));
            }
          } else if (reasoning_step.action.toLowerCase().includes('get_code')) {
            toolResult = await this.getCodeContent(reasoning_step.actionInput);
            if (toolResult.success) {
              sources.push(...this.extractSources(toolResult));
            }
          } else if (reasoning_step.action.toLowerCase().includes('search_files')) {
            toolResult = await this.searchFiles(reasoning_step.actionInput);
          } else {
            toolResult = {
              toolName: 'unknown',
              input: reasoning_step.actionInput,
              output: 'Unknown action type',
              success: false,
              error: `Unknown action: ${reasoning_step.action}`
            };
          }
        } catch (error) {
          toolResult = {
            toolName: reasoning_step.action,
            input: reasoning_step.actionInput,
            output: '',
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          };
        }

        // Update the reasoning step with tool result
        reasoning_step.observation = toolResult.output;
        reasoning_step.toolResult = toolResult;

        // Add the tool result to conversation
        conversation.push(new AIMessage(String(response.content || '')));
        conversation.push(new HumanMessage(`Observation: ${toolResult.output}`));

        currentStep++;
      }

      // If we didn't get a final answer, generate one based on the reasoning
      if (!finalAnswer && reasoning.length > 0) {
        const summaryPrompt = this.buildSummaryPrompt(question, reasoning);
        conversation.push(new HumanMessage(summaryPrompt));
        
        const summaryResponse = await this.llmService.chat(reasoningConfig, conversation);
        finalAnswer = String(summaryResponse.content || '');
        confidence = Math.max(0.3, confidence - 0.2); // Lower confidence for incomplete reasoning
      }

      return {
        answer: finalAnswer || 'I was unable to find a complete answer to your question.',
        reasoning: includeReasoning ? reasoning : [],
        cypherQueries,
        confidence,
        sources: Array.from(new Set(sources)) // Remove duplicates
      };

    } catch (error) {
      throw new Error(`RAG orchestration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Build the ReAct system prompt
   */
  private buildReActSystemPrompt(strictMode: boolean): string {
    const prompt = `You are an expert code analyst using a ReAct (Reasoning + Acting) approach to answer questions about a codebase.

You have access to the following tools:
1. query_graph(question): Query the code knowledge graph using natural language
2. get_code(file_path): Retrieve the source code content of a specific file
3. search_files(pattern): Search for files matching a pattern or containing specific text

IMPORTANT INSTRUCTIONS:
- Always think step by step using the format: Thought: [your reasoning]
- Then specify an action using: Action: [tool_name]
- Provide the input using: Action Input: [input for the tool]
- After receiving an observation, continue reasoning or provide a final answer
- Use Final Answer: [your answer] when you have sufficient information
- Base your answers ONLY on the information retrieved from tools
- Do not make assumptions or hallucinate information
- If you cannot find information, say so explicitly

RESPONSE FORMAT:
Thought: [Your reasoning about what to do next]
Action: [query_graph, get_code, search_files, or Final Answer]
Action Input: [The input for the action]

After receiving an Observation, continue with:
Thought: [Your analysis of the observation]
Action: [Next action or Final Answer]
Action Input: [Input for next action or your final answer]

FINAL ANSWER FORMATTING:
When providing your final answer, use markdown formatting for better readability:
- Use **bold** for important terms and concepts
- Use \`inline code\` for function names, file names, and code snippets
- Use code blocks with language specification for longer code examples
- Use bullet points or numbered lists for structured information
- Use headers (##, ###) to organize complex answers
- Use tables when presenting structured data

Example final answer format:
## Summary
The codebase contains **15 functions** across **3 files**.

### Key Functions:
- \`authenticate()\` - Handles user authentication
- \`process_data()\` - Main data processing logic
- \`save_results()\` - Saves processed data to database

${strictMode ? '\nSTRICT MODE: Only use information explicitly found in the tools. Do not infer or assume anything.' : ''}

Remember: Your goal is to provide accurate, evidence-based, and well-formatted answers about the codebase.`;

    return prompt;
  }

  /**
   * Parse a reasoning step from LLM response
   */
  private parseReasoningStep(response: string, stepNumber: number): ReasoningStep {
    // Ensure response is a string
    const responseText = typeof response === 'string' ? response : String(response || '');
    
    const thoughtMatch = responseText.match(/Thought:\s*(.*?)(?=\n|Action:|$)/s);
    const actionMatch = responseText.match(/Action:\s*(.*?)(?=\n|Action Input:|$)/s);
    const inputMatch = responseText.match(/Action Input:\s*(.*?)(?=\n|$)/s);

    return {
      step: stepNumber,
      thought: thoughtMatch?.[1]?.trim() || 'No thought provided',
      action: actionMatch?.[1]?.trim() || 'unknown',
      actionInput: inputMatch?.[1]?.trim() || '',
      observation: '' // Will be filled after tool execution
    };
  }

  /**
   * Execute a graph query using the new GraphQueryEngine
   */
  private async executeGraphQuery(question: string, llmConfig: LLMConfig): Promise<ToolResult> {
    try {
      const cypherQuery = await this.cypherGenerator.generateQuery(question, llmConfig);
      
      // Import and use the real GraphQueryEngine
      const { GraphQueryEngine } = await import('../core/graph/query-engine.ts');
      const queryEngine = new GraphQueryEngine(this.context!.graph);
      
      // Execute the actual Cypher query
      const queryResult = queryEngine.executeQuery(cypherQuery.cypher, { limit: 10 });
      
      // Format the results for the LLM
      let formattedResults = '';
      if (queryResult.data.length > 0) {
        formattedResults = queryResult.data.map((row, index) => {
          const entries = Object.entries(row);
          if (entries.length === 0) return `Result ${index + 1}: (no data)`;
          
          return entries.map(([key, value]) => {
            if (typeof value === 'object' && value !== null && 'properties' in value) {
              // This is a node object
              const node = value as GraphNode;
              return `${key}: ${node.label} "${node.properties.name || node.properties.filePath || node.id}"`;
            }
            return `${key}: ${value}`;
          }).join(', ');
        }).join('\n');
      } else {
        formattedResults = 'No results found';
      }
      
      return {
        toolName: 'query_graph',
        input: question,
        output: `Query: ${cypherQuery.cypher}\n\nResults (${queryResult.data.length} found):\n${formattedResults}\n\nExplanation: ${cypherQuery.explanation}`,
        success: true
      };
    } catch (error) {
      return {
        toolName: 'query_graph',
        input: question,
        output: '',
        success: false,
        error: error instanceof Error ? error.message : 'Query execution failed'
      };
    }
  }

  /**
   * Get code content from a file
   */
  private async getCodeContent(filePath: string): Promise<ToolResult> {
    if (!this.context) {
      return {
        toolName: 'get_code',
        input: filePath,
        output: '',
        success: false,
        error: 'No context available'
      };
    }

    const content = this.context.fileContents.get(filePath);
    if (!content) {
      // Try to find similar file paths
      const similarFiles = Array.from(this.context.fileContents.keys())
        .filter(path => path.includes(filePath) || filePath.includes(path))
        .slice(0, 3);

      if (similarFiles.length > 0) {
        return {
          toolName: 'get_code',
          input: filePath,
          output: `File not found. Similar files available: ${similarFiles.join(', ')}`,
          success: false,
          error: 'File not found'
        };
      }

      return {
        toolName: 'get_code',
        input: filePath,
        output: 'File not found',
        success: false,
        error: 'File not found'
      };
    }

    return {
      toolName: 'get_code',
      input: filePath,
      output: `File: ${filePath}\n\n${content}`,
      success: true
    };
  }

  /**
   * Search for files matching a pattern
   */
  private async searchFiles(pattern: string): Promise<ToolResult> {
    if (!this.context) {
      return {
        toolName: 'search_files',
        input: pattern,
        output: '',
        success: false,
        error: 'No context available'
      };
    }

    const matchingFiles: string[] = [];
    const lowerPattern = pattern.toLowerCase();

    // Search in file paths
    for (const filePath of this.context.fileContents.keys()) {
      if (filePath.toLowerCase().includes(lowerPattern)) {
        matchingFiles.push(filePath);
      }
    }

    // Search in file contents
    for (const [filePath, content] of this.context.fileContents.entries()) {
      if (!matchingFiles.includes(filePath) && 
          content.toLowerCase().includes(lowerPattern)) {
        matchingFiles.push(filePath);
      }
    }

    return {
      toolName: 'search_files',
      input: pattern,
      output: matchingFiles.length > 0 
        ? `Found ${matchingFiles.length} files:\n${matchingFiles.slice(0, 10).join('\n')}${matchingFiles.length > 10 ? '\n... and more' : ''}`
        : 'No files found matching the pattern',
      success: true
    };
  }

  /**
   * Extract Cypher queries from tool results
   */
  private extractCypherQueries(toolResult: ToolResult): CypherQuery[] {
    const queries: CypherQuery[] = [];
    const queryMatch = toolResult.output.match(/Query: (.*?)(?=\n|$)/);
    
    if (queryMatch) {
      queries.push({
        cypher: queryMatch[1],
        explanation: 'Generated during reasoning',
        confidence: 0.8
      });
    }

    return queries;
  }

  /**
   * Extract sources from tool results
   */
  private extractSources(toolResult: ToolResult): string[] {
    const sources: string[] = [];
    const fileMatch = toolResult.output.match(/File: (.*?)(?=\n|$)/);
    
    if (fileMatch) {
      sources.push(fileMatch[1]);
    }

    return sources;
  }

  /**
   * Calculate confidence based on reasoning quality
   */
  private calculateConfidence(reasoning: ReasoningStep[], queries: CypherQuery[]): number {
    let confidence = 0.5;

    // Boost confidence for successful tool usage
    const successfulSteps = reasoning.filter(step => step.toolResult?.success).length;
    confidence += (successfulSteps / reasoning.length) * 0.3;

    // Boost confidence for high-quality queries
    const avgQueryConfidence = queries.length > 0 
      ? queries.reduce((sum, q) => sum + q.confidence, 0) / queries.length
      : 0.5;
    confidence += avgQueryConfidence * 0.2;

    // Cap at reasonable bounds
    return Math.min(0.95, Math.max(0.1, confidence));
  }

  /**
   * Build summary prompt for incomplete reasoning
   */
  private buildSummaryPrompt(question: string, reasoning: ReasoningStep[]): string {
    const observations = reasoning
      .map(step => `Step ${step.step}: ${step.observation}`)
      .join('\n');

    return `Based on the following observations from your reasoning process, please provide a final answer to the question: "${question}"

Observations:
${observations}

Final Answer:`;
  }

  /**
   * Get current context information
   */
  public getContextInfo(): { nodeCount: number; fileCount: number; hasContext: boolean } {
    if (!this.context) {
      return { nodeCount: 0, fileCount: 0, hasContext: false };
    }

    return {
      nodeCount: this.context.graph.nodes.length,
      fileCount: this.context.fileContents.size,
      hasContext: true
    };
  }

  /**
   * Test the orchestrator with a simple query (for debugging)
   */
  public async testOrchestrator(llmConfig: LLMConfig): Promise<{ success: boolean; error?: string; response?: RAGResponse }> {
    if (!this.context) {
      return { success: false, error: 'No context set' };
    }

    try {
      const testQuestion = "How many functions are in this project?";
      const response = await this.answerQuestion(testQuestion, llmConfig, { 
        maxReasoningSteps: 2, 
        includeReasoning: true 
      });
      
      return { success: true, response };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }
}

================
File: src/App.css
================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: src/App.tsx
================
import React from 'react';
import { HomePage, ErrorBoundary } from './ui/index.ts';

const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <HomePage />
    </ErrorBoundary>
  );
};

export default App;

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/config/config.ts
================
/**
 * Centralized Configuration System
 * Provides type-safe configuration with environment validation and defaults
 */

import { z } from 'zod';

// Configuration schemas with validation
const MemoryConfigSchema = z.object({
  maxMemoryMB: z.number().min(100).max(2048).default(512),
  cleanupThresholdMB: z.number().min(50).max(1024).default(400),
  gcIntervalMs: z.number().min(5000).max(60000).default(30000),
  maxFileSizeMB: z.number().min(1).max(50).default(10),
  maxFilesInMemory: z.number().min(100).max(10000).default(1000)
});

const GitHubConfigSchema = z.object({
  apiUrl: z.string().url().default('https://api.github.com'),
  token: z.string().optional(),
  rateLimit: z.object({
    maxRequests: z.number().min(1).max(5000).default(60),
    windowMs: z.number().min(1000).max(3600000).default(60000)
  }),
  retry: z.object({
    maxRetries: z.number().min(0).max(5).default(3),
    backoffMs: z.number().min(100).max(10000).default(1000)
  })
});

const LLMConfigSchema = z.object({
  providers: z.object({
    openai: z.object({
      apiKey: z.string().optional(),
      model: z.string().default('gpt-4'),
      maxTokens: z.number().min(100).max(10000).default(2000),
      temperature: z.number().min(0).max(2).default(0.7)
    }).optional(),
    azure: z.object({
      apiKey: z.string().optional(),
      endpoint: z.string().url().optional(),
      deployment: z.string().optional(),
      maxTokens: z.number().min(100).max(10000).default(2000),
      temperature: z.number().min(0).max(2).default(0.7)
    }).optional(),
    anthropic: z.object({
      apiKey: z.string().optional(),
      model: z.string().default('claude-3-sonnet-20240229'),
      maxTokens: z.number().min(100).max(10000).default(2000),
      temperature: z.number().min(0).max(2).default(0.7)
    }).optional(),
    gemini: z.object({
      apiKey: z.string().optional(),
      model: z.string().default('gemini-pro'),
      maxTokens: z.number().min(100).max(10000).default(2000),
      temperature: z.number().min(0).max(2).default(0.7)
    }).optional()
  }),
  defaultProvider: z.enum(['openai', 'azure', 'anthropic', 'gemini']).default('openai')
});

const ProcessingConfigSchema = z.object({
  batchSize: z.number().min(1).max(100).default(10),
  maxConcurrentRequests: z.number().min(1).max(50).default(5),
  timeoutMs: z.number().min(1000).max(300000).default(30000),
  retry: z.object({
    maxRetries: z.number().min(0).max(5).default(3),
    backoffMs: z.number().min(100).max(10000).default(1000)
  }),
  fileExtensions: z.array(z.string()).default([
    '.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.cpp', '.c', '.h', '.hpp',
    '.cs', '.php', '.rb', '.go', '.rs', '.swift', '.kt', '.scala', '.dart',
    '.json', '.yaml', '.yml', '.xml', '.toml', '.ini', '.cfg', '.properties'
  ])
});

const LoggingConfigSchema = z.object({
  level: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
  enableMetrics: z.boolean().default(true),
  enablePerformanceTracking: z.boolean().default(true),
  maxLogEntries: z.number().min(100).max(10000).default(1000)
});

// Main configuration schema
const AppConfigSchema = z.object({
  memory: MemoryConfigSchema,
  github: GitHubConfigSchema,
  llm: LLMConfigSchema,
  processing: ProcessingConfigSchema,
  logging: LoggingConfigSchema,
  environment: z.enum(['development', 'staging', 'production']).default('development')
});

export type AppConfig = z.infer<typeof AppConfigSchema>;
export type MemoryConfig = z.infer<typeof MemoryConfigSchema>;
export type GitHubConfig = z.infer<typeof GitHubConfigSchema>;
export type LLMConfig = z.infer<typeof LLMConfigSchema>;
export type ProcessingConfig = z.infer<typeof ProcessingConfigSchema>;
export type LoggingConfig = z.infer<typeof LoggingConfigSchema>;

/**
 * Configuration service with environment validation
 */
export class ConfigService {
  private static instance: ConfigService;
  private config: AppConfig;
  private validationErrors: string[] = [];

  private constructor() {
    this.config = this.loadConfiguration();
    this.validateEnvironment();
  }

  public static getInstance(): ConfigService {
    if (!ConfigService.instance) {
      ConfigService.instance = new ConfigService();
    }
    return ConfigService.instance;
  }

  /**
   * Load configuration from environment variables and defaults
   */
  private loadConfiguration(): AppConfig {
    try {
      const config: AppConfig = {
        memory: {
          maxMemoryMB: this.getEnvNumber('MEMORY_MAX_MB', 512),
          cleanupThresholdMB: this.getEnvNumber('MEMORY_CLEANUP_THRESHOLD_MB', 400),
          gcIntervalMs: this.getEnvNumber('MEMORY_GC_INTERVAL_MS', 30000),
          maxFileSizeMB: this.getEnvNumber('MEMORY_MAX_FILE_SIZE_MB', 10),
          maxFilesInMemory: this.getEnvNumber('MEMORY_MAX_FILES', 1000)
        },
        github: {
          apiUrl: this.getEnvString('GITHUB_API_URL', 'https://api.github.com') ?? 'https://api.github.com',
          token: this.getEnvString('GITHUB_TOKEN'),
          rateLimit: {
            maxRequests: this.getEnvNumber('GITHUB_RATE_LIMIT_MAX', 60),
            windowMs: this.getEnvNumber('GITHUB_RATE_LIMIT_WINDOW_MS', 60000)
          },
          retry: {
            maxRetries: this.getEnvNumber('GITHUB_RETRY_MAX', 3),
            backoffMs: this.getEnvNumber('GITHUB_RETRY_BACKOFF_MS', 1000)
          }
        },
        llm: {
          providers: {
            openai: this.getLLMProviderConfig('OPENAI'),
            azure: this.getLLMProviderConfig('AZURE'),
            anthropic: this.getLLMProviderConfig('ANTHROPIC'),
            gemini: this.getLLMProviderConfig('GEMINI')
          },
          defaultProvider: (this.getEnvString('LLM_DEFAULT_PROVIDER', 'openai') as 'openai' | 'azure' | 'anthropic' | 'gemini') ?? 'openai'
        },
        processing: {
          batchSize: this.getEnvNumber('PROCESSING_BATCH_SIZE', 10),
          maxConcurrentRequests: this.getEnvNumber('PROCESSING_MAX_CONCURRENT', 5),
          timeoutMs: this.getEnvNumber('PROCESSING_TIMEOUT_MS', 30000),
          retry: {
            maxRetries: this.getEnvNumber('PROCESSING_RETRY_MAX', 3),
            backoffMs: this.getEnvNumber('PROCESSING_RETRY_BACKOFF_MS', 1000)
          },
          fileExtensions: this.getEnvArray('PROCESSING_FILE_EXTENSIONS', [
            '.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.cpp', '.c', '.h', '.hpp',
            '.cs', '.php', '.rb', '.go', '.rs', '.swift', '.kt', '.scala', '.dart',
            '.json', '.yaml', '.yml', '.xml', '.toml', '.ini', '.cfg', '.properties'
          ])
        },
        logging: {
          level: (this.getEnvString('LOG_LEVEL', 'info') as 'debug' | 'info' | 'warn' | 'error') ?? 'info',
          enableMetrics: this.getEnvBoolean('LOG_ENABLE_METRICS', true),
          enablePerformanceTracking: this.getEnvBoolean('LOG_ENABLE_PERFORMANCE', true),
          maxLogEntries: this.getEnvNumber('LOG_MAX_ENTRIES', 1000)
        },
        environment: (this.getEnvString('NODE_ENV', 'development') as 'development' | 'staging' | 'production') ?? 'development'
      };

      // Validate with Zod
      const result = AppConfigSchema.safeParse(config);
      if (!result.success) {
        this.validationErrors = result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`);
        console.warn('Configuration validation errors:', this.validationErrors);
      }

      return result.success ? result.data : AppConfigSchema.parse({
        memory: {},
        github: { rateLimit: {}, retry: {} },
        llm: { providers: {} },
        processing: { retry: {} },
        logging: {},
      });
    } catch (error) {
      console.error('Failed to load configuration:', error);
      return AppConfigSchema.parse({});
    }
  }

  private getLLMProviderConfig(prefix: string) {
    const apiKey = this.getEnvString(`${prefix}_API_KEY`);
    if (!apiKey) return undefined;

    return {
      apiKey,
      model: this.getEnvString(`${prefix}_MODEL`) ?? 'gpt-4',
      maxTokens: this.getEnvNumber(`${prefix}_MAX_TOKENS`, 2000),
      temperature: this.getEnvNumber(`${prefix}_TEMPERATURE`, 0.7)
    };
  }

  private getEnvString(key: string, defaultValue?: string): string | undefined {
    return typeof process !== 'undefined' ? process.env[key] : defaultValue;
  }

  private getEnvNumber(key: string, defaultValue: number): number {
    const value = this.getEnvString(key);
    return value ? parseInt(value, 10) || defaultValue : defaultValue;
  }

  private getEnvBoolean(key: string, defaultValue: boolean): boolean {
    const value = this.getEnvString(key);
    return value ? value.toLowerCase() === 'true' : defaultValue;
  }

  private getEnvArray(key: string, defaultValue: string[]): string[] {
    const value = this.getEnvString(key);
    return value ? value.split(',').map(s => s.trim()) : defaultValue;
  }

  /**
   * Validate environment configuration
   */
  private validateEnvironment(): void {
    const warnings: string[] = [];

    // Check for required API keys
    if (!this.config.github.token) {
      warnings.push('GitHub token not provided - rate limits will be lower');
    }

    const hasAnyLLMProvider = Object.values(this.config.llm.providers)
      .some(provider => provider?.apiKey);
    
    if (!hasAnyLLMProvider) {
      warnings.push('No LLM provider API keys configured - AI features disabled');
    }

    // Check memory limits
    if (this.config.memory.maxMemoryMB < 256) {
      warnings.push('Memory limit is very low - may cause performance issues');
    }

    if (warnings.length > 0) {
      console.warn('Configuration warnings:', warnings);
    }
  }

  /**
   * Get configuration values
   */
  public getConfiguration(): AppConfig {
    return this.config;
  }

  public get memory(): MemoryConfig {
    return this.config.memory;
  }

  public get github(): GitHubConfig {
    return this.config.github;
  }

  public get llm(): LLMConfig {
    return this.config.llm;
  }

  public get processing(): ProcessingConfig {
    return this.config.processing;
  }

  public get logging(): LoggingConfig {
    return this.config.logging;
  }

  public get environment(): string {
    return this.config.environment;
  }

  public get isDevelopment(): boolean {
    return this.config.environment === 'development';
  }

  public get isProduction(): boolean {
    return this.config.environment === 'production';
  }

  /**
   * Get validation errors
   */
  public getValidationErrors(): string[] {
    return [...this.validationErrors];
  }

  /**
   * Update configuration at runtime
   */
  public updateConfig(updates: Partial<AppConfig>): void {
    try {
      const newConfig = { ...this.config, ...updates };
      const result = AppConfigSchema.safeParse(newConfig);
      if (result.success) {
        this.config = result.data;
      } else {
        throw new Error(`Invalid configuration: ${result.error.errors.map(e => e.message).join(', ')}`);
      }
    } catch (error) {
      console.error('Failed to update configuration:', error);
      throw error;
    }
  }
}

// Export singleton instance
export const config = ConfigService.getInstance();

================
File: src/config/language-config.ts
================
/**
 * Language-specific configuration and built-ins
 * Centralized configuration to eliminate hardcoded values
 */

export interface LanguageConfig {
  name: string;
  extensions: string[];
  builtinFunctions: Set<string>;
  builtinTypes: Set<string>;
  commentPatterns: {
    singleLine: string[];
    multiLineStart: string[];
    multiLineEnd: string[];
  };
  importPatterns: {
    import: RegExp[];
    fromImport: RegExp[];
    require: RegExp[];
  };

}

// Python built-in functions and types
const PYTHON_BUILTINS = new Set([
  // Core built-ins
  'int', 'str', 'float', 'bool', 'list', 'dict', 'set', 'tuple',
  'len', 'range', 'enumerate', 'zip', 'map', 'filter', 'sorted',
  'sum', 'min', 'max', 'abs', 'round', 'all', 'any', 'hasattr',
  'getattr', 'setattr', 'isinstance', 'issubclass', 'type',
  'print', 'input', 'open', 'format', 'join', 'split', 'strip',
  'replace', 'upper', 'lower', 'append', 'extend', 'insert',
  'remove', 'pop', 'clear', 'copy', 'update', 'keys', 'values',
  'items', 'get', 'add', 'discard', 'union', 'intersection',
  'difference', 'locals', 'globals', 'vars', 'dir', 'help', 'id', 'hash',
  'ord', 'chr', 'bin', 'oct', 'hex', 'divmod', 'pow', 'exec',
  'eval', 'compile', 'next', 'iter', 'reversed', 'slice',
  
  // String methods
  'endswith', 'startswith', 'find', 'rfind', 'index', 'rindex',
  'count', 'encode', 'decode', 'capitalize', 'title', 'swapcase',
  'center', 'ljust', 'rjust', 'zfill', 'expandtabs', 'splitlines',
  'partition', 'rpartition', 'translate', 'maketrans', 'casefold',
  'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier',
  'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper',
  'lstrip', 'rstrip', 'removeprefix', 'removesuffix',
  
  // List/sequence methods
  'sort', 'reverse', 'count', 'index',
  
  // Dictionary methods
  'setdefault', 'popitem', 'fromkeys',
  
  // Set methods
  'difference_update', 'intersection_update', 'symmetric_difference',
  'symmetric_difference_update', 'isdisjoint', 'issubset', 'issuperset',
  
  // Common exceptions
  'ValueError', 'TypeError', 'KeyError', 'IndexError', 'AttributeError',
  'ImportError', 'ModuleNotFoundError', 'FileNotFoundError',
  'ConnectionError', 'HTTPException', 'RuntimeError', 'OSError',
  'Exception', 'BaseException', 'StopIteration', 'GeneratorExit'
]);

const PYTHON_LIBRARY_FUNCTIONS = new Set([
  // Date/time methods
  'now', 'today', 'fromisoformat', 'isoformat', 'astimezone', 
  'strftime', 'strptime', 'timestamp', 'weekday', 'isoweekday',
  'date', 'time', 'timetz', 'utctimetuple', 'timetuple',
    
  // Random
  'random', 'choice', 'randint', 'shuffle',
  
  // Logging methods
  'debug', 'info', 'warning', 'error', 'critical', 'exception',
  'getLogger', 'basicConfig', 'StreamHandler',
  
  // Environment
  'load_dotenv', 'getenv', 'dirname', 'abspath', 'join', 'exists', 'run',
  
  // Database/ORM methods
  'find', 'find_one', 'update_one', 'insert_one', 'delete_one',
  'aggregate', 'bulk_write', 'to_list', 'sort', 'limit', 'close',
  'ObjectId', 'UpdateOne', 'AsyncIOMotorClient', 'command',
  
  // Pydantic/FastAPI
  'Field', 'validator', 'field_validator', 'model_dump', 'model_dump_json',
  'FastAPI', 'HTTPException', 'add_middleware', 'include_router',
  
  // Threading/async
  'Lock', 'RLock', 'Semaphore', 'Event', 'Condition', 'Barrier',
  'sleep', 'gather', 'create_task', 'run_until_complete',
  
  // Collections
  'defaultdict', 'Counter', 'OrderedDict', 'deque', 'namedtuple',
  
  // Math/statistics
  'mean', 'median', 'mode', 'stdev', 'variance', 'sqrt', 'pow',
  'sin', 'cos', 'tan', 'log', 'exp', 'ceil', 'floor',
  
  // UUID
  'uuid4', 'uuid1', 'uuid3', 'uuid5',
  
  // URL/HTTP
  'quote', 'unquote', 'quote_plus', 'unquote_plus', 'urlencode',
  
  // JSON
  'loads', 'dumps', 'load', 'dump',
  
  // Regex
  'match', 'search', 'findall', 'finditer', 'sub', 'subn', 'compile',
  
  // AI/ML libraries
  'AsyncAzureOpenAI', 'AzureOpenAI', 'OpenAI', 'wrap_openai', 'create'
]);

// JavaScript built-in functions and types
const JAVASCRIPT_BUILTINS = new Set([
  // Global functions
  'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'decodeURI', 'decodeURIComponent',
  'encodeURI', 'encodeURIComponent', 'eval', 'setTimeout', 'setInterval',
  'clearTimeout', 'clearInterval', 'console', 'alert', 'confirm', 'prompt',
  
  // Object methods
  'toString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
  
  // Array methods
  'push', 'pop', 'shift', 'unshift', 'slice', 'splice', 'concat', 'join',
  'reverse', 'sort', 'indexOf', 'lastIndexOf', 'forEach', 'map', 'filter',
  'reduce', 'reduceRight', 'every', 'some', 'find', 'findIndex', 'includes',
  
  // String methods
  'charAt', 'charCodeAt', 'concat', 'indexOf', 'lastIndexOf', 'localeCompare',
  'match', 'replace', 'search', 'slice', 'split', 'substring', 'toLowerCase',
  'toUpperCase', 'trim', 'padStart', 'padEnd',
  
  // Math
  'abs', 'ceil', 'floor', 'round', 'max', 'min', 'pow', 'sqrt', 'random',
  
  // Date
  'getTime', 'getFullYear', 'getMonth', 'getDate', 'getDay', 'getHours',
  'getMinutes', 'getSeconds', 'getMilliseconds', 'toISOString', 'toDateString',
  
  // Promise/async
  'then', 'catch', 'finally', 'resolve', 'reject', 'all', 'race',

  // JSON
  'parse', 'stringify',
  
  // Types
  'Object', 'Array', 'String', 'Number', 'Boolean', 'Function', 'Date',
  'RegExp', 'Error', 'Promise', 'Map', 'Set', 'WeakMap', 'WeakSet'
]);

// TypeScript built-ins (extends JavaScript)
const TYPESCRIPT_BUILTINS = new Set([
  ...JAVASCRIPT_BUILTINS,
  // TypeScript specific
  'Partial', 'Required', 'Readonly', 'Pick', 'Omit', 'Exclude', 'Extract',
  'Record', 'Parameters', 'ConstructorParameters', 'ReturnType',
  'InstanceType', 'ThisParameterType', 'OmitThisParameter', 'ThisType'
]);

// Centralized ignore patterns
export const IGNORE_PATTERNS = new Set([
  // Version Control
  '.git', '.svn', '.hg',
  
  // Package Managers & Dependencies
  'node_modules', 'bower_components', 'jspm_packages', 'vendor', 'deps',
  
  // Python Virtual Environments & Cache
  'venv', 'env', '.venv', '.env', 'envs', 'virtualenv', '__pycache__',
  '.pytest_cache', '.mypy_cache', '.tox',
  
  // Build & Distribution Directories
  'build', 'dist', 'out', 'target', 'bin', 'obj', '.gradle', '_build',
  
  // IDE & Editor Directories
  '.vs', '.vscode', '.idea', '.eclipse', '.settings',
  
  // Temporary & Log Directories
  'tmp', '.tmp', 'temp', 'logs', 'log',
  
  // Coverage & Testing
  'coverage', '.coverage', 'htmlcov', '.nyc_output',
  
  // OS & System
  '.DS_Store', 'Thumbs.db',
  
  // Documentation Build Output
  '_site', '.docusaurus',
  
  // Cache Directories
  '.cache', '.parcel-cache', '.next', '.nuxt'
]);

// Language configurations
export const LANGUAGE_CONFIGS: Record<string, LanguageConfig> = {
  python: {
    name: 'Python',
    extensions: ['.py', '.pyx', '.pyi'],
    builtinFunctions: new Set([...PYTHON_BUILTINS, ...PYTHON_LIBRARY_FUNCTIONS]),
    builtinTypes: new Set(['int', 'str', 'float', 'bool', 'list', 'dict', 'set', 'tuple']),
    commentPatterns: {
      singleLine: ['#'],
      multiLineStart: ['"""', "'''"],
      multiLineEnd: ['"""', "'''"]
    },
    importPatterns: {
      import: [/^import\s+(.+)$/],
      fromImport: [/^from\s+(.+)\s+import\s+(.+)$/],
      require: []
    }
  },
  
  javascript: {
    name: 'JavaScript',
    extensions: ['.js', '.mjs', '.cjs', '.jsx'],
    builtinFunctions: JAVASCRIPT_BUILTINS,
    builtinTypes: new Set(['Object', 'Array', 'String', 'Number', 'Boolean', 'Function']),
    commentPatterns: {
      singleLine: ['//'],
      multiLineStart: ['/*'],
      multiLineEnd: ['*/']
    },
    importPatterns: {
      import: [/^import\s+.*\s+from\s+['"'](.+)['"]$/],
      fromImport: [],
      require: [/require\s*\(\s*['"'](.+)['"]\s*\)/]
    }
  },

  typescript: {
    name: 'TypeScript',
    extensions: ['.ts', '.tsx'],
    builtinFunctions: TYPESCRIPT_BUILTINS,
    builtinTypes: new Set(['Object', 'Array', 'String', 'Number', 'Boolean', 'Function']),
    commentPatterns: {
      singleLine: ['//'],
      multiLineStart: ['/*'],
      multiLineEnd: ['*/']
    },
    importPatterns: {
      import: [/^import\s+.*\s+from\s+['"'](.+)['"]$/],
      fromImport: [],
      require: [/require\s*\(\s*['"'](.+)['"]\s*\)/]
    }
  }
};

// Language abstraction interface
export interface ParsedDefinition {
  name: string;
  type: 'function' | 'class' | 'method' | 'interface' | 'enum' | 'decorator' | 'variable';
  startLine: number;
  endLine: number;
  parentClass?: string;
  decorators?: string[];
  baseClasses?: string[];
  parameters?: string[];
  returnType?: string;
}

export interface ImportInfo {
  localName: string;
  importedFrom: string;
  exportedName: string;
  importType: 'default' | 'named' | 'namespace' | 'dynamic';
}

export interface LanguageProcessor {
  name: string;
  extensions: string[];
  isBuiltinFunction(name: string): boolean;
  isBuiltinType(name: string): boolean;
  parseDefinitions(content: string, filePath: string): ParsedDefinition[];
  extractImports(content: string): ImportInfo[];
}

// Base language processor implementation
export abstract class BaseLanguageProcessor implements LanguageProcessor {
  protected config: LanguageConfig;

  constructor(config: LanguageConfig) {
    this.config = config;
  }

  get name(): string {
    return this.config.name;
  }

  get extensions(): string[] {
    return this.config.extensions;
  }

  isBuiltinFunction(name: string): boolean {
    return this.config.builtinFunctions.has(name);
  }

  isBuiltinType(name: string): boolean {
    return this.config.builtinTypes.has(name);
  }

  abstract parseDefinitions(content: string, filePath: string): ParsedDefinition[];
  abstract extractImports(content: string): ImportInfo[];
}

// Language processor factory
export class LanguageProcessorFactory {
  private static processors: Map<string, () => LanguageProcessor> = new Map();

  static register(language: string, factory: () => LanguageProcessor): void {
    this.processors.set(language, factory);
  }

  static create(language: string): LanguageProcessor | null {
    const factory = this.processors.get(language);
    return factory ? factory() : null;
  }

  static getConfig(language: string): LanguageConfig | null {
    return LANGUAGE_CONFIGS[language] || null;
  }

  static getSupportedLanguages(): string[] {
    return Object.keys(LANGUAGE_CONFIGS);
  }
}

// Utility functions for language detection
export const languageDetection = {
  detectFromExtension(filePath: string): string | null {
    const extension = filePath.substring(filePath.lastIndexOf('.')).toLowerCase();
    
    for (const [lang, config] of Object.entries(LANGUAGE_CONFIGS)) {
      if (config.extensions.includes(extension)) {
        return lang;
      }
    }
    
    return null;
  },

  detectFromContent(content: string): string | null {
    // Simple content-based detection
    if (content.includes('def ') && content.includes('import ')) {
      return 'python';
    }
    if (content.includes('function ') || content.includes('const ') || content.includes('let ')) {
      if (content.includes('interface ') || content.includes(': string')) {
        return 'typescript';
      }
      return 'javascript';
    }
    
    return null;
  }
};

================
File: src/core/graph/graph.ts
================
/**
 * Graph interfaces and types
 */

import { GraphNode, GraphRelationship, NodeProperties, RelationshipProperties } from './types.js';

export interface KnowledgeGraph {
  nodes: GraphNode[];
  relationships: GraphRelationship[];
  addNode(node: GraphNode): void;
  addRelationship(relationship: GraphRelationship): void;
}

export interface GraphProcessor<T> {
  process(graph: KnowledgeGraph, input: T): Promise<void>;
}

// Simple implementation of KnowledgeGraph
export class SimpleKnowledgeGraph implements KnowledgeGraph {
  nodes: GraphNode[] = [];
  relationships: GraphRelationship[] = [];

  addNode(node: GraphNode): void {
    this.nodes.push(node);
  }

  addRelationship(relationship: GraphRelationship): void {
    this.relationships.push(relationship);
  }
}

================
File: src/core/graph/query-engine.ts
================
import type { KnowledgeGraph, GraphNode, GraphRelationship } from './types.ts';

export interface QueryResult {
  nodes: GraphNode[];
  relationships: GraphRelationship[];
  data: Record<string, any>[];
}

export interface QueryOptions {
  limit?: number;
  offset?: number;
}

export class GraphQueryEngine {
  constructor(private graph: KnowledgeGraph) {}

  /**
   * Execute a simplified Cypher-like query against the knowledge graph
   */
  public executeQuery(cypher: string, options: QueryOptions = {}): QueryResult {
    const { limit = 100, offset = 0 } = options;
    
    try {
      const parsedQuery = this.parseCypher(cypher);
      
      switch (parsedQuery.type) {
        case 'MATCH':
          return this.executeMatchQuery(parsedQuery, limit, offset);
        case 'MATCH_WHERE':
          return this.executeWhereQuery(parsedQuery, limit, offset);
        case 'MATCH_PATH':
          return this.executePathQuery(parsedQuery, limit, offset);
        case 'MATCH_AGGREGATION':
          return this.executeAggregationQuery(parsedQuery, limit, offset);
        case 'MATCH_RELATIONSHIP':
          return this.executeRelationshipQuery(parsedQuery, limit, offset);
        default:
          throw new Error(`Unsupported query type: ${parsedQuery.type}`);
      }
    } catch (error) {
      console.error('Query execution failed:', error);
      return { nodes: [], relationships: [], data: [] };
    }
  }

  private parseCypher(cypher: string) {
    // Enhanced parsing with WHERE clause support
    const simpleMatchWithWherePattern = /MATCH\s+\((\w+):(\w+)(?:\s*\{([^}]*)\})?\)\s+WHERE\s+(.+?)\s+RETURN\s+(.+)/i;
    const whereMatch = cypher.match(simpleMatchWithWherePattern);
    
    if (whereMatch) {
      const [, variable, label, properties, whereClause, returnClause] = whereMatch;
      return {
        type: 'MATCH_WHERE',
        variable,
        label,
        properties: this.parseProperties(properties || ''),
        whereClause: whereClause.trim(),
        returnClause: returnClause.trim()
      };
    }

    // Variable-length relationship pattern: MATCH (a)-[:REL*1..3]->(b)
    const variableLengthPattern = /MATCH\s+\((\w+)(?::(\w+))?\)-\[:(\w+)\*(\d+)\.\.(\d+)\]->\((\w+)(?::(\w+))?\)\s+RETURN\s+(.+)/i;
    const varLenMatch = cypher.match(variableLengthPattern);
    
    if (varLenMatch) {
      const [, sourceVar, sourceLabel, relType, minDepth, maxDepth, targetVar, targetLabel, returnClause] = varLenMatch;
      return {
        type: 'MATCH_PATH',
        sourceVar,
        sourceLabel,
        relationshipType: relType,
        minDepth: parseInt(minDepth),
        maxDepth: parseInt(maxDepth),
        targetVar,
        targetLabel,
        returnClause: returnClause.trim()
      };
    }

    // Aggregation pattern: MATCH (n:Label) RETURN COUNT(n)
    const aggregationPattern = /MATCH\s+\((\w+):(\w+)(?:\s*\{([^}]*)\})?\)\s+RETURN\s+(COUNT|COLLECT|AVG|SUM)\(([^)]+)\)/i;
    const aggMatch = cypher.match(aggregationPattern);
    
    if (aggMatch) {
      const [, variable, label, properties, aggFunction, aggTarget] = aggMatch;
      return {
        type: 'MATCH_AGGREGATION',
        variable,
        label,
        properties: this.parseProperties(properties || ''),
        aggregationFunction: aggFunction.toUpperCase(),
        aggregationTarget: aggTarget.trim(),
        returnClause: `${aggFunction}(${aggTarget})`
      };
    }

    // Pattern: MATCH (n:Label {property: 'value'}) RETURN n.property
    const simpleMatchPattern = /MATCH\s+\((\w+):(\w+)(?:\s*\{([^}]*)\})?\)\s+RETURN\s+(.+)/i;
    const simpleMatch = cypher.match(simpleMatchPattern);
    
    if (simpleMatch) {
      const [, variable, label, properties, returnClause] = simpleMatch;
      return {
        type: 'MATCH',
        variable,
        label,
        properties: this.parseProperties(properties || ''),
        returnClause: returnClause.trim()
      };
    }

    // Pattern: MATCH (a)-[:RELATIONSHIP]->(b:Label) RETURN a, b
    const relationshipPattern = /MATCH\s+\((\w+)(?::(\w+))?\)-\[:(\w+)\]->\((\w+)(?::(\w+))?\)\s+RETURN\s+(.+)/i;
    const relMatch = cypher.match(relationshipPattern);
    
    if (relMatch) {
      const [, sourceVar, sourceLabel, relType, targetVar, targetLabel, returnClause] = relMatch;
      return {
        type: 'MATCH_RELATIONSHIP',
        sourceVar,
        sourceLabel,
        relationshipType: relType,
        targetVar,
        targetLabel,
        returnClause: returnClause.trim()
      };
    }

    throw new Error(`Cannot parse Cypher query: ${cypher}`);
  }

  private parseProperties(propString: string): Record<string, string> {
    const props: Record<string, string> = {};
    if (!propString.trim()) return props;

    // Simple property parsing: name: 'value', type: 'Function'
    const matches = propString.match(/(\w+):\s*['"]([^'"]*)['"]/g);
    if (matches) {
      matches.forEach(match => {
        const [, key, value] = match.match(/(\w+):\s*['"]([^'"]*)['"]/!) || [];
        if (key && value) {
          props[key] = value;
        }
      });
    }

    return props;
  }

  private executeMatchQuery(query: any, limit: number, offset: number): QueryResult {
    let matchingNodes = this.graph.nodes.filter(node => {
      // Match by label
      if (query.label && node.label !== query.label) {
        return false;
      }

      // Match by properties
      for (const [key, value] of Object.entries(query.properties)) {
        if (node.properties[key] !== value) {
          return false;
        }
      }

      return true;
    });

    // Apply pagination
    matchingNodes = matchingNodes.slice(offset, offset + limit);

    // Process return clause
    const data = matchingNodes.map(node => {
      const result: Record<string, any> = {};
      
      if (query.returnClause.includes(`${query.variable}.`)) {
        // Return specific properties: n.name, n.filePath
        const propertyMatches = query.returnClause.match(new RegExp(`${query.variable}\\.(\\w+)`, 'g'));
        if (propertyMatches) {
          propertyMatches.forEach((match: string) => {
            const prop = match.split('.')[1];
            result[prop] = node.properties[prop];
          });
        }
      } else if (query.returnClause === query.variable) {
        // Return entire node
        result.node = node;
      }

      return result;
    });

    return {
      nodes: matchingNodes,
      relationships: [],
      data
    };
  }

  private executeWhereQuery(query: any, limit: number, offset: number): QueryResult {
    let matchingNodes = this.graph.nodes.filter(node => {
      if (query.label && node.label !== query.label) return false;
      
      for (const [key, value] of Object.entries(query.properties)) {
        if (node.properties[key] !== value) return false;
      }
      
      return this.evaluateWhereClause(node, query.whereClause, query.variable);
    });

    matchingNodes = matchingNodes.slice(offset, offset + limit);
    
    const data = matchingNodes.map(node => {
      const result: Record<string, any> = {};
      if (query.returnClause.includes(`${query.variable}.`)) {
        const propertyMatches = query.returnClause.match(new RegExp(`${query.variable}\\.(\\w+)`, 'g'));
        if (propertyMatches) {
          propertyMatches.forEach((match: string) => {
            const prop = match.split('.')[1];
            result[prop] = node.properties[prop];
          });
        }
      } else if (query.returnClause === query.variable) {
        result.node = node;
      }
      return result;
    });

    return { nodes: matchingNodes, relationships: [], data };
  }

  private evaluateWhereClause(node: GraphNode, whereClause: string, variable: string): boolean {
    // Simple WHERE clause evaluation
    const containsPattern = new RegExp(`${variable}\\.(\\w+)\\s+CONTAINS\\s+['"]([^'"]*)['"]/i`);
    const containsMatch = whereClause.match(containsPattern);
    
    if (containsMatch) {
      const [, property, value] = containsMatch;
      const nodeValue = node.properties[property];
      return typeof nodeValue === 'string' && nodeValue.toLowerCase().includes(value.toLowerCase());
    }
    
    const equalsPattern = new RegExp(`${variable}\\.(\\w+)\\s*=\\s*['"]([^'"]*)['"]/i`);
    const equalsMatch = whereClause.match(equalsPattern);
    
    if (equalsMatch) {
      const [, property, value] = equalsMatch;
      return node.properties[property] === value;
    }
    
    return true;
  }

  private executePathQuery(query: any, limit: number, offset: number): QueryResult {
    // Use existing pathsBetween function from query.ts
    const sourceNodes = this.graph.nodes.filter(n => 
      !query.sourceLabel || n.label === query.sourceLabel
    );
    const targetNodes = this.graph.nodes.filter(n => 
      !query.targetLabel || n.label === query.targetLabel
    );

    const allResults: { source: GraphNode; target: GraphNode; path: GraphRelationship[] }[] = [];
    
    for (const source of sourceNodes.slice(0, 50)) { // Limit source nodes to avoid explosion
      for (const target of targetNodes.slice(0, 50)) {
        if (source.id === target.id) continue;
        
        const paths = this.findPaths(source.id, target.id, query.relationshipType, query.minDepth, query.maxDepth);
        paths.forEach(path => {
          allResults.push({ source, target, path });
        });
      }
    }

    const paginatedResults = allResults.slice(offset, offset + limit);
    
    const data = paginatedResults.map(({ source, target, path }) => {
      const result: Record<string, any> = {};
      if (query.returnClause.includes(query.sourceVar)) {
        result[query.sourceVar] = source;
      }
      if (query.returnClause.includes(query.targetVar)) {
        result[query.targetVar] = target;
      }
      result.pathLength = path.length;
      return result;
    });

    return {
      nodes: paginatedResults.flatMap(r => [r.source, r.target]),
      relationships: paginatedResults.flatMap(r => r.path),
      data
    };
  }

  private findPaths(sourceId: string, targetId: string, relType: string, minDepth: number, maxDepth: number): GraphRelationship[][] {
    const paths: GraphRelationship[][] = [];
    const visited = new Set<string>();
    
    const dfs = (currentId: string, currentPath: GraphRelationship[], depth: number) => {
      if (depth > maxDepth) return;
      if (currentId === targetId && depth >= minDepth) {
        paths.push([...currentPath]);
        return;
      }
      
      visited.add(currentId);
      
      const outgoingRels = this.graph.relationships.filter(r => 
        r.source === currentId && r.type === relType && !visited.has(r.target)
      );
      
      for (const rel of outgoingRels) {
        dfs(rel.target, [...currentPath, rel], depth + 1);
      }
      
      visited.delete(currentId);
    };
    
    dfs(sourceId, [], 0);
    return paths.slice(0, 10); // Limit paths to prevent explosion
  }

  private executeAggregationQuery(query: any, _limit: number, _offset: number): QueryResult {
    let matchingNodes = this.graph.nodes.filter(node => {
      if (query.label && node.label !== query.label) return false;
      
      for (const [key, value] of Object.entries(query.properties)) {
        if (node.properties[key] !== value) return false;
      }
      
      return true;
    });

    let aggregatedValue: any;
    
    switch (query.aggregationFunction) {
      case 'COUNT':
        aggregatedValue = matchingNodes.length;
        break;
      case 'COLLECT':
        const targetProperty = query.aggregationTarget.includes('.') 
          ? query.aggregationTarget.split('.')[1] 
          : 'name';
        aggregatedValue = matchingNodes.map(n => n.properties[targetProperty]).filter(Boolean);
        break;
      default:
        aggregatedValue = matchingNodes.length;
    }

    return {
      nodes: [],
      relationships: [],
      data: [{ [query.returnClause]: aggregatedValue }]
    };
  }

  private executeRelationshipQuery(query: any, limit: number, offset: number): QueryResult {
    const results: { source: GraphNode; target: GraphNode; relationship: GraphRelationship }[] = [];

    // Find all relationships of the specified type
    const matchingRels = this.graph.relationships.filter(rel => 
      rel.type === query.relationshipType
    );

    for (const rel of matchingRels) {
      const sourceNode = this.graph.nodes.find(n => n.id === rel.source);
      const targetNode = this.graph.nodes.find(n => n.id === rel.target);

      if (!sourceNode || !targetNode) continue;

      // Apply label filters
      if (query.sourceLabel && sourceNode.label !== query.sourceLabel) continue;
      if (query.targetLabel && targetNode.label !== query.targetLabel) continue;

      results.push({ source: sourceNode, target: targetNode, relationship: rel });
    }

    // Apply pagination
    const paginatedResults = results.slice(offset, offset + limit);

    // Process return clause
    const data = paginatedResults.map(({ source, target }) => {
      const result: Record<string, any> = {};
      
      if (query.returnClause.includes(query.sourceVar)) {
        result[query.sourceVar] = source;
      }
      if (query.returnClause.includes(query.targetVar)) {
        result[query.targetVar] = target;
      }

      return result;
    });

    return {
      nodes: paginatedResults.flatMap(r => [r.source, r.target]),
      relationships: paginatedResults.map(r => r.relationship),
      data
    };
  }

  /**
   * Test the query engine with sample queries (for development/debugging)
   */
  public testQueries(): { query: string; result: any; success: boolean }[] {
    const testCases = [
      "MATCH (f:Function) RETURN COUNT(f)",
      "MATCH (c:Class) WHERE c.name CONTAINS 'Service' RETURN c.name",
      "MATCH (a:Function)-[:CALLS*1..2]->(b:Function) RETURN a.name, b.name",
      "MATCH (f:File)-[:CONTAINS]->(c:Class) RETURN f.name, COUNT(c)",
      "MATCH (m:Method) WHERE m.name CONTAINS 'get' RETURN COLLECT(m.name)"
    ];

    return testCases.map(query => {
      try {
        const result = this.executeQuery(query, { limit: 5 });
        return { query, result, success: true };
      } catch (error) {
        return { 
          query, 
          result: error instanceof Error ? error.message : 'Unknown error', 
          success: false 
        };
      }
    });
  }

  /**
   * Get query statistics
   */
  public getStats(): { nodeCount: number; relationshipCount: number; nodeTypes: string[]; relationshipTypes: string[] } {
    const nodeTypes = [...new Set(this.graph.nodes.map(n => n.label))];
    const relationshipTypes = [...new Set(this.graph.relationships.map(r => r.type))];

    return {
      nodeCount: this.graph.nodes.length,
      relationshipCount: this.graph.relationships.length,
      nodeTypes,
      relationshipTypes
    };
  }

  /**
   * Find nodes by text search
   */
  public searchNodes(searchTerm: string, nodeType?: string): GraphNode[] {
    const lowerSearch = searchTerm.toLowerCase();
    
    return this.graph.nodes.filter(node => {
      if (nodeType && node.label !== nodeType) return false;
      
      // Search in node properties
      const searchableText = [
        node.properties.name,
        node.properties.filePath,
        node.properties.qualifiedName
      ].filter(Boolean).join(' ').toLowerCase();
      
      return searchableText.includes(lowerSearch);
    });
  }

  /**
   * Get all relationships for a node
   */
  public getNodeRelationships(nodeId: string): { incoming: GraphRelationship[]; outgoing: GraphRelationship[] } {
    const incoming = this.graph.relationships.filter(r => r.target === nodeId);
    const outgoing = this.graph.relationships.filter(r => r.source === nodeId);
    
    return { incoming, outgoing };
  }
}

================
File: src/core/graph/query.ts
================
import type { KnowledgeGraph, GraphNode, GraphRelationship } from './types.ts';

export type NodeFilter = {
  idEquals?: string | string[];
  labelIn?: Array<GraphNode['label']>;
  nameContains?: string;
  pathContains?: string;
  props?: Record<string, unknown>;
};

export type RelFilter = {
  typeIn?: Array<GraphRelationship['type']>;
  fromIdIn?: string[];
  toIdIn?: string[];
};

export type TraverseOptions = {
  depth?: number;
  direction?: 'out' | 'in' | 'both';
  relTypeIn?: Array<GraphRelationship['type']>;
  limitNodes?: number;
};

export type PathOptions = {
  relTypeIn?: Array<GraphRelationship['type']>;
  maxDepth?: number;
  maxPaths?: number;
};

export interface GraphIndex {
  nodeById: Map<string, GraphNode>;
  outAdjacency: Map<string, GraphRelationship[]>;
  inAdjacency: Map<string, GraphRelationship[]>;
}

export function indexGraph(graph: KnowledgeGraph): GraphIndex {
  const nodeById = new Map<string, GraphNode>();
  const outAdjacency = new Map<string, GraphRelationship[]>();
  const inAdjacency = new Map<string, GraphRelationship[]>();

  for (const node of graph.nodes) {
    nodeById.set(node.id, node);
  }

  for (const rel of graph.relationships) {
    if (!outAdjacency.has(rel.source)) outAdjacency.set(rel.source, []);
    if (!inAdjacency.has(rel.target)) inAdjacency.set(rel.target, []);
    outAdjacency.get(rel.source)!.push(rel);
    inAdjacency.get(rel.target)!.push(rel);
  }

  return { nodeById, outAdjacency, inAdjacency };
}

export function queryNodes(graph: KnowledgeGraph, filter: NodeFilter): GraphNode[] {
  const idSet = new Set(typeof filter.idEquals === 'string' ? [filter.idEquals] : filter.idEquals || []);
  const nameNeedle = filter.nameContains?.toLowerCase();
  const pathNeedle = filter.pathContains?.toLowerCase();

  return graph.nodes.filter((node) => {
    if (idSet.size > 0 && !idSet.has(node.id)) return false;
    if (filter.labelIn && filter.labelIn.length > 0 && !filter.labelIn.includes(node.label)) return false;

    if (nameNeedle) {
      const name = String(node.properties?.name || '').toLowerCase();
      if (!name.includes(nameNeedle)) return false;
    }

    if (pathNeedle) {
      const path = String(node.properties?.path || node.properties?.filePath || '').toLowerCase();
      if (!path.includes(pathNeedle)) return false;
    }

    if (filter.props) {
      for (const [key, expected] of Object.entries(filter.props)) {
        if ((node.properties as Record<string, unknown>)?.[key] !== expected) return false;
      }
    }

    return true;
  });
}

export function queryRelationships(graph: KnowledgeGraph, filter: RelFilter): GraphRelationship[] {
  const typeSet = new Set(filter.typeIn || []);
  const fromSet = new Set(filter.fromIdIn || []);
  const toSet = new Set(filter.toIdIn || []);

  return graph.relationships.filter((rel) => {
    if (typeSet.size > 0 && !typeSet.has(rel.type)) return false;
    if (fromSet.size > 0 && !fromSet.has(rel.source)) return false;
    if (toSet.size > 0 && !toSet.has(rel.target)) return false;
    return true;
  });
}

export function neighborsOf(
  graph: KnowledgeGraph,
  seedNodeIds: string[],
  options: TraverseOptions = {}
): KnowledgeGraph {
  const { depth = 1, direction = 'both', relTypeIn, limitNodes = 500 } = options;
  const { outAdjacency, inAdjacency, nodeById } = indexGraph(graph);

  const allowedRelTypes = relTypeIn ? new Set(relTypeIn) : null;
  const visitedNodes = new Set<string>(seedNodeIds);
  const resultNodes = new Set<string>(seedNodeIds);
  const resultRels: GraphRelationship[] = [];

  let frontier = [...seedNodeIds];
  let currentDepth = 0;

  while (frontier.length > 0 && currentDepth < depth && resultNodes.size < limitNodes) {
    const nextFrontier: string[] = [];
    for (const nodeId of frontier) {
      if (direction === 'out' || direction === 'both') {
        const outRels = outAdjacency.get(nodeId) || [];
        for (const rel of outRels) {
          if (allowedRelTypes && !allowedRelTypes.has(rel.type)) continue;
          resultRels.push(rel);
          if (!visitedNodes.has(rel.target)) {
            visitedNodes.add(rel.target);
            resultNodes.add(rel.target);
            nextFrontier.push(rel.target);
            if (resultNodes.size >= limitNodes) break;
          }
        }
      }
      if (resultNodes.size >= limitNodes) break;
      if (direction === 'in' || direction === 'both') {
        const inRels = inAdjacency.get(nodeId) || [];
        for (const rel of inRels) {
          if (allowedRelTypes && !allowedRelTypes.has(rel.type)) continue;
          resultRels.push(rel);
          if (!visitedNodes.has(rel.source)) {
            visitedNodes.add(rel.source);
            resultNodes.add(rel.source);
            nextFrontier.push(rel.source);
            if (resultNodes.size >= limitNodes) break;
          }
        }
      }
      if (resultNodes.size >= limitNodes) break;
    }
    frontier = nextFrontier;
    currentDepth++;
  }

  const nodes = Array.from(resultNodes).map((id) => nodeById.get(id)!).filter(Boolean);
  const relationships = dedupeRelationships(resultRels);
  return { nodes, relationships };
}

export function pathsBetween(
  graph: KnowledgeGraph,
  fromId: string,
  toId: string,
  options: PathOptions = {}
): KnowledgeGraph {
  const { maxDepth = 6, relTypeIn, maxPaths = 3 } = options;
  const { outAdjacency, nodeById } = indexGraph(graph);
  const allowedRelTypes = relTypeIn ? new Set(relTypeIn) : null;

  const queue: Array<{ nodeId: string; path: GraphRelationship[] }> = [{ nodeId: fromId, path: [] }];
  const visited = new Set<string>([fromId]);
  const foundPaths: GraphRelationship[][] = [];

  while (queue.length > 0 && foundPaths.length < maxPaths) {
    const { nodeId, path } = queue.shift()!;
    if (path.length > maxDepth) continue;
    if (nodeId === toId) {
      foundPaths.push(path);
      continue;
    }
    const outRels = outAdjacency.get(nodeId) || [];
    for (const rel of outRels) {
      if (allowedRelTypes && !allowedRelTypes.has(rel.type)) continue;
      const nextId = rel.target;
      if (!visited.has(nextId)) {
        visited.add(nextId);
        queue.push({ nodeId: nextId, path: [...path, rel] });
      }
    }
  }

  const relSet = new Set<GraphRelationship>();
  for (const p of foundPaths) for (const r of p) relSet.add(r);
  const nodeSet = new Set<string>();
  for (const r of relSet) {
    nodeSet.add(r.source);
    nodeSet.add(r.target);
  }

  const nodes = Array.from(nodeSet).map((id) => nodeById.get(id)!).filter(Boolean);
  const relationships = dedupeRelationships(Array.from(relSet));
  return { nodes, relationships };
}

export function subgraphFromNodesAndRels(graph: KnowledgeGraph, nodeIds: string[], rels: GraphRelationship[]): KnowledgeGraph {
  const nodeIdSet = new Set(nodeIds);
  const nodes = graph.nodes.filter((n) => nodeIdSet.has(n.id));
  const relationships = dedupeRelationships(rels);
  return { nodes, relationships };
}

export function summarizeSubgraph(subgraph: KnowledgeGraph): string {
  const counts = subgraph.nodes.reduce<Record<string, number>>((acc, n) => {
    acc[n.label] = (acc[n.label] || 0) + 1;
    return acc;
  }, {});
  const relCounts = subgraph.relationships.reduce<Record<string, number>>((acc, r) => {
    acc[r.type] = (acc[r.type] || 0) + 1;
    return acc;
  }, {});
  const parts: string[] = [];
  parts.push(`Nodes: ${subgraph.nodes.length} (${Object.entries(counts).map(([k, v]) => `${k}:${v}`).join(', ') || 'none'})`);
  parts.push(`Relationships: ${subgraph.relationships.length} (${Object.entries(relCounts).map(([k, v]) => `${k}:${v}`).join(', ') || 'none'})`);
  const examples = subgraph.nodes.slice(0, 5).map((n) => `${n.label}:${String(n.properties?.name || n.id)}`);
  if (examples.length > 0) parts.push(`Examples: ${examples.join(', ')}`);
  return parts.join('\n');
}

function dedupeRelationships(rels: GraphRelationship[]): GraphRelationship[] {
  const seen = new Set<string>();
  const out: GraphRelationship[] = [];
  for (const r of rels) {
    const key = `${r.type}|${r.source}|${r.target}`;
    if (!seen.has(key)) {
      seen.add(key);
      out.push(r);
    }
  }
  return out;
}

================
File: src/core/graph/trie.ts
================
interface TrieNode {
  children: Map<string, TrieNode>;
  definitions: FunctionDefinition[];
  isEndOfWord: boolean;
}

interface FunctionDefinition {
  nodeId: string;
  qualifiedName: string;
  filePath: string;
  functionName: string;
  type: 'function' | 'method' | 'class' | 'interface' | 'enum';
  startLine?: number;
  endLine?: number;
}

export class FunctionRegistryTrie {
  private root: TrieNode;
  private allDefinitions: Map<string, FunctionDefinition>;
  // Performance optimization: Index for fast lookups
  private functionNameIndex: Map<string, FunctionDefinition[]>;
  private filePathIndex: Map<string, FunctionDefinition[]>;

  constructor() {
    this.root = {
      children: new Map(),
      definitions: [],
      isEndOfWord: false
    };
    this.allDefinitions = new Map();
    this.functionNameIndex = new Map();
    this.filePathIndex = new Map();
  }

  /**
   * Add a function definition to the trie with optimized indexing
   * @param definition The function definition to add
   */
  addDefinition(definition: FunctionDefinition): void {
    const parts = definition.qualifiedName.split('.');
    let currentNode = this.root;

    // Build the trie path
    for (const part of parts) {
      if (!currentNode.children.has(part)) {
        currentNode.children.set(part, {
          children: new Map(),
          definitions: [],
          isEndOfWord: false
        });
      }
      currentNode = currentNode.children.get(part)!;
    }

    // Mark end of word and store definition
    currentNode.isEndOfWord = true;
    currentNode.definitions.push(definition);
    
    // Store in flat map for quick access
    this.allDefinitions.set(definition.nodeId, definition);
    
    // Update indexes for performance
    this.updateIndexes(definition);
  }

  /**
   * Update performance indexes when adding definitions
   */
  private updateIndexes(definition: FunctionDefinition): void {
    // Function name index
    if (!this.functionNameIndex.has(definition.functionName)) {
      this.functionNameIndex.set(definition.functionName, []);
    }
    this.functionNameIndex.get(definition.functionName)!.push(definition);
    
    // File path index
    if (!this.filePathIndex.has(definition.filePath)) {
      this.filePathIndex.set(definition.filePath, []);
    }
    this.filePathIndex.get(definition.filePath)!.push(definition);
  }

  /**
   * Find all definitions that end with the given name (OPTIMIZED)
   * This is the key method for heuristic resolution
   * @param name The function name to search for
   * @returns Array of matching definitions
   */
  findEndingWith(name: string): FunctionDefinition[] {
    // Use index for O(1) lookup instead of O(n) tree traversal
    return this.functionNameIndex.get(name) || [];
  }

  /**
   * Get exact definition by qualified name
   * @param qualifiedName The full qualified name
   * @returns The definition if found
   */
  getExactMatch(qualifiedName: string): FunctionDefinition[] {
    const parts = qualifiedName.split('.');
    let currentNode = this.root;

    for (const part of parts) {
      if (!currentNode.children.has(part)) {
        return [];
      }
      currentNode = currentNode.children.get(part)!;
    }

    return currentNode.isEndOfWord ? currentNode.definitions : [];
  }

  /**
   * Find definitions in the same file (OPTIMIZED)
   * @param filePath The file path to search in
   * @param functionName The function name to find
   * @returns Array of matching definitions in the same file
   */
  findInSameFile(filePath: string, functionName: string): FunctionDefinition[] {
    // Use file path index for faster lookup
    const fileDefinitions = this.filePathIndex.get(filePath) || [];
    return fileDefinitions.filter(def => def.functionName === functionName);
  }

  /**
   * Get all definitions in a specific file (NEW - OPTIMIZED)
   * @param filePath The file path to search in
   * @returns Array of all definitions in the file
   */
  getDefinitionsInFile(filePath: string): FunctionDefinition[] {
    return this.filePathIndex.get(filePath) || [];
  }

  /**
   * Find definitions by type (NEW - OPTIMIZED)
   * @param type The definition type to search for
   * @returns Array of matching definitions
   */
  findByType(type: FunctionDefinition['type']): FunctionDefinition[] {
    return Array.from(this.allDefinitions.values()).filter(def => def.type === type);
  }

  /**
   * Get all definitions for debugging/stats
   * @returns All stored definitions
   */
  getAllDefinitions(): FunctionDefinition[] {
    return Array.from(this.allDefinitions.values());
  }

  /**
   * Get statistics about the trie (NEW)
   * @returns Trie statistics
   */
  getStatistics(): {
    totalDefinitions: number;
    definitionsByType: Record<string, number>;
    fileCount: number;
    uniqueFunctionNames: number;
  } {
    const definitionsByType: Record<string, number> = {};
    
    for (const definition of this.allDefinitions.values()) {
      definitionsByType[definition.type] = (definitionsByType[definition.type] || 0) + 1;
    }
    
    return {
      totalDefinitions: this.allDefinitions.size,
      definitionsByType,
      fileCount: this.filePathIndex.size,
      uniqueFunctionNames: this.functionNameIndex.size
    };
  }

  /**
   * Calculate import distance between two file paths
   * Lower score = closer/better match
   * @param callerPath Path of the calling file
   * @param candidatePath Path of the candidate definition file
   * @returns Distance score (lower is better)
   */
  static calculateImportDistance(callerPath: string, candidatePath: string): number {
    const callerParts = callerPath.split('/').filter(p => p !== '');
    const candidateParts = candidatePath.split('/').filter(p => p !== '');

    // Find common prefix length
    let commonPrefixLength = 0;
    const minLength = Math.min(callerParts.length, candidateParts.length);
    
    for (let i = 0; i < minLength; i++) {
      if (callerParts[i] === candidateParts[i]) {
        commonPrefixLength++;
      } else {
        break;
      }
    }

    // Calculate base distance
    const maxLength = Math.max(callerParts.length, candidateParts.length);
    let distance = maxLength - commonPrefixLength;

    // Bonus for sibling modules (same parent directory)
    if (commonPrefixLength === Math.min(callerParts.length, candidateParts.length) - 1) {
      distance -= 1; // Sibling bonus
    }

    return distance;
  }

  /**
   * Clear all data
   */
  clear(): void {
    this.root = {
      children: new Map(),
      definitions: [],
      isEndOfWord: false
    };
    this.allDefinitions.clear();
    this.functionNameIndex.clear();
    this.filePathIndex.clear();
  }

  /**
   * Remove definitions from a specific file (NEW - for incremental updates)
   * @param filePath The file path to remove definitions for
   */
  removeFileDefinitions(filePath: string): void {
    const definitions = this.filePathIndex.get(filePath);
    if (!definitions) return;

    // Remove from all indexes
    for (const definition of definitions) {
      this.allDefinitions.delete(definition.nodeId);
      
      // Remove from function name index
      const functionDefs = this.functionNameIndex.get(definition.functionName);
      if (functionDefs) {
        const index = functionDefs.indexOf(definition);
        if (index > -1) {
          functionDefs.splice(index, 1);
        }
        if (functionDefs.length === 0) {
          this.functionNameIndex.delete(definition.functionName);
        }
      }
    }

    // Remove from file path index
    this.filePathIndex.delete(filePath);

    // TODO: Clean up the trie structure (complex operation, can be done later)
    // For now, we'll leave empty nodes in the trie for performance
  }
}

export type { FunctionDefinition };

================
File: src/core/graph/types.ts
================
export type NodeLabel = 
  | 'Project' 
  | 'Package' 
  | 'Module' 
  | 'Folder' 
  | 'File' 
  | 'Class' 
  | 'Function' 
  | 'Method' 
  | 'Variable'
  | 'Interface'
  | 'Enum'
  | 'Decorator'
  | 'Import'
  | 'Type'
  | 'CodeElement';

export interface GraphNode {
  id: string;
  label: NodeLabel;
  properties: NodeProperties;
}

export type RelationshipType = 
  | 'CONTAINS' 
  | 'CALLS' 
  | 'INHERITS' 
  | 'OVERRIDES' 
  | 'IMPORTS'
  | 'USES'
  | 'DEFINES'
  | 'DECORATES'
  | 'IMPLEMENTS'
  | 'ACCESSES'
  | 'EXTENDS'
  | 'BELONGS_TO';

export interface GraphRelationship {
  id: string;
  type: RelationshipType;
  source: string;
  target: string;
  properties: RelationshipProperties;
}

// Type-safe property interfaces
export interface NodeProperties {
  // Common properties
  name?: string;
  path?: string;
  filePath?: string;
  extension?: string;
  language?: string;
  size?: number;
  
  // Project-specific
  description?: string;
  version?: string;
  
  // File-specific
  definitionCount?: number;
  lineCount?: number;
  
  // Definition-specific
  type?: string;
  startLine?: number;
  endLine?: number;
  qualifiedName?: string;
  parameters?: string[];
  returnType?: string;
  
  // Relationship-specific
  relationshipType?: string;
  [key: string]: string | number | boolean | string[] | undefined;
}

export interface RelationshipProperties {
  // Common properties
  strength?: number;
  confidence?: number;
  
  // Import-specific
  importType?: 'default' | 'named' | 'namespace';
  alias?: string;
  
  // Call-specific
  callType?: 'function' | 'method' | 'constructor';
  arguments?: string[];
  
  // Dependency-specific
  dependencyType?: 'direct' | 'transitive' | 'dev';
  version?: string;
  
  [key: string]: string | number | boolean | string[] | undefined;
}

export interface KnowledgeGraph {
  nodes: GraphNode[];
  relationships: GraphRelationship[];
}

================
File: src/core/ingestion/call-processor.ts
================
import type { KnowledgeGraph, GraphRelationship } from '../graph/types.ts';
import type { ParsedAST } from './parsing-processor.ts';
import type { ImportMap } from './import-processor.ts';
import { FunctionRegistryTrie } from '../graph/trie.ts';
import { generateId } from '../../lib/utils.ts';
import Parser from 'web-tree-sitter';

// Simple path utilities for browser compatibility
const pathUtils = {
  extname: (filePath: string): string => {
    const lastDot = filePath.lastIndexOf('.');
    return lastDot === -1 ? '' : filePath.substring(lastDot);
  },
  dirname: (filePath: string): string => {
    const lastSlash = filePath.lastIndexOf('/');
    return lastSlash === -1 ? '' : filePath.substring(0, lastSlash);
  }
};

interface CallInfo {
  callerFile: string;
  callerFunction?: string;
  functionName: string;
  startLine: number;
  endLine: number;
  callType: 'function_call' | 'method_call' | 'constructor_call';
}

interface ResolutionResult {
  success: boolean;
  targetNodeId?: string;
  stage: 'exact' | 'same_file' | 'heuristic' | 'failed';
  confidence: 'high' | 'medium' | 'low';
  distance?: number;
}

export class CallProcessor {
  private importMap: ImportMap = {};
  private functionTrie: FunctionRegistryTrie;
  private astMap: Map<string, ParsedAST> = new Map();
  
  // Statistics
  private stats = {
    totalCalls: 0,
    exactMatches: 0,
    sameFileMatches: 0,
    heuristicMatches: 0,
    failed: 0,
    callTypes: {} as Record<string, number>
  };

  constructor(functionTrie: FunctionRegistryTrie) {
    this.functionTrie = functionTrie;
  }

  /**
   * Process function calls using the 3-stage resolution strategy
   * This runs AFTER ImportProcessor has built the complete import map
   */
  async process(
    graph: KnowledgeGraph,
    astMap: Map<string, ParsedAST>,
    importMap: ImportMap
  ): Promise<KnowledgeGraph> {
    console.log('CallProcessor: Starting call resolution with 3-stage strategy...');
    
    this.importMap = importMap;
    this.astMap = astMap;
    this.resetStats();

    // Process calls for each file
    for (const [filePath, ast] of astMap) {
      if (ast.tree) {
        await this.processFileCalls(filePath, ast, graph);
      }
    }

    this.logStats();
    return graph;
  }

  /**
   * Process function calls in a single file
   */
  private async processFileCalls(
    filePath: string,
    ast: ParsedAST,
    graph: KnowledgeGraph
  ): Promise<void> {
    const calls = this.extractFunctionCalls(ast.tree!.rootNode, filePath);
    
    if (calls.length === 0) {
      // Only log for source files that should have function calls
      if (this.isSourceFile(filePath)) {
        console.log(`⚠️ CallProcessor: No function calls found in source file: ${filePath}`);
        
        // Debug: Check if this file has any 'call' nodes at all
        if (filePath.endsWith('.py')) {
          const callNodeCount = this.countNodeType(ast.tree!.rootNode, 'call');
          const definitionCount = graph.nodes.filter(n => 
            (n.label === 'Function' || n.label === 'Class' || n.label === 'Method') && 
            n.properties.filePath === filePath
          ).length;
          
          console.log(`  📊 Debug: ${filePath.split('/').pop()} has ${callNodeCount} call nodes, ${definitionCount} definitions`);
          
          // If we have definitions but no calls, that's suspicious
          if (definitionCount > 0 && callNodeCount === 0) {
            console.log(`  🚨 Suspicious: File has definitions but no call nodes - possible AST parsing issue`);
          }
        }
      }
    } else {
      console.log(`CallProcessor: Found ${calls.length} function calls in ${filePath}`);
    }
    
    for (const call of calls) {
      this.stats.totalCalls++;
      this.stats.callTypes[call.callType] = (this.stats.callTypes[call.callType] || 0) + 1;
      
      const resolution = await this.resolveCall(call);
      
      if (resolution.success && resolution.targetNodeId) {
        this.createCallRelationship(graph, call, resolution.targetNodeId);
        
        // Update statistics
        switch (resolution.stage) {
          case 'exact':
            this.stats.exactMatches++;
            break;
          case 'same_file':
            this.stats.sameFileMatches++;
            break;
          case 'heuristic':
            this.stats.heuristicMatches++;
            break;
        }
      } else {
        this.stats.failed++;
        console.log(`❌ Failed to resolve call: ${call.functionName} in ${call.callerFile}:${call.startLine}`);
      }
    }
  }

  /**
   * Count nodes of a specific type in the AST (for debugging)
   */
  private countNodeType(node: Parser.SyntaxNode, nodeType: string): number {
    let count = 0;
    
    if (node.type === nodeType) {
      count++;
    }
    
    // Recursively count in children
    for (let i = 0; i < node.childCount; i++) {
      const child = node.child(i);
      if (child) {
        count += this.countNodeType(child, nodeType);
      }
    }
    
    return count;
  }

  /**
   * 3-Stage Call Resolution Strategy
   */
  private async resolveCall(call: CallInfo): Promise<ResolutionResult> {
    // Stage 1: Exact Match using ImportMap
    const exactResult = this.stageExactMatch(call);
    if (exactResult.success) {
      return exactResult;
    }

    // Stage 2: Same-Module Match
    const sameFileResult = this.stageSameFileMatch(call);
    if (sameFileResult.success) {
      return sameFileResult;
    }

    // Stage 3: Heuristic Fallback
    const heuristicResult = this.stageHeuristicMatch(call);
    return heuristicResult;
  }

  /**
   * Stage 1: Exact Match using ImportMap (High Confidence)
   */
  private stageExactMatch(call: CallInfo): ResolutionResult {
    const importInfo = this.importMap[call.callerFile]?.[call.functionName];
    
    if (importInfo) {
      // We have an import for this function name
      const targetDefinitions = this.functionTrie.getAllDefinitions().filter(def =>
        def.filePath === importInfo.targetFile && 
        (def.functionName === importInfo.exportedName || 
         (importInfo.exportedName === 'default' && def.functionName === call.functionName))
      );

      if (targetDefinitions.length > 0) {
        return {
          success: true,
          targetNodeId: targetDefinitions[0].nodeId,
          stage: 'exact',
          confidence: 'high'
        };
      }
    }

    return { success: false, stage: 'exact', confidence: 'high' };
  }

  /**
   * Stage 2: Same-Module Match (High Confidence)
   */
  private stageSameFileMatch(call: CallInfo): ResolutionResult {
    const sameFileDefinitions = this.functionTrie.findInSameFile(call.callerFile, call.functionName);
    
    if (sameFileDefinitions.length > 0) {
      return {
        success: true,
        targetNodeId: sameFileDefinitions[0].nodeId,
        stage: 'same_file',
        confidence: 'high'
      };
    }

    return { success: false, stage: 'same_file', confidence: 'high' };
  }

  /**
   * Stage 3: Heuristic Fallback (Intelligent Guessing)
   */
  private stageHeuristicMatch(call: CallInfo): ResolutionResult {
    // Use trie to find all functions ending with this name
    const candidates = this.functionTrie.findEndingWith(call.functionName);
    
    if (candidates.length === 0) {
      return { success: false, stage: 'heuristic', confidence: 'low' };
    }

    // If only one candidate, use it
    if (candidates.length === 1) {
      return {
        success: true,
        targetNodeId: candidates[0].nodeId,
        stage: 'heuristic',
        confidence: 'medium'
      };
    }

    // Multiple candidates - apply smart heuristics
    let bestCandidate = candidates[0];
    let bestScore = this.calculateImportDistance(call.callerFile, bestCandidate.filePath);

    for (const candidate of candidates) {
      let score = this.calculateImportDistance(call.callerFile, candidate.filePath);
      
      // Special handling for method calls
      if (call.callType === 'method_call' && candidate.type === 'method') {
        // Bonus for methods in the same file (likely self/this calls)
        if (candidate.filePath === call.callerFile) {
          score -= 2; // Strong preference for same-file methods
        }
        
        // Bonus for methods in the same class context
        // This would require more context about the calling class
        // For now, we give a small bonus to method-to-method calls
        score -= 0.5;
      }
      
      // Bonus for function calls to functions (type matching)
      if (call.callType === 'function_call' && candidate.type === 'function') {
        score -= 0.5;
      }
      
      // Bonus for sibling modules (same parent directory)
      if (this.areSiblingModules(call.callerFile, candidate.filePath)) {
        score -= 1;
      }

      if (score < bestScore) {
        bestScore = score;
        bestCandidate = candidate;
      }
    }

    return {
      success: true,
      targetNodeId: bestCandidate.nodeId,
      stage: 'heuristic',
      confidence: bestScore <= 1 ? 'medium' : 'low'
    };
  }

  /**
   * Calculate import distance between two file paths
   */
  private calculateImportDistance(callerFile: string, targetFile: string): number {
    const callerParts = callerFile.split('/');
    const targetParts = targetFile.split('/');
    
    // Find common prefix length
    let commonPrefixLength = 0;
    const minLength = Math.min(callerParts.length, targetParts.length);
    
    for (let i = 0; i < minLength; i++) {
      if (callerParts[i] === targetParts[i]) {
        commonPrefixLength++;
      } else {
        break;
      }
    }
    
    // Distance is max depth minus common prefix
    return Math.max(callerParts.length, targetParts.length) - commonPrefixLength;
  }

  /**
   * Check if two file paths are sibling modules (same parent directory)
   */
  private areSiblingModules(file1: string, file2: string): boolean {
    const parent1 = pathUtils.dirname(file1);
    const parent2 = pathUtils.dirname(file2);
    return parent1 === parent2;
  }

  /**
   * Check if a function call should be ignored (built-ins, standard library, etc.)
   */
  private shouldIgnoreCall(functionName: string, filePath: string): boolean {
    // Python built-in functions that should be ignored
    const pythonBuiltins = new Set([
      'int', 'str', 'float', 'bool', 'list', 'dict', 'set', 'tuple',
      'len', 'range', 'enumerate', 'zip', 'map', 'filter', 'sorted',
      'sum', 'min', 'max', 'abs', 'round', 'all', 'any', 'hasattr',
      'getattr', 'setattr', 'isinstance', 'issubclass', 'type',
      'print', 'input', 'open', 'format', 'join', 'split', 'strip',
      'replace', 'upper', 'lower', 'append', 'extend', 'insert',
      'remove', 'pop', 'clear', 'copy', 'update', 'keys', 'values',
      'items', 'get', 'add', 'discard', 'union', 'intersection',
      'difference', 'now', 'today', 'fromisoformat', 'isoformat',
      'astimezone', 'random', 'choice', 'randint', 'shuffle',
      'locals', 'globals', 'vars', 'dir', 'help', 'id', 'hash',
      'ord', 'chr', 'bin', 'oct', 'hex', 'divmod', 'pow', 'exec',
      'eval', 'compile', 'next', 'iter', 'reversed', 'slice',
      // String methods
      'endswith', 'startswith', 'find', 'rfind', 'index', 'rindex',
      'count', 'encode', 'decode', 'capitalize', 'title', 'swapcase',
      'center', 'ljust', 'rjust', 'zfill', 'expandtabs', 'splitlines',
      'partition', 'rpartition', 'translate', 'maketrans', 'casefold',
      'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier',
      'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper',
      'lstrip', 'rstrip', 'removeprefix', 'removesuffix',
      // List/sequence methods
      'sort', 'reverse', 'count', 'index',
      // Dictionary methods
      'setdefault', 'popitem', 'fromkeys',
      // Set methods
      'difference_update', 'intersection_update', 'symmetric_difference',
      'symmetric_difference_update', 'isdisjoint', 'issubset', 'issuperset',
      // Date/time methods
      'strftime', 'strptime', 'timestamp', 'weekday', 'isoweekday',
      'date', 'time', 'timetz', 'utctimetuple', 'timetuple',
      // Common exceptions
      'ValueError', 'TypeError', 'KeyError', 'IndexError', 'AttributeError',
      'ImportError', 'ModuleNotFoundError', 'FileNotFoundError',
      'ConnectionError', 'HTTPException', 'RuntimeError', 'OSError',
      'Exception', 'BaseException', 'StopIteration', 'GeneratorExit',
      // Logging methods
      'debug', 'info', 'warning', 'error', 'critical', 'exception',
      // Common library functions
      'getLogger', 'basicConfig', 'StreamHandler', 'load_dotenv',
      'getenv', 'dirname', 'abspath', 'join', 'exists', 'run',
      // Database/ORM methods
      'find', 'find_one', 'update_one', 'insert_one', 'delete_one',
      'aggregate', 'bulk_write', 'to_list', 'sort', 'limit', 'close',
      // Pydantic/FastAPI
      'Field', 'validator', 'field_validator', 'model_dump', 'model_dump_json',
      // Motor/MongoDB
      'ObjectId', 'UpdateOne', 'AsyncIOMotorClient', 'command',
      // FastAPI
      'FastAPI', 'HTTPException', 'add_middleware', 'include_router',
      // Threading/async
      'Lock', 'RLock', 'Semaphore', 'Event', 'Condition', 'Barrier',
      'sleep', 'gather', 'create_task', 'run_until_complete',
      // Collections
      'defaultdict', 'Counter', 'OrderedDict', 'deque', 'namedtuple',
      // Math/statistics (numpy, pandas, statistics)
      'mean', 'median', 'mode', 'stdev', 'variance', 'sqrt', 'pow',
      'sin', 'cos', 'tan', 'log', 'exp', 'ceil', 'floor',
      // UUID
      'uuid4', 'uuid1', 'uuid3', 'uuid5',
      // URL/HTTP
      'quote', 'unquote', 'quote_plus', 'unquote_plus', 'urlencode',
      // JSON
      'loads', 'dumps', 'load', 'dump',
      // Regex
      'match', 'search', 'findall', 'finditer', 'sub', 'subn', 'compile',
      // Azure/OpenAI specific
      'AsyncAzureOpenAI', 'AzureOpenAI', 'OpenAI', 'wrap_openai', 'create'
    ]);

    // Check if it's a Python file and the function is a built-in
    if (filePath.endsWith('.py') && pythonBuiltins.has(functionName)) {
      return true;
    }

    // Ignore very short function names (likely built-ins or operators)
    if (functionName.length <= 2) {
      return true;
    }

    // Ignore common method patterns that are likely built-ins
    const commonMethodPatterns = [
      /^__\w+__$/, // Dunder methods like __init__, __str__, etc.
      /^\w+_$/, // Methods ending with underscore (often private)
    ];

    for (const pattern of commonMethodPatterns) {
      if (pattern.test(functionName)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Extract function calls from AST
   */
  private extractFunctionCalls(node: Parser.SyntaxNode, filePath: string): CallInfo[] {
    const calls: CallInfo[] = [];
    const language = this.detectLanguage(filePath);

    if (language === 'python') {
      this.extractPythonCalls(node, filePath, calls);
    } else {
      this.extractJSCalls(node, filePath, calls);
    }

    return calls;
  }

  /**
   * Extract Python function calls
   */
  private extractPythonCalls(node: Parser.SyntaxNode, filePath: string, calls: CallInfo[]): void {
    if (node.type === 'call') {
      const functionNode = node.childForFieldName('function');
      if (functionNode) {
        const functionName = this.extractPythonCallName(functionNode);
        
        // Debug: Log what we're finding vs filtering
        if (functionName) {
          const shouldIgnore = this.shouldIgnoreCall(functionName, filePath);
          if (shouldIgnore) {
            // Only log a few examples to avoid spam
            if (calls.length < 3) {
              console.log(`🔍 Filtered out: ${functionName} in ${filePath.split('/').pop()}`);
            }
          } else {
            calls.push({
              callerFile: filePath,
              functionName,
              startLine: node.startPosition.row + 1,
              endLine: node.endPosition.row + 1,
              callType: 'function_call'
            });
          }
        } else {
          // Debug: Log when we can't extract function name
          if (calls.length < 3) {
            console.log(`🔍 Could not extract function name from: ${functionNode.type} in ${filePath.split('/').pop()}`);
          }
        }
      }
    }

    // Recursively process children
    for (let i = 0; i < node.childCount; i++) {
      const child = node.child(i);
      if (child) {
        this.extractPythonCalls(child, filePath, calls);
      }
    }
  }

  /**
   * Extract JavaScript/TypeScript function calls
   */
  private extractJSCalls(node: Parser.SyntaxNode, filePath: string, calls: CallInfo[]): void {
    if (node.type === 'call_expression') {
      const functionNode = node.childForFieldName('function');
      if (functionNode) {
        const functionName = this.extractJSCallName(functionNode);
        if (functionName && !this.shouldIgnoreCall(functionName, filePath)) {
          calls.push({
            callerFile: filePath,
            functionName,
            startLine: node.startPosition.row + 1,
            endLine: node.endPosition.row + 1,
            callType: functionNode.type === 'member_expression' ? 'method_call' : 'function_call'
          });
        }
      }
    } else if (node.type === 'new_expression') {
      const constructorNode = node.childForFieldName('constructor');
      if (constructorNode) {
        const constructorName = constructorNode.text;
        calls.push({
          callerFile: filePath,
          functionName: constructorName,
          startLine: node.startPosition.row + 1,
          endLine: node.endPosition.row + 1,
          callType: 'constructor_call'
        });
      }
    }

    // Recursively process children
    for (let i = 0; i < node.childCount; i++) {
      const child = node.child(i);
      if (child) {
        this.extractJSCalls(child, filePath, calls);
      }
    }
  }

  /**
   * Extract function name from Python call node
   */
  private extractPythonCallName(node: Parser.SyntaxNode): string | null {
    if (node.type === 'identifier') {
      return node.text;
    } else if (node.type === 'attribute') {
      // For method calls like obj.method(), we want just 'method'
      const attributeNode = node.childForFieldName('attribute');
      return attributeNode ? attributeNode.text : null;
    } else if (node.type === 'subscript') {
      // For calls like obj[key](), try to get the base object
      const valueNode = node.childForFieldName('value');
      if (valueNode) {
        return this.extractPythonCallName(valueNode);
      }
    } else if (node.type === 'call') {
      // Nested call - try to get the function being called
      const functionNode = node.childForFieldName('function');
      if (functionNode) {
        return this.extractPythonCallName(functionNode);
      }
    }
    
    // Debug: Log unhandled node types (but limit spam)
    if (Math.random() < 0.1) { // Only log 10% of cases to avoid spam
      console.log(`🔍 Unhandled Python call node type: ${node.type} (text: "${node.text}")`);
    }
    
    return null;
  }

  /**
   * Extract function name from JavaScript call node
   */
  private extractJSCallName(node: Parser.SyntaxNode): string | null {
    if (node.type === 'identifier') {
      return node.text;
    } else if (node.type === 'member_expression') {
      // For method calls like obj.method(), we want just 'method'
      const propertyNode = node.childForFieldName('property');
      return propertyNode ? propertyNode.text : null;
    }
    return null;
  }

  /**
   * Create CALLS relationship in the graph
   */
  private createCallRelationship(
    graph: KnowledgeGraph,
    call: CallInfo,
    targetNodeId: string
  ): void {
    // Find the caller node (could be a function, method, or file)
    const callerNode = this.findCallerNode(graph, call);
    
    if (callerNode) {
      const relationship: GraphRelationship = {
        id: generateId('calls', `${callerNode.id}-calls-${targetNodeId}`),
        type: 'CALLS',
        source: callerNode.id,
        target: targetNodeId,
        properties: {
          callType: call.callType,
          functionName: call.functionName,
          startLine: call.startLine,
          endLine: call.endLine
        }
      };

      // Check if relationship already exists
      const existingRel = graph.relationships.find(r =>
        r.type === 'CALLS' &&
        r.source === callerNode.id &&
        r.target === targetNodeId
      );

      if (!existingRel) {
        graph.relationships.push(relationship);
      }
    }
  }

  /**
   * Find the caller node in the graph
   */
  private findCallerNode(graph: KnowledgeGraph, call: CallInfo): any {
    // First try to find a function/method that contains this call
    const containingFunction = graph.nodes.find(node =>
      (node.label === 'Function' || node.label === 'Method') &&
      node.properties.filePath === call.callerFile &&
      (node.properties.startLine as number) <= call.startLine &&
      (node.properties.endLine as number) >= call.endLine
    );

    if (containingFunction) {
      return containingFunction;
    }

    // If no containing function found, try to find a class that contains this call
    // This helps with method calls at class level
    const containingClass = graph.nodes.find(node =>
      node.label === 'Class' &&
      node.properties.filePath === call.callerFile &&
      (node.properties.startLine as number) <= call.startLine &&
      (node.properties.endLine as number) >= call.endLine
    );

    if (containingClass) {
      return containingClass;
    }

    // Fallback to file node
    return graph.nodes.find(node =>
      node.label === 'File' &&
      node.properties.filePath === call.callerFile
    );
  }

  /**
   * Detect programming language
   */
  private detectLanguage(filePath: string): 'python' | 'javascript' {
    const ext = pathUtils.extname(filePath).toLowerCase();
    return ext === '.py' ? 'python' : 'javascript';
  }

  /**
   * Reset statistics
   */
  private resetStats(): void {
    this.stats = {
      totalCalls: 0,
      exactMatches: 0,
      sameFileMatches: 0,
      heuristicMatches: 0,
      failed: 0,
      callTypes: {}
    };
  }

  /**
   * Log resolution statistics
   */
  private logStats(): void {
    console.log('📊 CallProcessor Resolution Statistics:');
    console.log(`  Total calls processed: ${this.stats.totalCalls}`);
    console.log(`  ✅ Exact matches (Stage 1): ${this.stats.exactMatches} (${((this.stats.exactMatches / this.stats.totalCalls) * 100).toFixed(1)}%)`);
    console.log(`  ✅ Same-file matches (Stage 2): ${this.stats.sameFileMatches} (${((this.stats.sameFileMatches / this.stats.totalCalls) * 100).toFixed(1)}%)`);
    console.log(`  🎯 Heuristic matches (Stage 3): ${this.stats.heuristicMatches} (${((this.stats.heuristicMatches / this.stats.totalCalls) * 100).toFixed(1)}%)`);
    console.log(`  ❌ Failed resolutions: ${this.stats.failed} (${((this.stats.failed / this.stats.totalCalls) * 100).toFixed(1)}%)`);
    console.log(`  Success rate: ${(((this.stats.totalCalls - this.stats.failed) / this.stats.totalCalls) * 100).toFixed(1)}%`);
  }

  /**
   * Get resolution statistics
   */
  getStats() {
    return this.stats;
  }

  /**
   * Clear all data
   */
  clear(): void {
    this.importMap = {};
    this.astMap.clear();
    this.resetStats();
  }

  /**
   * Check if a file is a source file that should contain function calls
   */
  private isSourceFile(filePath: string): boolean {
    const sourceExtensions = ['.py', '.js', '.ts', '.jsx', '.tsx'];
    const ext = pathUtils.extname(filePath).toLowerCase();
    return sourceExtensions.includes(ext);
  }
}

================
File: src/core/ingestion/import-processor.ts
================
import type { KnowledgeGraph, GraphRelationship } from '../graph/types.ts';
import type { ParsedAST } from './parsing-processor.ts';
import Parser from 'web-tree-sitter';

// Simple path utilities for browser compatibility
const pathUtils = {
  extname: (filePath: string): string => {
    const lastDot = filePath.lastIndexOf('.');
    return lastDot === -1 ? '' : filePath.substring(lastDot);
  },
  dirname: (filePath: string): string => {
    const lastSlash = Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\'));
    return lastSlash === -1 ? '.' : filePath.substring(0, lastSlash);
  },
  resolve: (basePath: string, relativePath: string): string => {
    // Simple relative path resolution
    if (relativePath.startsWith('./')) {
      return basePath + '/' + relativePath.substring(2);
    } else if (relativePath.startsWith('../')) {
      const parts = basePath.split('/');
      const relativeParts = relativePath.split('/');
      let upCount = 0;
      for (const part of relativeParts) {
        if (part === '..') upCount++;
        else break;
      }
      const resultParts = parts.slice(0, -upCount);
      const remainingParts = relativeParts.slice(upCount);
      return [...resultParts, ...remainingParts].join('/');
    }
    return basePath + '/' + relativePath;
  },
  join: (...parts: string[]): string => {
    return parts.join('/').replace(/\/+/g, '/');
  }
};

interface ImportMap {
  [importingFile: string]: {
    [localName: string]: {
      targetFile: string;
      exportedName: string;
      importType: 'default' | 'named' | 'namespace' | 'dynamic';
    }
  }
}

interface ImportInfo {
  importingFile: string;
  localName: string;
  targetFile: string;
  exportedName: string;
  importType: 'default' | 'named' | 'namespace' | 'dynamic';
}

export class ImportProcessor {
  private importMap: ImportMap = {};
  private projectFiles: Set<string> = new Set();

  /**
   * Process all imports after parsing is complete
   * @param graph The knowledge graph being built
   * @param astMap Map of file paths to their parsed ASTs
   * @param fileContents Map of file contents
   * @returns Updated graph with import relationships
   */
  async process(
    graph: KnowledgeGraph, 
    astMap: Map<string, ParsedAST>,
    fileContents: Map<string, string>
  ): Promise<KnowledgeGraph> {
    console.log('ImportProcessor: Starting import resolution...');
    
    // Build set of all project files for validation
    this.projectFiles = new Set(fileContents.keys());
    
    // Clear previous import map
    this.importMap = {};
    
    let totalImportsFound = 0;
    let totalImportsResolved = 0;
    
    // Process imports for each file
    for (const [filePath, ast] of astMap) {
      const fileImports = await this.processFileImports(filePath, ast, graph);
      totalImportsFound += fileImports.found;
      totalImportsResolved += fileImports.resolved;
    }
    
    console.log('ImportProcessor: Completed import resolution');
    console.log(`ImportProcessor: Found ${totalImportsFound} imports, resolved ${totalImportsResolved} (${((totalImportsResolved/totalImportsFound)*100).toFixed(1)}%)`);
    console.log(`ImportProcessor: Built import map for ${Object.keys(this.importMap).length} files`);
    
    return graph;
  }

  /**
   * Process imports for a single file
   */
  private async processFileImports(
    filePath: string, 
    ast: ParsedAST, 
    graph: KnowledgeGraph
  ): Promise<{ found: number; resolved: number }> {
    if (!ast.tree) return { found: 0, resolved: 0 };

    const imports = this.extractImports(ast.tree.rootNode, filePath);
    
    if (imports.length === 0) return { found: 0, resolved: 0 };

    // Initialize import map for this file
    this.importMap[filePath] = {};

    let found = 0;
    let resolved = 0;

    for (const importInfo of imports) {
      // Store in import map
      this.importMap[filePath][importInfo.localName] = {
        targetFile: importInfo.targetFile,
        exportedName: importInfo.exportedName,
        importType: importInfo.importType
      };

      // Create IMPORTS relationship in graph
      this.createImportRelationship(graph, importInfo);
      found++;
      if (importInfo.targetFile !== importInfo.exportedName) { // Only count as resolved if it's not a default import
        resolved++;
      }
    }
    return { found, resolved };
  }

  /**
   * Extract import statements from AST
   */
  private extractImports(rootNode: Parser.SyntaxNode, filePath: string): ImportInfo[] {
    const imports: ImportInfo[] = [];
    const language = this.detectLanguage(filePath);

    if (language === 'python') {
      this.extractPythonImports(rootNode, filePath, imports);
    } else if (language === 'javascript' || language === 'typescript') {
      this.extractJSImports(rootNode, filePath, imports);
    }

    return imports;
  }

  /**
   * Extract Python imports
   */
  private extractPythonImports(
    node: Parser.SyntaxNode, 
    filePath: string, 
    imports: ImportInfo[]
  ): void {
    if (node.type === 'import_statement') {
      // Handle: import module
      // Handle: import module as alias
      const moduleNode = node.childForFieldName('name');
      if (moduleNode) {
        const moduleName = moduleNode.text;
        const targetFile = this.resolveModulePath(moduleName, filePath, 'python');
        
        imports.push({
          importingFile: filePath,
          localName: moduleName.split('.').pop() || moduleName,
          targetFile,
          exportedName: moduleName,
          importType: 'namespace'
        });
      }
    } else if (node.type === 'import_from_statement') {
      // Handle: from module import name
      // Handle: from module import name as alias
      const moduleNode = node.childForFieldName('module_name');
      const namesNode = node.childForFieldName('name');
      
      if (moduleNode && namesNode) {
        const moduleName = moduleNode.text;
        const targetFile = this.resolveModulePath(moduleName, filePath, 'python');
        
        // Handle multiple imports: from module import a, b, c
        if (namesNode.type === 'import_list') {
          for (let i = 0; i < namesNode.childCount; i++) {
            const nameNode = namesNode.child(i);
            if (nameNode && nameNode.type === 'import_from_statement') {
              const importName = nameNode.text;
              imports.push({
                importingFile: filePath,
                localName: importName,
                targetFile,
                exportedName: importName,
                importType: 'named'
              });
            }
          }
        } else {
          const importName = namesNode.text;
          imports.push({
            importingFile: filePath,
            localName: importName,
            targetFile,
            exportedName: importName,
            importType: 'named'
          });
        }
      }
    }

    // Recursively process children
    for (let i = 0; i < node.childCount; i++) {
      const child = node.child(i);
      if (child) {
        this.extractPythonImports(child, filePath, imports);
      }
    }
  }

  /**
   * Extract JavaScript/TypeScript imports
   */
  private extractJSImports(
    node: Parser.SyntaxNode, 
    filePath: string, 
    imports: ImportInfo[]
  ): void {
    if (node.type === 'import_statement') {
      const sourceNode = node.childForFieldName('source');
      if (!sourceNode) return;

      const sourcePath = sourceNode.text.replace(/['"]/g, '');
      const targetFile = this.resolveModulePath(sourcePath, filePath, 'javascript');

      // Handle different import patterns
      const importClauseNode = node.childForFieldName('import_clause');
      if (importClauseNode) {
        this.processJSImportClause(importClauseNode, filePath, targetFile, imports);
      }
    } else if (node.type === 'variable_declaration') {
      // Handle CommonJS: const x = require('module')
      this.processRequireStatement(node, filePath, imports);
    }

    // Recursively process children
    for (let i = 0; i < node.childCount; i++) {
      const child = node.child(i);
      if (child) {
        this.extractJSImports(child, filePath, imports);
      }
    }
  }

  /**
   * Process JS import clause (handles named, default, namespace imports)
   */
  private processJSImportClause(
    importClauseNode: Parser.SyntaxNode,
    filePath: string,
    targetFile: string,
    imports: ImportInfo[]
  ): void {
    for (let i = 0; i < importClauseNode.childCount; i++) {
      const child = importClauseNode.child(i);
      if (!child) continue;

      if (child.type === 'import_specifier') {
        // Named import: { name } or { name as alias }
        const nameNode = child.childForFieldName('name');
        const aliasNode = child.childForFieldName('alias');
        
        if (nameNode) {
          const exportedName = nameNode.text;
          const localName = aliasNode ? aliasNode.text : exportedName;
          
          imports.push({
            importingFile: filePath,
            localName,
            targetFile,
            exportedName,
            importType: 'named'
          });
        }
      } else if (child.type === 'namespace_import') {
        // Namespace import: * as name
        const nameNode = child.childForFieldName('name');
        if (nameNode) {
          imports.push({
            importingFile: filePath,
            localName: nameNode.text,
            targetFile,
            exportedName: '*',
            importType: 'namespace'
          });
        }
      } else if (child.type === 'identifier') {
        // Default import
        imports.push({
          importingFile: filePath,
          localName: child.text,
          targetFile,
          exportedName: 'default',
          importType: 'default'
        });
      }
    }
  }

  /**
   * Process CommonJS require statements
   */
  private processRequireStatement(
    node: Parser.SyntaxNode,
    filePath: string,
    imports: ImportInfo[]
  ): void {
    // Look for: const x = require('module')
    const declaratorNode = node.child(1); // variable_declarator
    if (!declaratorNode) return;

    const nameNode = declaratorNode.childForFieldName('name');
    const valueNode = declaratorNode.childForFieldName('value');

    if (nameNode && valueNode && valueNode.type === 'call_expression') {
      const functionNode = valueNode.childForFieldName('function');
      const argumentsNode = valueNode.childForFieldName('arguments');

      if (functionNode?.text === 'require' && argumentsNode) {
        const firstArg = argumentsNode.child(1); // Skip opening paren
        if (firstArg && firstArg.type === 'string') {
          const modulePath = firstArg.text.replace(/['"]/g, '');
          const targetFile = this.resolveModulePath(modulePath, filePath, 'javascript');

          imports.push({
            importingFile: filePath,
            localName: nameNode.text,
            targetFile,
            exportedName: 'default',
            importType: 'dynamic'
          });
        }
      }
    }
  }

  /**
   * Resolve module path to actual file path
   */
  private resolveModulePath(moduleName: string, importingFile: string, language: 'python' | 'javascript'): string {
    // Handle relative imports
    if (moduleName.startsWith('.')) {
      const importingDir = pathUtils.dirname(importingFile);
      const resolvedPath = pathUtils.resolve(importingDir, moduleName);
      
      // Try different extensions
      const extensions = language === 'python' ? ['.py'] : ['.js', '.ts', '.tsx', '.jsx'];
      
      for (const ext of extensions) {
        const candidate = resolvedPath + ext;
        if (this.projectFiles.has(candidate)) {
          return candidate;
        }
      }
      
      // Try index files
      for (const ext of extensions) {
        const indexCandidate = pathUtils.join(resolvedPath, `index${ext}`);
        if (this.projectFiles.has(indexCandidate)) {
          return indexCandidate;
        }
      }
      
      return resolvedPath; // Return even if not found, for external modules
    }

    // Handle absolute/package imports for Python
    if (language === 'python') {
      // First, try to find files that match the module pattern
      const modulePatterns = [
        // Direct module.py
        moduleName.replace(/\./g, '/') + '.py',
        // Package with __init__.py
        moduleName.replace(/\./g, '/') + '/__init__.py',
        // Try within the project structure
        `src/python/${moduleName.replace(/\./g, '/')}.py`,
        `src/python/${moduleName.replace(/\./g, '/')}/__init__.py`,
      ];
      
      // Also try to match partial paths for complex project structures
      for (const filePath of this.projectFiles) {
        if (filePath.endsWith('.py')) {
          // Check if this file could match the module name
          const moduleSegments = moduleName.split('.');
          const pathSegments = filePath.replace('.py', '').split('/');
          
          // Try to match the last few segments
          if (moduleSegments.length > 0) {
            const lastSegment = moduleSegments[moduleSegments.length - 1];
            const fileName = pathSegments[pathSegments.length - 1];
            
            // If the last segment matches the filename, this could be it
            if (fileName === lastSegment) {
              // Check if the path contains the module structure
              const modulePathInFile = moduleSegments.slice(0, -1).join('/');
              if (!modulePathInFile || filePath.includes(modulePathInFile)) {
                return filePath;
              }
            }
          }
        }
      }
      
      // Try the direct patterns
      for (const pattern of modulePatterns) {
        if (this.projectFiles.has(pattern)) {
          return pattern;
        }
      }
      
      // For complex module paths, try to find any file that ends with the module name
      const lastModuleSegment = moduleName.split('.').pop();
      if (lastModuleSegment) {
        for (const filePath of this.projectFiles) {
          if (filePath.endsWith(`${lastModuleSegment}.py`)) {
            return filePath;
          }
        }
      }
    }

    // For external modules or unresolved, return as-is
    return moduleName;
  }

  /**
   * Create IMPORTS relationship in the graph
   */
  private createImportRelationship(graph: KnowledgeGraph, importInfo: ImportInfo): void {
    // Find source and target nodes
    const sourceNode = graph.nodes.find(n => 
      n.label === 'File' && n.properties.filePath === importInfo.importingFile
    );
    
    const targetNode = graph.nodes.find(n => 
      n.label === 'File' && n.properties.filePath === importInfo.targetFile
    );

    if (sourceNode && targetNode && sourceNode.id !== targetNode.id) {
      // Check if relationship already exists
      const existingRel = graph.relationships.find(r =>
        r.type === 'IMPORTS' &&
        r.source === sourceNode.id &&
        r.target === targetNode.id
      );

      if (!existingRel) {
        const relationship: GraphRelationship = {
          id: `imports_${sourceNode.id}_${targetNode.id}_${Date.now()}`,
          type: 'IMPORTS',
          source: sourceNode.id,
          target: targetNode.id,
          properties: {
            importType: importInfo.importType,
            localName: importInfo.localName,
            exportedName: importInfo.exportedName
          }
        };

        graph.relationships.push(relationship);
      }
    }
  }

  /**
   * Detect programming language from file extension
   */
  private detectLanguage(filePath: string): 'python' | 'javascript' | 'typescript' {
    const ext = pathUtils.extname(filePath).toLowerCase();
    
    if (ext === '.py') return 'python';
    if (ext === '.ts' || ext === '.tsx') return 'typescript';
    return 'javascript'; // .js, .jsx, or default
  }

  /**
   * Get the complete import map for use by CallProcessor
   */
  getImportMap(): ImportMap {
    return this.importMap;
  }

  /**
   * Get import info for a specific file and local name
   */
  getImportInfo(filePath: string, localName: string): ImportMap[string][string] | null {
    return this.importMap[filePath]?.[localName] || null;
  }

  /**
   * Clear all data
   */
  clear(): void {
    this.importMap = {};
    this.projectFiles.clear();
  }
}

export type { ImportMap, ImportInfo };

================
File: src/core/ingestion/parsing-processor.ts
================
import { GraphNode, GraphRelationship, NodeLabel, RelationshipType } from '../graph/types.js';
import { MemoryManager } from '../../services/memory-manager.js';
import { KnowledgeGraph, GraphProcessor } from '../graph/graph.js';
import {
  pathUtils,
  OptimizedSet,
  DuplicateDetector,
  BatchProcessor
} from '../../lib/shared-utils.js';
import { IGNORE_PATTERNS } from '../../config/language-config.js';
import Parser from 'web-tree-sitter';
import { TYPESCRIPT_QUERIES, PYTHON_QUERIES, JAVA_QUERIES } from './tree-sitter-queries.ts';
import { initTreeSitter, loadTypeScriptParser, loadPythonParser, loadJavaScriptParser } from '../tree-sitter/parser-loader.js';
import { FunctionRegistryTrie, FunctionDefinition } from '../graph/trie.js';

export interface ParsingInput {
	filePaths: string[];
	fileContents: Map<string, string>;
	options?: { directoryFilter?: string; fileExtensions?: string };
}

export interface ParsedDefinition {
	name: string;
	type: 'function' | 'class' | 'method' | 'variable' | 'import' | 'interface' | 'type' | 'decorator';
	startLine: number;
	endLine?: number;
	parameters?: string[] | undefined;
	returnType?: string | undefined;
	accessibility?: 'public' | 'private' | 'protected';

	isStatic?: boolean | undefined;
	isAsync?: boolean | undefined;
	parentClass?: string | undefined;
	decorators?: string[] | undefined;
	extends?: string[] | undefined;
	implements?: string[] | undefined;
	importPath?: string | undefined;
	exportType?: 'named' | 'default' | 'namespace';
	docstring?: string | undefined;
}

export interface ParsedAST {
  tree: Parser.Tree;
}

function generateId(prefix: string, identifier: string): string {
	let hash = 0;
	for (let i = 0; i < identifier.length; i++) {
		const char = identifier.charCodeAt(i);
		hash = ((hash << 5) - hash) + char;
		hash = hash & hash;
	}
	return `${prefix}-${Math.abs(hash)}-${identifier.replace(/[^a-zA-Z0-9]/g, '_')}`;
}

export class ParsingProcessor implements GraphProcessor<ParsingInput> {
	private memoryManager: MemoryManager;
	private duplicateDetector = new DuplicateDetector<string>((item: string) => item);
	private processedFiles = new OptimizedSet<string>();
  private parser: Parser | null = null;
  private languageParsers: Map<string, Parser.Language> = new Map();
  private astMap: Map<string, ParsedAST> = new Map();
  private functionTrie: FunctionRegistryTrie = new FunctionRegistryTrie();

	constructor() {
		this.memoryManager = MemoryManager.getInstance();
	}

  public getASTMap(): Map<string, ParsedAST> {
    return this.astMap;
  }

  public getFunctionRegistry(): FunctionRegistryTrie {
    return this.functionTrie;
  }

	public async process(graph: KnowledgeGraph, input: ParsingInput): Promise<void> {
		const { filePaths, fileContents, options } = input;

		console.log(`ParsingProcessor: Processing ${filePaths.length} total paths`);

		const memoryStats = this.memoryManager.getStats();
		console.log(`Memory status: ${memoryStats.usedMemoryMB}MB used, ${memoryStats.fileCount} files cached`);

		const filteredFiles = this.applyFiltering(filePaths, fileContents, options);
		
		console.log(`ParsingProcessor: After filtering: ${filteredFiles.length} files to parse`);

		const BATCH_SIZE = 10;
		const sourceFiles = filteredFiles.filter((path: string) => this.isSourceFile(path));
		const configFiles = filteredFiles.filter((path: string) => this.isConfigFile(path));
		const allProcessableFiles = [...sourceFiles, ...configFiles];
		
		console.log(`ParsingProcessor: Found ${sourceFiles.length} source files and ${configFiles.length} config files, processing in batches of ${BATCH_SIZE}`);

		try {
			await this.initializeParser();
			
			const batchProcessor = new BatchProcessor<string, void>(BATCH_SIZE, async (filePaths: string[]) => {
				for (const filePath of filePaths) {
					if (this.processedFiles.has(filePath)) {
						continue;
					}
					
					const content = fileContents.get(filePath);
					if (!content) {
						console.warn(`No content found for file: ${filePath}`);
						continue;
					}
					
					try {
						await this.parseFile(graph, filePath, content);
						this.processedFiles.add(filePath);
					} catch (error) {
						console.error(`Error parsing file ${filePath}:`, error);
					}
				}
				return [];
			});

			
			await batchProcessor.processAll(allProcessableFiles);
			
			console.log(`ParsingProcessor: Successfully processed ${this.processedFiles.size} files`);
		} catch (error) {
			console.error('Error initializing parser:', error);
		}
	}

	private applyFiltering(
		filePaths: string[], 
		fileContents: Map<string, string>, 
		options?: { directoryFilter?: string; fileExtensions?: string }): string[] {

		let filtered = filePaths;

		if (options?.directoryFilter) {
			filtered = filtered.filter(path => path.includes(options.directoryFilter ?? ''));
		}

		if (options?.fileExtensions) {
			const extensions = options.fileExtensions.split(',').map(ext => ext.trim()).filter(ext => ext.length);
			filtered = filtered.filter(path => extensions.some(ext => path.endsWith(ext)));
		}

		filtered = filtered.filter(path => 
		  ![...IGNORE_PATTERNS].some(pattern => {
		    if (typeof pattern === 'string') {
		      return path.includes(pattern);
		    }
		    return false;
		  })
		);

		filtered = filtered.filter(path => {
		  const content = fileContents.get(path);
		  return content && content.trim().length > 0;
		});

		return filtered;
	}

	private isSourceFile(filePath: string): boolean {
		const sourceExtensions = ['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.cpp', '.c', '.h', '.hpp', '.cs', '.php', '.rb', '.go', '.rs'];
		return sourceExtensions.some(ext => filePath.toLowerCase().endsWith(ext));
	}

	private isConfigFile(filePath: string): boolean {
		const configFiles = ['package.json', 'tsconfig.json', 'webpack.config.js', 'vite.config.ts', '.eslintrc.js', '.prettierrc'];
		const configExtensions = ['.json', '.yaml', '.yml', '.toml'];

		return configFiles.some(name => filePath.endsWith(name)) ||
			configExtensions.some(ext => filePath.toLowerCase().endsWith(ext));
	}

	private async initializeParser(): Promise<void> {
    if (this.parser) return;
    
    this.parser = await initTreeSitter();

    const languageLoaders = {
      typescript: loadTypeScriptParser,
      javascript: loadJavaScriptParser,
      python: loadPythonParser,
    };

    for (const [lang, loader] of Object.entries(languageLoaders)) {
      try {
        const languageParser = await loader();
        this.languageParsers.set(lang, languageParser);
        console.log(`${lang} parser loaded successfully.`);
      } catch (error) {
        console.error(`Failed to load ${lang} parser:`, error);
      }
    }
	}

	private async parseFile(graph: KnowledgeGraph, filePath: string, content: string): Promise<void> {
    const language = this.detectLanguage(filePath);
    const langParser = this.languageParsers.get(language);

    if (!langParser || !this.parser) {
      console.warn(`No parser available for language: ${language}. Skipping file: ${filePath}`);
      await this.parseGenericFile(graph, filePath, content);
      return;
    }

    this.parser.setLanguage(langParser);
    const tree = this.parser.parse(content);
    this.astMap.set(filePath, { tree });
    const definitions: ParsedDefinition[] = [];

    const queries = this.getQueriesForLanguage(language);
    if (!queries) {
      console.warn(`No queries available for language: ${language}.`);
      return;
    }

    for (const [queryName, queryString] of Object.entries(queries)) {
      const query = langParser.query(queryString as string);
      const matches = query.matches(tree.rootNode);

      for (const match of matches) {
        for (const capture of match.captures) {
          const node = capture.node;
          const definition = this.extractDefinition(node, queryName, filePath);
          if (definition) {
            definitions.push(definition);
          }
        }
      }
    }

    await this.addDefinitionsToGraph(graph, filePath, definitions);
	}

  private extractDefinition(node: Parser.SyntaxNode, queryName: string, filePath: string): ParsedDefinition | null {
    const nameNode = node.childForFieldName('name');
    const name = nameNode ? nameNode.text : 'anonymous';

    return {
      name,
      type: this.getDefinitionType(queryName),
      startLine: node.startPosition.row + 1,
      endLine: node.endPosition.row + 1,
      filePath,
    } as ParsedDefinition;
  }

  private getDefinitionType(queryName: string): ParsedDefinition['type'] {
    switch (queryName) {
      case 'classes': return 'class';
      case 'methods': return 'method';
      case 'functions':
      case 'arrowFunctions': return 'function';
      case 'imports':
      case 'from_imports': return 'import';
      case 'interfaces': return 'interface';
      case 'types': return 'type';
      case 'decorators': return 'decorator';
      default: return 'variable';
    }
  }

	private detectLanguage(filePath: string): string {
		const extension = pathUtils.extname(filePath).toLowerCase();

		switch (extension) {
			case '.ts':
			case '.tsx': return 'typescript';
			case '.js':
			case '.jsx': return 'javascript';
			case '.py': return 'python';
			case '.java': return 'java';
			default: return 'generic';
		}
	}

  private getQueriesForLanguage(language: string): Record<string, string> | null {
    switch (language) {
      case 'typescript':
      case 'javascript':
        return TYPESCRIPT_QUERIES;
      case 'python':
        return PYTHON_QUERIES;
      case 'java':
        return JAVA_QUERIES;
      default:
        return null;
    }
  }

	private async parseGenericFile(graph: KnowledgeGraph, filePath: string, _content: string): Promise<void> {
		const fileNode: GraphNode = {
			id: generateId('file', filePath),
			label: 'File' as NodeLabel,
			properties: {
				name: pathUtils.getFileName(filePath),
				path: filePath,
				size: _content.length,
				language: this.detectLanguage(filePath)
			}
		};

		graph.addNode(fileNode);
	}

	private async addDefinitionsToGraph(
		graph: KnowledgeGraph, 
		filePath: string, 
		definitions: ParsedDefinition[]
	): Promise<void> {
		const fileNode: GraphNode = { 
			id: generateId('file', filePath),
			label: 'File' as NodeLabel,
			properties: {
				name: pathUtils.getFileName(filePath),
				path: filePath,
				language: this.detectLanguage(filePath)
			}
		};

		graph.addNode(fileNode);

		for (const def of definitions) {
			const nodeId = generateId(def.type, `${filePath}:${def.name}`);

			if (this.duplicateDetector.checkAndMark(nodeId)) continue;

			const node: GraphNode = {
				id: nodeId,
				label: this.getNodeLabelForType(def.type),
				properties: {
					name: def.name,
					type: def.type,
					startLine: def.startLine,
					endLine: def.endLine,
					parameters: def.parameters,
					returnType: def.returnType,
					accessibility: def.accessibility,
					isStatic: def.isStatic,
					isAsync: def.isAsync,
					parentClass: def.parentClass,
					decorators: def.decorators,
					extends: def.extends,
					implements: def.implements,
					importPath: def.importPath,
					exportType: def.exportType,
					docstring: def.docstring,
					filePath: filePath
				}
			};

			graph.addNode(node);

      if (def.type === 'function' || def.type === 'method' || def.type === 'class' || def.type === 'interface') {
        const functionDef: FunctionDefinition = {
          nodeId: nodeId,
          qualifiedName: `${filePath}:${def.name}`,
          filePath: filePath,
          functionName: def.name,
          type: def.type,
          startLine: def.startLine,
          endLine: def.endLine,
        };
        this.functionTrie.addDefinition(functionDef);
      }

			const definesRelationship: GraphRelationship = {
				id: generateId('defines', `${fileNode.id}:${node.id}`),
				type: 'DEFINES' as RelationshipType,
				source: fileNode.id,
				target: node.id,
				properties: { 
					filePath: filePath, 
					line_number: def.startLine 
				}
			};

			graph.addRelationship(definesRelationship);

			if (def.extends && def.extends.length > 0) {
				for (const extend of def.extends) {
					const extendsRelationship: GraphRelationship = { 
						id: generateId('extends', `${node.id}:${extend}`),
						type: 'EXTENDS' as RelationshipType,
						source: node.id,
						target: generateId('class', extend),
						properties: {}
					};

					graph.addRelationship(extendsRelationship);
				}
			}

			if (def.implements && def.implements.length > 0) {
				for (const interfaceName of def.implements) {
					const implementsRelationship: GraphRelationship = {
						id: generateId('implements', `${node.id}:${interfaceName}`),
						type: 'IMPLEMENTS' as RelationshipType,
						source: node.id,
						target: generateId('interface', interfaceName),
						properties: {}
					};

					graph.addRelationship(implementsRelationship);
				}
			}

			if (def.importPath) {
				const importRelationship: GraphRelationship = { 
					id: generateId('imports', `${node.id}:${def.importPath}`),
					type: 'IMPORTS' as RelationshipType,
					source: node.id, 
					target: generateId('file', def.importPath),
					properties: { 
						importPath: def.importPath 
					}
				};
				graph.addRelationship(importRelationship);
			}

			if (def.parentClass) {			  
				const parentRelationship: GraphRelationship = {
					id: generateId('belongs_to', `${node.id}:${def.parentClass}`),
					type: 'BELONGS_TO' as RelationshipType,
					source: node.id,
					target: generateId('class', `${filePath}:${def.parentClass}`), 
					properties: {}
				};
				graph.addRelationship(parentRelationship);
			}
		}
	}

	private getNodeLabelForType(type: string): NodeLabel {
		switch (type) {			
			case 'class': return 'Class' as NodeLabel;
			case 'function': return 'Function' as NodeLabel;
			case 'method': return 'Method' as NodeLabel;
			case 'variable': return 'Variable' as NodeLabel;
			case 'import': return 'Import' as NodeLabel;
			case 'interface': return 'Interface' as NodeLabel;
			case 'type': return 'Type' as NodeLabel;
			case 'decorator': return 'Decorator' as NodeLabel;
			default: return 'CodeElement' as NodeLabel;
		}
	}

	public reset(): void {
		this.processedFiles.clear();
		this.duplicateDetector.clear();
		this.memoryManager.clearCache();
	}
}

================
File: src/core/ingestion/pipeline.ts
================
import { SimpleKnowledgeGraph } from '../graph/graph.js';
import type { KnowledgeGraph } from '../graph/types.ts';
import { StructureProcessor } from './structure-processor.ts';
import { ParsingProcessor } from './parsing-processor.ts';
import { ImportProcessor } from './import-processor.ts';
import { CallProcessor } from './call-processor.ts';

export interface PipelineInput {
  projectRoot: string;
  projectName: string;
  filePaths: string[];
  fileContents: Map<string, string>;
  options?: {
    directoryFilter?: string;
    fileExtensions?: string;
  };
}

export class GraphPipeline {
  private structureProcessor: StructureProcessor;
  private parsingProcessor: ParsingProcessor;
  private importProcessor: ImportProcessor;
  private callProcessor!: CallProcessor;

  constructor() {
    this.structureProcessor = new StructureProcessor();
    this.parsingProcessor = new ParsingProcessor();
    this.importProcessor = new ImportProcessor();
    
  }

  public async run(input: PipelineInput): Promise<KnowledgeGraph> {
    const { projectRoot, projectName, filePaths, fileContents, options } = input;
    
    const graph = new SimpleKnowledgeGraph();

    console.log(`🚀 Starting 4-pass ingestion for project: ${projectName}`);
    
    // Pass 1: Structure Analysis
    console.log('📁 Pass 1: Analyzing project structure...');
    await this.structureProcessor.process(graph, {
      projectRoot,
      projectName,
      filePaths
    });
    
    // Pass 2: Code Parsing and Definition Extraction (populates FunctionRegistryTrie)
    console.log('🔍 Pass 2: Parsing code and extracting definitions...');
    await this.parsingProcessor.process(graph, {
      filePaths,
      fileContents,
      options  // Pass filtering options to ParsingProcessor
    });
    
    // Get AST map and function registry from parsing processor
    const astMap = this.parsingProcessor.getASTMap();
    const functionTrie = this.parsingProcessor.getFunctionRegistry();
    
    this.callProcessor = new CallProcessor(functionTrie);
    
    // Pass 3: Import Resolution (builds complete import map)
    console.log('🔗 Pass 3: Resolving imports and building dependency map...');
    await this.importProcessor.process(graph, astMap, fileContents);
    
    // Pass 4: Call Resolution (uses import map and function trie)
    console.log('📞 Pass 4: Resolving function calls with 3-stage strategy...');
    const importMap = this.importProcessor.getImportMap();
    await this.callProcessor.process(graph, astMap, importMap);
    
    console.log(`Ingestion complete. Graph contains ${graph.nodes.length} nodes and ${graph.relationships.length} relationships.`);
    
    // Debug: Show graph structure
    const nodesByType = graph.nodes.reduce((acc, node) => {
      acc[node.label] = (acc[node.label] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    const relationshipsByType = graph.relationships.reduce((acc, rel) => {
      acc[rel.type] = (acc[rel.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    console.log('📊 Graph Statistics:');
    console.log('Nodes by type:', nodesByType);
    console.log('Relationships by type:', relationshipsByType);
    
    // Debug: Find isolated nodes (nodes with no relationships)
    const connectedNodeIds = new Set<string>();
    graph.relationships.forEach(rel => {
      connectedNodeIds.add(rel.source);
      connectedNodeIds.add(rel.target);
    });
    
    const isolatedNodes = graph.nodes.filter(node => !connectedNodeIds.has(node.id));
    if (isolatedNodes.length > 0) {
      console.warn(`⚠️ Found ${isolatedNodes.length} isolated nodes:`);
      const isolatedByType = isolatedNodes.reduce((acc, node) => {
        acc[node.label] = (acc[node.label] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);
      console.warn('Isolated nodes by type:', isolatedByType);
      
      // Show some examples
      console.warn('Sample isolated nodes:', isolatedNodes.slice(0, 5).map(n => ({
        type: n.label,
        name: n.properties.name || n.properties.filePath || n.id,
        properties: Object.keys(n.properties)
      })));
    }
    
    // Debug: Check for files without content
    const fileNodes = graph.nodes.filter(n => n.label === 'File');
    const filesWithoutDefinitions = fileNodes.filter(fileNode => {
      const hasDefinitions = graph.relationships.some(rel => 
        rel.source === fileNode.id && 
        rel.type === 'CONTAINS' && 
        graph.nodes.some(targetNode => 
          targetNode.id === rel.target && 
          ['Function', 'Class', 'Method'].includes(targetNode.label)
        )
      );
      return !hasDefinitions;
    });
    
    if (filesWithoutDefinitions.length > 0) {
      console.warn(`⚠️ Found ${filesWithoutDefinitions.length} files without definitions:`);
      console.warn('Files without content:', filesWithoutDefinitions.slice(0, 5).map(n => 
        n.properties.filePath || n.properties.name
      ));
    }
    
    // Validate graph integrity
    this.validateGraphIntegrity(graph);
    
    return graph;
  }

  /**
   * Validate graph integrity and identify potential issues
   */
  private validateGraphIntegrity(graph: KnowledgeGraph): void {
    console.log('🔍 Validating graph integrity...');
    
    const issues: string[] = [];
    
    // Check 1: Orphaned relationships (references to non-existent nodes)
    const nodeIds = new Set(graph.nodes.map(n => n.id));
    const orphanedRels = graph.relationships.filter(rel => 
      !nodeIds.has(rel.source) || !nodeIds.has(rel.target)
    );
    
    if (orphanedRels.length > 0) {
      issues.push(`${orphanedRels.length} relationships reference non-existent nodes`);
    }
    
    // Check 2: Files without proper structure connections
    const projectNodes = graph.nodes.filter(n => n.label === 'Project');
    const folderNodes = graph.nodes.filter(n => n.label === 'Folder');
    const fileNodes = graph.nodes.filter(n => n.label === 'File');
    
    const filesNotConnectedToStructure = fileNodes.filter(fileNode => {
      const hasStructuralParent = graph.relationships.some(rel =>
        rel.target === fileNode.id && 
        rel.type === 'CONTAINS' &&
        (projectNodes.some(p => p.id === rel.source) || folderNodes.some(f => f.id === rel.source))
      );
      return !hasStructuralParent;
    });
    
    if (filesNotConnectedToStructure.length > 0) {
      issues.push(`${filesNotConnectedToStructure.length} files not connected to project structure`);
    }
    
    // Check 3: Source files without any definitions
    const sourceFileExtensions = ['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.cpp', '.c', '.cs'];
    const sourceFiles = fileNodes.filter(fileNode => {
      const filePath = fileNode.properties.filePath as string || '';
      return sourceFileExtensions.some(ext => filePath.endsWith(ext));
    });
    
    const sourceFilesWithoutDefinitions = sourceFiles.filter(fileNode => {
      const hasDefinitions = graph.relationships.some(rel =>
        rel.source === fileNode.id && 
        rel.type === 'CONTAINS' &&
        graph.nodes.some(n => 
          n.id === rel.target && 
          ['Function', 'Class', 'Method', 'Variable'].includes(n.label)
        )
      );
      return !hasDefinitions;
    });
    
    if (sourceFilesWithoutDefinitions.length > 0) {
      issues.push(`${sourceFilesWithoutDefinitions.length} source files contain no parsed definitions`);
      console.warn('Source files without definitions:', 
        sourceFilesWithoutDefinitions.slice(0, 3).map(n => n.properties.filePath)
      );
    }
    
    // Check 4: Functions/Classes without file parents
    const definitionNodes = graph.nodes.filter(n => 
      ['Function', 'Class', 'Method', 'Variable'].includes(n.label)
    );
    
    const definitionsWithoutFiles = definitionNodes.filter(defNode => {
      const hasFileParent = graph.relationships.some(rel =>
        rel.target === defNode.id &&
        rel.type === 'CONTAINS' &&
        graph.nodes.some(n => n.id === rel.source && n.label === 'File')
      );
      return !hasFileParent;
    });
    
    if (definitionsWithoutFiles.length > 0) {
      issues.push(`${definitionsWithoutFiles.length} definitions not connected to files`);
    }
    
    // Check 5: Import/Call relationship issues
    const importRels = graph.relationships.filter(r => r.type === 'IMPORTS');
    const callRels = graph.relationships.filter(r => r.type === 'CALLS');
    
    if (sourceFiles.length > 1 && importRels.length === 0) {
      issues.push('No import relationships found between files');
    }
    
    if (definitionNodes.length > 1 && callRels.length === 0) {
      issues.push('No function call relationships found');
    }
    
    // Report results
    if (issues.length === 0) {
      console.log('✅ Graph integrity validation passed');
    } else {
      console.warn('⚠️ Graph integrity issues found:');
      issues.forEach((issue, i) => console.warn(`  ${i + 1}. ${issue}`));
    }
  }

  public getStats(graph: KnowledgeGraph): { nodeStats: Record<string, number>; relationshipStats: Record<string, number> } {
    const nodeStats: Record<string, number> = {};
    const relationshipStats: Record<string, number> = {};
    
    for (const node of graph.nodes) {
      nodeStats[node.label] = (nodeStats[node.label] || 0) + 1;
    }
    
    for (const relationship of graph.relationships) {
      relationshipStats[relationship.type] = (relationshipStats[relationship.type] || 0) + 1;
    }
    
    return { nodeStats, relationshipStats };
  }

  public getCallStats() {
    return this.callProcessor.getStats();
  }
}

================
File: src/core/ingestion/structure-processor.ts
================
import type { KnowledgeGraph, GraphNode, GraphRelationship } from '../graph/types.ts';
import { generateId } from '../../lib/utils.ts';

export interface StructureInput {
  projectRoot: string;
  projectName: string;
  filePaths: string[];  // Now includes ALL paths: files AND directories
}

export class StructureProcessor {
  private nodeIdMap: Map<string, string> = new Map();

  // Import ignore patterns from ParsingProcessor
  private static readonly IGNORE_PATTERNS = new Set([
    // Version Control
    '.git', '.svn', '.hg',
    
    // Package Managers & Dependencies
    'node_modules', 'bower_components', 'jspm_packages', 'vendor', 'deps',
    
    // Python Virtual Environments & Cache
    'venv', 'env', '.venv', '.env', 'envs', 'virtualenv', '__pycache__',
    '.pytest_cache', '.mypy_cache', '.tox',
    
    // Build & Distribution Directories
    'build', 'dist', 'out', 'target', 'bin', 'obj', '.gradle', '_build',
    
    // IDE & Editor Directories
    '.vs', '.vscode', '.idea', '.eclipse', '.settings',
    
    // Temporary & Log Directories
    'tmp', '.tmp', 'temp', 'logs', 'log',
    
    // Coverage & Testing
    'coverage', '.coverage', 'htmlcov', '.nyc_output',
    
    // OS & System
    '.DS_Store', 'Thumbs.db',
    
    // Documentation Build Output
    '_site', '.docusaurus',
    
    // Cache Directories
    '.cache', '.parcel-cache', '.next', '.nuxt'
  ]);

  /**
   * Process complete repository structure directly from discovered paths
   * This is the new robust approach that doesn't infer structure
   */
  public async process(graph: KnowledgeGraph, input: StructureInput): Promise<void> {
    const { projectRoot, projectName, filePaths } = input;
    
    console.log(`StructureProcessor: Processing ${filePaths.length} complete paths`);
    
    // Create project root node
    const projectNode = this.createProjectNode(projectName, projectRoot);
    graph.addNode(projectNode);
    
    // Separate files and directories from the complete path list
    const { directories, files } = this.categorizePaths(filePaths);
    
    console.log(`StructureProcessor: Found ${directories.length} directories and ${files.length} files`);
    
    // Filter out ignored directories from KG display (but keep for internal structure)
    const visibleDirectories = directories.filter(dir => !this.shouldHideDirectory(dir));
    const hiddenDirectoriesCount = directories.length - visibleDirectories.length;
    
    if (hiddenDirectoriesCount > 0) {
      console.log(`StructureProcessor: Hiding ${hiddenDirectoriesCount} ignored directories from KG`);
    }
    
    // Create directory nodes only for visible directories
    const directoryNodes = this.createDirectoryNodes(visibleDirectories);
    directoryNodes.forEach(node => graph.addNode(node));
    
    // Filter out files that are inside ignored directories
    const visibleFiles = files.filter(file => !this.shouldHideFile(file));
    const hiddenFilesCount = files.length - visibleFiles.length;
    
    if (hiddenFilesCount > 0) {
      console.log(`StructureProcessor: Hiding ${hiddenFilesCount} files in ignored directories from KG`);
    }
    
    // Create file nodes only for visible files
    const fileNodes = this.createFileNodes(visibleFiles);
    fileNodes.forEach(node => graph.addNode(node));
    
    // Establish CONTAINS relationships for visible structure only
    this.createContainsRelationships(graph, projectNode.id, visibleDirectories, visibleFiles);
    
    const totalHidden = hiddenDirectoriesCount + hiddenFilesCount;
    console.log(`StructureProcessor: Created ${graph.nodes.length} nodes total (${totalHidden} items hidden)`);
  }

  /**
   * Categorize paths into files and directories
   * Since we now receive the complete structure, we need to distinguish between them
   */
  private categorizePaths(allPaths: string[]): { directories: string[], files: string[] } {
    const directories: string[] = [];
    const files: string[] = [];
    const pathSet = new Set(allPaths);
    
    for (const path of allPaths) {
      // A path is a directory if:
      // 1. Other paths exist that start with this path + "/"
      // 2. OR it doesn't have a file extension and other paths are nested under it
      const isDirectory = allPaths.some(otherPath => 
        otherPath !== path && otherPath.startsWith(path + '/')
      );
      
      if (isDirectory) {
        directories.push(path);
      } else {
        // It's a file if it's not identified as a directory
        files.push(path);
      }
    }
    
    // Also add intermediate directories that might not be explicitly listed
    const allIntermediateDirs = new Set<string>();
    for (const path of allPaths) {
      const parts = path.split('/');
      for (let i = 1; i < parts.length; i++) {
        const intermediatePath = parts.slice(0, i).join('/');
        if (intermediatePath && !pathSet.has(intermediatePath)) {
          allIntermediateDirs.add(intermediatePath);
        }
      }
    }
    
    // Add intermediate directories that weren't explicitly listed
    directories.push(...Array.from(allIntermediateDirs));
    
    return { 
      directories: [...new Set(directories)].sort(),  // Remove duplicates and sort
      files: files.sort() 
    };
  }

  private createProjectNode(projectName: string, projectRoot: string): GraphNode {
    const id = generateId('project', projectName);
    this.nodeIdMap.set('', id); // Empty path represents project root
    
    return {
      id,
      label: 'Project',
      properties: {
        name: projectName,
        path: projectRoot,
        createdAt: new Date().toISOString()
      }
    };
  }

  /**
   * Create nodes for directories directly from discovered directory paths
   */
  private createDirectoryNodes(directoryPaths: string[]): GraphNode[] {
    const nodes: GraphNode[] = [];
    
    for (const dirPath of directoryPaths) {
      if (!dirPath) continue;
      
      const id = generateId('folder', dirPath);
      this.nodeIdMap.set(dirPath, id);
      
      const pathParts = dirPath.split('/');
      const dirName = pathParts[pathParts.length - 1];
      
      const node: GraphNode = {
        id,
        label: 'Folder',
        properties: {
          name: dirName,
          path: dirPath,
          fullPath: dirPath,
          depth: pathParts.length
        }
      };
      
      nodes.push(node);
    }
    
    return nodes;
  }

  /**
   * Create nodes for files directly from discovered file paths
   */
  private createFileNodes(filePaths: string[]): GraphNode[] {
    const nodes: GraphNode[] = [];
    
    for (const filePath of filePaths) {
      if (!filePath) continue;
      
      const id = generateId('file', filePath);
      this.nodeIdMap.set(filePath, id);
      
      const fileName = filePath.split('/').pop() || filePath;
      const extension = this.getFileExtension(fileName);
      
      const node: GraphNode = {
        id,
        label: 'File',
        properties: {
          name: fileName,
          path: filePath,
          filePath: filePath,  // For compatibility with existing code
          extension,
          // Note: definitionCount will be set later by ParsingProcessor
          // language will be determined later by ParsingProcessor
        }
      };
      
      nodes.push(node);
    }
    
    return nodes;
  }

  /**
   * Create CONTAINS relationships for the complete discovered structure
   */
  private createContainsRelationships(
    graph: KnowledgeGraph, 
    projectId: string, 
    directories: string[], 
    files: string[]
  ): void {
    // Create relationships: directories contain subdirectories and files
    const allPaths = [...directories, ...files];
    
    for (const path of allPaths) {
      const parentPath = this.getParentPath(path);
      const parentId = parentPath === '' ? projectId : this.nodeIdMap.get(parentPath);
      const childId = this.nodeIdMap.get(path);
      
      // Only create relationships if both parent and child nodes exist in the graph
      if (parentId && childId && parentId !== childId) {
        const relationship: GraphRelationship = {
          id: generateId('contains', `${parentId}-${childId}`),
          type: 'CONTAINS',
          source: parentId,
          target: childId,
          properties: {}
        };
        
        graph.addRelationship(relationship);
      } else if (!parentId && parentPath !== '') {
        // If parent directory was hidden, connect directly to project or nearest visible parent
        const visibleParentId = this.findVisibleParent(parentPath, projectId);
        if (visibleParentId && childId && visibleParentId !== childId) {
          const relationship: GraphRelationship = {
            id: generateId('contains', `${visibleParentId}-${childId}`),
            type: 'CONTAINS',
            source: visibleParentId,
            target: childId,
            properties: {}
          };
          
          graph.addRelationship(relationship);
        }
      }
    }
    
    console.log(`StructureProcessor: Created ${graph.relationships.length} CONTAINS relationships`);
  }

  /**
   * Find the nearest visible parent directory or project root
   */
  private findVisibleParent(path: string, projectId: string): string {
    if (path === '') return projectId;
    
    const parentPath = this.getParentPath(path);
    const parentId = this.nodeIdMap.get(parentPath);
    
    if (parentId) {
      return parentId; // Found visible parent
    }
    
    // Recursively look for visible parent
    return this.findVisibleParent(parentPath, projectId);
  }

  private getParentPath(path: string): string {
    if (!path || !path.includes('/')) {
      return ''; // Root level
    }
    
    const lastSlashIndex = path.lastIndexOf('/');
    return path.substring(0, lastSlashIndex);
  }

  private getFileExtension(fileName: string): string {
    const lastDotIndex = fileName.lastIndexOf('.');
    if (lastDotIndex === -1 || lastDotIndex === 0) {
      return '';
    }
    return fileName.substring(lastDotIndex);
  }

  public getNodeId(path: string): string | undefined {
    return this.nodeIdMap.get(path);
  }

  public clear(): void {
    this.nodeIdMap.clear();
  }

  /**
   * Check if a directory should be hidden from the KG visualization
   * This matches the ignore patterns used in ParsingProcessor
   */
  private shouldHideDirectory(dirPath: string): boolean {
    const pathSegments = dirPath.split('/');
    
    // Check if any segment of the path matches an ignore pattern
    const hasIgnoredSegment = pathSegments.some(segment => 
      StructureProcessor.IGNORE_PATTERNS.has(segment.toLowerCase())
    );
    
    if (hasIgnoredSegment) {
      return true;
    }
    
    // Additional pattern matching
    const lowerPath = dirPath.toLowerCase();
    
    // Hide Python egg-info directories
    if (lowerPath.includes('.egg-info')) {
      return true;
    }
    
    // Hide site-packages directories
    if (lowerPath.includes('site-packages')) {
      return true;
    }
    
    // Hide most hidden directories (except important ones like .github)
    for (const segment of pathSegments) {
      if (segment.startsWith('.') && segment !== '.github') {
        return true;
      }
    }
    
    return false;
  }

  /**
   * Check if a file should be hidden from the KG visualization
   * This matches the ignore patterns used in ParsingProcessor
   */
  private shouldHideFile(filePath: string): boolean {
    const pathSegments = filePath.split('/');
    
    // Check if any segment of the path matches an ignore pattern
    const hasIgnoredSegment = pathSegments.some(segment => 
      StructureProcessor.IGNORE_PATTERNS.has(segment.toLowerCase())
    );
    
    if (hasIgnoredSegment) {
      return true;
    }
    
    // Additional pattern matching
    const lowerPath = filePath.toLowerCase();
    
    // Hide Python egg-info directories
    if (lowerPath.includes('.egg-info')) {
      return true;
    }
    
    // Hide site-packages directories
    if (lowerPath.includes('site-packages')) {
      return true;
    }
    
    // Hide most hidden directories (except important ones like .github)
    for (const segment of pathSegments) {
      if (segment.startsWith('.') && segment !== '.github') {
        return true;
      }
    }
    
    return false;
  }
}

================
File: src/core/ingestion/tree-sitter-queries.ts
================
export const TYPESCRIPT_QUERIES = {
  imports: `
    (import_statement) @import
  `,
  classes: `
    (class_declaration) @class
  `,
  methods: `
    (method_definition) @method
  `,
  functions: `
    (function_declaration) @function
  `,
  arrowFunctions: `
    (lexical_declaration
      (variable_declarator
        name: (identifier) @name
        value: (arrow_function))) @arrow_function
  `,
  interfaces: `
    (interface_declaration) @interface
  `,
  types: `
    (type_alias_declaration) @type
  `,
};

export const PYTHON_QUERIES = {
  imports: `
    (import_statement) @import
  `,
  from_imports: `
    (import_from_statement) @from_import
  `,
  classes: `
    (class_definition) @class
  `,
  functions: `
    (function_definition) @function
  `,
  decorators: `
    (decorator) @decorator
  `,
};

export const JAVA_QUERIES = {
  classes: `
    (class_declaration) @class
  `,
  methods: `
    (method_declaration) @method
  `,
  interfaces: `
    (interface_declaration) @interface
  `,
};

================
File: src/core/tree-sitter/parser-loader.ts
================
// Import tree-sitter explicitly to ensure Vite pre-optimizes it
import Parser from "web-tree-sitter";

const getWasmPath = (path: string) => {
  const baseUrl = import.meta.env.BASE_URL || '/';
  const finalBaseUrl = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;
  return `${finalBaseUrl}wasm/${path}`;
};

let parserInstance: Parser | null = null;
const parserCache = new Map<string, Parser.Language>();

export async function initTreeSitter(): Promise<Parser> {
  if (parserInstance) return parserInstance;
  
  try {
    // Initialize WebAssembly with proper configuration
    await Parser.init({
      locateFile(scriptName: string, scriptDirectory: string) {
        // Return the correct path for WASM files
        if (scriptName.endsWith('.wasm')) {
          return getWasmPath(scriptName);
        }
        return scriptDirectory + scriptName;
      }
    });
    parserInstance = new Parser();
    return parserInstance;
  } catch (error) {
    console.error('Failed to initialize Tree-sitter:', error);
    throw new Error(`Tree-sitter initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function loadPythonParser(): Promise<Parser.Language> {
  if (parserCache.has('python')) {
    return parserCache.get('python')!;
  }
  
  try {
    // Load Python language from WASM file
    const wasmPath = getWasmPath('python/tree-sitter-python.wasm');
    console.log('Loading Python parser from:', wasmPath);
    
    const pythonLang = await Parser.Language.load(wasmPath);
    
    parserCache.set('python', pythonLang);
    console.log('Python parser loaded successfully');
    return pythonLang;
  } catch (error) {
    console.error('Failed to load Python parser:', error);
    throw new Error(`Python parser loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function loadJavaScriptParser(): Promise<Parser.Language> {
  if (parserCache.has('javascript')) {
    return parserCache.get('javascript')!;
  }
  try {
    const wasmPath = getWasmPath('javascript/tree-sitter-javascript.wasm');
    console.log('Loading JavaScript parser from:', wasmPath);
    const jsLang = await Parser.Language.load(wasmPath);
    parserCache.set('javascript', jsLang);
    console.log('JavaScript parser loaded successfully');
    return jsLang;
  } catch (error) {
    console.error('Failed to load JavaScript parser:', error);
    throw new Error(`JavaScript parser loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function loadTypeScriptParser(): Promise<Parser.Language> {
  if (parserCache.has('typescript')) {
    return parserCache.get('typescript')!;
  }
  try {
    const wasmPath = getWasmPath('typescript/tree-sitter-typescript.wasm');
    console.log('Loading TypeScript parser from:', wasmPath);
    const tsLang = await Parser.Language.load(wasmPath);
    parserCache.set('typescript', tsLang);
    console.log('TypeScript parser loaded successfully');
    return tsLang;
  } catch (error) {
    console.error('Failed to load TypeScript parser:', error);
    throw new Error(`TypeScript parser loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function loadTsxParser(): Promise<Parser.Language> {
  if (parserCache.has('tsx')) {
    return parserCache.get('tsx')!;
  }
  try {
    const wasmPath = getWasmPath('typescript/tree-sitter-tsx.wasm');
    console.log('Loading TSX parser from:', wasmPath);
    const tsxLang = await Parser.Language.load(wasmPath);
    parserCache.set('tsx', tsxLang);
    console.log('TSX parser loaded successfully');
    return tsxLang;
  } catch (error) {
    console.error('Failed to load TSX parser:', error);
    throw new Error(`TSX parser loading failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

================
File: src/index.css
================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

================
File: src/lib/error-handler.ts
================
/**
 * Comprehensive error handling and recovery mechanisms
 */

import { ConfigService } from '../config/config';
import { MemoryManager } from '../services/memory-manager';

// Base error class for all application errors
export class GitNexusError extends Error {
  public readonly code: string;
  public readonly timestamp: Date;
  public readonly context?: Record<string, unknown>;
  public readonly isRecoverable: boolean;

  constructor(
    message: string,
    code: string,
    isRecoverable = true,
    context?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'GitNexusError';
    this.code = code;
    this.timestamp = new Date();
    this.context = context;
    this.isRecoverable = isRecoverable;
    
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GitNexusError);
    }
  }
}

// Specific error types
export class ValidationError extends GitNexusError {
  constructor(message: string, context?: Record<string, unknown>) {
    super(message, 'VALIDATION_ERROR', true, context);
    this.name = 'ValidationError';
  }
}

export class NetworkError extends GitNexusError {
  constructor(message: string, context?: Record<string, unknown>) {
    super(message, 'NETWORK_ERROR', true, context);
    this.name = 'NetworkError';
  }
}

export class MemoryError extends GitNexusError {
  constructor(message: string, context?: Record<string, unknown>) {
    super(message, 'MEMORY_ERROR', true, context);
    this.name = 'MemoryError';
  }
}

export class ParsingError extends GitNexusError {
  constructor(message: string, context?: Record<string, unknown>) {
    super(message, 'PARSING_ERROR', true, context);
    this.name = 'ParsingError';
  }
}

export class ConfigurationError extends GitNexusError {
  constructor(message: string, context?: Record<string, unknown>) {
    super(message, 'CONFIGURATION_ERROR', false, context);
    this.name = 'ConfigurationError';
  }
}

// Retry configuration
interface RetryConfig {
  maxAttempts: number;
  initialDelay: number;
  maxDelay: number;
  backoffMultiplier: number;
  retryableErrors: string[];
}

// Circuit breaker states
enum CircuitBreakerState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN'
}

class CircuitBreaker {
  private state = CircuitBreakerState.CLOSED;
  private failureCount = 0;
  private lastFailureTime: number | null = null;
  private readonly failureThreshold: number;
  private readonly resetTimeout: number;

  constructor(failureThreshold = 5, resetTimeout = 60000) {
    this.failureThreshold = failureThreshold;
    this.resetTimeout = resetTimeout;
  }

  canExecute(): boolean {
    if (this.state === CircuitBreakerState.OPEN) {
      if (this.lastFailureTime && Date.now() - this.lastFailureTime > this.resetTimeout) {
        this.state = CircuitBreakerState.HALF_OPEN;
        return true;
      }
      return false;
    }
    return true;
  }

  recordSuccess(): void {
    this.failureCount = 0;
    this.state = CircuitBreakerState.CLOSED;
  }

  recordFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = CircuitBreakerState.OPEN;
    }
  }

  getState(): string {
    return this.state;
  }
}

// Error recovery service
export class ErrorRecoveryService {
  private static instance: ErrorRecoveryService;
  private readonly config: ConfigService;
  private readonly memoryManager: MemoryManager;
  private readonly circuitBreakers = new Map<string, CircuitBreaker>();
  private readonly retryConfig: RetryConfig;

  private constructor() {
    this.config = ConfigService.getInstance();
    this.memoryManager = MemoryManager.getInstance();
    this.retryConfig = this.getRetryConfig();
  }

  static getInstance(): ErrorRecoveryService {
    if (!ErrorRecoveryService.instance) {
      ErrorRecoveryService.instance = new ErrorRecoveryService();
    }
    return ErrorRecoveryService.instance;
  }

  private getRetryConfig(): RetryConfig {
    const processingConfig = this.config.processing;
    return {
      maxAttempts: processingConfig.retry.maxRetries,
      initialDelay: 1000,
      maxDelay: 10000,
      backoffMultiplier: 2,
      retryableErrors: ['NETWORK_ERROR', 'MEMORY_ERROR', 'VALIDATION_ERROR']
    };
  }

  /**
   * Execute an operation with retry logic and circuit breaker
   */
  async executeWithRetry<T>(
    operation: () => Promise<T>,
    operationName: string,
    customRetryConfig?: Partial<RetryConfig>
  ): Promise<T> {
    const circuitBreaker = this.getCircuitBreaker(operationName);
    
    if (!circuitBreaker.canExecute()) {
      throw new GitNexusError(
        `Circuit breaker is open for ${operationName}`,
        'CIRCUIT_BREAKER_OPEN',
        false,
        { operationName, state: circuitBreaker.getState() }
      );
    }

    const retryConfig = { ...this.retryConfig, ...customRetryConfig };
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= retryConfig.maxAttempts; attempt++) {
      try {
        // Check memory before operation
        await this.memoryManager.forceCleanup();
        
        const result = await operation();
        circuitBreaker.recordSuccess();
        return result;
      } catch (error) {
        lastError = error as Error;
        
        if (!this.shouldRetry(error, retryConfig)) {
          circuitBreaker.recordFailure();
          throw error;
        }

        if (attempt < retryConfig.maxAttempts) {
          const delay = this.calculateDelay(attempt, retryConfig);
          await this.wait(delay);
          
          console.warn(`Retrying ${operationName} (attempt ${attempt}/${retryConfig.maxAttempts})`);
        }
      }
    }

    circuitBreaker.recordFailure();
    throw lastError;
  }

  /**
   * Execute an operation with graceful degradation
   */
  async executeWithFallback<T>(
    primaryOperation: () => Promise<T>,
    fallbackOperation: () => Promise<T>,
    operationName: string
  ): Promise<T> {
    try {
      return await this.executeWithRetry(primaryOperation, operationName);
    } catch (error) {
      console.warn(`Primary operation failed for ${operationName}, using fallback`, error);
      
      try {
        return await fallbackOperation();
      } catch (fallbackError) {
        throw new GitNexusError(
          `Both primary and fallback operations failed for ${operationName}`,
          'FALLBACK_FAILED',
          false,
          { 
            operationName, 
            primaryError: error instanceof Error ? error.message : String(error),
            fallbackError: fallbackError instanceof Error ? fallbackError.message : String(fallbackError)
          }
        );
      }
    }
  }

  /**
   * Handle memory-related errors with recovery
   */
  async handleMemoryError(error: Error, context?: Record<string, unknown>): Promise<void> {
    console.error('Memory error detected, attempting recovery', error, context);
    
    try {
      // Force cleanup
      await this.memoryManager.clearCache();
      
      // Trigger garbage collection if available
      if (global.gc) {
        global.gc();
      }
      
      console.info('Memory recovery completed');
    } catch (recoveryError) {
      throw new MemoryError(
        'Failed to recover from memory error',
        { 
          originalError: error.message,
          recoveryError: recoveryError instanceof Error ? recoveryError.message : String(recoveryError),
          ...context 
        }
      );
    }
  }

  /**
   * Log error with context for debugging
   */
  logError(error: GitNexusError, context?: Record<string, unknown>): void {
    const errorLog = {
      timestamp: error.timestamp.toISOString(),
      code: error.code,
      message: error.message,
      stack: error.stack,
      context: { ...error.context, ...context },
      isRecoverable: error.isRecoverable
    };

    // In production, this would send to external logging service
    console.error('Application error:', JSON.stringify(errorLog, null, 2));
  }

  private getCircuitBreaker(operationName: string): CircuitBreaker {
    if (!this.circuitBreakers.has(operationName)) {
      this.circuitBreakers.set(operationName, new CircuitBreaker());
    }
    return this.circuitBreakers.get(operationName)!;
  }

  private shouldRetry(error: unknown, retryConfig: RetryConfig): boolean {
    if (error instanceof GitNexusError) {
      return retryConfig.retryableErrors.includes(error.code) && error.isRecoverable;
    }
    return true; // Retry unknown errors by default
  }

  private calculateDelay(attempt: number, retryConfig: RetryConfig): number {
    const delay = retryConfig.initialDelay * Math.pow(retryConfig.backoffMultiplier, attempt - 1);
    return Math.min(delay, retryConfig.maxDelay);
  }

  private wait(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Global error handler
export function setupGlobalErrorHandlers(): void {
  process.on('uncaughtException', (error: Error) => {
    const recoveryService = ErrorRecoveryService.getInstance();
    const gitNexusError = error instanceof GitNexusError 
      ? error 
      : new GitNexusError(
          'Uncaught exception',
          'UNCAUGHT_EXCEPTION',
          false,
          { originalError: error.message, stack: error.stack }
        );
    
    recoveryService.logError(gitNexusError);
    
    // Attempt graceful shutdown
    process.exit(1);
  });

  process.on('unhandledRejection', (reason: unknown) => {
    const recoveryService = ErrorRecoveryService.getInstance();
    const error = reason instanceof Error ? reason : new Error(String(reason));
    const gitNexusError = new GitNexusError(
      'Unhandled promise rejection',
      'UNHANDLED_REJECTION',
      false,
      { reason: error.message, stack: error.stack }
    );
    
    recoveryService.logError(gitNexusError);
  });
}

// Utility functions for common error scenarios
export function createSafeAsync<T extends (...args: any[]) => Promise<unknown>>(
  fn: T,
  errorHandler?: (error: Error, ...args: Parameters<T>) => Promise<unknown>
): T {
  return (async (...args: Parameters<T>) => {
    try {
      return await fn(...args);
    } catch (error) {
      if (errorHandler) {
        return await errorHandler(error as Error, ...args);
      }
      throw error;
    }
  }) as T;
}

export function createSafe<T extends (...args: any[]) => unknown>(
  fn: T,
  errorHandler?: (error: Error, ...args: Parameters<T>) => unknown
): T {
  return ((...args: Parameters<T>) => {
    try {
      return fn(...args);
    } catch (error) {
      if (errorHandler) {
        return errorHandler(error as Error, ...args);
      }
      throw error;
    }
  }) as T;
}

================
File: src/lib/export.ts
================
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface ExportOptions {
  filename?: string;
  includeMetadata?: boolean;
  prettyPrint?: boolean;
  includeTimestamp?: boolean;
}

export interface ExportMetadata {
  exportedAt: string;
  version: string;
  nodeCount: number;
  relationshipCount: number;
  fileCount?: number;
  processingDuration?: number;
}

export interface ExportedGraph {
  metadata: ExportMetadata;
  graph: KnowledgeGraph;
  fileContents?: Record<string, string>;
}

/**
 * Export a KnowledgeGraph to JSON format
 */
export function exportGraphToJSON(
  graph: KnowledgeGraph,
  options: ExportOptions = {},
  fileContents?: Map<string, string>,
  processingStats?: { duration: number }
): string {
  const {
    includeMetadata = true,
    prettyPrint = true,
    includeTimestamp = true
  } = options;

  let exportData: ExportedGraph | KnowledgeGraph;

  if (includeMetadata) {
    const metadata: ExportMetadata = {
      exportedAt: includeTimestamp ? new Date().toISOString() : '',
      version: '1.0.0',
      nodeCount: graph.nodes.length,
      relationshipCount: graph.relationships.length,
      fileCount: fileContents?.size,
      processingDuration: processingStats?.duration
    };

    exportData = {
      metadata,
      graph,
      ...(fileContents && { fileContents: Object.fromEntries(fileContents) })
    };
  } else {
    exportData = graph;
  }

  return JSON.stringify(exportData, null, prettyPrint ? 2 : 0);
}

/**
 * Trigger download of a JSON file
 */
export function downloadJSON(content: string, filename: string): void {
  try {
    // Create blob with JSON content
    const blob = new Blob([content], { type: 'application/json' });
    
    // Create download URL
    const url = URL.createObjectURL(blob);
    
    // Create temporary download link
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    // Add to DOM, click, and remove
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up URL
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('Failed to download JSON file:', error);
    throw new Error('Failed to download file. Please check your browser permissions.');
  }
}

/**
 * Generate a default filename for the export
 */
export function generateExportFilename(
  projectName?: string,
  includeTimestamp: boolean = true
): string {
  const baseName = projectName 
    ? `gitnexus-${projectName.replace(/[^a-zA-Z0-9-_]/g, '-')}`
    : 'gitnexus-graph';
  
  if (includeTimestamp) {
    const timestamp = new Date().toISOString()
      .replace(/[:.]/g, '-')
      .replace('T', '_')
      .split('.')[0]; // Remove milliseconds
    return `${baseName}_${timestamp}.json`;
  }
  
  return `${baseName}.json`;
}

/**
 * Export and download a KnowledgeGraph
 */
export function exportAndDownloadGraph(
  graph: KnowledgeGraph,
  options: ExportOptions & { projectName?: string } = {},
  fileContents?: Map<string, string>,
  processingStats?: { duration: number }
): void {
  const {
    filename,
    projectName,
    includeTimestamp = true,
    ...exportOptions
  } = options;

  try {
    // Generate filename if not provided
    const finalFilename = filename || generateExportFilename(projectName, includeTimestamp);
    
    // Export to JSON
    const jsonContent = exportGraphToJSON(graph, exportOptions, fileContents, processingStats);
    
    // Trigger download
    downloadJSON(jsonContent, finalFilename);
    
    console.log(`Successfully exported graph to ${finalFilename}`);
  } catch (error) {
    console.error('Export failed:', error);
    throw error;
  }
}

/**
 * Calculate export file size (approximate)
 */
export function calculateExportSize(
  graph: KnowledgeGraph,
  includeFileContents: boolean = false,
  fileContents?: Map<string, string>
): { sizeBytes: number; sizeFormatted: string } {
  // Create a sample export to measure size
  const sampleExport = exportGraphToJSON(
    graph,
    { includeMetadata: true, prettyPrint: false },
    includeFileContents ? fileContents : undefined
  );
  
  const sizeBytes = new Blob([sampleExport]).size;
  const sizeFormatted = formatFileSize(sizeBytes);
  
  return { sizeBytes, sizeFormatted };
}

/**
 * Format file size in human-readable format
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Validate if a graph can be exported
 */
export function validateGraphForExport(graph: KnowledgeGraph): {
  isValid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  // Check if graph exists
  if (!graph) {
    errors.push('Graph is null or undefined');
    return { isValid: false, errors, warnings };
  }
  
  // Check if graph has nodes
  if (!graph.nodes || graph.nodes.length === 0) {
    warnings.push('Graph has no nodes');
  }
  
  // Check if graph has relationships
  if (!graph.relationships || graph.relationships.length === 0) {
    warnings.push('Graph has no relationships');
  }
  
  // Check for invalid node IDs
  const nodeIds = new Set(graph.nodes.map(n => n.id));
  if (nodeIds.size !== graph.nodes.length) {
    errors.push('Graph contains duplicate node IDs');
  }
  
  // Check for invalid relationships
  graph.relationships.forEach((rel, index) => {
    if (!nodeIds.has(rel.source)) {
      errors.push(`Relationship ${index} has invalid source node ID: ${rel.source}`);
    }
    if (!nodeIds.has(rel.target)) {
      errors.push(`Relationship ${index} has invalid target node ID: ${rel.target}`);
    }
  });
  
  // Check for very large exports
  const approximateSize = JSON.stringify(graph).length;
  if (approximateSize > 50 * 1024 * 1024) { // 50MB
    warnings.push('Export file will be very large (>50MB). Consider filtering the data.');
  }
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Import a KnowledgeGraph from JSON string
 */
export function importGraphFromJSON(jsonString: string): {
  graph: KnowledgeGraph;
  metadata?: ExportMetadata;
  fileContents?: Map<string, string>;
} {
  try {
    const parsed = JSON.parse(jsonString);
    
    // Check if it's an exported graph with metadata
    if (parsed.metadata && parsed.graph) {
      const result: {
        graph: KnowledgeGraph;
        metadata: ExportMetadata;
        fileContents?: Map<string, string>;
      } = {
        graph: parsed.graph,
        metadata: parsed.metadata
      };
      
      // Convert file contents back to Map if present
      if (parsed.fileContents) {
        result.fileContents = new Map(Object.entries(parsed.fileContents));
      }
      
      return result;
    }
    
    // Assume it's a raw graph
    return { graph: parsed };
  } catch (error) {
    throw new Error(`Failed to import graph: ${error instanceof Error ? error.message : 'Invalid JSON'}`);
  }
}

/**
 * Create a filtered export of the graph
 */
export function createFilteredExport(
  graph: KnowledgeGraph,
  filters: {
    nodeTypes?: string[];
    relationshipTypes?: string[];
    filePatterns?: string[];
    maxNodes?: number;
  }
): KnowledgeGraph {
  const { nodeTypes, relationshipTypes, filePatterns, maxNodes } = filters;
  
  let filteredNodes = graph.nodes;
  let filteredRelationships = graph.relationships;
  
  // Filter by node types
  if (nodeTypes && nodeTypes.length > 0) {
    filteredNodes = filteredNodes.filter(node => nodeTypes.includes(node.label));
  }
  
  // Filter by file patterns
  if (filePatterns && filePatterns.length > 0) {
    filteredNodes = filteredNodes.filter(node => {
      const filePath = node.properties.filePath as string;
      if (!filePath) return true; // Keep nodes without file paths
      
      return filePatterns.some(pattern => {
        const regex = new RegExp(pattern.replace(/\*/g, '.*'), 'i');
        return regex.test(filePath);
      });
    });
  }
  
  // Limit number of nodes
  if (maxNodes && filteredNodes.length > maxNodes) {
    filteredNodes = filteredNodes.slice(0, maxNodes);
  }
  
  // Get filtered node IDs
  const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
  
  // Filter relationships to only include those between filtered nodes
  filteredRelationships = filteredRelationships.filter(rel => 
    filteredNodeIds.has(rel.source) && filteredNodeIds.has(rel.target)
  );
  
  // Filter by relationship types
  if (relationshipTypes && relationshipTypes.length > 0) {
    filteredRelationships = filteredRelationships.filter(rel => 
      relationshipTypes.includes(rel.type)
    );
  }
  
  return {
    nodes: filteredNodes,
    relationships: filteredRelationships
  };
}

================
File: src/lib/polyfills.ts
================
// Browser polyfill for Node.js AsyncLocalStorage
export class AsyncLocalStorage<T> {
  private storage = new Map<string, T>();
  private currentId = 0;

  constructor() {}

  run<R>(store: T, callback: () => R): R {
    const id = (++this.currentId).toString();
    this.storage.set(id, store);
    try {
      return callback();
    } finally {
      this.storage.delete(id);
    }
  }

  getStore(): T | undefined {
    // In browser context, we can't truly replicate AsyncLocalStorage
    // Return undefined as fallback
    return undefined;
  }
}

// Export as both named and default to match different import styles
export { AsyncLocalStorage as default };

// Polyfill for global async_hooks if not available
if (typeof globalThis !== 'undefined' && !(globalThis as any).AsyncLocalStorage) {
  (globalThis as any).AsyncLocalStorage = AsyncLocalStorage;
}

================
File: src/lib/preload.ts
================
// Preload all dependencies that might be loaded during processing
// This ensures Vite optimizes them during initial build rather than during runtime

import 'web-tree-sitter';
import 'comlink';

// Import all the processing modules to ensure their dependencies are discovered
import '../core/ingestion/pipeline';
import '../core/ingestion/parsing-processor';
import '../core/ingestion/call-processor';
import '../core/ingestion/structure-processor';
import '../core/tree-sitter/parser-loader';

console.log('Dependencies preloaded to prevent runtime optimization');

================
File: src/lib/shared-utils.ts
================
/**
 * Shared utilities for path handling, deduplication, and common operations
 * Consolidates duplicated code across processors
 */

// Path utilities for browser compatibility
export const pathUtils = {
  extname: (filePath: string): string => {
    const lastDot = filePath.lastIndexOf('.');
    return lastDot === -1 ? '' : filePath.substring(lastDot);
  },
  
  dirname: (filePath: string): string => {
    const lastSlash = Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\'));
    return lastSlash === -1 ? '.' : filePath.substring(0, lastSlash);
  },
  
  resolve: (basePath: string, relativePath: string): string => {
    // Simple relative path resolution
    if (relativePath.startsWith('./')) {
      return basePath + '/' + relativePath.substring(2);
    } else if (relativePath.startsWith('../')) {
      const parts = basePath.split('/');
      const relativeParts = relativePath.split('/');
      let upCount = 0;
      for (const part of relativeParts) {
        if (part === '..') upCount++;
        else break;
      }
      const resultParts = parts.slice(0, -upCount);
      const remainingParts = relativeParts.slice(upCount);
      return [...resultParts, ...remainingParts].join('/');
    }
    return basePath + '/' + relativePath;
  },
  
  join: (...parts: string[]): string => {
    return parts.join('/').replace(/\/+/g, '/');
  },
  
  normalize: (filePath: string): string => {
    return filePath.replace(/\\/g, '/');
  },
  
  getFileExtension: (filePath: string): string => {
    if (!filePath) return '';
    const lastDotIndex = filePath.lastIndexOf('.');
    if (lastDotIndex === -1) {
      return '';
    }
    return filePath.substring(lastDotIndex);
  },
  
  getFileName: (filePath: string): string => {
    return filePath.split('/').pop() || filePath;
  }
};

// Performance optimizations using Sets instead of Arrays
export class OptimizedSet<T> {
  private items: Set<T>;
  private _array: T[] | null = null;

  constructor(items?: Iterable<T>) {
    this.items = new Set(items);
  }

  add(item: T): this {
    this.items.add(item);
    this._array = null; // Invalidate cache
    return this;
  }

  has(item: T): boolean {
    return this.items.has(item);
  }

  delete(item: T): boolean {
    const result = this.items.delete(item);
    if (result) {
      this._array = null; // Invalidate cache
    }
    return result;
  }

  clear(): void {
    this.items.clear();
    this._array = null;
  }

  get size(): number {
    return this.items.size;
  }

  // Convert to array only when needed and cache the result
  toArray(): T[] {
    if (this._array === null) {
      this._array = Array.from(this.items);
    }
    return this._array;
  }

  forEach(callback: (value: T) => void): void {
    this.items.forEach(callback);
  }

  filter(predicate: (value: T) => boolean): T[] {
    return this.toArray().filter(predicate);
  }

  map<U>(mapper: (value: T) => U): U[] {
    return this.toArray().map(mapper);
  }

  some(predicate: (value: T) => boolean): boolean {
    for (const item of this.items) {
      if (predicate(item)) return true;
    }
    return false;
  }

  every(predicate: (value: T) => boolean): boolean {
    for (const item of this.items) {
      if (!predicate(item)) return false;
    }
    return true;
  }
}

// Duplicate detection using Sets for O(1) performance
export class DuplicateDetector<T> {
  private seen: Set<string>;
  private keyExtractor: (item: T) => string;

  constructor(keyExtractor: (item: T) => string) {
    this.seen = new Set();
    this.keyExtractor = keyExtractor;
  }

  isDuplicate(item: T): boolean {
    const key = this.keyExtractor(item);
    return this.seen.has(key);
  }

  markAsSeen(item: T): void {
    const key = this.keyExtractor(item);
    this.seen.add(key);
  }

  checkAndMark(item: T): boolean {
    const key = this.keyExtractor(item);
    if (this.seen.has(key)) {
      return true; // Is duplicate
    }
    this.seen.add(key);
    return false; // Not duplicate
  }

  clear(): void {
    this.seen.clear();
  }

  get size(): number {
    return this.seen.size;
  }
}

// Language detection utilities
export const languageUtils = {
  getLanguageFromExtension: (extension: string): string => {
    switch (extension.toLowerCase()) {
      case '.py':
      case '.pyx':
      case '.pyi':
        return 'python';
      case '.js':
      case '.mjs':
      case '.cjs':
      case '.jsx':
        return 'javascript';
      case '.ts':
        return 'typescript';
      case '.tsx':
        return 'tsx';
      case '.java':
        return 'java';
      case '.cpp':
      case '.cc':
      case '.cxx':
        return 'cpp';
      case '.c':
        return 'c';
      case '.h':
      case '.hpp':
        return 'header';
      case '.cs':
        return 'csharp';
      case '.php':
        return 'php';
      case '.rb':
        return 'ruby';
      case '.go':
        return 'go';
      case '.rs':
        return 'rust';
      case '.swift':
        return 'swift';
      case '.kt':
        return 'kotlin';
      case '.scala':
        return 'scala';
      case '.dart':
        return 'dart';
      default:
        return 'unknown';
    }
  },

  isSourceFile: (filePath: string): boolean => {
    if (!filePath) return false;
    const fileName = pathUtils.getFileName(filePath);
    
    // Include special files
    if (fileName === '__init__.py') return true;
    
    const extension = pathUtils.getFileExtension(filePath).toLowerCase();
    const sourceExtensions = new Set([
      '.py', '.js', '.jsx', '.ts', '.tsx', '.java', '.cpp', '.c', '.h', '.hpp',
      '.cs', '.php', '.rb', '.go', '.rs', '.swift', '.kt', '.scala', '.dart'
    ]);
    return sourceExtensions.has(extension);
  },

  isConfigFile: (filePath: string): boolean => {
    if (!filePath) return false;
    const fileName = pathUtils.getFileName(filePath);
    
    const configFiles = new Set([
      'package.json', 'tsconfig.json', 'tsconfig.base.json',
      'vite.config.ts', 'vite.config.js', 'webpack.config.js',
      '.eslintrc', '.eslintrc.json', '.eslintrc.js',
      '.prettierrc', '.prettierrc.json',
      'docker-compose.yml', 'docker-compose.yaml',
      'dockerfile', 'Dockerfile',
      '.env', '.env.example', '.env.local', '.env.production',
      'pyproject.toml', 'setup.py', 'requirements.txt', 'poetry.lock',
      'Cargo.toml', 'Cargo.lock',
      'pom.xml', 'build.gradle', 'build.gradle.kts'
    ]);
    
    return configFiles.has(fileName.toLowerCase());
  }
};

// Memory-efficient batch processing
export class BatchProcessor<T, R> {
  private batchSize: number;
  private processor: (batch: T[]) => Promise<R[]>;

  constructor(batchSize: number, processor: (batch: T[]) => Promise<R[]>) {
    this.batchSize = batchSize;
    this.processor = processor;
  }

  async processAll(
    items: T[], 
    progressCallback?: (processed: number, total: number) => void
  ): Promise<R[]> {
    const results: R[] = [];
    const total = items.length;

    for (let i = 0; i < items.length; i += this.batchSize) {
      const batch = items.slice(i, i + this.batchSize);
      const batchResults = await this.processor(batch);
      results.push(...batchResults);

      if (progressCallback) {
        progressCallback(Math.min(i + this.batchSize, total), total);
      }

      // Small delay to prevent blocking
      if (i + this.batchSize < items.length) {
        await new Promise(resolve => setTimeout(resolve, 1));
      }
    }

    return results;
  }
}

// String utilities for sanitization and validation
export const stringUtils = {
  sanitize: (input: string, maxLength = 1000): string => {
    return input
      .trim()
      .replace(/[<>]/g, '') // Remove potential XSS vectors
      .substring(0, maxLength);
  },

  isValidIdentifier: (name: string): boolean => {
    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);
  },

  extractIdentifiers: (text: string): string[] => {
    const identifiers = text.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);
    return identifiers ? [...new Set(identifiers)] : [];
  },

  levenshteinDistance: (a: string, b: string): number => {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;

    const matrix: number[][] = [];

    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1, // substitution
            matrix[i][j - 1] + 1,     // insertion
            matrix[i - 1][j] + 1      // deletion
          );
        }
      }
    }

    return matrix[b.length][a.length];
  }
};

================
File: src/lib/streaming-processor.ts
================
/**
 * Streaming processor for handling large files with memory constraints
 */

import { createReadStream } from 'fs';
import { createInterface } from 'readline';
import { pipeline } from 'stream/promises';
import { Transform } from 'stream';
import { MemoryManager } from '../services/memory-manager';
import { ErrorRecoveryService } from './error-handler';

export interface StreamingOptions {
  chunkSize?: number;
  maxFileSize?: number;
  encoding?: BufferEncoding;
  parallelProcessing?: boolean;
  maxConcurrency?: number;
}

export interface ProcessingResult<T> {
  data: T[];
  processedLines: number;
  skippedLines: number;
  errors: ProcessingError[];
  processingTime: number;
}

export interface ProcessingError {
  lineNumber: number;
  error: string;
  content?: string;
}

export interface ProgressCallback<T> {
  (progress: {
    processedLines: number;
    totalLines?: number;
    percentage?: number;
    currentChunk: T[];
  }): void;
}

export class StreamingProcessor {
  private static instance: StreamingProcessor;
  private readonly memoryManager: MemoryManager;
  private readonly errorRecovery: ErrorRecoveryService;

  private constructor() {
    this.memoryManager = MemoryManager.getInstance();
    this.errorRecovery = ErrorRecoveryService.getInstance();
  }

  static getInstance(): StreamingProcessor {
    if (!StreamingProcessor.instance) {
      StreamingProcessor.instance = new StreamingProcessor();
    }
    return StreamingProcessor.instance;
  }

  /**
   * Process a file line by line using streaming
   */
  async processFile<T>(
    filePath: string,
    lineProcessor: (line: string, lineNumber: number) => Promise<T | null>,
    options: StreamingOptions = {},
    progressCallback?: ProgressCallback<T>
  ): Promise<ProcessingResult<T>> {
    const startTime = Date.now();
    const defaultOptions: StreamingOptions = {
      chunkSize: 1000,
      maxFileSize: 50 * 1024 * 1024, // 50MB
      encoding: 'utf8',
      parallelProcessing: false,
      maxConcurrency: 4
    };

    const finalOptions = { ...defaultOptions, ...options };

    return this.errorRecovery.executeWithRetry(async () => {
      // Check file size
      const fileSize = await this.getFileSize(filePath);
      if (fileSize > (finalOptions.maxFileSize ?? 0)) {
        throw new Error(`File too large: ${fileSize} bytes (max: ${finalOptions.maxFileSize})`);
      }

      // Check memory
      await this.memoryManager.forceCleanup();

      const results: T[] = [];
      const errors: ProcessingError[] = [];
      let processedLines = 0;
      let skippedLines = 0;

      const readStream = createReadStream(filePath, { encoding: finalOptions.encoding });
      const rl = createInterface({
        input: readStream,
        crlfDelay: Infinity
      });

      let currentChunk: T[] = [];
      let lineNumber = 0;

      try {
        for await (const line of rl) {
          lineNumber++;

          try {
            const result = await lineProcessor(line, lineNumber);
            if (result !== null) {
              currentChunk.push(result);
              results.push(result);
            } else {
              skippedLines++;
            }

            processedLines++;

            // Process chunk if size reached
            if (currentChunk.length >= (finalOptions.chunkSize ?? 0)) {
              if (progressCallback) {
                progressCallback({
                  processedLines,
                  percentage: fileSize ? (processedLines / (fileSize / 100)) * 100 : undefined,
                  currentChunk
                });
              }

              // Clear chunk to manage memory
              currentChunk = [];
              
              // Periodic memory check
              if (processedLines % 10000 === 0) {
                await this.memoryManager.forceCleanup();
              }
            }
          } catch (error) {
            errors.push({
              lineNumber,
              error: error instanceof Error ? error.message : String(error),
              content: line.substring(0, 100) // Limit content length
            });
          }
        }

        // Final progress callback
        if (progressCallback && currentChunk.length > 0) {
          progressCallback({
            processedLines,
            percentage: 100,
            currentChunk
          });
        }

      } finally {
        rl.close();
        readStream.destroy();
      }

      return {
        data: results,
        processedLines,
        skippedLines,
        errors,
        processingTime: Date.now() - startTime
      };
    }, `processFile:${filePath}`);
  }

  /**
   * Process multiple files in parallel with memory management
   */
  async processFilesParallel<T>(
    files: string[],
    fileProcessor: (filePath: string) => Promise<T>,
    maxConcurrency = 4
  ): Promise<Array<{ filePath: string; result: T | null; error?: string }>> {
    const semaphore = new Semaphore(maxConcurrency);
    const results: Array<{ filePath: string; result: T | null; error?: string }> = [];

    const processFileWithSemaphore = async (filePath: string) => {
      await semaphore.acquire();
      try {
        const result = await this.errorRecovery.executeWithRetry(
          () => fileProcessor(filePath),
          `processFile:${filePath}`
        );
        results.push({ filePath, result });
      } catch (error) {
        results.push({
          filePath,
          result: null,
          error: error instanceof Error ? error.message : String(error)
        });
      } finally {
        semaphore.release();
      }
    };

    await Promise.all(files.map(processFileWithSemaphore));
    return results;
  }

  /**
   * Transform stream for processing large data streams
   */
  createTransformStream<T, R>(
    transformer: (chunk: T) => Promise<R>,
    options: { parallel?: boolean; maxConcurrency?: number } = {}
  ): Transform {
    const { parallel = false, maxConcurrency = 4 } = options;

    return new Transform({
      objectMode: true,
      async transform(chunk: T, encoding, callback) {
        try {
          if (parallel) {
            const semaphore = new Semaphore(maxConcurrency);
            await semaphore.acquire();
            try {
              const result = await transformer(chunk);
              callback(null, result);
            } finally {
              semaphore.release();
            }
          } else {
            const result = await transformer(chunk);
            callback(null, result);
          }
        } catch (error) {
          callback(error as Error);
        }
      }
    });
  }

  /**
   * Process data in batches with memory management
   */
  async processInBatches<T, R>(
    data: T[],
    batchProcessor: (batch: T[]) => Promise<R[]>,
    batchSize = 100,
    progressCallback?: (progress: { processed: number; total: number; percentage: number }) => void
  ): Promise<R[]> {
    const results: R[] = [];
    const total = data.length;

    for (let i = 0; i < data.length; i += batchSize) {
      const batch = data.slice(i, i + batchSize);
      
      try {
        const batchResults = await this.errorRecovery.executeWithRetry(
          () => batchProcessor(batch),
          `processBatch:${i}`
        );
        
        results.push(...batchResults);
        
        if (progressCallback) {
          progressCallback({
            processed: Math.min(i + batchSize, total),
            total,
            percentage: ((Math.min(i + batchSize, total) / total) * 100)
          });
        }

        // Memory management every few batches
        if (i % (batchSize * 10) === 0) {
          await this.memoryManager.forceCleanup();
        }
      } catch (error) {
        console.error(`Failed to process batch ${i}-${i + batchSize}:`, error);
        // Continue processing other batches
      }
    }

    return results;
  }

  /**
   * Get file size in bytes
   */
  private async getFileSize(filePath: string): Promise<number> {
    const fs = await import('fs/promises');
    const stats = await fs.stat(filePath);
    return stats.size;
  }

  /**
   * Create a memory-efficient pipeline
   */
  async createPipeline(
    inputStream: NodeJS.ReadableStream,
    transforms: Transform[],
    outputStream: NodeJS.WritableStream
  ): Promise<void> {
    const streamArray: (NodeJS.ReadableStream | Transform | NodeJS.WritableStream)[] = [inputStream, ...transforms, outputStream];
    await pipeline(streamArray);
  }
}

// Semaphore for controlling concurrency
class Semaphore {
  private permits: number;
  private readonly queue: Array<() => void> = [];

  constructor(permits: number) {
    this.permits = permits;
  }

  async acquire(): Promise<void> {
    if (this.permits > 0) {
      this.permits--;
      return;
    }

    return new Promise(resolve => {
      this.queue.push(resolve);
    });
  }

  release(): void {
    this.permits++;
    const resolve = this.queue.shift();
    if (resolve) {
      resolve();
    }
  }
}

// Caching utilities
export class ProcessingCache<T> {
  private cache = new Map<string, { data: T; timestamp: number; size: number }>();
  private readonly maxSize: number;
  private readonly ttl: number;

  constructor(maxSize = 100, ttl = 300000) { // 100 items, 5 minutes TTL
    this.maxSize = maxSize;
    this.ttl = ttl;
  }

  get(key: string): T | null {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    return item.data;
  }

  set(key: string, data: T, size = 1): void {
    if (this.cache.size >= this.maxSize) {
      this.evictOldest();
    }

    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      size
    });
  }

  private evictOldest(): void {
    let oldestKey: string | null = null;
    let oldestTime = Infinity;

    for (const [key, item] of this.cache.entries()) {
      if (item.timestamp < oldestTime) {
        oldestTime = item.timestamp;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  clear(): void {
    this.cache.clear();
  }

  size(): number {
    return this.cache.size;
  }
}

================
File: src/lib/utils.ts
================
export function generateId(type: string, identifier: string): string {
  // Use cryptographically secure UUID v4
  const uuid = crypto.randomUUID();
  return `${type}_${uuid}`;
}

/**
 * Legacy hash function - deprecated, use generateId instead
 * @deprecated Use generateId with UUID
 */
function simpleHash(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

================
File: src/lib/validation.ts
================
/**
 * Type validation utilities for ensuring data integrity
 */

import { z } from 'zod';
import type { GraphNode, GraphRelationship, NodeProperties, RelationshipProperties } from '../core/graph/types';

// Validation schemas for nodes and relationships
const NodePropertiesSchema = z.object({
  name: z.string().optional(),
  path: z.string().optional(),
  filePath: z.string().optional(),
  extension: z.string().optional(),
  language: z.string().optional(),
  size: z.number().nonnegative().optional(),
  description: z.string().optional(),
  version: z.string().optional(),
  definitionCount: z.number().nonnegative().optional(),
  lineCount: z.number().nonnegative().optional(),
  type: z.string().optional(),
  startLine: z.number().positive().optional(),
  endLine: z.number().positive().optional(),
  qualifiedName: z.string().optional(),
  parameters: z.array(z.string()).optional(),
  returnType: z.string().optional(),
  relationshipType: z.string().optional()
}).catchall(z.union([z.string(), z.number(), z.boolean(), z.array(z.string()), z.undefined()]));

const RelationshipPropertiesSchema = z.object({
  strength: z.number().min(0).max(1).optional(),
  confidence: z.number().min(0).max(1).optional(),
  importType: z.enum(['default', 'named', 'namespace']).optional(),
  alias: z.string().optional(),
  callType: z.enum(['function', 'method', 'constructor']).optional(),
  arguments: z.array(z.string()).optional(),
  dependencyType: z.enum(['direct', 'transitive', 'dev']).optional(),
  version: z.string().optional()
}).catchall(z.union([z.string(), z.number(), z.boolean(), z.array(z.string()), z.undefined()]));

const GraphNodeSchema = z.object({
  id: z.string().min(1),
  label: z.enum([
    'Project', 'Package', 'Module', 'Folder', 'File', 'Class', 'Function', 
    'Method', 'Variable', 'Interface', 'Enum', 'Decorator'
  ]),
  properties: NodePropertiesSchema
});

const GraphRelationshipSchema = z.object({
  id: z.string().min(1),
  type: z.enum([
    'CONTAINS', 'CALLS', 'INHERITS', 'OVERRIDES', 'IMPORTS', 'USES', 
    'DEFINES', 'DECORATES', 'IMPLEMENTS', 'ACCESSES'
  ]),
  source: z.string().min(1),
  target: z.string().min(1),
  properties: RelationshipPropertiesSchema
});

/**
 * Validation utilities for graph data
 */
export class ValidationService {
  /**
   * Validate a node object
   */
  static validateNode(node: unknown): GraphNode {
    try {
      return GraphNodeSchema.parse(node);
    } catch (error) {
      throw new Error(`Invalid node: ${error}`);
    }
  }

  /**
   * Validate a relationship object
   */
  static validateRelationship(relationship: unknown): GraphRelationship {
    try {
      return GraphRelationshipSchema.parse(relationship);
    } catch (error) {
      throw new Error(`Invalid relationship: ${error}`);
    }
  }

  /**
   * Validate node properties
   */
  static validateNodeProperties(properties: unknown): NodeProperties {
    try {
      return NodePropertiesSchema.parse(properties);
    } catch (error) {
      throw new Error(`Invalid node properties: ${error}`);
    }
  }

  /**
   * Validate relationship properties
   */
  static validateRelationshipProperties(properties: unknown): RelationshipProperties {
    try {
      return RelationshipPropertiesSchema.parse(properties);
    } catch (error) {
      throw new Error(`Invalid relationship properties: ${error}`);
    }
  }

  /**
   * Validate a complete graph
   */
  static validateGraph(graph: { nodes: unknown[]; relationships: unknown[] }): void {
    const errors: string[] = [];

    // Validate nodes
    const nodeIds = new Set<string>();
    graph.nodes.forEach((node, index) => {
      try {
        const validated = this.validateNode(node);
        if (nodeIds.has(validated.id)) {
          errors.push(`Duplicate node ID: ${validated.id} at index ${index}`);
        }
        nodeIds.add(validated.id);
      } catch (error) {
        errors.push(`Node at index ${index}: ${error}`);
      }
    });

    // Validate relationships
    const relationshipIds = new Set<string>();
    graph.relationships.forEach((relationship, index) => {
      try {
        const validated = this.validateRelationship(relationship);
        if (relationshipIds.has(validated.id)) {
          errors.push(`Duplicate relationship ID: ${validated.id} at index ${index}`);
        }
        relationshipIds.add(validated.id);

        // Check if referenced nodes exist
        if (!nodeIds.has(validated.source)) {
          errors.push(`Relationship at index ${index} references non-existent source: ${validated.source}`);
        }
        if (!nodeIds.has(validated.target)) {
          errors.push(`Relationship at index ${index} references non-existent target: ${validated.target}`);
        }
      } catch (error) {
        errors.push(`Relationship at index ${index}: ${error}`);
      }
    });

    if (errors.length > 0) {
      throw new Error(`Graph validation failed:\n${errors.join('\n')}`);
    }
  }

  /**
   * Sanitize string inputs
   */
  static sanitizeString(input: string): string {
    return input
      .trim()
      .replace(/[<>]/g, '') // Remove potential XSS vectors
      .substring(0, 1000); // Limit length
  }

  /**
   * Validate file path
   */
  static validateFilePath(path: string): string {
    if (!path || typeof path !== 'string') {
      throw new Error('Invalid file path');
    }
    
    const sanitized = path.trim();
    if (sanitized.length === 0 || sanitized.length > 500) {
      throw new Error('File path too long or empty');
    }
    
    // Check for directory traversal
    if (sanitized.includes('..') || sanitized.includes('~')) {
      throw new Error('Invalid file path: contains directory traversal');
    }
    
    return sanitized;
  }

  /**
   * Validate language identifier
   */
  static validateLanguage(language: string): string {
    const validLanguages = [
      'javascript', 'typescript', 'python', 'java', 'cpp', 'c', 'csharp',
      'php', 'ruby', 'go', 'rust', 'swift', 'kotlin', 'scala', 'dart'
    ];
    
    const normalized = language.toLowerCase();
    if (!validLanguages.includes(normalized)) {
      throw new Error(`Invalid language: ${language}`);
    }
    
    return normalized;
  }
}

================
File: src/lib/worker-pool.ts
================
/**
 * Worker Pool Manager for parallel processing
 * Manages a pool of workers to process tasks concurrently
 */

import { Worker } from 'worker_threads';
import { EventEmitter } from 'events';
import * as path from 'path';
import * as os from 'os';

export interface WorkerTask<TInput = unknown, TOutput = unknown> {
  id: string;
  input: TInput;
  resolve: (result: TOutput) => void;
  reject: (error: Error) => void;
}

export interface WorkerPoolOptions {
  maxWorkers?: number;
  workerScript?: string;
  timeout?: number;
}

export class WorkerPool extends EventEmitter {
  private workers: Worker[] = [];
  private availableWorkers: Worker[] = [];
  private taskQueue: WorkerTask<unknown, unknown>[] = [];
  private activeTasks: Map<string, WorkerTask<unknown, unknown>> = new Map();
  protected maxWorkers: number;
  private workerScript: string;
  private timeout: number;
  private isShuttingDown: boolean = false;

  constructor(options: WorkerPoolOptions = {}) {
    super();
    this.maxWorkers = options.maxWorkers || Math.max(2, Math.min(8, os.cpus().length));
    this.workerScript = options.workerScript || path.join(__dirname, 'worker-scripts', 'generic-worker.js');
    this.timeout = options.timeout || 30000; // 30 seconds
  }

  /**
   * Execute a task using available worker
   */
  async execute<TInput, TOutput>(input: TInput): Promise<TOutput> {
    if (this.isShuttingDown) {
      throw new Error('Worker pool is shutting down');
    }

    return new Promise<TOutput>((resolve, reject) => {
      const task: WorkerTask<TInput, TOutput> = {
        id: this.generateTaskId(),
        input,
        resolve,
        reject
      };

      this.taskQueue.push(task as WorkerTask<unknown, unknown>);
      this.processQueue();
    });
  }

  /**
   * Execute multiple tasks in parallel
   */
  async executeAll<TInput, TOutput>(inputs: TInput[]): Promise<TOutput[]> {
    const promises = inputs.map(input => this.execute<TInput, TOutput>(input));
    return Promise.all(promises);
  }

  /**
   * Execute tasks with concurrency limit
   */
  async executeBatch<TInput, TOutput>(
    inputs: TInput[], 
    batchSize: number = this.maxWorkers
  ): Promise<TOutput[]> {
    const results: TOutput[] = [];    
    for (let i = 0; i < inputs.length; i += batchSize) {
      const batch = inputs.slice(i, i + batchSize);
      const batchResults = await this.executeAll<TInput, TOutput>(batch);
      results.push(...batchResults);
    }
    return results;
  }

  /**
   * Get pool statistics
   */
  getStats() {
    return {
      totalWorkers: this.workers.length,
      availableWorkers: this.availableWorkers.length,
      activeTasks: this.activeTasks.size,
      queuedTasks: this.taskQueue.length,
      maxWorkers: this.maxWorkers
    };
  }

  /**
   * Shut down the worker pool
   */
  async shutdown(): Promise<void> {
    this.isShuttingDown = true;
    
    // Reject all queued tasks
    for (const task of this.taskQueue) {
      task.reject(new Error('Worker pool is shutting down'));
    }
    this.taskQueue.length = 0;

    // Wait for active tasks to complete or timeout
    const activeTaskPromises = Array.from(this.activeTasks.values()).map(task => 
      new Promise<void>((resolve) => {
        const originalResolve = task.resolve;
        const originalReject = task.reject;
        
        task.resolve = (result) => {
          originalResolve(result);
          resolve();
        };

        task.reject = (error) => {
          originalReject(error);
          resolve();
        };
      })
    );

    // Terminate all workers
    const terminatePromises = this.workers.map(worker => worker.terminate());

    try {
      await Promise.race([
        Promise.all(activeTaskPromises),
        new Promise(resolve => setTimeout(resolve, 5000)) // 5 second timeout
      ]);
    } catch {
      // Ignore timeout errors during shutdown
    }

    await Promise.all(terminatePromises);
    
    this.workers.length = 0;
    this.availableWorkers.length = 0;
    this.activeTasks.clear();
    
    this.emit('shutdown');
  }

  private processQueue(): void {
    while (this.taskQueue.length > 0 && this.getAvailableWorker()) {
      const task = this.taskQueue.shift()!;
      const worker = this.getAvailableWorker()!;
      
      this.assignTaskToWorker(task, worker);
    }
  }

  private getAvailableWorker(): Worker | null {
    if (this.availableWorkers.length > 0) {
      return this.availableWorkers.pop()!;
    }

    if (this.workers.length < this.maxWorkers) {
      return this.createWorker();
    }

    return null;
  }

  private createWorker(): Worker {
    const worker = new Worker(this.workerScript);
    
    worker.on('error', (error) => {
      this.handleWorkerError(worker, error);
    });

    worker.on('exit', (code) => {
      this.handleWorkerExit(worker, code);
    });

    this.workers.push(worker);
    this.emit('workerCreated', { workerId: worker.threadId, totalWorkers: this.workers.length });
    
    return worker;
  }

  private assignTaskToWorker(task: WorkerTask, worker: Worker): void {
    this.activeTasks.set(task.id, task);

    const timeoutId = setTimeout(() => {
      task.reject(new Error(`Task ${task.id} timed out after ${this.timeout}ms`));
      this.activeTasks.delete(task.id);
      this.recycleWorker(worker);
    }, this.timeout);

    const messageHandler = (result: unknown) => {
      clearTimeout(timeoutId);
      worker.off('message', messageHandler);
      worker.off('error', errorHandler);
      
      this.activeTasks.delete(task.id);
      task.resolve(result);
      this.recycleWorker(worker);
    };

    const errorHandler = (error: Error) => {
      clearTimeout(timeoutId);
      worker.off('message', messageHandler);
      worker.off('error', errorHandler);
      
      this.activeTasks.delete(task.id);
      task.reject(error);
      this.handleWorkerError(worker, error);
    };

    worker.on('message', messageHandler);
    worker.on('error', errorHandler);
    worker.postMessage({ taskId: task.id, input: task.input });
  }

  private recycleWorker(worker: Worker): void {
    if (!this.isShuttingDown && this.workers.includes(worker)) {
      this.availableWorkers.push(worker);
      this.processQueue();
    }
  }

  private handleWorkerError(worker: Worker, error: Error): void {
    this.emit('workerError', { workerId: worker.threadId, error });
    
    // Remove worker from pools
    const workerIndex = this.workers.indexOf(worker);
    if (workerIndex !== -1) {
      this.workers.splice(workerIndex, 1);
    }

    const availableIndex = this.availableWorkers.indexOf(worker);
    if (availableIndex !== -1) {
      this.availableWorkers.splice(availableIndex, 1);
    }

    // Try to replace the worker if not shutting down
    if (!this.isShuttingDown && this.workers.length < this.maxWorkers) {
      this.processQueue();
    }
  }

  private handleWorkerExit(worker: Worker, code: number): void {
    this.emit('workerExit', { workerId: worker.threadId, exitCode: code });
    
    // Remove worker from pools
    const workerIndex = this.workers.indexOf(worker);
    if (workerIndex !== -1) {
      this.workers.splice(workerIndex, 1);
    }

    const availableIndex = this.availableWorkers.indexOf(worker);
    if (availableIndex !== -1) {
      this.availableWorkers.splice(availableIndex, 1);
    }
  }

  private generateTaskId(): string {
    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

/**
 * Singleton worker pool for file processing
 */
export class FileProcessingPool extends WorkerPool {
  private static instance: FileProcessingPool;

  static getInstance(): FileProcessingPool {
    if (!FileProcessingPool.instance) {
      FileProcessingPool.instance = new FileProcessingPool({
        maxWorkers: Math.max(2, Math.min(6, os.cpus().length - 1)),
        workerScript: path.join(__dirname, 'worker-scripts', 'file-processing-worker.js'),
        timeout: 45000 // 45 seconds for file processing
      });
    }
    return FileProcessingPool.instance;
  }

  /**
   * Process files in parallel
   */
  async processFiles<TOutput>(
    filePaths: string[], 
    processor: (filePath: string) => Promise<TOutput>
  ): Promise<TOutput[]> {
    const processingTasks = filePaths.map(filePath => ({
      filePath,
      processorFunction: processor.toString()
    }));

    return this.executeAll(processingTasks);
  }

  /**
   * Process files with progress callback
   */
  async processFilesWithProgress<TOutput>(
    filePaths: string[], 
    processor: (filePath: string) => Promise<TOutput>,
    onProgress?: (completed: number, total: number) => void
  ): Promise<TOutput[]> {
    const results: TOutput[] = [];
    const total = filePaths.length;
    let completed = 0;

    const batchSize = Math.min(this.maxWorkers, 10);
    
    for (let i = 0; i < filePaths.length; i += batchSize) {
      const batch = filePaths.slice(i, i + batchSize);
      const batchResults = await this.processFiles(batch, processor);
      
      results.push(...batchResults);
      completed += batch.length;
      
      if (onProgress) {
        onProgress(completed, total);
      }
    }

    return results;
  }
}

/**
 * Worker pool utilities
 */
export const WorkerPoolUtils = {
  /**
   * Create a specialized worker pool for CPU-intensive tasks
   */
  createCPUPool(options: Partial<WorkerPoolOptions> = {}): WorkerPool {
    return new WorkerPool({
      maxWorkers: os.cpus().length,
      timeout: 60000, // 1 minute
      ...options
    });
  },

  /**
   * Create a worker pool for I/O operations
   */
  createIOPool(options: Partial<WorkerPoolOptions> = {}): WorkerPool {
    return new WorkerPool({
      maxWorkers: Math.min(20, os.cpus().length * 4), // More workers for I/O
      timeout: 30000, // 30 seconds
      ...options
    });
  },

  /**
   * Get optimal worker count for different task types
   */
  getOptimalWorkerCount(taskType: 'cpu' | 'io' | 'mixed' = 'mixed'): number {
    const cpuCount = os.cpus().length;
    
    switch (taskType) {
      case 'cpu':
        return cpuCount;
      case 'io':
        return Math.min(20, cpuCount * 4);
      case 'mixed':
      default:
        return Math.max(2, Math.min(8, cpuCount));
    }
  }
};

================
File: src/lib/workerUtils.ts
================
// Worker utilities for handling different runtime environments
import * as Comlink from 'comlink';
import { IngestionWorker } from '../workers/ingestion.worker.ts';
import type { IngestionProgress, IngestionResult } from '../workers/ingestion.worker.ts';
import type { PipelineInput } from '../core/ingestion/pipeline.ts';

// Export types for external use
export type { IngestionProgress, IngestionResult };

export interface WorkerProxy {
  processRepository(input: PipelineInput): Promise<IngestionResult>;
  processFiles(projectName: string, files: { path: string; content: string }[]): Promise<IngestionResult>;
  validateRepository(input: PipelineInput): Promise<{ valid: boolean; errors: string[] }>;
  getWorkerInfo(): Promise<{ version: string; capabilities: string[] }>;
  setProgressCallback(callback: (progress: IngestionProgress) => void): Promise<void>;
  terminate(): Promise<void>;
}

export class IngestionWorkerManager {
  private worker: Worker | null = null;
  private workerProxy: WorkerProxy | null = null;
  private isInitialized = false;

  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      // Create the worker
      this.worker = new Worker(
        new URL('../workers/ingestion.worker.ts', import.meta.url).href,
        {
          type: 'module',
          name: 'ingestion-worker'
        }
      );

      // Wrap with Comlink
      this.workerProxy = Comlink.wrap<IngestionWorker>(this.worker) as WorkerProxy;
      
      this.isInitialized = true;
      console.log('Ingestion worker initialized successfully');
      
    } catch (error) {
      throw new Error(`Failed to initialize ingestion worker: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async processRepository(input: PipelineInput): Promise<IngestionResult> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.processRepository(input);
    } catch (error) {
      throw new Error(`Worker processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async processFiles(
    projectName: string, 
    files: { path: string; content: string }[]
  ): Promise<IngestionResult> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.processFiles(projectName, files);
    } catch (error) {
      throw new Error(`Worker file processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async validateRepository(input: PipelineInput): Promise<{ valid: boolean; errors: string[] }> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.validateRepository(input);
    } catch (error) {
      return {
        valid: false,
        errors: [`Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`]
      };
    }
  }

  public async setProgressCallback(callback: (progress: IngestionProgress) => void): Promise<void> {
    await this.ensureInitialized();
    
    try {
      // Wrap callback with Comlink.proxy to allow it to be called from worker
      const proxiedCallback = Comlink.proxy(callback);
      await this.workerProxy!.setProgressCallback(proxiedCallback);
    } catch (error) {
      console.warn('Failed to set progress callback:', error);
    }
  }

  public async getWorkerInfo(): Promise<{ version: string; capabilities: string[] }> {
    await this.ensureInitialized();
    
    try {
      return await this.workerProxy!.getWorkerInfo();
    } catch (error) {
      throw new Error(`Failed to get worker info: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async terminate(): Promise<void> {
    if (!this.isInitialized || !this.worker) {
      return;
    }

    try {
      // Notify worker to cleanup
      if (this.workerProxy) {
        await this.workerProxy.terminate();
      }
      
      // Terminate the worker
      this.worker.terminate();
      
      // Cleanup references
      this.worker = null;
      this.workerProxy = null;
      this.isInitialized = false;
      
      console.log('Ingestion worker terminated');
      
    } catch (error) {
      console.warn('Error during worker termination:', error);
      
      // Force terminate if cleanup fails
      if (this.worker) {
        this.worker.terminate();
        this.worker = null;
        this.workerProxy = null;
        this.isInitialized = false;
      }
    }
  }

  public isWorkerReady(): boolean {
    return this.isInitialized && this.worker !== null && this.workerProxy !== null;
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.isInitialized) {
      await this.initialize();
    }
  }
}

// Singleton instance for easy access
let workerManager: IngestionWorkerManager | null = null;

export function getIngestionWorker(): IngestionWorkerManager {
  if (!workerManager) {
    workerManager = new IngestionWorkerManager();
  }
  return workerManager;
}

export async function createIngestionWorker(): Promise<IngestionWorkerManager> {
  const manager = new IngestionWorkerManager();
  await manager.initialize();
  return manager;
}

// Utility function for processing with automatic cleanup
export async function processWithWorker<T>(
  processor: (worker: IngestionWorkerManager) => Promise<T>
): Promise<T> {
  const worker = await createIngestionWorker();
  
  try {
    return await processor(worker);
  } finally {
    await worker.terminate();
  }
}

// Error handling utilities
export class WorkerError extends Error {
  constructor(message: string, public readonly cause?: Error) {
    super(message);
    this.name = 'WorkerError';
  }
}

export function isWorkerSupported(): boolean {
  try {
    return typeof Worker !== 'undefined';
  } catch {
    return false;
  }
}

================
File: src/main.tsx
================
import './lib/polyfills.ts';
import './lib/preload.ts';
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById('root')!).render(
  <App />
)

================
File: src/services/github.ts
================
import axios, { type AxiosInstance, type AxiosResponse } from 'axios';

interface GitHubFile {
  name: string;
  path: string;
  sha: string;
  size: number;
  url: string;
  html_url: string;
  git_url: string;
  download_url: string | null;
  type: 'file' | 'dir';
  content?: string;
  encoding?: string;
}

interface GitHubDirectory {
  name: string;
  path: string;
  sha: string;
  size: number;
  url: string;
  html_url: string;
  git_url: string;
  download_url: string | null;
  type: 'file' | 'dir';
}

interface RateLimitInfo {
  limit: number;
  remaining: number;
  reset: number;
  used: number;
}

interface GitHubError {
  message: string;
  documentation_url?: string;
}

export interface CompleteRepositoryStructure {
  allPaths: string[];  // All file and directory paths
  fileContents: Map<string, string>;  // Only files with content
}

export class GitHubService {
  private client: AxiosInstance;
  private baseURL = 'https://api.github.com';
  private rateLimitInfo: RateLimitInfo | null = null;

  constructor(token?: string) {
    this.client = axios.create({
      baseURL: this.baseURL,
      headers: {
        'Accept': 'application/vnd.github.v3+json',
        ...(token && { 'Authorization': `Bearer ${token}` })
      },
      timeout: 30000
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    this.client.interceptors.response.use(
      (response: AxiosResponse) => {
        this.updateRateLimitInfo(response);
        return response;
      },
      (error: { response?: AxiosResponse; message: string }) => {
        if (error.response) {
          this.updateRateLimitInfo(error.response);
          
          if (error.response.status === 403 && this.isRateLimited()) {
            const resetTime = new Date(this.rateLimitInfo!.reset * 1000);
            throw new Error(`GitHub API rate limit exceeded. Resets at ${resetTime.toISOString()}`);
          }
          
          if (error.response.status === 401) {
            throw new Error('GitHub API authentication failed. Please check your token.');
          }
          
          if (error.response.status === 404) {
            throw new Error('Repository or resource not found.');
          }
          
          const githubError: GitHubError = error.response.data;
          throw new Error(`GitHub API error: ${githubError.message}`);
        }
        
        throw new Error(`Network error: ${error.message}`);
      }
    );
  }

  private updateRateLimitInfo(response: AxiosResponse): void {
    const headers = response.headers;
    if (headers['x-ratelimit-limit']) {
      this.rateLimitInfo = {
        limit: parseInt(headers['x-ratelimit-limit'], 10),
        remaining: parseInt(headers['x-ratelimit-remaining'], 10),
        reset: parseInt(headers['x-ratelimit-reset'], 10),
        used: parseInt(headers['x-ratelimit-used'], 10)
      };
    }
  }

  private isRateLimited(): boolean {
    return this.rateLimitInfo !== null && this.rateLimitInfo.remaining === 0;
  }

  public getRateLimitInfo(): RateLimitInfo | null {
    return this.rateLimitInfo;
  }

  public async checkRateLimit(): Promise<void> {
    if (this.isRateLimited()) {
      const resetTime = new Date(this.rateLimitInfo!.reset * 1000);
      const now = new Date();
      
      if (now < resetTime) {
        const waitTime = Math.ceil((resetTime.getTime() - now.getTime()) / 1000);
        throw new Error(`Rate limit exceeded. Wait ${waitTime} seconds before making another request.`);
      }
    }
  }

  public async getRepositoryContents(
    owner: string, 
    repo: string, 
    path: string = ''
  ): Promise<(GitHubFile | GitHubDirectory)[]> {
    await this.checkRateLimit();
    
    try {
      const response = await this.client.get(`/repos/${owner}/${repo}/contents/${path}`);
      
      if (!Array.isArray(response.data)) {
        throw new Error('Expected directory contents, but received a single file.');
      }
      
      return response.data as (GitHubFile | GitHubDirectory)[];
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to fetch repository contents');
    }
  }

  public async getFileContent(
    owner: string, 
    repo: string, 
    path: string
  ): Promise<string> {
    await this.checkRateLimit();
    
    try {
      const response = await this.client.get(`/repos/${owner}/${repo}/contents/${path}`);
      const file = response.data as GitHubFile;
      
      if (file.type !== 'file') {
        throw new Error(`Path ${path} is not a file`);
      }
      
      // If content or encoding is missing, try to download directly
      if (!file.content || !file.encoding) {
        if (file.download_url) {
          console.warn(`File ${path} missing content/encoding, downloading directly`);
          return await this.downloadFileRaw(owner, repo, path);
        } else {
          throw new Error('File content, encoding, and download URL are all missing');
        }
      }
      
      if (file.encoding === 'base64') {
        try {
          return atob(file.content.replace(/\s/g, ''));
        } catch {
          throw new Error('Failed to decode base64 content');
        }
      }
      
      return file.content;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to fetch file content');
    }
  }

  public async downloadFileRaw(
    owner: string, 
    repo: string, 
    path: string
  ): Promise<string> {
    await this.checkRateLimit();
    
    try {
      const response = await this.client.get(`/repos/${owner}/${repo}/contents/${path}`);
      const file = response.data as GitHubFile;
      
      if (file.type !== 'file' || !file.download_url) {
        throw new Error(`Cannot download file: ${path}`);
      }
      
      const downloadResponse = await axios.get(file.download_url, {
        timeout: 30000
      });
      
      return downloadResponse.data;
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      throw new Error('Failed to download file');
    }
  }

  public async getAllFilesRecursively(owner: string, repo: string, path: string = ''): Promise<GitHubFile[]> {
    const files: GitHubFile[] = [];
    
    try {
      const contents = await this.getRepositoryContents(owner, repo, path);
      
      for (const item of contents) {
        if (item.type === 'dir') {
          // Skip common directories that shouldn't be processed
          if (this.shouldSkipDirectory(item.path)) {
            console.log(`Skipping directory: ${item.path}`);
            continue;
          }
          
          // Recursively get files from subdirectories
          const subFiles = await this.getAllFilesRecursively(owner, repo, item.path);
          files.push(...subFiles);
        } else if (item.type === 'file') {
          // Only include files that should be processed
          if (this.shouldIncludeFile(item.path)) {
            files.push(item);
          } else {
            console.log(`Skipping file: ${item.path}`);
          }
        }
      }
    } catch (error) {
      console.error(`Error fetching contents for ${path}:`, error);
    }
    
    return files;
  }

  private shouldSkipDirectory(path: string): boolean {
    if (!path) return true; // Skip if path is undefined/null
    
    const skipDirs = [
      // Git version control
      '.git',
      // JavaScript dependencies (common in full-stack projects)
      'node_modules',
      // Python bytecode cache
      '__pycache__',
      // Python virtual environments
      'venv',
      'env', 
      '.venv',
      'envs',
      'virtualenv',
      // Build, distribution, and temporary directories
      'build',
      'dist', 
      'logs',
      'tmp',
      '.tmp',
      // Additional common directories to skip
      'coverage',
      '.coverage',
      'htmlcov',
      'vendor',
      'deps',
      '_build',
      '.gradle',
      'bin',
      'obj',
      '.vs',
      '.vscode',
      '.idea',
      'temp'
    ];
    
    // Check each directory component in the path
    const pathParts = path.split('/');
    for (const part of pathParts) {
      const dirName = part.toLowerCase();
      
      // Check for exact matches
      if (skipDirs.includes(dirName) || dirName.startsWith('.')) {
        return true;
      }
      
      // Check for .egg-info directories
      if (dirName.endsWith('.egg-info')) {
        return true;
      }
    }
    
    // Check for virtual environment patterns anywhere in the path
    const fullPathLower = path.toLowerCase();
    const venvPatterns = [
      '/.venv/',
      '/venv/',
      '/env/',
      '/.env/',
      '/envs/',
      '/virtualenv/',
      '/site-packages/',
      '/lib/python',
      '/lib64/python',
      '/scripts/',
      '/bin/python'
    ];
    
    if (venvPatterns.some(pattern => fullPathLower.includes(pattern))) {
      return true;
    }
    
    return false;
  }

  private shouldIncludeFile(path: string): boolean {
    if (!path) return false; // Skip if path is undefined/null
    
    const fileName = path.split('/').pop() || '';
    
    // Skip hidden files except specific config files
    if (fileName.startsWith('.') && !fileName.endsWith('.env.example')) {
      return false;
    }
    
    // Skip Python-specific file patterns
    const skipPatterns = [
      // Python compiled bytecode
      /\.pyc$/,
      /\.pyo$/,
      // Python extension modules (binary)
      /\.pyd$/,
      /\.so$/,
      // Python packages
      /\.egg$/,
      /\.whl$/,
      // Lock files
      /\.lock$/,
      /poetry\.lock$/,
      /Pipfile\.lock$/,
      // Editor swap files
      /\..*\.swp$/,
      /\..*\.swo$/,
      // OS metadata files
      /^Thumbs\.db$/,
      /^\.DS_Store$/,
      // General binary and archive files
      /\.zip$/,
      /\.tar$/,
      /\.rar$/,
      /\.7z$/,
      /\.gz$/,
      // Media files
      /\.(jpg|jpeg|png|gif|bmp|svg|ico)$/i,
      /\.(mp4|avi|mov|wmv|flv|webm)$/i,
      /\.(mp3|wav|flac|aac|ogg)$/i,
      // Document files
      /\.(pdf|doc|docx|xls|xlsx|ppt|pptx)$/i,
      // Other binary files
      /\.(exe|dll|dylib)$/i,
      // Minified files and source maps
      /\.min\.(js|css)$/,
      /\.map$/,
      // Log and temporary files
      /\.log$/,
      /\.tmp$/,
      /\.cache$/,
      /\.pid$/,
      /\.seed$/
    ];
    
    if (skipPatterns.some(pattern => pattern.test(fileName))) {
      return false;
    }
    
    // Include common source and important config files
    const extension = '.' + (fileName.split('.').pop() || '').toLowerCase();

    const includeSourceExts = new Set(['.py', '.js', '.jsx', '.ts', '.tsx']);
    if (includeSourceExts.has(extension)) {
      return true;
    }

    const importantConfigFiles = new Set([
      // Python
      'pyproject.toml', 'setup.py', 'requirements.txt', 'setup.cfg', 'tox.ini', 'pytest.ini', 'pipfile', 'poetry.toml',
      '__init__.py',
      // JS/TS ecosystem
      'package.json', 'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml',
      'tsconfig.json', 'tsconfig.base.json',
      'vite.config.ts', 'vite.config.js',
      '.eslintrc', '.eslintrc.json', '.eslintrc.js', '.prettierrc', '.prettierrc.json',
      // Docs/licenses
      'readme.md', 'license', 'changelog.md', 'manifest.in'
    ]);
    if (importantConfigFiles.has(fileName.toLowerCase())) {
      return true;
    }

    return false;
  }

  public async getAllPathsRecursively(owner: string, repo: string, path: string = ''): Promise<string[]> {
    const allPaths: string[] = [];
    const fileContents: Map<string, string> = new Map();

    try {
      const contents = await this.getRepositoryContents(owner, repo, path);

      for (const item of contents) {
        const fullPath = item.path;
        allPaths.push(fullPath);

        if (item.type === 'file' && this.shouldIncludeFile(fullPath)) {
          const content = await this.getFileContent(owner, repo, fullPath);
          fileContents.set(fullPath, content);
        }

        if (item.type === 'dir') {
          // Skip common directories that shouldn't be processed
          if (this.shouldSkipDirectory(fullPath)) {
            console.log(`Skipping directory: ${fullPath}`);
            continue;
          }
          const subPaths = await this.getAllPathsRecursively(owner, repo, fullPath);
          allPaths.push(...subPaths);
        }
      }
    } catch (error) {
      console.error(`Error fetching contents for ${path}:`, error);
    }

    return allPaths;
  }

  /**
   * Get complete repository structure including all paths and file contents
   * This is the new robust method that discovers structure first, then filters during parsing
   */
  public async getCompleteRepositoryStructure(owner: string, repo: string): Promise<CompleteRepositoryStructure> {
    const allPaths: string[] = [];
    const fileContents: Map<string, string> = new Map();

    await this.collectPathsAndContent(owner, repo, '', allPaths, fileContents);

    console.log(`GitHub: Discovered ${allPaths.length} total paths, ${fileContents.size} files with content`);
    
    return {
      allPaths,
      fileContents
    };
  }

  private async collectPathsAndContent(
    owner: string, 
    repo: string, 
    path: string, 
    allPaths: string[], 
    fileContents: Map<string, string>
  ): Promise<void> {
    try {
      const contents = await this.getRepositoryContents(owner, repo, path);

      for (const item of contents) {
        const fullPath = item.path;
        allPaths.push(fullPath);

        if (item.type === 'file') {
          // Always try to get content for files, regardless of filtering
          // Filtering will happen later in ParsingProcessor
          try {
            const content = await this.getFileContent(owner, repo, fullPath);
            fileContents.set(fullPath, content);
          } catch (error) {
            console.warn(`Failed to get content for ${fullPath}:`, error);
          }
        } else if (item.type === 'dir') {
          // REMOVED: shouldSkipDirectory check for complete structure discovery
          // All directories are now discovered, filtering happens during parsing
          await this.collectPathsAndContent(owner, repo, fullPath, allPaths, fileContents);
        }
      }
    } catch (error) {
      console.error(`Error fetching contents for ${path}:`, error);
    }
  }

  public getAuthenticationStatus(): { authenticated: boolean; rateLimitInfo: RateLimitInfo | null } {
    const authHeader = this.client.defaults.headers['Authorization'];
    return {
      authenticated: !!authHeader,
      rateLimitInfo: this.rateLimitInfo
    };
  }
}

================
File: src/services/health-monitor.ts
================
/**
 * Health monitoring and metrics collection service
 */

import { performance } from 'perf_hooks';
import { ConfigService } from '../config/config';
import { MemoryManager } from './memory-manager.js';
import { ErrorRecoveryService } from '../lib/error-handler.js';

export interface HealthMetrics {
  timestamp: Date;
  uptime: number;
  memory: {
    used: number;
    total: number;
    free: number;
    percentage: number;
  };
  processing: {
    totalFiles: number;
    successfulFiles: number;
    failedFiles: number;
    averageProcessingTime: number;
    errors: string[];
  };
  system: {
    loadAverage?: number[];
    cpuUsage?: number;
    activeConnections: number;
  };
}

export interface MetricPoint {
  timestamp: Date;
  value: number;
  label?: string;
  tags?: Record<string, string>;
}

export interface AlertThreshold {
  metric: string;
  threshold: number;
  comparison: 'gt' | 'lt' | 'gte' | 'lte';
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
}

export class HealthMonitor {
  private static instance: HealthMonitor;
  private readonly config: ConfigService;
  private readonly memoryManager: MemoryManager;
  private readonly errorService: ErrorRecoveryService;
  private metrics: Map<string, MetricPoint[]> = new Map();
  private alerts: AlertThreshold[] = [];
  private startTime: Date;
  private processingStats = {
    totalFiles: 0,
    successfulFiles: 0,
    failedFiles: 0,
    processingTimes: [] as number[],
    errors: [] as string[]
  };
  private activeConnections = 0;
  private monitoringInterval?: NodeJS.Timeout;

  private constructor() {
    this.config = ConfigService.getInstance();
    this.memoryManager = MemoryManager.getInstance();
    this.errorService = ErrorRecoveryService.getInstance();
    this.startTime = new Date();
    this.setupDefaultAlerts();
  }

  static getInstance(): HealthMonitor {
    if (!HealthMonitor.instance) {
      HealthMonitor.instance = new HealthMonitor();
    }
    return HealthMonitor.instance;
  }

  /**
   * Start health monitoring
   */
  start(): void {
    const interval = this.config.get('monitoring.interval', 30000); // 30 seconds
    
    this.monitoringInterval = setInterval(() => {
      this.collectMetrics();
      this.checkAlerts();
    }, interval);

    console.info('Health monitoring started');
  }

  /**
   * Stop health monitoring
   */
  stop(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = undefined;
    }
    console.info('Health monitoring stopped');
  }

  /**
   * Record a metric value
   */
  recordMetric(name: string, value: number, label?: string, tags?: Record<string, string>): void {
    const metricPoint: MetricPoint = {
      timestamp: new Date(),
      value,
      label,
      tags
    };

    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }

    const metricArray = this.metrics.get(name)!;
    metricArray.push(metricPoint);

    // Keep only last 1000 points per metric
    if (metricArray.length > 1000) {
      metricArray.shift();
    }
  }

  /**
   * Record file processing statistics
   */
  recordFileProcessing(filePath: string, success: boolean, processingTime: number, error?: string): void {
    this.processingStats.totalFiles++;
    
    if (success) {
      this.processingStats.successfulFiles++;
    } else {
      this.processingStats.failedFiles++;
      if (error) {
        this.processingStats.errors.push(error);
      }
    }

    this.processingStats.processingTimes.push(processingTime);
    
    // Keep only last 1000 processing times
    if (this.processingStats.processingTimes.length > 1000) {
      this.processingStats.processingTimes.shift();
    }

    // Record metrics
    this.recordMetric('file_processing_time', processingTime, filePath);
    this.recordMetric('file_processing_success', success ? 1 : 0, filePath);
  }

  /**
   * Increment active connections counter
   */
  incrementConnections(): void {
    this.activeConnections++;
    this.recordMetric('active_connections', this.activeConnections);
  }

  /**
   * Decrement active connections counter
   */
  decrementConnections(): void {
    this.activeConnections = Math.max(0, this.activeConnections - 1);
    this.recordMetric('active_connections', this.activeConnections);
  }

  /**
   * Get current health status
   */
  getHealthStatus(): HealthMetrics {
    const memoryUsage = process.memoryUsage();
    const uptime = Date.now() - this.startTime.getTime();

    return {
      timestamp: new Date(),
      uptime,
      memory: {
        used: memoryUsage.heapUsed,
        total: memoryUsage.heapTotal,
        free: memoryUsage.heapTotal - memoryUsage.heapUsed,
        percentage: (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100
      },
      processing: {
        totalFiles: this.processingStats.totalFiles,
        successfulFiles: this.processingStats.successfulFiles,
        failedFiles: this.processingStats.failedFiles,
        averageProcessingTime: this.calculateAverageProcessingTime(),
        errors: [...new Set(this.processingStats.errors)].slice(-10) // Last 10 unique errors
      },
      system: {
        loadAverage: this.getLoadAverage(),
        cpuUsage: this.getCpuUsage(),
        activeConnections: this.activeConnections
      }
    };
  }

  /**
   * Get metrics for a specific name
   */
  getMetrics(name: string, timeRange?: { start: Date; end: Date }): MetricPoint[] {
    const allMetrics = this.metrics.get(name) || [];
    
    if (!timeRange) {
      return allMetrics;
    }

    return allMetrics.filter(metric => 
      metric.timestamp >= timeRange.start && metric.timestamp <= timeRange.end
    );
  }

  /**
   * Get aggregated metrics
   */
  getAggregatedMetrics(name: string, aggregation: 'sum' | 'avg' | 'min' | 'max' | 'count', timeRange?: { start: Date; end: Date }): number {
    const metrics = this.getMetrics(name, timeRange);
    
    if (metrics.length === 0) return 0;

    const values = metrics.map(m => m.value);

    switch (aggregation) {
      case 'sum':
        return values.reduce((a, b) => a + b, 0);
      case 'avg':
        return values.reduce((a, b) => a + b, 0) / values.length;
      case 'min':
        return Math.min(...values);
      case 'max':
        return Math.max(...values);
      case 'count':
        return values.length;
      default:
        return 0;
    }
  }

  /**
   * Add custom alert threshold
   */
  addAlert(alert: AlertThreshold): void {
    this.alerts.push(alert);
  }

  /**
   * Get active alerts
   */
  getActiveAlerts(): AlertThreshold[] {
    return this.alerts.filter(alert => this.isAlertTriggered(alert));
  }

  /**
   * Export health report
   */
  exportHealthReport(): string {
    const health = this.getHealthStatus();
    const alerts = this.getActiveAlerts();
    
    const report = {
      generatedAt: new Date().toISOString(),
      healthStatus: health,
      activeAlerts: alerts,
      metricsSummary: this.getMetricsSummary()
    };

    return JSON.stringify(report, null, 2);
  }

  /**
   * Collect system metrics
   */
  private collectMetrics(): void {
    const memoryUsage = process.memoryUsage();
    
    this.recordMetric('memory_heap_used', memoryUsage.heapUsed);
    this.recordMetric('memory_heap_total', memoryUsage.heapTotal);
    this.recordMetric('memory_rss', memoryUsage.rss);
    this.recordMetric('memory_external', memoryUsage.external);
    
    this.recordMetric('uptime', Date.now() - this.startTime.getTime());
    this.recordMetric('active_connections', this.activeConnections);
    
    // Memory manager metrics
    const cacheStats = this.memoryManager.getCacheStats();
    this.recordMetric('cache_size', cacheStats.size);
    this.recordMetric('cache_hits', cacheStats.hits);
    this.recordMetric('cache_misses', cacheStats.misses);
  }

  /**
   * Check alert thresholds
   */
  private checkAlerts(): void {
    for (const alert of this.alerts) {
      if (this.isAlertTriggered(alert)) {
        this.triggerAlert(alert);
      }
    }
  }

  /**
   * Check if an alert is triggered
   */
  private isAlertTriggered(alert: AlertThreshold): boolean {
    const currentValue = this.getCurrentMetricValue(alert.metric);
    if (currentValue === null) return false;

    switch (alert.comparison) {
      case 'gt':
        return currentValue > alert.threshold;
      case 'lt':
        return currentValue < alert.threshold;
      case 'gte':
        return currentValue >= alert.threshold;
      case 'lte':
        return currentValue <= alert.threshold;
      default:
        return false;
    }
  }

  /**
   * Get current value for a metric
   */
  private getCurrentMetricValue(metric: string): number | null {
    const health = this.getHealthStatus();
    
    switch (metric) {
      case 'memory_percentage':
        return health.memory.percentage;
      case 'processing_errors':
        return this.processingStats.errors.length;
      case 'active_connections':
        return health.system.activeConnections;
      case 'uptime':
        return health.uptime;
      default:
        return null;
    }
  }

  /**
   * Trigger an alert
   */
  private triggerAlert(alert: AlertThreshold): void {
    const message = {
      timestamp: new Date().toISOString(),
      severity: alert.severity,
      message: alert.message,
      metric: alert.metric,
      threshold: alert.threshold,
      currentValue: this.getCurrentMetricValue(alert.metric)
    };

    console.warn(`ALERT [${alert.severity}]: ${alert.message}`, message);
    
    // In production, this would send to external monitoring service
    this.recordMetric('alerts_triggered', 1, alert.message, { severity: alert.severity });
  }

  /**
   * Setup default alert thresholds
   */
  private setupDefaultAlerts(): void {
    this.addAlert({
      metric: 'memory_percentage',
      threshold: 85,
      comparison: 'gte',
      severity: 'high',
      message: 'Memory usage is critically high'
    });

    this.addAlert({
      metric: 'processing_errors',
      threshold: 10,
      comparison: 'gte',
      severity: 'medium',
      message: 'High number of processing errors detected'
    });

    this.addAlert({
      metric: 'active_connections',
      threshold: 100,
      comparison: 'gte',
      severity: 'medium',
      message: 'High number of active connections'
    });
  }

  /**
   * Calculate average processing time
   */
  private calculateAverageProcessingTime(): number {
    const times = this.processingStats.processingTimes;
    if (times.length === 0) return 0;
    return times.reduce((a, b) => a + b, 0) / times.length;
  }

  /**
   * Get system load average (Node.js specific)
   */
  private getLoadAverage(): number[] | undefined {
    if (process.platform !== 'win32') {
      return require('os').loadavg();
    }
    return undefined;
  }

  /**
   * Get CPU usage (simplified)
   */
  private getCpuUsage(): number | undefined {
    // This is a simplified version - in production, use proper CPU monitoring
    const usage = process.cpuUsage();
    return (usage.user + usage.system) / 1000000; // Convert to milliseconds
  }

  /**
   * Get metrics summary
   */
  private getMetricsSummary(): Record<string, any> {
    const summary: Record<string, any> = {};
    
    for (const [name, metrics] of this.metrics.entries()) {
      if (metrics.length > 0) {
        const values = metrics.map(m => m.value);
        summary[name] = {
          count: values.length,
          avg: values.reduce((a, b) => a + b, 0) / values.length,
          min: Math.min(...values),
          max: Math.max(...values),
          last: values[values.length - 1]
        };
      }
    }
    
    return summary;
  }
}

// Health check endpoint for external monitoring
export class HealthCheckEndpoint {
  private healthMonitor: HealthMonitor;

  constructor() {
    this.healthMonitor = HealthMonitor.getInstance();
  }

  async handleHealthCheck(): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    metrics: HealthMetrics;
    alerts: AlertThreshold[];
  }> {
    const metrics = this.healthMonitor.getHealthStatus();
    const alerts = this.healthMonitor.getActiveAlerts();
    
    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
    
    if (alerts.some(alert => alert.severity === 'critical')) {
      status = 'unhealthy';
    } else if (alerts.length > 0) {
      status = 'degraded';
    }

    return { status, metrics, alerts };
  }
}

================
File: src/services/ingestion.service.ts
================
import { GitHubService, type CompleteRepositoryStructure } from './github.ts';
import { ZipService, type CompleteZipStructure } from './zip.ts';
import { getIngestionWorker } from '../lib/workerUtils.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface IngestionOptions {
  directoryFilter?: string;
  fileExtensions?: string;
  onProgress?: (message: string) => void;
}

export interface IngestionResult {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
}

export class IngestionService {
  private githubService: GitHubService;
  private zipService: ZipService;

  constructor(githubToken?: string) {
    this.githubService = new GitHubService(githubToken);
    this.zipService = new ZipService();
  }

  async processGitHubRepo(
    githubUrl: string, 
    options: IngestionOptions = {}
  ): Promise<IngestionResult> {
    const { onProgress } = options;

    // Parse GitHub URL
    const match = githubUrl.match(/^https:\/\/github\.com\/([^/]+)\/([^/]+)(?:\/.*)?$/);
    if (!match) {
      throw new Error('Invalid GitHub repository URL');
    }

    const [, owner, repo] = match;
    
    onProgress?.('Discovering complete repository structure...');
    
    // Get complete repository structure (all paths + file contents)
    const structure: CompleteRepositoryStructure = await this.githubService.getCompleteRepositoryStructure(owner, repo);
    
    onProgress?.(`Discovered ${structure.allPaths.length} paths, ${structure.fileContents.size} files. Processing...`);
    
    // Prepare data for pipeline
    const projectName = `${owner}/${repo}`;
    const projectRoot = '';
    
    // The pipeline now receives ALL paths (files + directories)
    // Filtering will happen during parsing, not here
    const filePaths = structure.allPaths;
    const fileContents = structure.fileContents;

    onProgress?.('Generating knowledge graph...');

    // Create worker and process
    const worker = await getIngestionWorker();
    
    try {
      const result = await worker.processRepository({
        projectName,
        projectRoot,
        filePaths,
        fileContents: fileContents
      });

      if (!result.success) {
        throw new Error(result.error || 'Processing failed');
      }

      return {
        graph: result.graph!,
        fileContents
      };
    } finally {
      // Clean up worker
      if ('terminate' in worker) {
        (worker as { terminate: () => void }).terminate();
      }
    }
  }

  async processZipFile(
    file: File,
    options: IngestionOptions = {}
  ): Promise<IngestionResult> {
    const { onProgress } = options;

    onProgress?.('Discovering complete ZIP structure...');

    // Get complete ZIP structure (all paths + file contents)
    const structure: CompleteZipStructure = await this.zipService.extractCompleteStructure(file);
    
    // Normalize ZIP paths to remove common top-level folder
    const normalizedStructure = this.normalizeZipPaths(structure);
    
    onProgress?.(`Discovered ${normalizedStructure.allPaths.length} paths, ${normalizedStructure.fileContents.size} files. Processing...`);

    // Prepare data for pipeline
    const projectName = file.name.replace('.zip', '');
    const projectRoot = '';
    
    // The pipeline now receives ALL paths (files + directories)
    // Filtering will happen during parsing, not here
    const filePaths = normalizedStructure.allPaths;
    const fileContents = normalizedStructure.fileContents;

    onProgress?.('Generating knowledge graph...');

    // Create worker and process
    const worker = await getIngestionWorker();
    
    try {
      const result = await worker.processRepository({
        projectName,
        projectRoot,
        filePaths,
        fileContents: fileContents
      });

      if (!result.success) {
        throw new Error(result.error || 'Processing failed');
      }

      return {
        graph: result.graph!,
        fileContents
      };
    } finally {
      // Clean up worker
      if ('terminate' in worker) {
        (worker as { terminate: () => void }).terminate();
      }
    }
  }

  private normalizeZipPaths(structure: CompleteZipStructure): CompleteZipStructure {
    const paths = structure.allPaths;
    
    if (paths.length === 0) {
      return structure;
    }

    // Find common prefix to remove (usually the top-level folder)
    const firstPath = paths[0];
    const pathParts = firstPath.split('/');
    
    if (pathParts.length <= 1) {
      return structure; // No normalization needed
    }

    // Check if all paths start with the same top-level folder
    const potentialPrefix = pathParts[0] + '/';
    const allHaveSamePrefix = paths.every(path => path.startsWith(potentialPrefix));
    
    if (!allHaveSamePrefix) {
      return structure; // No common prefix to remove
    }

    console.log(`Normalizing ZIP paths: removing common prefix "${potentialPrefix}"`);

    // Remove the common prefix from all paths
    const normalizedPaths = paths.map(path => {
      const withoutPrefix = path.substring(potentialPrefix.length);
      return withoutPrefix || path; // Keep original if normalization would result in empty string
    }).filter(path => path.length > 0); // Remove empty paths

    // Normalize file contents map
    const normalizedContents = new Map<string, string>();
    for (const [originalPath, content] of structure.fileContents) {
      const normalizedPath = originalPath.startsWith(potentialPrefix) 
        ? originalPath.substring(potentialPrefix.length)
        : originalPath;
      
      if (normalizedPath) {
        normalizedContents.set(normalizedPath, content);
      }
    }

    return {
      allPaths: normalizedPaths,
      fileContents: normalizedContents
    };
  }
}

================
File: src/services/memory-manager.ts
================
/**
 * Memory Management Service
 * Provides resource limits, cleanup, and monitoring for the GitNexus application
 */

export interface MemoryConfig {
  maxMemoryMB: number;
  cleanupThresholdMB: number;
  gcIntervalMs: number;
  maxFileSizeMB: number;
  maxFilesInMemory: number;
}

export interface MemoryStats {
  usedMemoryMB: number;
  totalMemoryMB: number;
  fileCount: number;
  lastCleanup: Date;
  warnings: string[];
}

export class MemoryManager {
  private static instance: MemoryManager;
  private config: MemoryConfig;
  private fileCache: Map<string, { content: string; size: number; lastAccess: Date }>;
  private cleanupTimer: NodeJS.Timeout | null = null;
  private memoryWarnings: string[] = [];

  private constructor() {
    this.config = {
      maxMemoryMB: 512,
      cleanupThresholdMB: 400,
      gcIntervalMs: 30000,
      maxFileSizeMB: 10,
      maxFilesInMemory: 1000
    };
    this.fileCache = new Map();
    this.startCleanupTimer();
  }

  public static getInstance(): MemoryManager {
    if (!MemoryManager.instance) {
      MemoryManager.instance = new MemoryManager();
    }
    return MemoryManager.instance;
  }

  /**
   * Configure memory limits
   */
  public configure(config: Partial<MemoryConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Get current memory statistics
   */
  public getStats(): MemoryStats {
    const totalSize = Array.from(this.fileCache.values())
      .reduce((sum, item) => sum + item.size, 0);
    
    return {
      usedMemoryMB: Math.round(totalSize / (1024 * 1024)),
      totalMemoryMB: this.config.maxMemoryMB,
      fileCount: this.fileCache.size,
      lastCleanup: new Date(),
      warnings: [...this.memoryWarnings]
    };
  }

  /**
   * Cache file content with memory limits
   */
  public cacheFile(filePath: string, content: string): boolean {
        const size = typeof Blob !== 'undefined' ? new Blob([content]).size : Buffer.byteLength(content, 'utf-8');
    
    // Check file size limit
    if (size > this.config.maxFileSizeMB * 1024 * 1024) {
      this.addWarning(`File too large: ${filePath} (${Math.round(size / (1024 * 1024))}MB)`);
      return false;
    }

    // Check memory limit
    const currentTotal = Array.from(this.fileCache.values())
      .reduce((sum, item) => sum + item.size, 0);
    
    if (currentTotal + size > this.config.maxMemoryMB * 1024 * 1024) {
      this.performCleanup();
    }

    // Check file count limit
    if (this.fileCache.size >= this.config.maxFilesInMemory) {
      this.evictOldestFiles();
    }

    this.fileCache.set(filePath, {
      content,
      size,
      lastAccess: new Date()
    });

    return true;
  }

  /**
   * Get cached file content
   */
  public getFile(filePath: string): string | null {
    const item = this.fileCache.get(filePath);
    if (item) {
      item.lastAccess = new Date();
      return item.content;
    }
    return null;
  }

  /**
   * Remove file from cache
   */
  public removeFile(filePath: string): void {
    this.fileCache.delete(filePath);
  }

  /**
   * Clear all cached files
   */
  public clearCache(): void {
    this.fileCache.clear();
    this.memoryWarnings = [];
  }

  /**
   * Force cleanup when memory is low
   */
  public forceCleanup(): void {
    this.performCleanup();
  }

  private performCleanup(): void {
    const currentTotal = Array.from(this.fileCache.values())
      .reduce((sum, item) => sum + item.size, 0);

    if (currentTotal > this.config.cleanupThresholdMB * 1024 * 1024) {
      // Remove least recently used files
      const sorted = Array.from(this.fileCache.entries())
        .sort((a, b) => a[1].lastAccess.getTime() - b[1].lastAccess.getTime());

      const toRemove = Math.ceil(sorted.length * 0.2); // Remove 20%
      for (let i = 0; i < toRemove; i++) {
        this.fileCache.delete(sorted[i][0]);
      }

      this.addWarning(`Cleanup performed: removed ${toRemove} files`);
    }

    // Trigger garbage collection if available
    if (typeof globalThis.gc === 'function') {
      globalThis.gc();
    }
  }

  private evictOldestFiles(): void {
    const sorted = Array.from(this.fileCache.entries())
      .sort((a, b) => a[1].lastAccess.getTime() - b[1].lastAccess.getTime());
    
    const toRemove = Math.max(1, Math.floor(this.config.maxFilesInMemory * 0.1));
    for (let i = 0; i < toRemove; i++) {
      this.fileCache.delete(sorted[i][0]);
    }
  }

  private startCleanupTimer(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
    
    this.cleanupTimer = setInterval(() => {
      this.performCleanup();
    }, this.config.gcIntervalMs);
  }

  private addWarning(message: string): void {
    this.memoryWarnings.push(message);
    if (this.memoryWarnings.length > 10) {
      this.memoryWarnings.shift();
    }
    
    console.warn(`[MemoryManager] ${message}`);
  }

  /**
   * Stop the cleanup timer
   */
  public destroy(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
    this.clearCache();
  }
}

================
File: src/services/zip.ts
================
import JSZip from 'jszip';

interface JSZipObjectWithData extends JSZip.JSZipObject {
  _data?: {
    uncompressedSize: number;
  };
}

interface ZipFileEntry {
  path: string;
  content: string;
  isDirectory: boolean;
  size: number;
  lastModified: Date;
}

interface ExtractionOptions {
  maxFileSize?: number;
  maxTotalSize?: number;
  allowedExtensions?: string[];
  excludeDirectories?: boolean;
}

export interface CompleteZipStructure {
  allPaths: string[];  // All file and directory paths
  fileContents: Map<string, string>;  // Only files with content
}

export class ZipService {
  private static readonly DEFAULT_MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
  private static readonly DEFAULT_MAX_TOTAL_SIZE = 100 * 1024 * 1024; // 100MB
  private static readonly TEXT_EXTENSIONS = new Set([
    '.js', '.ts', '.tsx', '.jsx', '.py', '.java', '.cpp', '.c', '.h', '.hpp',
    '.cs', '.php', '.rb', '.go', '.rs', '.swift', '.kt', '.scala', '.clj',
    '.html', '.htm', '.xml', '.css', '.scss', '.sass', '.less', '.json',
    '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf', '.md', '.txt',
    '.sql', '.sh', '.bash', '.zsh', '.fish', '.ps1', '.bat', '.cmd',
    '.dockerfile', '.gitignore', '.gitattributes', '.env', '.properties'
  ]);

  constructor() {}

  /**
   * Extract complete ZIP structure including all paths and file contents
   * This is the new robust method that discovers structure first, then filters during parsing
   */
  public async extractCompleteStructure(
    file: File,
    options: ExtractionOptions = {}
  ): Promise<CompleteZipStructure> {
    const {
      maxFileSize = ZipService.DEFAULT_MAX_FILE_SIZE,
      maxTotalSize = ZipService.DEFAULT_MAX_TOTAL_SIZE
    } = options;

    if (!file) {
      throw new Error('No file provided');
    }

    if (!file.name.toLowerCase().endsWith('.zip')) {
      throw new Error('File must be a ZIP archive');
    }

    console.log(`Starting complete ZIP extraction of: ${file.name} (${file.size} bytes)`);

    try {
      const zip = await JSZip.loadAsync(file);
      const allPaths: string[] = [];
      const fileContents: Map<string, string> = new Map();
      const directories: Set<string> = new Set();
      let totalExtractedSize = 0;

      // First pass: collect all paths and identify directories
      zip.forEach((relativePath, zipObject) => {
        // Normalize path separators
        const normalizedPath = relativePath.replace(/\\/g, '/');
        
        // Add all parent directories
        const pathParts = normalizedPath.split('/');
        for (let i = 1; i < pathParts.length; i++) {
          const dirPath = pathParts.slice(0, i).join('/');
          if (dirPath && !directories.has(dirPath)) {
            directories.add(dirPath);
            allPaths.push(dirPath);
          }
        }

        // Add the current path
        if (!allPaths.includes(normalizedPath)) {
          allPaths.push(normalizedPath);
        }

        // If it's a directory entry, mark it
        if (zipObject.dir) {
          directories.add(normalizedPath.replace(/\/$/, ''));
        }
      });

      // Second pass: extract file contents
      const filePromises: Promise<void>[] = [];

      zip.forEach((relativePath, zipObject) => {
        const normalizedPath = relativePath.replace(/\\/g, '/');

        // Skip directories and empty paths
        if (zipObject.dir || !normalizedPath || normalizedPath.endsWith('/')) {
          return;
        }

        // REMOVED: shouldSkipDirectory check for complete structure discovery
        // All files are now discovered, filtering happens during parsing

        const zipObjectWithData = zipObject as JSZipObjectWithData;
        const uncompressedSize = zipObjectWithData._data?.uncompressedSize || 0;

        // Check individual file size
        if (uncompressedSize > maxFileSize) {
          console.warn(`Skipping large file: ${normalizedPath} (${uncompressedSize} bytes)`);
          return;
        }

        // Check total extracted size
        if (totalExtractedSize + uncompressedSize > maxTotalSize) {
          console.warn(`Stopping extraction: total size limit reached (${maxTotalSize} bytes)`);
          return;
        }

        // Extract file content
        const promise = zipObject.async('text')
          .then(content => {
            if (content.length > 0) {
              fileContents.set(normalizedPath, content);
              totalExtractedSize += content.length;
            }
          })
          .catch(error => {
            console.warn(`Failed to extract ${normalizedPath}:`, error);
          });

        filePromises.push(promise);
      });

      // Wait for all file extractions to complete
      await Promise.all(filePromises);

      console.log(`ZIP: Discovered ${allPaths.length} total paths, ${fileContents.size} files with content`);
      console.log(`ZIP: Total extracted size: ${totalExtractedSize} bytes`);

      return {
        allPaths: allPaths.sort(), // Sort for consistent ordering
        fileContents
      };

    } catch (error) {
      console.error('Error extracting ZIP file:', error);
      throw new Error(`Failed to extract ZIP file: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  public async extractTextFiles(
    file: File,
    options: ExtractionOptions = {}
  ): Promise<Map<string, string>> {
    const {
      maxFileSize = ZipService.DEFAULT_MAX_FILE_SIZE,
      maxTotalSize = ZipService.DEFAULT_MAX_TOTAL_SIZE,
      allowedExtensions = Array.from(ZipService.TEXT_EXTENSIONS),
      excludeDirectories = true
    } = options;

    if (!file) {
      throw new Error('No file provided');
    }

    if (file.type !== 'application/zip' && !file.name.toLowerCase().endsWith('.zip')) {
      throw new Error('File must be a ZIP archive');
    }

    try {
      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      const zipContent = await zip.loadAsync(arrayBuffer);
      
      const extractedFiles = new Map<string, string>();
      let totalExtractedSize = 0;
      
      const files = Object.keys(zipContent.files);
      
      for (const filePath of files) {
        const zipFile = zipContent.files[filePath];
        
        if (zipFile.dir && excludeDirectories) {
          continue;
        }
        
        if (zipFile.dir) {
          extractedFiles.set(filePath, '');
          continue;
        }
        
        // Skip directories and files that shouldn't be processed
        if (this.shouldSkipPath(filePath)) {
          console.log(`Skipping filtered path: ${filePath}`);
          continue;
        }
        
        if (!this.isTextFile(filePath, allowedExtensions)) {
          continue;
        }
        
        const zipFileWithData = zipFile as JSZipObjectWithData;
        if (zipFileWithData._data && zipFileWithData._data.uncompressedSize > maxFileSize) {
          console.warn(`Skipping file ${filePath}: exceeds maximum file size (${maxFileSize} bytes)`);
          continue;
        }
        
        if (totalExtractedSize + (zipFileWithData._data?.uncompressedSize || 0) > maxTotalSize) {
          console.warn(`Stopping extraction: total size would exceed maximum (${maxTotalSize} bytes)`);
          break;
        }
        
        try {
          const content = await zipFile.async('text');
          
          if (content.length > maxFileSize) {
            console.warn(`Skipping file ${filePath}: content exceeds maximum file size`);
            continue;
          }
          
          extractedFiles.set(filePath, content);
          totalExtractedSize += content.length;
          
        } catch (fileError) {
          console.warn(`Failed to extract file ${filePath}:`, fileError);
          continue;
        }
      }
      
      return extractedFiles;
      
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes('corrupt') || error.message.includes('invalid')) {
          throw new Error('ZIP file appears to be corrupted or invalid');
        }
        throw new Error(`Failed to extract ZIP file: ${error.message}`);
      }
      throw new Error('Unknown error occurred while extracting ZIP file');
    }
  }

  public async getZipFileInfo(file: File): Promise<ZipFileEntry[]> {
    if (!file) {
      throw new Error('No file provided');
    }

    try {
      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      const zipContent = await zip.loadAsync(arrayBuffer);
      
      const fileInfos: ZipFileEntry[] = [];
      
      for (const [path, zipFile] of Object.entries(zipContent.files)) {
        const file = zipFile as { dir: boolean; _data?: { uncompressedSize: number }; date?: Date };
        fileInfos.push({
          path,
          content: '', // Don't load content for info request
          isDirectory: file.dir,
          size: file._data?.uncompressedSize || 0,
          lastModified: file.date || new Date()
        });
      }
      
      return fileInfos.sort((a, b) => a.path.localeCompare(b.path));
      
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to read ZIP file info: ${error.message}`);
      }
      throw new Error('Unknown error occurred while reading ZIP file info');
    }
  }

  public async extractSpecificFiles(
    file: File,
    filePaths: string[]
  ): Promise<Map<string, string>> {
    if (!file) {
      throw new Error('No file provided');
    }

    if (!filePaths || filePaths.length === 0) {
      throw new Error('No file paths specified');
    }

    try {
      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      const zipContent = await zip.loadAsync(arrayBuffer);
      
      const extractedFiles = new Map<string, string>();
      
      for (const filePath of filePaths) {
        const zipFile = zipContent.files[filePath];
        
        if (!zipFile) {
          console.warn(`File not found in ZIP: ${filePath}`);
          continue;
        }
        
        if (zipFile.dir) {
          extractedFiles.set(filePath, '');
          continue;
        }
        
        try {
          const content = await zipFile.async('text');
          extractedFiles.set(filePath, content);
        } catch (fileError) {
          console.warn(`Failed to extract file ${filePath}:`, fileError);
          continue;
        }
      }
      
      return extractedFiles;
      
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to extract specific files from ZIP: ${error.message}`);
      }
      throw new Error('Unknown error occurred while extracting specific files');
    }
  }

  public isValidZipFile(file: File): boolean {
    if (!file) return false;
    
    return (
      file.type === 'application/zip' || 
      file.type === 'application/x-zip-compressed' ||
      file.name.toLowerCase().endsWith('.zip')
    );
  }

  private async fileToArrayBuffer(file: File): Promise<ArrayBuffer> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = () => {
        if (reader.result instanceof ArrayBuffer) {
          resolve(reader.result);
        } else {
          reject(new Error('Failed to read file as ArrayBuffer'));
        }
      };
      
      reader.onerror = () => {
        reject(new Error('Error reading file'));
      };
      
      reader.readAsArrayBuffer(file);
    });
  }

  private isTextFile(filePath: string, allowedExtensions: string[]): boolean {
    if (!filePath || filePath.endsWith('/')) {
      return false;
    }
    
    const extension = filePath.toLowerCase().split('.').pop();
    return extension ? allowedExtensions.includes(`.${extension}`) : false;
  }

  private shouldSkipPath(filePath: string): boolean {
    // Skip directories that shouldn't be processed
    if (this.shouldSkipDirectory(filePath)) {
      return true;
    }
    
    // Skip files that shouldn't be processed
    if (!this.shouldIncludeFile(filePath)) {
      return true;
    }
    
    return false;
  }

  private shouldSkipDirectory(path: string): boolean {
    if (!path) return true; // Skip if path is undefined/null
    
    const skipDirs = [
      // Git version control
      '.git',
      // JavaScript dependencies (common in full-stack projects)
      'node_modules',
      // Python bytecode cache
      '__pycache__',
      // Python virtual environments
      'venv',
      'env', 
      '.venv',
      'envs',
      'virtualenv',
      // Build, distribution, and temporary directories
      'build',
      'dist', 
      'logs',
      'tmp',
      '.tmp',
      // Additional common directories to skip
      'coverage',
      '.coverage',
      'htmlcov',
      'vendor',
      'deps',
      '_build',
      '.gradle',
      'bin',
      'obj',
      '.vs',
      '.vscode',
      '.idea',
      'temp'
    ];
    
    // Check each directory component in the path
    const pathParts = path.split('/');
    for (const part of pathParts) {
      const dirName = part.toLowerCase();
      
      // Check for exact matches
      if (skipDirs.includes(dirName) || dirName.startsWith('.')) {
        return true;
      }
      
      // Check for .egg-info directories
      if (dirName.endsWith('.egg-info')) {
        return true;
      }
    }
    
    // Check for virtual environment patterns anywhere in the path
    const fullPathLower = path.toLowerCase();
    const venvPatterns = [
      '/.venv/',
      '/venv/',
      '/env/',
      '/.env/',
      '/envs/',
      '/virtualenv/',
      '/site-packages/',
      '/lib/python',
      '/lib64/python',
      '/scripts/',
      '/bin/python'
    ];
    
    if (venvPatterns.some(pattern => fullPathLower.includes(pattern))) {
      return true;
    }
    
    return false;
  }

  private shouldIncludeFile(path: string): boolean {
    if (!path) return false; // Skip if path is undefined/null
    
    const fileName = path.split('/').pop() || '';
    
    // Skip hidden files except specific config files
    if (fileName.startsWith('.') && !fileName.endsWith('.env.example')) {
      return false;
    }
    
    // Skip common compiled/binary patterns
    const skipPatterns = [
      // Python compiled bytecode
      /\.pyc$/,
      /\.pyo$/,
      // Python extension modules (binary)
      /\.pyd$/,
      /\.so$/,
      // Python packages
      /\.egg$/,
      /\.whl$/,
      // Lock files
      /\.lock$/,
      /poetry\.lock$/,
      /Pipfile\.lock$/,
      // Editor swap files
      /\..*\.swp$/,
      /\..*\.swo$/,
      // OS metadata files
      /^Thumbs\.db$/,
      /^\.DS_Store$/,
      // General binary and archive files
      /\.zip$/,
      /\.tar$/,
      /\.rar$/,
      /\.7z$/,
      /\.gz$/,
      // Media files
      /\.(jpg|jpeg|png|gif|bmp|svg|ico)$/i,
      /\.(mp4|avi|mov|wmv|flv|webm)$/i,
      /\.(mp3|wav|flac|aac|ogg)$/i,
      // Document files
      /\.(pdf|doc|docx|xls|xlsx|ppt|pptx)$/i,
      // Other binary files
      /\.(exe|dll|dylib)$/i,
      // Minified files and source maps
      /\.min\.(js|css)$/,
      /\.map$/,
      // Log and temporary files
      /\.log$/,
      /\.tmp$/,
      /\.cache$/,
      /\.pid$/,
      /\.seed$/
    ];
    
    if (skipPatterns.some(pattern => pattern.test(fileName))) {
      return false;
    }
    
    // Include common source and important config files
    const extension = '.' + (fileName.split('.').pop() || '').toLowerCase();
    const includeSourceExts = new Set(['.py', '.js', '.jsx', '.ts', '.tsx']);
    if (includeSourceExts.has(extension)) {
      return true;
    }

    const importantConfigFiles = new Set([
      // Python
      'pyproject.toml', 'setup.py', 'requirements.txt', 'setup.cfg', 'tox.ini', 'pytest.ini', 'pipfile', 'poetry.toml',
      '__init__.py',
      // JS/TS ecosystem
      'package.json', 'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml',
      'tsconfig.json', 'tsconfig.base.json',
      'vite.config.ts', 'vite.config.js',
      '.eslintrc', '.eslintrc.json', '.eslintrc.js', '.prettierrc', '.prettierrc.json',
      // Docs/licenses
      'readme.md', 'license', 'changelog.md', 'manifest.in'
    ]);
    if (importantConfigFiles.has(fileName.toLowerCase())) {
      return true;
    }

    return false;
  }

  public getDefaultTextExtensions(): string[] {
    return Array.from(ZipService.TEXT_EXTENSIONS);
  }

  public async validateZipFile(file: File): Promise<{ valid: boolean; error?: string }> {
    try {
      if (!this.isValidZipFile(file)) {
        return { valid: false, error: 'File is not a valid ZIP archive' };
      }

      const arrayBuffer = await this.fileToArrayBuffer(file);
      const zip = new JSZip();
      await zip.loadAsync(arrayBuffer);
      
      return { valid: true };
      
    } catch (error) {
      return { 
        valid: false, 
        error: error instanceof Error ? error.message : 'Unknown validation error' 
      };
    }
  }
}

================
File: src/ui/components/chat/ChatInterface.tsx
================
import React, { useState, useRef, useEffect } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeHighlight from 'rehype-highlight';
import type { KnowledgeGraph } from '../../../core/graph/types.ts';
import { LLMService, type LLMProvider, type LLMConfig } from '../../../ai/llm-service.ts';
import { CypherGenerator } from '../../../ai/cypher-generator.ts';
import { RAGOrchestrator, type RAGResponse, type RAGOptions } from '../../../ai/orchestrator.ts';

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  metadata?: {
    cypherQueries?: Array<{ cypher: string; explanation: string; confidence?: number }>;
    sources?: string[];
    confidence?: number;
    reasoning?: Array<{ 
      step: number; 
      thought: string; 
      action: string;
      actionInput?: string;
      observation?: string;
      toolResult?: {
        toolName: string;
        input: string;
        output: string;
        success: boolean;
        error?: string;
      };
    }>;
    debugInfo?: {
      llmConfig: LLMConfig;
      ragOptions: RAGOptions;
      contextInfo: {
        nodeCount: number;
        fileCount: number;
        hasContext: boolean;
      };
      totalExecutionTime?: number;
      queryExecutionTimes?: Array<{ query: string; time: number }>;
    };
  };
}

interface ChatInterfaceProps {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
  className?: string;
  style?: React.CSSProperties;
}

interface LLMSettings {
  provider: LLMProvider;
  apiKey: string;
  model: string;
  temperature: number;
  maxTokens: number;
  // Azure OpenAI specific fields
  azureOpenAIEndpoint?: string;
  azureOpenAIDeploymentName?: string;
  azureOpenAIApiVersion?: string;
}

const ChatInterface: React.FC<ChatInterfaceProps> = ({
  graph,
  fileContents,
  className = '',
  style = {}
}) => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showReasoning, setShowReasoning] = useState(false);
  const [debugMode, setDebugMode] = useState(false);
  
  // LLM Configuration
  const [llmSettings, setLLMSettings] = useState<LLMSettings>({
    provider: 'openai',
    apiKey: '',
    model: 'gpt-4o-mini',
    temperature: 0.1,
    maxTokens: 4000,
    azureOpenAIEndpoint: '',
    azureOpenAIDeploymentName: '',
    azureOpenAIApiVersion: '2024-02-01'
  });

  // Services
  const [llmService] = useState(new LLMService());
  const [cypherGenerator] = useState(new CypherGenerator(llmService));
  const [ragOrchestrator] = useState(new RAGOrchestrator(llmService, cypherGenerator));

  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  // Initialize RAG context when graph or fileContents change
  useEffect(() => {
    ragOrchestrator.setContext({ graph, fileContents });
  }, [graph, fileContents, ragOrchestrator]);

  // Load settings from localStorage on mount
  useEffect(() => {
    const savedProvider = localStorage.getItem('llm_provider') as LLMProvider;
    const savedApiKey = localStorage.getItem('llm_api_key');
    const savedAzureEndpoint = localStorage.getItem('azure_openai_endpoint');
    const savedAzureDeployment = localStorage.getItem('azure_openai_deployment');
    const savedAzureApiVersion = localStorage.getItem('azure_openai_api_version');
    const savedDebugMode = localStorage.getItem('debug_mode') === 'true';

    if (savedProvider || savedApiKey || savedAzureEndpoint) {
      setLLMSettings(prev => ({
        ...prev,
        provider: savedProvider || prev.provider,
        apiKey: savedApiKey || prev.apiKey,
        azureOpenAIEndpoint: savedAzureEndpoint || prev.azureOpenAIEndpoint,
        azureOpenAIDeploymentName: savedAzureDeployment || prev.azureOpenAIDeploymentName,
        azureOpenAIApiVersion: savedAzureApiVersion || prev.azureOpenAIApiVersion,
        // For Azure OpenAI, use deployment name as model, otherwise use default model
        model: savedProvider === 'azure-openai' 
          ? (savedAzureDeployment || 'gpt-4.1-mini-v2')
          : (savedProvider ? llmService.getAvailableModels(savedProvider)[0] : prev.model)
      }));
    }

    setDebugMode(savedDebugMode);
  }, [llmService]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputValue.trim() || isLoading) return;

    // Validate API key
    if (!llmSettings.apiKey.trim()) {
      alert('Please configure your API key in settings');
      setShowSettings(true);
      return;
    }

    if (!llmService.validateApiKey(llmSettings.provider, llmSettings.apiKey)) {
      alert('Invalid API key format. Please check your settings.');
      setShowSettings(true);
      return;
    }

    // Additional validation for Azure OpenAI
    if (llmSettings.provider === 'azure-openai') {
      if (!llmSettings.azureOpenAIEndpoint?.trim()) {
        alert('Please configure your Azure OpenAI endpoint in settings');
        setShowSettings(true);
        return;
      }
      if (!llmSettings.azureOpenAIDeploymentName?.trim()) {
        alert('Please configure your Azure OpenAI deployment name in settings');
        setShowSettings(true);
        return;
      }
    }

    const userMessage: ChatMessage = {
      id: generateId(),
      role: 'user',
      content: inputValue.trim(),
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInputValue('');
    setIsLoading(true);

    try {
      const startTime = Date.now();
      
      const llmConfig: LLMConfig = {
        provider: llmSettings.provider,
        apiKey: llmSettings.apiKey,
        model: llmSettings.model,
        temperature: llmSettings.temperature,
        maxTokens: llmSettings.maxTokens,
        // Azure OpenAI specific fields
        azureOpenAIEndpoint: llmSettings.azureOpenAIEndpoint,
        azureOpenAIDeploymentName: llmSettings.azureOpenAIDeploymentName,
        azureOpenAIApiVersion: llmSettings.azureOpenAIApiVersion
      };

      const ragOptions: RAGOptions = {
        maxReasoningSteps: 5,
        includeReasoning: debugMode || showReasoning, // Always include reasoning in debug mode
        strictMode: false,
        temperature: llmSettings.temperature
      };

      const response: RAGResponse = await ragOrchestrator.answerQuestion(
        userMessage.content,
        llmConfig,
        ragOptions
      );

      const endTime = Date.now();
      const executionTime = endTime - startTime;

      const assistantMessage: ChatMessage = {
        id: generateId(),
        role: 'assistant',
        content: response.answer,
        timestamp: new Date(),
        metadata: {
          cypherQueries: response.cypherQueries.map(q => ({
            cypher: q.cypher,
            explanation: q.explanation,
            confidence: q.confidence
          })),
          sources: response.sources,
          confidence: response.confidence,
          reasoning: (debugMode || showReasoning) ? response.reasoning.map(r => ({
            step: r.step,
            thought: r.thought,
            action: r.action,
            actionInput: r.actionInput,
            observation: r.observation,
            toolResult: r.toolResult
          })) : undefined,
          debugInfo: debugMode ? {
            llmConfig,
            ragOptions,
            contextInfo: ragOrchestrator.getContextInfo(),
            totalExecutionTime: executionTime,
            queryExecutionTimes: response.cypherQueries.map(q => ({
              query: q.cypher,
              time: 0 // We'd need to instrument the query engine for this
            }))
          } : undefined
        }
      };

      setMessages(prev => [...prev, assistantMessage]);

    } catch (error) {
      const errorMessage: ChatMessage = {
        id: generateId(),
        role: 'assistant',
        content: `I apologize, but I encountered an error while processing your question: ${error instanceof Error ? error.message : 'Unknown error'}`,
        timestamp: new Date()
      };

      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  // Handle key press in textarea
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e as any);
    }
  };

  // Clear conversation
  const clearConversation = () => {
    setMessages([]);
  };

  // Toggle debug mode and save to localStorage
  const toggleDebugMode = () => {
    const newDebugMode = !debugMode;
    setDebugMode(newDebugMode);
    localStorage.setItem('debug_mode', newDebugMode.toString());
  };

  // Graph diagnostics
  const runGraphDiagnostics = () => {
    const contextInfo = ragOrchestrator.getContextInfo();
    
    if (!contextInfo.hasContext) {
      alert('No graph loaded yet. Please load a repository first.');
      return;
    }

    // Basic statistics
    const stats = [
      `📊 Graph Statistics:`,
      `• Nodes: ${contextInfo.nodeCount}`,
      `• Files: ${contextInfo.fileCount}`,
      ``,
      `🔍 Diagnostic Tips:`,
      `• Check browser console for detailed ingestion logs`,
      `• Look for warnings about isolated nodes or parsing failures`,
      `• Verify that source files contain recognizable functions/classes`,
      ``,
      `If you see isolated nodes:`,
      `1. Check if files failed to parse (console warnings)`,
      `2. Ensure files contain valid code syntax`,
      `3. Check if file extensions are supported (.js, .ts, .py, etc.)`,
      `4. Look for import/export syntax errors`
    ].join('\n');

    alert(stats);
    
    // Also log to console for more details
    console.log('🔍 Graph Diagnostics Requested');
    console.log('Context Info:', contextInfo);
  };

  // Debug Panel Component
  const DebugPanel: React.FC<{ message: ChatMessage }> = ({ message }) => {
    if (!message.metadata?.debugInfo && !message.metadata?.reasoning && !message.metadata?.cypherQueries) {
      return null;
    }

    const [activeTab, setActiveTab] = useState<'reasoning' | 'queries' | 'config' | 'context'>('reasoning');

    return (
      <div className="mt-4 border border-gray-200 rounded-lg bg-gray-50">
        <div className="border-b border-gray-200">
          <nav className="flex space-x-8 px-4" aria-label="Tabs">
            {message.metadata?.reasoning && (
              <button
                onClick={() => setActiveTab('reasoning')}
                className={`py-2 px-1 border-b-2 font-medium text-sm ${
                  activeTab === 'reasoning'
                    ? 'border-blue-500 text-blue-600'
                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                }`}
              >
                Reasoning Steps ({message.metadata.reasoning.length})
              </button>
            )}
            {message.metadata?.cypherQueries && message.metadata.cypherQueries.length > 0 && (
              <button
                onClick={() => setActiveTab('queries')}
                className={`py-2 px-1 border-b-2 font-medium text-sm ${
                  activeTab === 'queries'
                    ? 'border-blue-500 text-blue-600'
                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                }`}
              >
                Cypher Queries ({message.metadata.cypherQueries.length})
              </button>
            )}
            {message.metadata?.debugInfo && (
              <>
                <button
                  onClick={() => setActiveTab('config')}
                  className={`py-2 px-1 border-b-2 font-medium text-sm ${
                    activeTab === 'config'
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  }`}
                >
                  Configuration
                </button>
                <button
                  onClick={() => setActiveTab('context')}
                  className={`py-2 px-1 border-b-2 font-medium text-sm ${
                    activeTab === 'context'
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  }`}
                >
                  Context Info
                </button>
              </>
            )}
          </nav>
        </div>

        <div className="p-4">
          {/* Reasoning Steps Tab */}
          {activeTab === 'reasoning' && message.metadata?.reasoning && (
            <div className="space-y-4">
              {message.metadata.reasoning.map((step, index) => (
                <div key={index} className="border border-gray-200 rounded-lg p-4 bg-white">
                  <div className="flex items-center justify-between mb-2">
                    <h4 className="font-semibold text-gray-900">Step {step.step}</h4>
                    <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                      step.toolResult?.success 
                        ? 'bg-green-100 text-green-800' 
                        : step.toolResult?.success === false
                        ? 'bg-red-100 text-red-800'
                        : 'bg-gray-100 text-gray-800'
                    }`}>
                      {step.action}
                    </span>
                  </div>
                  
                  <div className="space-y-3">
                    <div>
                      <h5 className="font-medium text-gray-700 mb-1">Thought:</h5>
                      <p className="text-gray-600 text-sm bg-blue-50 p-2 rounded">{step.thought}</p>
                    </div>
                    
                    {step.actionInput && (
                      <div>
                        <h5 className="font-medium text-gray-700 mb-1">Action Input:</h5>
                        <p className="text-gray-600 text-sm bg-yellow-50 p-2 rounded font-mono">{step.actionInput}</p>
                      </div>
                    )}
                    
                    {step.observation && (
                      <div>
                        <h5 className="font-medium text-gray-700 mb-1">Observation:</h5>
                        <div className="text-gray-600 text-sm bg-green-50 p-2 rounded overflow-x-auto">
                          <MarkdownContent content={step.observation} role="assistant" />
                        </div>
                      </div>
                    )}
                    
                    {step.toolResult && (
                      <div className="border-t pt-3">
                        <h5 className="font-medium text-gray-700 mb-2">Tool Result:</h5>
                        <div className="grid grid-cols-2 gap-4 text-sm">
                          <div>
                            <span className="font-medium">Tool:</span> {step.toolResult.toolName}
                          </div>
                          <div>
                            <span className="font-medium">Success:</span> 
                            <span className={`ml-1 ${step.toolResult.success ? 'text-green-600' : 'text-red-600'}`}>
                              {step.toolResult.success ? 'Yes' : 'No'}
                            </span>
                          </div>
                          {step.toolResult.error && (
                            <div className="col-span-2">
                              <span className="font-medium text-red-600">Error:</span>
                              <p className="text-red-600 bg-red-50 p-2 rounded mt-1">{step.toolResult.error}</p>
                            </div>
                          )}
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              ))}
            </div>
          )}

          {/* Cypher Queries Tab */}
          {activeTab === 'queries' && message.metadata?.cypherQueries && (
            <div className="space-y-4">
              {message.metadata.cypherQueries.map((query, index) => (
                <div key={index} className="border border-gray-200 rounded-lg p-4 bg-white">
                  <div className="flex items-center justify-between mb-3">
                    <h4 className="font-semibold text-gray-900">Query {index + 1}</h4>
                    {query.confidence && (
                      <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                        query.confidence > 0.8 
                          ? 'bg-green-100 text-green-800' 
                          : query.confidence > 0.6
                          ? 'bg-yellow-100 text-yellow-800'
                          : 'bg-red-100 text-red-800'
                      }`}>
                        Confidence: {(query.confidence * 100).toFixed(0)}%
                      </span>
                    )}
                  </div>
                  
                  <div className="space-y-3">
                    <div>
                      <h5 className="font-medium text-gray-700 mb-2">Cypher Query:</h5>
                      <pre className="bg-gray-900 text-green-400 p-3 rounded-lg text-sm overflow-x-auto font-mono">
                        {query.cypher}
                      </pre>
                    </div>
                    
                    <div>
                      <h5 className="font-medium text-gray-700 mb-2">Explanation:</h5>
                      <div className="text-gray-600 text-sm bg-blue-50 p-3 rounded">
                        <MarkdownContent content={query.explanation} role="assistant" />
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}

          {/* Configuration Tab */}
          {activeTab === 'config' && message.metadata?.debugInfo && (
            <div className="space-y-6">
              <div className="border border-gray-200 rounded-lg p-4 bg-white">
                <h4 className="font-semibold text-gray-900 mb-3">LLM Configuration</h4>
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div><span className="font-medium">Provider:</span> {message.metadata.debugInfo.llmConfig.provider}</div>
                  <div><span className="font-medium">Model:</span> {message.metadata.debugInfo.llmConfig.model}</div>
                  <div><span className="font-medium">Temperature:</span> {message.metadata.debugInfo.llmConfig.temperature}</div>
                  <div><span className="font-medium">Max Tokens:</span> {message.metadata.debugInfo.llmConfig.maxTokens}</div>
                </div>
              </div>
              
              <div className="border border-gray-200 rounded-lg p-4 bg-white">
                <h4 className="font-semibold text-gray-900 mb-3">RAG Options</h4>
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div><span className="font-medium">Max Reasoning Steps:</span> {message.metadata.debugInfo.ragOptions.maxReasoningSteps}</div>
                  <div><span className="font-medium">Include Reasoning:</span> {message.metadata.debugInfo.ragOptions.includeReasoning ? 'Yes' : 'No'}</div>
                  <div><span className="font-medium">Strict Mode:</span> {message.metadata.debugInfo.ragOptions.strictMode ? 'Yes' : 'No'}</div>
                  <div><span className="font-medium">Temperature:</span> {message.metadata.debugInfo.ragOptions.temperature}</div>
                </div>
              </div>

              <div className="border border-gray-200 rounded-lg p-4 bg-white">
                <h4 className="font-semibold text-gray-900 mb-3">Performance</h4>
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div><span className="font-medium">Total Execution Time:</span> {message.metadata.debugInfo.totalExecutionTime}ms</div>
                  <div><span className="font-medium">Confidence Score:</span> {message.metadata.confidence ? (message.metadata.confidence * 100).toFixed(1) + '%' : 'N/A'}</div>
                </div>
              </div>
            </div>
          )}

          {/* Context Info Tab */}
          {activeTab === 'context' && message.metadata?.debugInfo && (
            <div className="space-y-4">
              <div className="border border-gray-200 rounded-lg p-4 bg-white">
                <h4 className="font-semibold text-gray-900 mb-3">Knowledge Graph Context</h4>
                <div className="grid grid-cols-3 gap-4 text-sm">
                  <div className="text-center p-4 bg-blue-50 rounded">
                    <div className="text-2xl font-bold text-blue-600">{message.metadata.debugInfo.contextInfo.nodeCount}</div>
                    <div className="text-gray-600">Graph Nodes</div>
                  </div>
                  <div className="text-center p-4 bg-green-50 rounded">
                    <div className="text-2xl font-bold text-green-600">{message.metadata.debugInfo.contextInfo.fileCount}</div>
                    <div className="text-gray-600">Files Indexed</div>
                  </div>
                  <div className="text-center p-4 bg-purple-50 rounded">
                    <div className="text-2xl font-bold text-purple-600">{message.metadata.sources?.length || 0}</div>
                    <div className="text-gray-600">Sources Used</div>
                  </div>
                </div>
              </div>

              {message.metadata.sources && message.metadata.sources.length > 0 && (
                <div className="border border-gray-200 rounded-lg p-4 bg-white">
                  <h4 className="font-semibold text-gray-900 mb-3">Sources Referenced</h4>
                  <div className="space-y-2">
                    {message.metadata.sources.map((source, index) => (
                      <div key={index} className="flex items-center space-x-2 text-sm">
                        <span className="w-6 h-6 bg-gray-200 rounded-full flex items-center justify-center text-xs font-medium">
                          {index + 1}
                        </span>
                        <code className="bg-gray-100 px-2 py-1 rounded text-gray-800">{source}</code>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    );
  };

  // Generate unique ID
  const generateId = () => {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  };

  // Markdown Content Component
  const MarkdownContent: React.FC<{ content: string; role: 'user' | 'assistant' }> = ({ content, role }) => {
    if (role === 'user') {
      // Don't apply markdown to user messages
      return <div>{content}</div>;
    }

    return (
      <div className="markdown-content">
        <ReactMarkdown
          remarkPlugins={[remarkGfm]}
          rehypePlugins={[rehypeHighlight]}
          components={{
            // Custom styling for different markdown elements
            h1: ({ children }) => <h1 style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '12px', color: '#333' }}>{children}</h1>,
            h2: ({ children }) => <h2 style={{ fontSize: '16px', fontWeight: 'bold', marginBottom: '10px', color: '#333' }}>{children}</h2>,
            h3: ({ children }) => <h3 style={{ fontSize: '14px', fontWeight: 'bold', marginBottom: '8px', color: '#333' }}>{children}</h3>,
            p: ({ children }) => <p style={{ marginBottom: '12px', lineHeight: '1.5' }}>{children}</p>,
            ul: ({ children }) => <ul style={{ marginBottom: '12px', paddingLeft: '20px' }}>{children}</ul>,
            ol: ({ children }) => <ol style={{ marginBottom: '12px', paddingLeft: '20px' }}>{children}</ol>,
            li: ({ children }) => <li style={{ marginBottom: '4px', lineHeight: '1.4' }}>{children}</li>,
            code: ({ children, className, ...props }) => {
              const inline = !className?.includes('language-');
              return inline ? (
                <code 
                  style={{ 
                    backgroundColor: '#f1f3f4', 
                    padding: '2px 4px', 
                    borderRadius: '3px', 
                    fontSize: '13px',
                    fontFamily: 'Monaco, Consolas, "Liberation Mono", "Courier New", monospace'
                  }}
                  {...props}
                >
                  {children}
                </code>
              ) : (
                <pre style={{ 
                  backgroundColor: '#f8f9fa', 
                  padding: '12px', 
                  borderRadius: '6px', 
                  overflow: 'auto',
                  marginBottom: '12px',
                  border: '1px solid #e9ecef'
                }}>
                  <code 
                    style={{ 
                      fontSize: '13px',
                      fontFamily: 'Monaco, Consolas, "Liberation Mono", "Courier New", monospace'
                    }}
                    className={className}
                    {...props}
                  >
                    {children}
                  </code>
                </pre>
              );
            },
            blockquote: ({ children }) => (
              <blockquote style={{ 
                borderLeft: '4px solid #007bff', 
                paddingLeft: '12px', 
                marginLeft: '0',
                marginBottom: '12px',
                fontStyle: 'italic',
                color: '#666'
              }}>
                {children}
              </blockquote>
            ),
            table: ({ children }) => (
              <table style={{ 
                borderCollapse: 'collapse', 
                width: '100%', 
                marginBottom: '12px',
                fontSize: '13px'
              }}>
                {children}
              </table>
            ),
            th: ({ children }) => (
              <th style={{ 
                border: '1px solid #ddd', 
                padding: '8px', 
                backgroundColor: '#f8f9fa',
                fontWeight: 'bold',
                textAlign: 'left'
              }}>
                {children}
              </th>
            ),
            td: ({ children }) => (
              <td style={{ 
                border: '1px solid #ddd', 
                padding: '8px'
              }}>
                {children}
              </td>
            ),
            strong: ({ children }) => <strong style={{ fontWeight: '600' }}>{children}</strong>,
            em: ({ children }) => <em style={{ fontStyle: 'italic' }}>{children}</em>,
            a: ({ children, href }) => (
              <a 
                href={href} 
                target="_blank" 
                rel="noopener noreferrer"
                style={{ 
                  color: '#007bff', 
                  textDecoration: 'none'
                }}
                onMouseOver={(e) => e.currentTarget.style.textDecoration = 'underline'}
                onMouseOut={(e) => e.currentTarget.style.textDecoration = 'none'}
              >
                {children}
              </a>
            )
          }}
        >
          {content}
        </ReactMarkdown>
      </div>
    );
  };

  // Get available models for current provider
  const getAvailableModels = () => {
    return llmService.getAvailableModels(llmSettings.provider);
  };

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    height: '600px',
    border: '1px solid #ddd',
    borderRadius: '8px',
    backgroundColor: '#fff',
    ...style
  };

  const headerStyle: React.CSSProperties = {
    padding: '16px',
    borderBottom: '1px solid #eee',
    backgroundColor: '#f8f9fa',
    borderRadius: '8px 8px 0 0',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center'
  };

  const messagesStyle: React.CSSProperties = {
    flex: 1,
    overflowY: 'auto',
    padding: '16px',
    display: 'flex',
    flexDirection: 'column',
    gap: '16px'
  };

  const inputAreaStyle: React.CSSProperties = {
    padding: '16px',
    borderTop: '1px solid #eee'
  };

  const messageStyle = (role: 'user' | 'assistant'): React.CSSProperties => ({
    padding: '12px 16px',
    borderRadius: '12px',
    maxWidth: '80%',
    alignSelf: role === 'user' ? 'flex-end' : 'flex-start',
    backgroundColor: role === 'user' ? '#007bff' : '#f1f3f4',
    color: role === 'user' ? '#fff' : '#333',
    wordWrap: 'break-word'
  });

  const buttonStyle: React.CSSProperties = {
    padding: '8px 16px',
    border: 'none',
    borderRadius: '4px',
    backgroundColor: '#007bff',
    color: '#fff',
    cursor: 'pointer',
    fontSize: '14px'
  };

  const textareaStyle: React.CSSProperties = {
    width: '100%',
    minHeight: '60px',
    padding: '12px',
    border: '1px solid #ddd',
    borderRadius: '4px',
    resize: 'vertical',
    fontSize: '14px',
    fontFamily: 'inherit'
  };

  return (
    <div className={`chat-interface ${className}`} style={containerStyle}>
      {/* Header */}
      <div style={headerStyle}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <span style={{ fontSize: '18px', fontWeight: '600' }}>💬</span>
          <span style={{ fontSize: '16px', fontWeight: '600' }}>Code Assistant</span>
          <span style={{ 
            fontSize: '12px', 
            color: '#666',
            backgroundColor: '#e9ecef',
            padding: '2px 8px',
            borderRadius: '12px'
          }}>
            {llmService.getProviderDisplayName(llmSettings.provider)}
          </span>
        </div>
        
        <div style={{ display: 'flex', gap: '8px' }}>
          <button
            onClick={() => setShowReasoning(!showReasoning)}
            style={{
              ...buttonStyle,
              backgroundColor: showReasoning ? '#28a745' : '#6c757d',
              fontSize: '12px',
              padding: '6px 12px'
            }}
            title="Toggle reasoning display"
          >
            🧠 Reasoning
          </button>
          <button
            onClick={toggleDebugMode}
            style={{
              ...buttonStyle,
              backgroundColor: debugMode ? '#17a2b8' : '#6c757d',
              fontSize: '12px',
              padding: '6px 12px'
            }}
            title="Toggle debug mode - shows detailed internal workings"
          >
            🔍 Debug
          </button>
          <button
            onClick={runGraphDiagnostics}
            style={{
              ...buttonStyle,
              backgroundColor: '#ffc107',
              color: '#000',
              fontSize: '12px',
              padding: '6px 12px'
            }}
            title="Run graph diagnostics to check for issues"
          >
            🩺 Diagnose
          </button>
          <button
            onClick={() => setShowSettings(!showSettings)}
            style={{ ...buttonStyle, fontSize: '12px', padding: '6px 12px' }}
            title="Settings"
          >
            ⚙️
          </button>
          <button
            onClick={clearConversation}
            style={{
              ...buttonStyle,
              backgroundColor: '#dc3545',
              fontSize: '12px',
              padding: '6px 12px'
            }}
            title="Clear conversation"
          >
            🗑️
          </button>
        </div>
      </div>

      {/* Settings Panel */}
      {showSettings && (
        <div style={{
          padding: '16px',
          backgroundColor: '#f8f9fa',
          borderBottom: '1px solid #eee'
        }}>
          <h4 style={{ margin: '0 0 12px 0', fontSize: '14px' }}>LLM Configuration</h4>
          
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', marginBottom: '12px' }}>
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>Provider</label>
              <select
                value={llmSettings.provider}
                onChange={(e) => setLLMSettings(prev => ({
                  ...prev,
                  provider: e.target.value as LLMProvider,
                  model: llmService.getAvailableModels(e.target.value as LLMProvider)[0]
                }))}
                style={{ width: '100%', padding: '6px', fontSize: '14px' }}
              >
                <option value="openai">OpenAI</option>
                <option value="azure-openai">Azure OpenAI</option>
                <option value="anthropic">Anthropic</option>
                <option value="gemini">Google Gemini</option>
              </select>
            </div>
            
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>
                {llmSettings.provider === 'azure-openai' ? 'Deployment Name' : 'Model'}
              </label>
              {llmSettings.provider === 'azure-openai' ? (
                <input
                  type="text"
                  value={llmSettings.model}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, model: e.target.value }))}
                  placeholder="gpt-4.1-mini-v2"
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                />
              ) : (
                <select
                  value={llmSettings.model}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, model: e.target.value }))}
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                >
                  {getAvailableModels().map(model => (
                    <option key={model} value={model}>{model}</option>
                  ))}
                </select>
              )}
            </div>
          </div>

          <div style={{ marginBottom: '12px' }}>
            <label style={{ fontSize: '12px', color: '#666' }}>API Key</label>
            <input
              type="password"
              value={llmSettings.apiKey}
              onChange={(e) => setLLMSettings(prev => ({ ...prev, apiKey: e.target.value }))}
              placeholder={
                llmSettings.provider === 'azure-openai' ? 'Your Azure OpenAI key...' :
                llmSettings.provider === 'anthropic' ? 'sk-ant-...' :
                llmSettings.provider === 'gemini' ? 'Your Google API key...' : 'sk-...'
              }
              style={{ width: '100%', padding: '6px', fontSize: '14px' }}
            />
          </div>

          {/* Azure OpenAI Specific Fields */}
          {llmSettings.provider === 'azure-openai' && (
            <>
              <div style={{ marginBottom: '12px' }}>
                <label style={{ fontSize: '12px', color: '#666' }}>Azure OpenAI Endpoint</label>
                <input
                  type="text"
                  value={llmSettings.azureOpenAIEndpoint || ''}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, azureOpenAIEndpoint: e.target.value }))}
                  placeholder="https://your-resource.openai.azure.com"
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                />
              </div>

              <div style={{ marginBottom: '12px' }}>
                <label style={{ fontSize: '12px', color: '#666' }}>API Version</label>
                <input
                  type="text"
                  value={llmSettings.azureOpenAIApiVersion || '2024-02-01'}
                  onChange={(e) => setLLMSettings(prev => ({ ...prev, azureOpenAIApiVersion: e.target.value }))}
                  placeholder="2024-02-01"
                  style={{ width: '100%', padding: '6px', fontSize: '14px' }}
                />
              </div>
            </>
          )}

          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>
                Temperature: {llmSettings.temperature}
              </label>
              <input
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={llmSettings.temperature}
                onChange={(e) => setLLMSettings(prev => ({ ...prev, temperature: parseFloat(e.target.value) }))}
                style={{ width: '100%' }}
              />
            </div>
            
            <div>
              <label style={{ fontSize: '12px', color: '#666' }}>Max Tokens</label>
              <input
                type="number"
                min="100"
                max="8000"
                step="100"
                value={llmSettings.maxTokens}
                onChange={(e) => setLLMSettings(prev => ({ ...prev, maxTokens: parseInt(e.target.value) }))}
                style={{ width: '100%', padding: '6px', fontSize: '14px' }}
              />
            </div>
          </div>

          {/* Save Button */}
          <div style={{ marginTop: '16px', display: 'flex', justifyContent: 'flex-end', gap: '8px' }}>
            <button
              onClick={() => {
                // Save to localStorage
                localStorage.setItem('llm_provider', llmSettings.provider);
                localStorage.setItem('llm_api_key', llmSettings.apiKey);
                if (llmSettings.azureOpenAIEndpoint) {
                  localStorage.setItem('azure_openai_endpoint', llmSettings.azureOpenAIEndpoint);
                }
                // For Azure OpenAI, the model field contains the deployment name
                if (llmSettings.provider === 'azure-openai' && llmSettings.model) {
                  localStorage.setItem('azure_openai_deployment', llmSettings.model);
                }
                if (llmSettings.azureOpenAIApiVersion) {
                  localStorage.setItem('azure_openai_api_version', llmSettings.azureOpenAIApiVersion);
                }
                setShowSettings(false);
                alert('Settings saved successfully!');
              }}
              style={{
                ...buttonStyle,
                backgroundColor: '#28a745',
                fontSize: '12px',
                padding: '8px 16px'
              }}
            >
              💾 Save Settings
            </button>
            <button
              onClick={() => setShowSettings(false)}
              style={{
                ...buttonStyle,
                backgroundColor: '#6c757d',
                fontSize: '12px',
                padding: '8px 16px'
              }}
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Messages */}
      <div style={messagesStyle}>
        {messages.length === 0 && (
          <div style={{
            textAlign: 'center',
            color: '#666',
            fontSize: '14px',
            padding: '40px 20px'
          }}>
            <div style={{ fontSize: '48px', marginBottom: '16px', opacity: 0.3 }}>💬</div>
            <div>Ask me anything about the codebase!</div>
            <div style={{ fontSize: '12px', marginTop: '8px', color: '#999' }}>
              I can help you understand functions, classes, dependencies, and more.
            </div>
          </div>
        )}

        {messages.map((message) => (
          <div key={message.id}>
            <div style={messageStyle(message.role)}>
              <div style={{ marginBottom: message.metadata ? '8px' : '0' }}>
                <MarkdownContent content={message.content} role={message.role} />
              </div>
              
              {/* Debug Panel (when debug mode is enabled) */}
              {debugMode && message.role === 'assistant' && (
                <DebugPanel message={message} />
              )}
              
              {/* Simple Metadata (when debug mode is disabled) */}
              {!debugMode && message.metadata && (
                <div style={{ fontSize: '12px', opacity: 0.8 }}>
                  {message.metadata.confidence && (
                    <div style={{ marginBottom: '4px' }}>
                      Confidence: {Math.round(message.metadata.confidence * 100)}%
                    </div>
                  )}
                  
                  {message.metadata.sources && message.metadata.sources.length > 0 && (
                    <div style={{ marginBottom: '4px' }}>
                      Sources: {message.metadata.sources.join(', ')}
                    </div>
                  )}
                  
                  {message.metadata.cypherQueries && message.metadata.cypherQueries.length > 0 && (
                    <details style={{ marginTop: '8px' }}>
                      <summary style={{ cursor: 'pointer' }}>View Queries ({message.metadata.cypherQueries.length})</summary>
                      {message.metadata.cypherQueries.map((query, index) => (
                        <div key={index} style={{ 
                          marginTop: '4px', 
                          padding: '8px', 
                          backgroundColor: 'rgba(0,0,0,0.1)', 
                          borderRadius: '4px',
                          fontFamily: 'monospace',
                          fontSize: '11px'
                        }}>
                          <div><strong>Query:</strong> {query.cypher}</div>
                          <div><strong>Explanation:</strong> {query.explanation}</div>
                        </div>
                      ))}
                    </details>
                  )}

                  {message.metadata.reasoning && message.metadata.reasoning.length > 0 && (
                    <details style={{ marginTop: '8px' }}>
                      <summary style={{ cursor: 'pointer' }}>View Reasoning ({message.metadata.reasoning.length} steps)</summary>
                      {message.metadata.reasoning.map((step, index) => (
                        <div key={index} style={{ 
                          marginTop: '4px', 
                          padding: '8px', 
                          backgroundColor: 'rgba(0,0,0,0.1)', 
                          borderRadius: '4px',
                          fontSize: '11px'
                        }}>
                          <div><strong>Step {step.step}:</strong> {step.thought}</div>
                          <div><strong>Action:</strong> {step.action}</div>
                        </div>
                      ))}
                    </details>
                  )}
                </div>
              )}
            </div>
            
            <div style={{
              fontSize: '11px',
              color: '#999',
              textAlign: message.role === 'user' ? 'right' : 'left',
              marginTop: '4px'
            }}>
              {message.timestamp.toLocaleTimeString()}
            </div>
          </div>
        ))}

        {isLoading && (
          <div style={messageStyle('assistant')}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              <div style={{ 
                width: '16px', 
                height: '16px', 
                border: '2px solid #ccc',
                borderTop: '2px solid #007bff',
                borderRadius: '50%',
                animation: 'spin 1s linear infinite'
              }} />
              Thinking...
            </div>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Input Area */}
      <div style={inputAreaStyle}>
        <form onSubmit={handleSubmit} style={{ display: 'flex', gap: '8px' }}>
          <textarea
            ref={inputRef}
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Ask a question about the code..."
            style={textareaStyle}
            disabled={isLoading}
          />
          <button
            type="submit"
            disabled={isLoading || !inputValue.trim()}
            style={{
              ...buttonStyle,
              minWidth: '80px',
              opacity: (isLoading || !inputValue.trim()) ? 0.5 : 1
            }}
          >
            {isLoading ? '...' : 'Send'}
          </button>
        </form>
      </div>

      {/* CSS for spinner animation and syntax highlighting */}
      <style>{`
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }

        /* Syntax highlighting styles */
        .hljs {
          background: #f8f9fa !important;
          color: #333 !important;
        }
        
        .hljs-keyword,
        .hljs-selector-tag,
        .hljs-title,
        .hljs-section,
        .hljs-doctag,
        .hljs-name,
        .hljs-strong {
          color: #d73a49;
        }
        
        .hljs-string,
        .hljs-title,
        .hljs-section,
        .hljs-built_in,
        .hljs-literal,
        .hljs-type,
        .hljs-addition,
        .hljs-tag,
        .hljs-quote,
        .hljs-name,
        .hljs-selector-id,
        .hljs-selector-class {
          color: #032f62;
        }
        
        .hljs-comment,
        .hljs-quote,
        .hljs-variable,
        .hljs-template-variable,
        .hljs-attribute,
        .hljs-tag,
        .hljs-name,
        .hljs-regexp,
        .hljs-link,
        .hljs-name,
        .hljs-selector-id,
        .hljs-selector-class {
          color: #6f42c1;
        }
        
        .hljs-number,
        .hljs-meta,
        .hljs-built_in,
        .hljs-builtin-name,
        .hljs-literal,
        .hljs-type,
        .hljs-params {
          color: #005cc5;
        }
        
        .hljs-attr,
        .hljs-variable,
        .hljs-template-variable,
        .hljs-type,
        .hljs-built_in,
        .hljs-builtin-name,
        .hljs-symbol,
        .hljs-bullet,
        .hljs-link,
        .hljs-meta,
        .hljs-selector-attr,
        .hljs-selector-pseudo {
          color: #e36209;
        }

        /* Custom markdown styles */
        .chat-interface .markdown-content {
          line-height: 1.6;
        }
        
        .chat-interface .markdown-content > *:first-child {
          margin-top: 0;
        }
        
        .chat-interface .markdown-content > *:last-child {
          margin-bottom: 0;
        }
        
        /* Better spacing for lists */
        .chat-interface .markdown-content ul,
        .chat-interface .markdown-content ol {
          margin: 8px 0 12px 0;
        }
        
        .chat-interface .markdown-content li {
          margin-bottom: 2px;
        }
        
        /* Code block improvements */
        .chat-interface .markdown-content pre {
          max-width: 100%;
          overflow-x: auto;
          white-space: pre-wrap;
          word-wrap: break-word;
        }
        
        /* Table improvements */
        .chat-interface .markdown-content table {
          max-width: 100%;
          overflow-x: auto;
          display: block;
          white-space: nowrap;
        }
        
        .chat-interface .markdown-content thead,
        .chat-interface .markdown-content tbody,
        .chat-interface .markdown-content tr {
          display: table;
          width: 100%;
          table-layout: fixed;
        }
      `}</style>
    </div>
  );
};

export default ChatInterface;

================
File: src/ui/components/chat/CodeAssistant.tsx
================
import React, { useState } from 'react';
import ChatInterface from './ChatInterface.tsx';
import { GraphExplorer } from '../graph/index.ts';
import type { KnowledgeGraph } from '../../../core/graph/types.ts';

interface CodeAssistantProps {
  graph: KnowledgeGraph;
  fileContents: Map<string, string>;
  className?: string;
  style?: React.CSSProperties;
}

type ViewMode = 'chat' | 'graph' | 'split';

const CodeAssistant: React.FC<CodeAssistantProps> = ({
  graph,
  fileContents,
  className = '',
  style = {}
}) => {
  const [viewMode, setViewMode] = useState<ViewMode>('split');

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    height: '800px',
    backgroundColor: '#f5f5f5',
    borderRadius: '8px',
    overflow: 'hidden',
    ...style
  };

  const headerStyle: React.CSSProperties = {
    padding: '16px',
    backgroundColor: '#fff',
    borderBottom: '1px solid #ddd',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center'
  };

  const contentStyle: React.CSSProperties = {
    flex: 1,
    display: 'flex',
    overflow: 'hidden'
  };

  const panelStyle: React.CSSProperties = {
    flex: 1,
    display: 'flex',
    flexDirection: 'column',
    overflow: 'hidden'
  };

  const buttonStyle = (active: boolean): React.CSSProperties => ({
    padding: '8px 16px',
    border: 'none',
    borderRadius: '4px',
    backgroundColor: active ? '#007bff' : '#6c757d',
    color: '#fff',
    cursor: 'pointer',
    fontSize: '14px',
    marginLeft: '8px'
  });

  const renderContent = () => {
    switch (viewMode) {
      case 'chat':
        return (
          <div style={panelStyle}>
            <ChatInterface
              graph={graph}
              fileContents={fileContents}
              style={{ height: '100%' }}
            />
          </div>
        );

      case 'graph':
        return (
          <div style={panelStyle}>
            <GraphExplorer 
              graph={graph}
              isLoading={false}
            />
          </div>
        );

      case 'split':
        return (
          <>
            <div style={{ ...panelStyle, marginRight: '8px' }}>
              <div style={{
                fontSize: '14px',
                fontWeight: '600',
                padding: '8px 12px',
                backgroundColor: '#e9ecef',
                borderRadius: '4px 4px 0 0',
                marginBottom: '8px'
              }}>
                💬 AI Assistant
              </div>
              <ChatInterface
                graph={graph}
                fileContents={fileContents}
                style={{ height: 'calc(100% - 40px)' }}
              />
            </div>
            
            <div style={{ ...panelStyle, marginLeft: '8px' }}>
              <div style={{
                fontSize: '14px',
                fontWeight: '600',
                padding: '8px 12px',
                backgroundColor: '#e9ecef',
                borderRadius: '4px 4px 0 0',
                marginBottom: '8px'
              }}>
                🕸️ Knowledge Graph
              </div>
              <GraphExplorer
                graph={graph}
                isLoading={false}
              />
            </div>
          </>
        );

      default:
        return null;
    }
  };

  const getStatsText = () => {
    const nodeCount = graph.nodes.length;
    const relationshipCount = graph.relationships.length;
    const fileCount = fileContents.size;
    
    return `${nodeCount} nodes • ${relationshipCount} relationships • ${fileCount} files`;
  };

  return (
    <div className={`code-assistant ${className}`} style={containerStyle}>
      {/* Header */}
      <div style={headerStyle}>
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <span style={{ fontSize: '20px', fontWeight: '600' }}>🤖</span>
          <div>
            <div style={{ fontSize: '18px', fontWeight: '600' }}>
              GitNexus Code Assistant
            </div>
            <div style={{ fontSize: '12px', color: '#666' }}>
              {getStatsText()}
            </div>
          </div>
        </div>

        <div style={{ display: 'flex', alignItems: 'center' }}>
          <span style={{ fontSize: '14px', color: '#666', marginRight: '12px' }}>
            View:
          </span>
          <button
            onClick={() => setViewMode('chat')}
            style={buttonStyle(viewMode === 'chat')}
          >
            💬 Chat Only
          </button>
          <button
            onClick={() => setViewMode('graph')}
            style={buttonStyle(viewMode === 'graph')}
          >
            🕸️ Graph Only
          </button>
          <button
            onClick={() => setViewMode('split')}
            style={buttonStyle(viewMode === 'split')}
          >
            📱 Split View
          </button>
        </div>
      </div>

      {/* Content */}
      <div style={contentStyle}>
        {renderContent()}
      </div>

      {/* Help Text */}
      {graph.nodes.length === 0 && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          textAlign: 'center',
          color: '#666',
          fontSize: '16px',
          zIndex: 10
        }}>
          <div style={{ fontSize: '64px', marginBottom: '16px', opacity: 0.3 }}>
            🤖
          </div>
          <div style={{ marginBottom: '8px' }}>
            No knowledge graph loaded
          </div>
          <div style={{ fontSize: '14px', color: '#999' }}>
            Please load a project to start using the AI assistant
          </div>
        </div>
      )}
    </div>
  );
};

export default CodeAssistant;

================
File: src/ui/components/chat/index.ts
================
export { default as ChatInterface } from './ChatInterface.tsx';
export { default as CodeAssistant } from './CodeAssistant.tsx';

================
File: src/ui/components/ErrorBoundary.tsx
================
import React, { Component, ReactNode } from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;
}

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    // Update state so the next render will show the fallback UI
    return {
      hasError: true,
      error
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log the error to console for debugging
    console.error('ErrorBoundary caught an error:', error);
    console.error('Error info:', errorInfo);

    // Update state with error details
    this.setState({
      error,
      errorInfo
    });

    // Call optional error handler
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }

    // In a production app, you might want to log this to an error reporting service
    // logErrorToService(error, errorInfo);
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };

  render() {
    if (this.state.hasError) {
      // Custom fallback UI
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Default error UI
      return (
        <div style={containerStyle}>
          <div style={errorBoxStyle}>
            <div style={iconStyle}>⚠️</div>
            
            <h2 style={titleStyle}>Something went wrong</h2>
            
            <p style={messageStyle}>
              We encountered an unexpected error. This might be due to a temporary issue 
              or an incompatibility with your browser.
            </p>

            <div style={buttonContainerStyle}>
              <button
                onClick={this.handleReset}
                style={primaryButtonStyle}
              >
                Try Again
              </button>
              
              <button
                onClick={() => window.location.reload()}
                style={secondaryButtonStyle}
              >
                Reload Page
              </button>
            </div>

            {/* Error details (collapsible) */}
            <details style={detailsStyle}>
              <summary style={summaryStyle}>
                Technical Details (for developers)
              </summary>
              
              <div style={errorDetailsStyle}>
                <div style={errorSectionStyle}>
                  <strong>Error:</strong>
                  <pre style={preStyle}>
                    {this.state.error?.toString()}
                  </pre>
                </div>
                
                {this.state.errorInfo && (
                  <div style={errorSectionStyle}>
                    <strong>Component Stack:</strong>
                    <pre style={preStyle}>
                      {this.state.errorInfo.componentStack}
                    </pre>
                  </div>
                )}
                
                {this.state.error?.stack && (
                  <div style={errorSectionStyle}>
                    <strong>Stack Trace:</strong>
                    <pre style={preStyle}>
                      {this.state.error.stack}
                    </pre>
                  </div>
                )}
              </div>
            </details>

            <div style={helpTextStyle}>
              <p>
                <strong>What you can do:</strong>
              </p>
              <ul style={helpListStyle}>
                <li>Try refreshing the page</li>
                <li>Clear your browser cache and reload</li>
                <li>Try a different browser</li>
                <li>Check the console for additional error details</li>
              </ul>
              
              <p style={reportStyle}>
                If this problem persists, please report it with the technical details above.
              </p>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

// Styles
const containerStyle: React.CSSProperties = {
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  minHeight: '400px',
  padding: '20px',
  backgroundColor: '#f8f9fa',
  fontFamily: 'system-ui, -apple-system, sans-serif'
};

const errorBoxStyle: React.CSSProperties = {
  maxWidth: '600px',
  width: '100%',
  backgroundColor: '#fff',
  borderRadius: '8px',
  padding: '32px',
  boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
  border: '1px solid #e9ecef',
  textAlign: 'center'
};

const iconStyle: React.CSSProperties = {
  fontSize: '48px',
  marginBottom: '16px'
};

const titleStyle: React.CSSProperties = {
  fontSize: '24px',
  fontWeight: '600',
  color: '#dc3545',
  margin: '0 0 16px 0'
};

const messageStyle: React.CSSProperties = {
  fontSize: '16px',
  color: '#666',
  lineHeight: '1.5',
  margin: '0 0 24px 0'
};

const buttonContainerStyle: React.CSSProperties = {
  display: 'flex',
  gap: '12px',
  justifyContent: 'center',
  marginBottom: '24px'
};

const primaryButtonStyle: React.CSSProperties = {
  padding: '12px 24px',
  backgroundColor: '#007bff',
  color: '#fff',
  border: 'none',
  borderRadius: '4px',
  fontSize: '14px',
  fontWeight: '500',
  cursor: 'pointer',
  transition: 'background-color 0.2s ease'
};

const secondaryButtonStyle: React.CSSProperties = {
  padding: '12px 24px',
  backgroundColor: '#6c757d',
  color: '#fff',
  border: 'none',
  borderRadius: '4px',
  fontSize: '14px',
  fontWeight: '500',
  cursor: 'pointer',
  transition: 'background-color 0.2s ease'
};

const detailsStyle: React.CSSProperties = {
  textAlign: 'left',
  marginTop: '24px',
  border: '1px solid #dee2e6',
  borderRadius: '4px'
};

const summaryStyle: React.CSSProperties = {
  padding: '12px 16px',
  backgroundColor: '#f8f9fa',
  cursor: 'pointer',
  fontSize: '14px',
  fontWeight: '500',
  borderBottom: '1px solid #dee2e6'
};

const errorDetailsStyle: React.CSSProperties = {
  padding: '16px',
  fontSize: '12px'
};

const errorSectionStyle: React.CSSProperties = {
  marginBottom: '16px'
};

const preStyle: React.CSSProperties = {
  backgroundColor: '#f8f9fa',
  padding: '12px',
  borderRadius: '4px',
  overflow: 'auto',
  fontSize: '11px',
  fontFamily: 'Monaco, Menlo, "Ubuntu Mono", Consolas, source-code-pro, monospace',
  color: '#e83e8c',
  border: '1px solid #dee2e6',
  marginTop: '8px'
};

const helpTextStyle: React.CSSProperties = {
  textAlign: 'left',
  marginTop: '24px',
  padding: '16px',
  backgroundColor: '#f8f9fa',
  borderRadius: '4px',
  fontSize: '14px'
};

const helpListStyle: React.CSSProperties = {
  margin: '8px 0',
  paddingLeft: '20px'
};

const reportStyle: React.CSSProperties = {
  fontSize: '12px',
  color: '#666',
  fontStyle: 'italic',
  marginTop: '12px'
};

export default ErrorBoundary;

================
File: src/ui/components/graph/GraphExplorer.tsx
================
import React, { useState, useMemo } from 'react';
import GraphVisualization from './Visualization.tsx';
import type { KnowledgeGraph } from '../../../core/graph/types.ts';

interface GraphExplorerProps {
  graph: KnowledgeGraph | null;
  isLoading: boolean;
  onNodeSelect?: (nodeId: string | null) => void;
}

export default function GraphExplorer({ graph, isLoading, onNodeSelect }: GraphExplorerProps) {
  const [selectedNode, setSelectedNode] = useState<string | null>(null);
  const [hideExternalNodes, setHideExternalNodes] = useState(false);
  const [hideAllIsolatedNodes, setHideAllIsolatedNodes] = useState(false);

  const handleNodeSelect = (nodeId: string | null) => {
    setSelectedNode(nodeId);
    onNodeSelect?.(nodeId);
  };

  // Filter out isolated external nodes if toggle is enabled
  const filteredGraph = useMemo(() => {
    if (!graph || (!hideExternalNodes && !hideAllIsolatedNodes)) return graph;

    // Find nodes that have no relationships (isolated nodes)
    const connectedNodeIds = new Set<string>();
    graph.relationships.forEach(rel => {
      connectedNodeIds.add(rel.source);
      connectedNodeIds.add(rel.target);
    });

    // Get all isolated nodes
    const isolatedNodes = graph.nodes.filter(node => !connectedNodeIds.has(node.id));
    
    // Debug: Log what we're filtering
    console.log('🔍 GraphExplorer Filtering Debug:', {
      totalNodes: graph.nodes.length,
      connectedNodes: connectedNodeIds.size,
      isolatedNodes: isolatedNodes.length,
      hideExternal: hideExternalNodes,
      hideAll: hideAllIsolatedNodes,
      allNodeTypes: [...new Set(graph.nodes.map(n => n.label))],
      isolatedNodeDetails: isolatedNodes.map(n => ({
        id: n.id,
        label: n.label,
        name: n.properties.name || n.properties.functionName || 'unnamed',
        allProperties: Object.keys(n.properties)
      }))
    });

    let nodesToHide: typeof graph.nodes = [];

    if (hideAllIsolatedNodes) {
      // Hide ALL isolated nodes
      nodesToHide = isolatedNodes;
      console.log('🔍 Hiding ALL isolated nodes:', nodesToHide.length);
    } else if (hideExternalNodes) {
      // Hide external library nodes (regardless of whether they're isolated)
      nodesToHide = graph.nodes.filter(node => {
        const nodeName = (node.properties.name || node.properties.functionName || '') as string;
        
        console.log('🔍 Checking node for external patterns:', {
          id: node.id,
          label: node.label,
          name: nodeName,
          allProps: node.properties
        });
        
        // Check for external library patterns
        const isExternalLibrary = (
          // Specific external library names
          nodeName.includes('when_all') ||
          nodeName.includes('ruleset') ||
          nodeName.includes('APIRouter') ||
          nodeName.includes('StateGraph') ||
          nodeName.includes('AsyncAzureOpenAI') ||
          nodeName.includes('FastAPI') ||
          nodeName.includes('HTTPException') ||
          nodeName.includes('assert_fact') ||
          nodeName.includes('get_facts') ||
          nodeName.includes('delete_state') ||
          nodeName.includes('anyItem') ||
          nodeName.includes('allItems') ||
          nodeName.includes('matches') ||
          // Common external patterns
          /^[A-Z][a-zA-Z]*Model$/.test(nodeName) || // Models ending in 'Model'
          /^[A-Z][a-zA-Z]*Client$/.test(nodeName) || // Clients
          /^[A-Z][a-zA-Z]*Router$/.test(nodeName) || // Routers
          /^[A-Z][a-zA-Z]*Exception$/.test(nodeName) || // Exceptions
          // CamelCase starting with uppercase (often external classes)
          (/^[A-Z][a-zA-Z]*$/.test(nodeName) && nodeName.length > 3)
        );
        
        // Check for decorators and functions that are likely external
        const isLikelyExternal = (
          (node.label === 'Decorator' || node.label === 'Function') &&
          isExternalLibrary
        );
        
        console.log('🔍 External check result:', {
          name: nodeName,
          label: node.label,
          isExternalLibrary,
          isLikelyExternal
        });
        
        return isLikelyExternal;
      });
      console.log('🔍 Hiding external library nodes:', nodesToHide.length);
    }
    
    console.log('🔍 Final nodes to hide:', nodesToHide.map(n => ({
      id: n.id,
      label: n.label,
      name: n.properties.name || n.properties.functionName || 'unnamed'
    })));

    const nodeIdsToHide = new Set(nodesToHide.map(n => n.id));
    
    // Filter out the nodes we want to hide
    const filteredNodes = graph.nodes.filter(node => !nodeIdsToHide.has(node.id));
    
    // Filter out relationships involving hidden nodes
    const filteredRelationships = graph.relationships.filter(rel => 
      !nodeIdsToHide.has(rel.source) && !nodeIdsToHide.has(rel.target)
    );

    console.log('🔍 Filtering result:', {
      originalNodes: graph.nodes.length,
      filteredNodes: filteredNodes.length,
      hiddenNodes: nodeIdsToHide.size,
      originalRels: graph.relationships.length,
      filteredRels: filteredRelationships.length
    });

    return {
      nodes: filteredNodes,
      relationships: filteredRelationships
    };
  }, [graph, hideExternalNodes, hideAllIsolatedNodes]);

  const containerStyle: React.CSSProperties = {
    width: '100%',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    overflow: 'hidden'
  };

  const controlsStyle: React.CSSProperties = {
    padding: '8px 12px',
    borderBottom: '1px solid #e0e0e0',
    backgroundColor: '#f8f9fa',
    display: 'flex',
    alignItems: 'center',
    gap: '12px',
    fontSize: '14px'
  };

  const loadingStyle: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    height: '100%',
    fontSize: '16px',
    color: '#666'
  };

  const graphContainerStyle: React.CSSProperties = {
    flex: 1,
    overflow: 'hidden'
  };

  if (isLoading) {
    return <div style={containerStyle}><div style={loadingStyle}>Loading graph...</div></div>;
  }

  if (!graph) {
    return <div style={containerStyle}><div style={loadingStyle}>No graph data available</div></div>;
  }

  // Count isolated nodes for display
  const connectedNodeIds = new Set<string>();
  graph.relationships.forEach(rel => {
    connectedNodeIds.add(rel.source);
    connectedNodeIds.add(rel.target);
  });
  const isolatedCount = graph.nodes.filter(node => !connectedNodeIds.has(node.id)).length;
  
  // Count external nodes (not just isolated ones)
  const externalCount = useMemo(() => {
    if (!graph) return 0;
    
    return graph.nodes.filter(node => {
      const nodeName = (node.properties.name || node.properties.functionName || '') as string;
      const isExternalLibrary = (
        nodeName.includes('when_all') ||
        nodeName.includes('ruleset') ||
        nodeName.includes('APIRouter') ||
        nodeName.includes('StateGraph') ||
        nodeName.includes('AsyncAzureOpenAI') ||
        nodeName.includes('FastAPI') ||
        nodeName.includes('HTTPException') ||
        nodeName.includes('assert_fact') ||
        nodeName.includes('get_facts') ||
        nodeName.includes('delete_state') ||
        nodeName.includes('anyItem') ||
        nodeName.includes('allItems') ||
        nodeName.includes('matches') ||
        /^[A-Z][a-zA-Z]*Model$/.test(nodeName) ||
        /^[A-Z][a-zA-Z]*Client$/.test(nodeName) ||
        /^[A-Z][a-zA-Z]*Router$/.test(nodeName) ||
        /^[A-Z][a-zA-Z]*Exception$/.test(nodeName) ||
        (/^[A-Z][a-zA-Z]*$/.test(nodeName) && nodeName.length > 3)
      );
      return (node.label === 'Decorator' || node.label === 'Function') && isExternalLibrary;
    }).length;
  }, [graph]);
  
  // Count what's actually being hidden
  const hiddenCount = useMemo(() => {
    if (!graph) return 0;
    
    if (hideAllIsolatedNodes) {
      return isolatedCount;
    } else if (hideExternalNodes) {
      return externalCount;
    }
    return 0;
  }, [graph, hideExternalNodes, hideAllIsolatedNodes, isolatedCount, externalCount]);

  return (
    <div style={containerStyle}>
      <div style={controlsStyle}>
        <label style={{ display: 'flex', alignItems: 'center', gap: '6px', cursor: 'pointer' }}>
          <input
            type="checkbox"
            checked={hideExternalNodes}
            onChange={(e) => setHideExternalNodes(e.target.checked)}
            style={{ cursor: 'pointer' }}
          />
          <span>Hide external libraries</span>
        </label>
        <label style={{ display: 'flex', alignItems: 'center', gap: '6px', cursor: 'pointer' }}>
          <input
            type="checkbox"
            checked={hideAllIsolatedNodes}
            onChange={(e) => setHideAllIsolatedNodes(e.target.checked)}
            style={{ cursor: 'pointer' }}
          />
          <span>Hide all isolated nodes</span>
        </label>
        <span style={{ color: '#666', fontSize: '12px' }}>
          ({isolatedCount} isolated, {externalCount} external, {hiddenCount} hidden)
        </span>
      </div>
      <div style={graphContainerStyle}>
        <GraphVisualization 
          graph={filteredGraph || graph}
          onNodeSelect={handleNodeSelect}
          selectedNodeId={selectedNode}
        />
      </div>
    </div>
  );
}

================
File: src/ui/components/graph/index.ts
================
export { default as GraphVisualization } from './Visualization.tsx';
export { default as SourceViewer } from './SourceViewer.tsx';
export { default as GraphExplorer } from './GraphExplorer.tsx';

================
File: src/ui/components/graph/SourceViewer.tsx
================
import React, { useMemo } from 'react';
import type { KnowledgeGraph, GraphNode } from '../../../core/graph/types.ts';

interface SourceViewerProps {
  graph: KnowledgeGraph;
  selectedNodeId: string | null;
  fileContents?: Map<string, string>;
  className?: string;
  style?: React.CSSProperties;
}

interface SourceInfo {
  fileName: string;
  filePath: string;
  content: string;
  startLine?: number;
  endLine?: number;
  nodeType: string;
  nodeName: string;
  language?: string;
}

const SourceViewer: React.FC<SourceViewerProps> = ({
  graph,
  selectedNodeId,
  fileContents,
  className = '',
  style = {}
}) => {
  // Warm tone colors to match the new theme
  const colors = {
    background: '#FEF9F0', // Slightly warm white
    surface: '#FFFFFF',
    text: '#451A03', // Dark brown
    textSecondary: '#78350F', // Medium brown
    textMuted: '#A16207', // Light brown
    border: '#FED7AA', // Light orange
    borderLight: '#FEF3C7', // Very light orange
    primary: '#D97706', // Warm orange
    codeBackground: '#FDF6E3', // Warm cream for code
    lineNumbers: '#92400E' // Dark orange for line numbers
  };

  // Extract relevant content from a file for a specific function/class/method
  const extractRelevantContent = (fileContent: string, targetName: string, nodeType: string): string | null => {
    const lines = fileContent.split('\n');
    
    try {
      if (nodeType === 'Function') {
        // Look for function definition patterns
        const patterns = [
          new RegExp(`^\\s*def\\s+${targetName}\\s*\\(`),     // Python
          new RegExp(`^\\s*function\\s+${targetName}\\s*\\(`), // JavaScript
          new RegExp(`^\\s*const\\s+${targetName}\\s*=`),     // JavaScript const
          new RegExp(`^\\s*let\\s+${targetName}\\s*=`),       // JavaScript let
          new RegExp(`^\\s*export\\s+function\\s+${targetName}\\s*\\(`), // ES6 export
          new RegExp(`^\\s*(public|private|protected)?\\s*\\w*\\s*${targetName}\\s*\\(`) // Java/C#
        ];
        
        for (let i = 0; i < lines.length; i++) {
          if (patterns.some(pattern => pattern.test(lines[i]))) {
            // Found the function, now extract it with context
            const startLine = Math.max(0, i - 2); // Include 2 lines before for context
            let endLine = i + 1;
            
            // Find the end of the function (simple heuristic)
            let braceCount = 0;
            const indentLevel = lines[i].match(/^\s*/)?.[0].length || 0;
            
            for (let j = i + 1; j < lines.length; j++) {
              const line = lines[j];
              const currentIndent = line.match(/^\s*/)?.[0].length || 0;
              
              // For Python, use indentation
              if (lines[i].includes('def ')) {
                if (line.trim() && currentIndent <= indentLevel && !line.startsWith(' ')) {
                  break;
                }
                endLine = j;
              } 
              // For JavaScript/Java, use braces
              else {
                braceCount += (line.match(/\{/g) || []).length;
                braceCount -= (line.match(/\}/g) || []).length;
                endLine = j;
                if (braceCount === 0 && j > i) {
                  break;
                }
              }
              
              // Safety limit
              if (j - i > 100) break;
            }
            
            return lines.slice(startLine, endLine + 3).join('\n'); // Include 3 lines after
          }
        }
      }
      
      if (nodeType === 'Class') {
        const patterns = [
          new RegExp(`^\\s*class\\s+${targetName}\\b`),
          new RegExp(`^\\s*(public|private)?\\s*class\\s+${targetName}\\b`)
        ];
        
        for (let i = 0; i < lines.length; i++) {
          if (patterns.some(pattern => pattern.test(lines[i]))) {
            const startLine = Math.max(0, i - 2);
            const endLine = i + 20; // Show first 20 lines of class
            
            return lines.slice(startLine, Math.min(endLine, lines.length)).join('\n');
          }
        }
      }
      
      // If we can't extract specifically, return null to use full file
      return null;
    } catch (error) {
      console.warn('Error extracting content:', error);
      return null;
    }
  };

  // Generate mock source content based on node type
  const generateMockContent = (node: GraphNode): string => {
    try {
      const name = node.properties.name as string || 'unknown';
      
      switch (node.label) {
        case 'Function':
          return `def ${name}():
    """
    Function: ${name}
    """
    # Implementation here
    pass`;

        case 'Method': {
          const parentClass = node.properties.parentClass as string || 'UnknownClass';
          return `class ${parentClass}:
    def ${name}(self):
        """
        Method: ${name}
        Class: ${parentClass}
        """
        # Implementation here
        pass`;
        }

        case 'Class':
          return `class ${name}:
    """
    Class: ${name}
    """
    
    def __init__(self):
        # Constructor
        pass`;

        case 'Variable':
          return `# Variable: ${name}
${name} = None  # Initialize variable`;

        case 'File': {
          const path = node.properties.path as string || name;
          const extension = path.split('.').pop()?.toLowerCase() || 'txt';
          
          switch (extension) {
            case 'py':
              return `# File: ${path}
"""
Python module: ${name}
"""

def main():
    print("Hello from ${name}")

if __name__ == "__main__":
    main()`;
            
            case 'js':
            case 'ts':
              return `// File: ${path}
/**
 * JavaScript/TypeScript module: ${name}
 */

function main() {
    console.log("Hello from ${name}");
}

export default main;`;
            
            case 'java':
              return `// File: ${path}
/**
 * Java class: ${name}
 */
public class ${name.replace(/\.[^/.]+$/, "")} {
    public static void main(String[] args) {
        System.out.println("Hello from ${name}");
    }
}`;
            
            default:
              return `// File: ${path}
// Content of ${name}`;
          }
        }

        case 'Folder':
          return `# Directory: ${name}
# This is a folder containing other files and directories`;

        case 'Project':
          return `# Project: ${name}
# Root directory of the project`;

        default:
          return `# ${node.label}: ${name}
# No specific content available`;
      }
    } catch (error) {
      return `# Error generating content for ${node.label}
# ${error instanceof Error ? error.message : 'Unknown error'}`;
    }
  };

  // Generate content for built-in functions
  const generateBuiltinFunctionContent = (functionName: string): string => {
    switch (functionName) {
      case 'round':
        return `# Built-in Function: ${functionName}
"""
Rounds a number to the nearest integer.
"""

def round(number: float, ndigits: int = 0) -> float:
    """
    Rounds a number to the nearest integer.
    Args:
        number (float): The number to round.
        ndigits (int, optional): The number of decimal places to round to. Defaults to 0.
    Returns:
        float: The rounded number.
    """
    # Implementation here
    pass`;
      case 'len':
        return `# Built-in Function: ${functionName}
"""
Returns the number of items in an object.
"""

def len(obj: Any) -> int:
    """
    Returns the number of items in an object.
    Args:
        obj (Any): The object to get the length of.
    Returns:
        int: The number of items.
    """
    # Implementation here
    pass`;
      case 'print':
        return `# Built-in Function: ${functionName}
"""
Prints the given arguments to the standard output.
"""

def print(*args, sep: str = " ", end: str = "\\n") -> None:
    """
    Prints the given arguments to the standard output.
    Args:
        *args: The arguments to print.
        sep (str, optional): The separator between arguments. Defaults to " ".
        end (str, optional): The string to print at the end. Defaults to "\\n".
    """
    # Implementation here
    pass`;
      case 'input':
        return `# Built-in Function: ${functionName}
"""
Reads a line from the standard input.
"""

def input(prompt: str = "") -> str:
    """
    Reads a line from the standard input.
    Args:
        prompt (str, optional): The prompt to display. Defaults to "".
    Returns:
        str: The input string.
    """
    # Implementation here
    pass`;
      case 'open':
        return `# Built-in Function: ${functionName}
"""
Opens a file and returns a file object.
"""

def open(file: str, mode: str = "r", buffering: int = -1, encoding: str | None = None, errors: str | None = None, newline: str | None = None) -> Any:
    """
    Opens a file and returns a file object.
    Args:
        file (str): The path to the file.
        mode (str, optional): The mode in which the file is opened. Defaults to "r".
        buffering (int, optional): The buffering strategy. Defaults to -1.
        encoding (str | None, optional): The encoding to use. Defaults to None.
        errors (str | None, optional): How to handle encoding errors. Defaults to None.
        newline (str | None, optional): How to handle newlines. Defaults to None.
    Returns:
        Any: The file object.
    """
    # Implementation here
    pass`;
      case 'type':
        return `# Built-in Function: ${functionName}
"""
Returns the type of an object.
"""

def type(obj: Any) -> type:
    """
    Returns the type of an object.
    Args:
        obj (Any): The object to get the type of.
    Returns:
        type: The type of the object.
    """
    # Implementation here
    pass`;
      case 'isinstance':
        return `# Built-in Function: ${functionName}
"""
Checks if an object is an instance of a class or a tuple of classes.
"""

def isinstance(obj: Any, classinfo: type | tuple[type, ...]) -> bool:
    """
    Checks if an object is an instance of a class or a tuple of classes.
    Args:
        obj (Any): The object to check.
        classinfo (type | tuple[type, ...]): The class or tuple of classes to check against.
    Returns:
        bool: True if the object is an instance of the class or one of the classes in the tuple.
    """
    # Implementation here
    pass`;
      case 'hasattr':
        return `# Built-in Function: ${functionName}
"""
Checks if an object has an attribute.
"""

def hasattr(obj: Any, name: str) -> bool:
    """
    Checks if an object has an attribute.
    Args:
        obj (Any): The object to check.
        name (str): The name of the attribute to check for.
    Returns:
        bool: True if the object has the attribute, False otherwise.
    """
    # Implementation here
    pass`;
      default:
        return `# Built-in Function: ${functionName}
# No specific content available`;
    }
  };

  // Get source info for selected node
  const sourceInfo = useMemo((): SourceInfo | null => {
    if (!selectedNodeId || !graph?.nodes) return null;

    const node = graph.nodes.find(n => n.id === selectedNodeId);
    if (!node) return null;

    const nodeName = node.properties.name as string || node.id;
    
    // First, try to get the file path from the node's properties
    let filePath = node.properties.path as string || node.properties.filePath as string;
    
    // If the node doesn't have a direct file path, find it through graph relationships
    if (!filePath || filePath === nodeName) {
      console.log('SourceViewer - Finding file through graph relationships for:', nodeName);
      
      // Find the file that CONTAINS this node
      const containsRelationship = graph.relationships?.find(rel => 
        rel.type === 'CONTAINS' && rel.target === selectedNodeId
      );
      
      if (containsRelationship) {
        const fileNode = graph.nodes.find(n => n.id === containsRelationship.source);
        if (fileNode && fileNode.label === 'File') {
          filePath = fileNode.properties.path as string || fileNode.properties.filePath as string;
          console.log('SourceViewer - Found file through CONTAINS relationship:', filePath);
        }
      }
      
      // If still no file path, try reverse lookup by searching for the node name in file contents
      if (!filePath && fileContents) {
        console.log('SourceViewer - Searching file contents for node:', nodeName);
        
        // Try multiple search patterns for the function
        const searchPatterns = [
          `def ${nodeName}(`,           // Python function
          `def ${nodeName} (`,          // Python function with space
          `function ${nodeName}(`,      // JavaScript function
          `function ${nodeName} (`,     // JavaScript function with space
          `const ${nodeName} =`,        // JavaScript const
          `let ${nodeName} =`,          // JavaScript let
          `var ${nodeName} =`,          // JavaScript var
          `class ${nodeName}`,          // Class definition
          `${nodeName}:`,               // Object property or TypeScript type
          `export const ${nodeName}`,   // ES6 export
          `export function ${nodeName}`, // ES6 export function
          `public ${nodeName}(`,        // Java/C# method
          `private ${nodeName}(`,       // Java/C# method
          `protected ${nodeName}(`,     // Java/C# method
          // Also try with underscores and variations
          `def ${nodeName}_`,           // Python with underscore
          `function ${nodeName}_`,      // JavaScript with underscore
        ];
        
        for (const [path, content] of fileContents) {
          console.log(`SourceViewer - Checking file: ${path}`);
          
          // Check if any pattern matches
          const foundPattern = searchPatterns.find(pattern => {
            const found = content.includes(pattern);
            if (found) {
              console.log(`SourceViewer - Found pattern "${pattern}" in ${path}`);
            }
            return found;
          });
          
          if (foundPattern) {
            filePath = path;
            console.log('SourceViewer - Found file through content search:', filePath);
            break;
          }
        }
        
        // If still not found, try a more lenient search (case-insensitive)
        if (!filePath) {
          console.log('SourceViewer - Trying case-insensitive search for:', nodeName);
          for (const [path, content] of fileContents) {
            const lowerContent = content.toLowerCase();
            const lowerNodeName = nodeName.toLowerCase();
            
            if (lowerContent.includes(`def ${lowerNodeName}(`) || 
                lowerContent.includes(`function ${lowerNodeName}(`) ||
                lowerContent.includes(`const ${lowerNodeName} =`) ||
                lowerContent.includes(`class ${lowerNodeName}`)) {
              filePath = path;
              console.log('SourceViewer - Found file through case-insensitive search:', filePath);
              break;
            }
          }
        }
      }
    }

    const fileName = filePath ? filePath.split('/').pop() || filePath : nodeName;

    console.log('SourceViewer - Final node details:', {
      nodeId: selectedNodeId,
      nodeName,
      filePath,
      fileName,
      nodeLabel: node.label,
      nodeProperties: node.properties,
      fileContentsSize: fileContents?.size || 0,
      // Add detailed relationship debugging
      allRelationships: graph?.relationships?.length || 0,
      containsRelationships: graph?.relationships?.filter(rel => rel.type === 'CONTAINS').length || 0,
      relationshipsForThisNode: graph?.relationships?.filter(rel => rel.target === selectedNodeId || rel.source === selectedNodeId) || [],
      fileNodesInGraph: graph?.nodes?.filter(n => n.label === 'File').map(n => ({
        id: n.id,
        path: n.properties.path,
        filePath: n.properties.filePath,
        name: n.properties.name
      })) || [],
      availableFileContents: fileContents ? Array.from(fileContents.entries()).map(([path, content]) => ({
        path,
        size: content.length,
        firstLines: content.split('\n').slice(0, 3).join('\\n'),
        containsSub: content.includes('def sub(') || content.includes('function sub(')
      })) : []
    });

    // Try to get actual file content
    let content = '';
    
    if (filePath && fileContents && fileContents.has(filePath)) {
      content = fileContents.get(filePath)!;
      console.log('SourceViewer - Found file content for:', filePath);
      
      // For function/method/class nodes, try to extract just the relevant part
      if (node.label === 'Function' || node.label === 'Method' || node.label === 'Class') {
        const extractedContent = extractRelevantContent(content, nodeName, node.label);
        if (extractedContent) {
          content = extractedContent;
          console.log('SourceViewer - Extracted relevant content for:', nodeName);
        }
      }
    } else {
      console.log('SourceViewer - No file content found, checking if this is a built-in function');
      
      // Check if this is a built-in function
      if (node.id.includes('builtin_') || nodeName === 'round' || nodeName === 'len' || nodeName === 'print' || 
          ['round', 'len', 'str', 'int', 'float', 'bool', 'list', 'dict', 'tuple', 'set',
           'range', 'enumerate', 'zip', 'map', 'filter', 'sum', 'max', 'min', 'abs',
           'print', 'input', 'open', 'type', 'isinstance', 'hasattr'].includes(nodeName)) {
        
        content = generateBuiltinFunctionContent(nodeName);
        console.log('SourceViewer - Using built-in function content for:', nodeName);
      } else {
        console.log('SourceViewer - Using mock content for user-defined node:', nodeName);
        content = generateMockContent(node);
      }
    }

    // Detect language from file extension
    const extension = fileName.split('.').pop()?.toLowerCase();
    let language = 'text';
    switch (extension) {
      case 'js':
      case 'jsx':
        language = 'javascript';
        break;
      case 'ts':
      case 'tsx':
        language = 'typescript';
        break;
      case 'py':
        language = 'python';
        break;
      case 'java':
        language = 'java';
        break;
      case 'cpp':
      case 'cc':
      case 'cxx':
        language = 'cpp';
        break;
      case 'c':
        language = 'c';
        break;
      case 'cs':
        language = 'csharp';
        break;
      case 'php':
        language = 'php';
        break;
      case 'rb':
        language = 'ruby';
        break;
      case 'go':
        language = 'go';
        break;
      case 'rs':
        language = 'rust';
        break;
      case 'swift':
        language = 'swift';
        break;
      case 'kt':
        language = 'kotlin';
        break;
      case 'scala':
        language = 'scala';
        break;
      case 'html':
        language = 'html';
        break;
      case 'css':
        language = 'css';
        break;
      case 'scss':
        language = 'scss';
        break;
      case 'json':
        language = 'json';
        break;
      case 'xml':
        language = 'xml';
        break;
      case 'yaml':
      case 'yml':
        language = 'yaml';
        break;
      case 'md':
        language = 'markdown';
        break;
      case 'sh':
        language = 'bash';
        break;
      case 'sql':
        language = 'sql';
        break;
    }

    return {
      fileName,
      filePath: filePath || nodeName,
      content,
      nodeType: node.label,
      nodeName,
      language,
      startLine: node.properties.startLine as number,
      endLine: node.properties.endLine as number
    };
  }, [selectedNodeId, graph?.nodes, graph?.relationships, fileContents]);

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    width: '100%',
    backgroundColor: colors.background,
    overflow: 'hidden',
    ...style
  };

  const headerStyle: React.CSSProperties = {
    padding: '16px 20px',
    backgroundColor: colors.surface,
    borderBottom: `1px solid ${colors.borderLight}`,
    flexShrink: 0
  };

  const titleStyle: React.CSSProperties = {
    fontSize: '16px',
    fontWeight: '600',
    color: colors.text,
    marginBottom: '8px',
    display: 'flex',
    alignItems: 'center',
    gap: '8px'
  };

  const infoStyle: React.CSSProperties = {
    fontSize: '12px',
    color: colors.textMuted,
    display: 'flex',
    alignItems: 'center',
    gap: '16px',
    flexWrap: 'wrap'
  };

  const codeContainerStyle: React.CSSProperties = {
    flex: 1,
    overflow: 'auto',
    backgroundColor: colors.codeBackground,
    position: 'relative'
  };

  const codeStyle: React.CSSProperties = {
    fontFamily: "'Fira Code', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace",
    fontSize: '13px',
    lineHeight: '1.5',
    padding: '16px',
    margin: 0,
    backgroundColor: 'transparent',
    color: colors.text,
    whiteSpace: 'pre-wrap',
    wordBreak: 'break-word',
    border: 'none',
    outline: 'none',
    resize: 'none',
    width: '100%',
    minHeight: '100%',
    boxSizing: 'border-box'
  };

  const emptyStateStyle: React.CSSProperties = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'column',
    height: '100%',
    color: colors.textMuted,
    fontSize: '14px',
    gap: '12px',
    padding: '32px'
  };

  const renderEmptyState = () => (
    <div style={emptyStateStyle}>
      <div style={{ fontSize: '48px', opacity: 0.3 }}>📝</div>
      <div style={{ textAlign: 'center' }}>
        Select a node in the graph to view its source code
      </div>
    </div>
  );

  const renderSourceContent = (info: SourceInfo) => {
    const lines = info.content.split('\n');

    return (
      <>
        <div style={headerStyle}>
          <div style={titleStyle}>
            <span>📝</span>
            <span>{info.fileName}</span>
          </div>
          <div style={infoStyle}>
            <span>📄 {info.nodeType}</span>
            <span>🏷️ {info.nodeName}</span>
            {info.language && <span>💻 {info.language}</span>}
            <span>📏 {lines.length} lines</span>
          </div>
        </div>
        
        <div style={codeContainerStyle}>
          <pre style={codeStyle}>
            {info.content}
          </pre>
        </div>
      </>
    );
  };

  return (
    <div className={`source-viewer ${className}`} style={containerStyle}>
      {sourceInfo ? renderSourceContent(sourceInfo) : renderEmptyState()}
    </div>
  );
};

export default SourceViewer;

================
File: src/ui/components/graph/Visualization.tsx
================
import React, { useEffect, useRef, useState } from 'react';
import * as d3 from 'd3';
import type { KnowledgeGraph, GraphNode, GraphRelationship } from '../../../core/graph/types.ts';

interface GraphVisualizationProps {
  graph: KnowledgeGraph;
  onNodeSelect?: (nodeId: string | null) => void;
  selectedNodeId?: string | null;
  className?: string;
  style?: React.CSSProperties;
}

interface D3Node extends d3.SimulationNodeDatum {
  id: string;
  label: string;
  nodeType: string;
  properties: Record<string, unknown>;
  color: string;
  size: number;
}

interface D3Link extends d3.SimulationLinkDatum<D3Node> {
  id: string;
  source: string | D3Node;
  target: string | D3Node;
  relationshipType: string;
  color: string;
  width: number;
}

const GraphVisualization: React.FC<GraphVisualizationProps> = ({
  graph,
  onNodeSelect,
  selectedNodeId,
  className = '',
  style = {}
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const simulationRef = useRef<d3.Simulation<D3Node, D3Link> | null>(null);
  const onNodeSelectRef = useRef(onNodeSelect);
  const [isReady, setIsReady] = useState(false);

  // Update the ref whenever onNodeSelect changes
  onNodeSelectRef.current = onNodeSelect;

  // Convert KnowledgeGraph to D3 format
  const convertToD3Format = (graph: KnowledgeGraph) => {
    const nodeIds = new Set<string>();
    
    // First pass: collect all node IDs and analyze the graph structure
    graph.nodes.forEach(node => nodeIds.add(node.id));
    
    // Calculate node metrics for intelligent sizing
    const nodeMetrics = new Map<string, {
      inDegree: number;
      outDegree: number;
      totalDegree: number;
      depth: number;
      isRoot: boolean;
      childrenCount: number;
    }>();
    
    // Initialize metrics
    graph.nodes.forEach(node => {
      nodeMetrics.set(node.id, {
        inDegree: 0,
        outDegree: 0,
        totalDegree: 0,
        depth: 0,
        isRoot: false,
        childrenCount: 0
      });
    });
    
    // Calculate degrees and relationships
    graph.relationships.forEach(rel => {
      const sourceMetrics = nodeMetrics.get(rel.source);
      const targetMetrics = nodeMetrics.get(rel.target);
      
      if (sourceMetrics && targetMetrics) {
        sourceMetrics.outDegree++;
        targetMetrics.inDegree++;
        
        // For CONTAINS relationships, count children
        if (rel.type.toLowerCase() === 'contains') {
          sourceMetrics.childrenCount++;
        }
      }
    });
    
    // Calculate total degree and identify root nodes
    nodeMetrics.forEach((metrics) => {
      metrics.totalDegree = metrics.inDegree + metrics.outDegree;
      // Root nodes typically have high out-degree and low/zero in-degree
      metrics.isRoot = metrics.inDegree === 0 && metrics.outDegree > 0;
    });
    
    // Calculate depth (simplified - could be more sophisticated)
    const calculateDepth = (nodeId: string, visited = new Set<string>()): number => {
      if (visited.has(nodeId)) return 0;
      visited.add(nodeId);
      
      const parentRels = graph.relationships.filter(rel => 
        rel.target === nodeId && rel.type.toLowerCase() === 'contains'
      );
      
      if (parentRels.length === 0) return 0; // Root level
      
      const parentDepths = parentRels.map(rel => calculateDepth(rel.source, new Set(visited)));
      return Math.max(...parentDepths, 0) + 1;
    };
    
    // Calculate depths for all nodes
    graph.nodes.forEach(node => {
      const metrics = nodeMetrics.get(node.id);
      if (metrics) {
        metrics.depth = calculateDepth(node.id);
      }
    });
    
    // Convert nodes with intelligent sizing
    const nodes: D3Node[] = graph.nodes.map((node: GraphNode) => {
      const metrics = nodeMetrics.get(node.id)!;
      
      // Determine base color and size based on type
      let color = '#69b3a2';
      let baseSize = 8;
      
      switch (node.label.toLowerCase()) {
        case 'project':
          color = '#2E7D32';
          baseSize = 25; // Largest - project root
          break;
        case 'folder':
          color = '#F57C00';
          baseSize = 16;
          break;
        case 'file':
          color = '#1976D2';
          baseSize = 12;
          break;
        case 'function':
          color = '#00796B';
          baseSize = 8;
          break;
        case 'method':
          color = '#00695C';
          baseSize = 7;
          break;
        case 'class':
          color = '#C2185B';
          baseSize = 12;
          break;
        case 'variable':
          color = '#546E7A';
          baseSize = 6;
          break;
        default:
          color = '#69b3a2';
          baseSize = 8;
      }
      
      // Calculate final size based on multiple factors
      let finalSize = baseSize;
      
      // Factor 1: Hierarchy depth (higher levels = bigger)
      const depthMultiplier = Math.max(0.7, 1.5 - (metrics.depth * 0.15));
      finalSize *= depthMultiplier;
      
      // Factor 2: Connection importance (more connections = bigger)
      if (metrics.totalDegree > 0) {
        const connectionMultiplier = 1 + Math.min(0.8, metrics.totalDegree * 0.1);
        finalSize *= connectionMultiplier;
      }
      
      // Factor 3: Container nodes (nodes with children) should be bigger
      if (metrics.childrenCount > 0) {
        const containerMultiplier = 1 + Math.min(0.6, metrics.childrenCount * 0.08);
        finalSize *= containerMultiplier;
      }
      
      // Factor 4: Root nodes get a boost
      if (metrics.isRoot) {
        finalSize *= 1.4;
      }
      
      // Factor 5: Special boost for hub nodes (high degree centrality)
      if (metrics.totalDegree > 10) {
        finalSize *= 1.3;
        color = adjustColorBrightness(color, 20); // Make hub nodes slightly brighter
      }
      
      // Ensure size bounds
      finalSize = Math.max(4, Math.min(35, finalSize));
      
      return {
        id: node.id,
        label: node.properties.name as string || node.id,
        nodeType: node.label.toLowerCase(),
        properties: node.properties,
        color,
        size: Math.round(finalSize),
        // Store metrics for potential future use
        metrics
      };
    });

    // Convert links with validation (unchanged)
    const links: D3Link[] = [];
    graph.relationships.forEach((rel: GraphRelationship) => {
      // Validate that both source and target nodes exist
      if (!nodeIds.has(rel.source) || !nodeIds.has(rel.target)) {
        console.warn(`Skipping invalid relationship: ${rel.source} -> ${rel.target}`);
        return;
      }
      
      // Skip self-loops
      if (rel.source === rel.target) {
        return;
      }

      // Determine link color and width based on type
      let color = '#999';
      let width = 1;
      
      switch (rel.type.toLowerCase()) {
        case 'contains':
          color = '#4CAF50';
          width = 2;
          break;
        case 'calls':
          color = '#F44336';
          width = 1;
          break;
        case 'imports':
          color = '#9C27B0';
          width = 1.5;
          break;
        case 'inherits':
          color = '#2196F3';
          width = 2;
          break;
        default:
          color = '#999';
          width = 1;
      }

      links.push({
        id: rel.id,
        source: rel.source,
        target: rel.target,
        relationshipType: rel.type.toLowerCase(),
        color,
        width
      });
    });

    return { nodes, links };
  };

  // Helper function to adjust color brightness
  const adjustColorBrightness = (hex: string, percent: number): string => {
    const num = parseInt(hex.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
      (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
      (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
  };

  // Initialize D3 visualization
  useEffect(() => {
    if (!svgRef.current || !graph) return;

    const svg = d3.select(svgRef.current);
    const container = svg.select('.graph-container');
    
    // Clear previous content
    container.selectAll('*').remove();

    const { nodes, links } = convertToD3Format(graph);

    // Get SVG dimensions
    const rect = svgRef.current.getBoundingClientRect();
    const width = rect.width || 800;
    const height = rect.height || 600;

    // Set up zoom behavior
    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        container.attr('transform', event.transform);
      });

    // Apply zoom behavior to SVG
    svg.call(zoom);

    // Reset zoom on double-click
    svg.on('dblclick.zoom', null);
    svg.on('dblclick', () => {
      svg.transition().duration(750).call(
        zoom.transform,
        d3.zoomIdentity
      );
    });

    // Create force simulation
    const simulation = d3.forceSimulation<D3Node>(nodes)
      .force('link', d3.forceLink<D3Node, D3Link>(links)
        .id((d: D3Node) => d.id)
        .distance((d: D3Link) => {
          switch (d.relationshipType) {
            case 'contains': return 60;
            case 'imports': return 100;
            case 'calls': return 80;
            default: return 90;
          }
        })
        .strength(0.7)
      )
      .force('charge', d3.forceManyBody()
        .strength((d: d3.SimulationNodeDatum) => {
          const node = d as D3Node;
          switch (node.nodeType) {
            case 'project': return -800;
            case 'folder': return -400;
            case 'file': return -300;
            default: return -200;
          }
        })
      )
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide()
        .radius((node: d3.SimulationNodeDatum) => {
          const d = node as D3Node;
          return d.size + 5;
        })
        .strength(0.7)
      )
      .alphaTarget(0.05)
      .alphaDecay(0.005);

    simulationRef.current = simulation;

    // Create links
    const link = container.append('g')
      .attr('class', 'links')
      .selectAll('line')
      .data(links)
      .enter().append('line')
      .attr('stroke', (d) => d.color)
      .attr('stroke-width', (d) => d.width)
      .attr('stroke-opacity', 0.8)
      .style('stroke-dasharray', (d) => {
        switch (d.relationshipType) {
          case 'calls': return '5,5';
          case 'imports': return '3,3';
          default: return 'none';
        }
      });

    // Create nodes
    const node = container.append('g')
      .attr('class', 'nodes')
      .selectAll('circle')
      .data(nodes)
      .enter().append('circle')
      .attr('r', (d) => d.size)
      .attr('fill', (d) => d.color)
      .attr('stroke', '#fff')
      .attr('stroke-width', 2)
      .style('cursor', 'pointer');

    // Use D3 drag with proper click distance to prevent sticking
    node.call(d3.drag<SVGCircleElement, D3Node>()
      .clickDistance(10) // Larger threshold to better distinguish clicks from drags
      .on('start', function(event) {
        // Only fix position if this is actually a drag (not a click)
        if (event.sourceEvent.type === 'mousedown') {
          // Don't fix position immediately - wait for actual drag
        }
      })
      .on('drag', function(event, d) {
        // This only fires on actual drags (beyond clickDistance)
        if (!d.fx && !d.fy) {
          // First drag event - fix position and restart simulation
          d.fx = d.x;
          d.fy = d.y;
          if (!event.active) simulation.alphaTarget(0.3).restart();
        }
        d.fx = event.x;
        d.fy = event.y;
      })
      .on('end', function(event, d) {
        if (!event.active) simulation.alphaTarget(0.05);
        // Release the node
        d.fx = null;
        d.fy = null;
      })
    );

    // Create labels
    const label = container.append('g')
      .attr('class', 'labels')
      .selectAll('text')
      .data(nodes)
      .enter().append('text')
      .text((d) => d.label)
      .attr('font-size', (d) => Math.max(8, d.size - 2))
      .attr('font-family', 'Inter, system-ui, sans-serif')
      .attr('font-weight', '500')
      .attr('fill', '#fff')
      .attr('text-anchor', 'middle')
      .attr('dy', '0.35em')
      .style('pointer-events', 'none')
      .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)');

    // Node click handler
    node.on('click', (event, d) => {
      
      // Ignore clicks if we're dragging or just finished dragging
      if (d.fx || d.fy) return; // Check if node is being dragged
      
      event.stopPropagation();
      
      // Remove previous selection
      node.classed('selected', false);
      node.attr('stroke-width', 2);
      
      // Add selection to clicked node
      d3.select(event.currentTarget)
        .classed('selected', true)
        .attr('stroke-width', 4)
        .attr('stroke', '#FFD54F');
      
      // Highlight connected elements
      const connectedNodeIds = new Set<string>();
      link.attr('stroke-opacity', 0.1);
      node.attr('opacity', 0.3);
      label.attr('opacity', 0.3);
      
      links.forEach(linkData => {
        const sourceId = typeof linkData.source === 'object' ? linkData.source.id : linkData.source;
        const targetId = typeof linkData.target === 'object' ? linkData.target.id : linkData.target;
        
        if (sourceId === d.id || targetId === d.id) {
          connectedNodeIds.add(sourceId);
          connectedNodeIds.add(targetId);
        }
      });
      
      // Highlight connected nodes and links
      link.filter(linkData => {
        const sourceId = typeof linkData.source === 'object' ? linkData.source.id : linkData.source;
        const targetId = typeof linkData.target === 'object' ? linkData.target.id : linkData.target;
        return sourceId === d.id || targetId === d.id;
      }).attr('stroke-opacity', 1);
      
      node.filter(nodeData => connectedNodeIds.has(nodeData.id))
        .attr('opacity', 1);
      
      label.filter(nodeData => connectedNodeIds.has(nodeData.id))
        .attr('opacity', 1);
      
      // Keep selected node fully visible
      d3.select(event.currentTarget).attr('opacity', 1);
      label.filter(nodeData => nodeData.id === d.id).attr('opacity', 1);
      
      if (onNodeSelectRef.current) {
        onNodeSelectRef.current(d.id);
      }
    });

    // Background click handler - clear selection when clicking empty space
    svg.on('click', (event) => {
      // Only handle clicks on the SVG background (not on nodes or other elements)
      if (event.target === event.currentTarget) {
        // Remove all selections and highlighting
        node.classed('selected', false);
        node.attr('stroke-width', 2).attr('stroke', '#fff').attr('opacity', 1);
        link.attr('stroke-opacity', 0.8);
        label.attr('opacity', 1);
        
        if (onNodeSelectRef.current) {
          onNodeSelectRef.current(null);
        }
      }
    });

    // Hover effects
    node.on('mouseover', (event, d) => {
      d3.select(event.currentTarget)
        .transition()
        .duration(200)
        .attr('r', d.size * 1.3);
    });

    node.on('mouseout', (event, d) => {
      d3.select(event.currentTarget)
        .transition()
        .duration(200)
        .attr('r', d.size);
    });

    // Update positions on each tick
    simulation.on('tick', () => {
      link
        .attr('x1', (d) => (d.source as D3Node).x!)
        .attr('y1', (d) => (d.source as D3Node).y!)
        .attr('x2', (d) => (d.target as D3Node).x!)
        .attr('y2', (d) => (d.target as D3Node).y!);

      node
        .attr('cx', (d) => d.x!)
        .attr('cy', (d) => d.y!);

      label
        .attr('x', (d) => d.x!)
        .attr('y', (d) => d.y!);
    });

    setIsReady(true);

    // Cleanup function
    return () => {
      if (simulationRef.current) {
        simulationRef.current.stop();
        simulationRef.current = null;
      }
      setIsReady(false);
    };
  }, [graph]); // Removed onNodeSelect from dependencies to prevent re-renders

  // Handle selected node changes
  useEffect(() => {
    if (!svgRef.current || !isReady || !selectedNodeId) return;

    const svg = d3.select(svgRef.current);
    const nodes = svg.selectAll('.nodes circle');
    
    // Remove previous selection
    nodes.classed('selected', false);
    nodes.attr('stroke-width', 2).attr('stroke', '#fff');
    
    // Select the specified node
    nodes.filter(function(d) { return (d as D3Node).id === selectedNodeId; })
      .classed('selected', true)
      .attr('stroke-width', 4)
      .attr('stroke', '#FFD54F');
  }, [selectedNodeId, isReady]);

  const defaultStyle: React.CSSProperties = {
    width: '100%',
    height: '100%',
    minHeight: '400px',
    border: '1px solid #37474F',
    borderRadius: '8px',
    backgroundColor: '#263238',
    boxShadow: '0 4px 20px rgba(0,0,0,0.1)',
    ...style
  };

  return (
    <div className={`graph-visualization ${className}`} style={{ position: 'relative', width: '100%', height: '100%', minHeight: '400px' }}>
      <svg
        ref={svgRef}
        style={defaultStyle}
        className="d3-graph-container"
      >
        <g className="graph-container" />
      </svg>
      {!isReady && (
        <div
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: '#90A4AE',
            fontSize: '16px',
            fontFamily: 'Inter, system-ui, sans-serif',
            fontWeight: '500',
            zIndex: 10,
            display: 'flex',
            alignItems: 'center',
            gap: '12px'
          }}
        >
          <div
            style={{
              width: '20px',
              height: '20px',
              border: '2px solid #90A4AE',
              borderTop: '2px solid transparent',
              borderRadius: '50%',
              animation: 'spin 1s linear infinite'
            }}
          />
          Loading knowledge graph...
        </div>
      )}
      
      {/* Add navigation instructions */}
      <div
        style={{
          position: 'absolute',
          top: '10px',
          right: '16px',
          backgroundColor: 'rgba(0, 0, 0, 0.7)',
          color: '#fff',
          padding: '8px 12px',
          borderRadius: '4px',
          fontSize: '12px',
          fontFamily: 'Inter, system-ui, sans-serif',
          zIndex: 10,
          lineHeight: '1.4'
        }}
      >
        <div>🖱️ <strong>Navigation:</strong></div>
        <div>• Drag to pan</div>
        <div>• Scroll to zoom</div>
        <div>• Double-click to reset view</div>
        <div>• Drag nodes to reposition</div>
      </div>

      <style>{`
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        .d3-graph-container {
          font-family: 'Inter', system-ui, sans-serif;
          cursor: grab;
        }
        
        .d3-graph-container:active {
          cursor: grabbing;
        }
        
        .nodes circle.selected {
          filter: drop-shadow(0 0 10px rgba(255, 213, 79, 0.8));
        }
        
        .links line {
          transition: stroke-opacity 0.3s ease;
        }
        
        .nodes circle {
          transition: opacity 0.3s ease, r 0.2s ease;
        }
        
        .labels text {
          transition: opacity 0.3s ease;
        }
      `}</style>
    </div>
  );
};

export default GraphVisualization;

================
File: src/ui/components/index.ts
================
export * from './graph/index.ts';
export * from './chat/index.ts';
export { default as ErrorBoundary } from './ErrorBoundary.tsx';

================
File: src/ui/index.ts
================
export * from './components/index';
export * from './pages/index';

================
File: src/ui/pages/HomePage.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import ErrorBoundary from '../components/ErrorBoundary.tsx';
import { GraphExplorer } from '../components/graph/index.ts';
import { ChatInterface } from '../components/chat/index.ts';
import SourceViewer from '../components/graph/SourceViewer.tsx';
import type { KnowledgeGraph } from '../../core/graph/types.ts';
import { IngestionService } from '../../services/ingestion.service.ts';
import { LLMService, type LLMProvider } from '../../ai/llm-service.ts';
import { exportAndDownloadGraph } from '../../lib/export.ts';

interface AppState {
  // Data
  graph: KnowledgeGraph | null;
  fileContents: Map<string, string>;
  
  // UI State
  selectedNodeId: string | null;
  showWelcome: boolean;
  isLoading: boolean;
  showStats: boolean;
  
  // Input State
  githubUrl: string;
  directoryFilter: string;
  fileExtensions: string;
  
  // Processing State
  isProcessing: boolean;
  progress: string;
  error: string;
  
  // Settings
  llmProvider: LLMProvider;
  llmApiKey: string;
  // Azure OpenAI specific settings
  azureOpenAIEndpoint: string;
  azureOpenAIDeploymentName: string;
  azureOpenAIApiVersion: string;
  // GitHub settings
  githubToken: string;
  showSettings: boolean;
}

const initialState: AppState = {
  graph: null,
  fileContents: new Map(),
  selectedNodeId: null,
  showWelcome: true,
  isLoading: false,
  showStats: false,
  githubUrl: '',
  directoryFilter: 'src,lib,components,pages,utils',
  fileExtensions: '.ts,.tsx,.js,.jsx,.py,.java,.cpp,.c,.cs,.php,.rb,.go,.rs,.swift,.kt,.scala,.clj,.hs,.ml,.fs,.elm,.dart,.lua,.r,.m,.sh,.sql,.html,.css,.scss,.less,.vue,.svelte',
  isProcessing: false,
  progress: '',
  error: '',
  llmProvider: (localStorage.getItem('llm_provider') as LLMProvider) || 'openai',
  llmApiKey: localStorage.getItem('llm_api_key') || '',
  azureOpenAIEndpoint: localStorage.getItem('azure_openai_endpoint') || '',
  azureOpenAIDeploymentName: localStorage.getItem('azure_openai_deployment') || '',
  azureOpenAIApiVersion: localStorage.getItem('azure_openai_api_version') || '2024-02-01',
  githubToken: localStorage.getItem('github_token') || '',
  showSettings: false
};

const HomePage: React.FC = () => {
  const [state, setState] = useState<AppState>(initialState);
  const [services] = useState(() => ({
    ingestion: new IngestionService(),
    llm: new LLMService()
  }));

  const updateState = useCallback((updates: Partial<AppState>) => {
    setState(prev => ({ ...prev, ...updates }));
  }, []);

  const handleNodeSelect = (nodeId: string | null) => {
    updateState({ selectedNodeId: nodeId });
  };

  // Save LLM settings to localStorage
  useEffect(() => {
    if (state.llmApiKey) {
      localStorage.setItem('llm_api_key', state.llmApiKey);
    }
    localStorage.setItem('llm_provider', state.llmProvider);
    if (state.azureOpenAIEndpoint) {
      localStorage.setItem('azure_openai_endpoint', state.azureOpenAIEndpoint);
    }
    if (state.azureOpenAIDeploymentName) {
      localStorage.setItem('azure_openai_deployment', state.azureOpenAIDeploymentName);
    }
    if (state.azureOpenAIApiVersion) {
      localStorage.setItem('azure_openai_api_version', state.azureOpenAIApiVersion);
    }
    if (state.githubToken) {
      localStorage.setItem('github_token', state.githubToken);
    }
  }, [state.llmApiKey, state.llmProvider, state.azureOpenAIEndpoint, state.azureOpenAIDeploymentName, state.azureOpenAIApiVersion, state.githubToken]);

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !file.name.endsWith('.zip')) {
      updateState({ error: 'Please select a valid ZIP file' });
      return;
    }

    try {
      updateState({ 
        isProcessing: true, 
        error: '', 
        progress: 'Reading ZIP file...',
        showWelcome: false
      });

      console.log('Starting ZIP processing...', file.name);

      const result = await services.ingestion.processZipFile(file, {
        directoryFilter: state.directoryFilter,
        fileExtensions: state.fileExtensions
      });

      console.log('ZIP processing completed:', {
        nodeCount: result.graph?.nodes?.length || 0,
        relationshipCount: result.graph?.relationships?.length || 0,
        fileCount: result.fileContents?.size || 0
      });

      updateState({
        graph: result.graph,
        fileContents: result.fileContents,
        isProcessing: false,
        progress: '',
        showWelcome: false // Ensure we stay in main interface
      });
    } catch (error) {
      console.error('ZIP processing error:', error);
      updateState({
        error: error instanceof Error ? error.message : 'Failed to process ZIP file',
        isProcessing: false,
        progress: '',
        showWelcome: true // Return to welcome screen on error
      });
    }
  };

  const handleGitHubProcess = async () => {
    if (!state.githubUrl.trim()) {
      updateState({ error: 'Please enter a GitHub repository URL' });
      return;
    }

    try {
      updateState({ 
        isProcessing: true, 
        error: '', 
        progress: 'Fetching repository...',
        showWelcome: false
      });

      console.log('Starting GitHub processing...', state.githubUrl);

      // Create ingestion service with GitHub token if provided
      const ingestionService = new IngestionService(state.githubToken || undefined);

      const result = await ingestionService.processGitHubRepo(state.githubUrl, {
        directoryFilter: state.directoryFilter,
        fileExtensions: state.fileExtensions,
        onProgress: (progress) => {
          console.log('Progress:', progress);
          updateState({ progress });
        }
      });

      console.log('GitHub processing completed:', {
        nodeCount: result.graph?.nodes?.length || 0,
        relationshipCount: result.graph?.relationships?.length || 0,
        fileCount: result.fileContents?.size || 0
      });

      updateState({
        graph: result.graph,
        fileContents: result.fileContents,
        isProcessing: false,
        progress: '',
        showWelcome: false // Ensure we stay in main interface
      });
    } catch (error) {
      console.error('GitHub processing error:', error);
      updateState({
        error: error instanceof Error ? error.message : 'Failed to process repository',
        isProcessing: false,
        progress: '',
        showWelcome: true // Return to welcome screen on error
      });
    }
  };

  const handleNewProject = () => {
    updateState({
      ...initialState,
      showStats: false
    });
  };

  const handleDownloadGraph = () => {
    if (!state.graph) {
      alert('No knowledge graph to download. Please process a repository first.');
      return;
    }

    try {
      const projectName = state.githubUrl 
        ? state.githubUrl.split('/').pop()?.replace('.git', '') || 'repository'
        : 'project';

      exportAndDownloadGraph(
        state.graph,
        { 
          projectName,
          includeTimestamp: true,
          prettyPrint: true,
          includeMetadata: true
        },
        state.fileContents
      );
      
      console.log('Knowledge graph exported successfully');
    } catch (error) {
      console.error('Failed to export graph:', error);
      alert('Failed to export knowledge graph. Please try again.');
    }
  };

  const isApiKeyValid = (() => {
    if (state.llmProvider === 'azure-openai') {
      // For Azure OpenAI, we need to validate all required fields
      return services.llm.validateApiKey(state.llmProvider, state.llmApiKey) &&
             state.azureOpenAIEndpoint.trim() !== '' &&
             state.azureOpenAIDeploymentName.trim() !== '';
    }
    return services.llm.validateApiKey(state.llmProvider, state.llmApiKey);
  })();
  const isGraphValid = state.graph && state.graph.nodes && Array.isArray(state.graph.nodes) && state.graph.relationships && Array.isArray(state.graph.relationships);

  // Warm tone color palette
  const colors = {
    background: '#FDF6E3', // Warm cream
    surface: '#FFFFFF',
    surfaceWarm: '#FEF9F0', // Slightly warm white
    primary: '#D97706', // Warm orange
    primaryLight: '#F59E0B', // Light orange
    secondary: '#92400E', // Dark orange
    accent: '#DC2626', // Warm red
    text: '#451A03', // Dark brown
    textSecondary: '#78350F', // Medium brown
    textMuted: '#A16207', // Light brown
    border: '#FED7AA', // Light orange
    borderLight: '#FEF3C7', // Very light orange
    success: '#059669', // Warm green
    warning: '#D97706', // Orange
    error: '#DC2626' // Red
  };

  // Modern styles with warm theme
  const styles = {
    container: {
      display: 'flex',
      flexDirection: 'column' as const,
      height: '100vh',
      width: '100vw',
      backgroundColor: colors.background,
      fontFamily: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
      overflow: 'hidden'
    },

    // Top navbar (only visible when project is loaded)
    navbar: {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: '12px 24px',
      backgroundColor: colors.surface,
      borderBottom: `1px solid ${colors.borderLight}`,
      boxShadow: '0 1px 3px rgba(0,0,0,0.05)',
      position: 'relative' as const
    },

    navbarContent: {
      display: 'flex',
      alignItems: 'center',
      gap: '16px',
      fontSize: '14px',
      fontWeight: '500',
      color: colors.textSecondary
    },

    navbarButton: {
      padding: '8px 16px',
      backgroundColor: colors.surfaceWarm,
      border: `1px solid ${colors.border}`,
      borderRadius: '8px',
      color: colors.text,
      fontSize: '14px',
      fontWeight: '500',
      cursor: 'pointer',
      transition: 'all 0.2s ease',
      display: 'flex',
      alignItems: 'center',
      gap: '8px'
    },

    // Welcome screen (center overlay)
    welcomeOverlay: {
      position: 'fixed' as const,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: colors.background,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 1000
    },

    welcomeCard: {
      backgroundColor: colors.surface,
      borderRadius: '20px',
      padding: '48px',
      boxShadow: '0 20px 40px rgba(0,0,0,0.1)',
      border: `1px solid ${colors.borderLight}`,
      maxWidth: '600px',
      width: '90%',
      textAlign: 'center' as const
    },

    welcomeTitle: {
      fontSize: '32px',
      fontWeight: '700',
      color: colors.text,
      marginBottom: '16px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '12px'
    },

    welcomeSubtitle: {
      fontSize: '18px',
      color: colors.textSecondary,
      marginBottom: '40px',
      lineHeight: '1.6'
    },

    inputSection: {
      display: 'flex',
      flexDirection: 'column' as const,
      gap: '24px',
      marginBottom: '32px'
    },

    inputGroup: {
      display: 'flex',
      flexDirection: 'column' as const,
      gap: '8px',
      textAlign: 'left' as const
    },

    label: {
      fontSize: '14px',
      fontWeight: '600',
      color: colors.text
    },

    input: {
      padding: '16px',
      border: `2px solid ${colors.border}`,
      borderRadius: '12px',
      fontSize: '16px',
      backgroundColor: colors.surfaceWarm,
      color: colors.text,
      transition: 'all 0.2s ease',
      outline: 'none'
    },

    primaryButton: {
      padding: '16px 32px',
      backgroundColor: colors.primary,
      border: 'none',
      borderRadius: '12px',
      color: 'white',
      fontSize: '16px',
      fontWeight: '600',
      cursor: 'pointer',
      transition: 'all 0.2s ease',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '8px'
    },

    secondaryButton: {
      padding: '12px 24px',
      backgroundColor: colors.surfaceWarm,
      border: `2px solid ${colors.border}`,
      borderRadius: '12px',
      color: colors.text,
      fontSize: '14px',
      fontWeight: '500',
      cursor: 'pointer',
      transition: 'all 0.2s ease'
    },

    orDivider: {
      display: 'flex',
      alignItems: 'center',
      gap: '16px',
      margin: '20px 0',
      color: colors.textMuted,
      fontSize: '14px',
      fontWeight: '500'
    },

    orLine: {
      flex: 1,
      height: '1px',
      backgroundColor: colors.border
    },

    // Main layout (when project is loaded)
    mainLayout: {
      display: 'flex',
      flex: 1,
      overflow: 'hidden'
    },

    // Left side - Knowledge Graph (70% width)
    leftPanel: {
      flex: '0 0 70%',
      backgroundColor: colors.surface,
      borderRight: `1px solid ${colors.borderLight}`,
      overflow: 'hidden'
    },

    // Right side - Chat and Source (30% width)
    rightPanel: {
      flex: '0 0 30%',
      display: 'flex',
      flexDirection: 'column' as const,
      backgroundColor: colors.surfaceWarm
    },

    // Right panel sections
    chatSection: {
      flex: '0 0 60%',
      borderBottom: `1px solid ${colors.borderLight}`,
      overflow: 'hidden'
    },

    sourceSection: {
      flex: '0 0 40%',
      overflow: 'hidden'
    },

    // Error and progress styles
    errorBanner: {
      backgroundColor: '#FEF2F2',
      border: `1px solid #FECACA`,
      color: colors.error,
      padding: '16px',
      borderRadius: '12px',
      margin: '16px 0',
      fontSize: '14px'
    },

    progressBanner: {
      backgroundColor: '#FEF3C7',
      border: `1px solid ${colors.border}`,
      color: colors.secondary,
      padding: '16px',
      borderRadius: '12px',
      margin: '16px 0',
      fontSize: '14px',
      display: 'flex',
      alignItems: 'center',
      gap: '12px'
    },

    spinner: {
      width: '20px',
      height: '20px',
      border: `2px solid ${colors.border}`,
      borderTop: `2px solid ${colors.primary}`,
      borderRadius: '50%',
      animation: 'spin 1s linear infinite'
    }
  };

  const renderWelcomeScreen = () => (
    <div style={styles.welcomeOverlay}>
      <div style={styles.welcomeCard}>
        <div style={styles.welcomeTitle}>
          <span>🔍</span>
          <span>GitNexus</span>
        </div>
        <div style={styles.welcomeSubtitle}>
          Transform your codebase into an interactive knowledge graph
        </div>

        {state.error && (
          <div style={styles.errorBanner}>
            {state.error}
          </div>
        )}

        {state.isProcessing && (
          <div style={styles.progressBanner}>
            <div style={styles.spinner}></div>
            {state.progress}
          </div>
        )}

        <div style={styles.inputSection}>
          <div style={styles.inputGroup}>
            <label style={styles.label}>GitHub Repository URL</label>
            <input
              type="text"
              value={state.githubUrl}
              onChange={(e) => updateState({ githubUrl: e.target.value })}
              placeholder="https://github.com/owner/repo"
              style={styles.input}
              disabled={state.isProcessing}
            />
            
            {/* GitHub Token Input - Optional */}
            <div style={{ marginTop: '12px' }}>
              <label style={{...styles.label, color: colors.textMuted}}>
                GitHub Personal Access Token (Optional)
              </label>
              <input
                type="password"
                value={state.githubToken}
                onChange={(e) => updateState({ githubToken: e.target.value })}
                placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
                style={{
                  ...styles.input,
                  borderColor: colors.borderLight,
                  backgroundColor: colors.surface
                }}
                disabled={state.isProcessing}
              />
              <div style={{ 
                fontSize: '11px', 
                color: colors.textMuted, 
                marginTop: '4px',
                lineHeight: '1.4'
              }}>
                Increases rate limit from 60 to 5,000 requests/hour. 
                <a href="https://github.com/settings/tokens" target="_blank" rel="noopener noreferrer" 
                   style={{ color: colors.primary, textDecoration: 'none', marginLeft: '4px' }}>
                  Generate token
                </a>
              </div>
            </div>
            
            {/* GitHub Token Status */}
            <div style={{
              fontSize: '12px',
              color: state.githubToken ? colors.success : colors.textMuted,
              marginTop: '8px',
              display: 'flex',
              alignItems: 'center',
              gap: '4px'
            }}>
              <span>{state.githubToken ? '🔑' : '⚠️'}</span>
              {state.githubToken 
                ? 'GitHub token configured (5,000 requests/hour)' 
                : 'No GitHub token (60 requests/hour limit)'}
            </div>
            
            <button
              onClick={handleGitHubProcess}
              disabled={state.isProcessing || !state.githubUrl.trim()}
              style={{
                ...styles.primaryButton,
                opacity: state.isProcessing || !state.githubUrl.trim() ? 0.5 : 1,
                marginTop: '16px'
              }}
            >
              <span>📊</span>
              Analyze Repository
            </button>
          </div>

          <div style={styles.orDivider}>
            <div style={styles.orLine}></div>
            <span>OR</span>
            <div style={styles.orLine}></div>
          </div>

          <div style={styles.inputGroup}>
            <label style={styles.label}>Upload ZIP File</label>
            <input
              type="file"
              accept=".zip"
              onChange={handleFileUpload}
              disabled={state.isProcessing}
              style={styles.input}
            />
          </div>
        </div>

        <button
          onClick={() => updateState({ showSettings: true })}
          style={styles.secondaryButton}
        >
          ⚙️ Settings
        </button>
      </div>
    </div>
  );

  const renderMainInterface = () => {
    // Double-check graph validity before rendering
    if (!isGraphValid) {
      console.warn('Attempted to render main interface with invalid graph:', state.graph);
      return renderWelcomeScreen();
    }

    return (
      <>
        {/* Top Navbar */}
        <div style={styles.navbar}>
          <div style={styles.navbarContent}>
            <span>🔍 GitNexus</span>
            <span>•</span>
            <span>{state.graph?.nodes.length || 0} nodes</span>
            <span>•</span>
            <span>{state.graph?.relationships.length || 0} relationships</span>
            <span>•</span>
            <span>{state.fileContents?.size || 0} files</span>
          </div>
          <div style={{ position: 'absolute', right: '24px', display: 'flex', gap: '12px' }}>
            <button
              onClick={() => updateState({ showStats: !state.showStats })}
              style={{
                ...styles.navbarButton,
                backgroundColor: state.showStats ? colors.primary : colors.surfaceWarm,
                color: state.showStats ? '#fff' : colors.text
              }}
            >
              <span>📊</span>
              Stats
            </button>
            <button
              onClick={handleDownloadGraph}
              style={{
                ...styles.navbarButton,
                backgroundColor: state.graph ? colors.primary : colors.border,
                color: state.graph ? '#fff' : colors.textMuted,
                cursor: state.graph ? 'pointer' : 'not-allowed',
                opacity: state.graph ? 1 : 0.6
              }}
              disabled={!state.graph}
            >
              <span>📥</span>
              Download KG
            </button>
            <button
              onClick={handleNewProject}
              style={styles.navbarButton}
            >
              <span>🔄</span>
              New Project
            </button>
          </div>
        </div>

        {/* Statistics Panel */}
        {state.showStats && state.graph && (
          <div style={{
            backgroundColor: colors.surfaceWarm,
            borderBottom: `1px solid ${colors.borderLight}`,
            padding: '16px 24px',
            fontSize: '14px'
          }}>
            <div style={{ 
              display: 'grid', 
              gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', 
              gap: '24px' 
            }}>
              {/* Node Statistics */}
              <div>
                <div style={{ 
                  fontWeight: '600', 
                  color: colors.text, 
                  marginBottom: '8px',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px'
                }}>
                  <span>🔵</span>
                  Node Types
                </div>
                {(() => {
                  const nodeStats: Record<string, number> = {};
                  state.graph.nodes.forEach(node => {
                    nodeStats[node.label] = (nodeStats[node.label] || 0) + 1;
                  });
                  return Object.entries(nodeStats)
                    .sort(([,a], [,b]) => b - a)
                    .map(([type, count]) => (
                      <div key={type} style={{ 
                        display: 'flex', 
                        justifyContent: 'space-between',
                        color: colors.textSecondary,
                        marginBottom: '4px'
                      }}>
                        <span>{type}:</span>
                        <span style={{ fontWeight: '500' }}>{count}</span>
                      </div>
                    ));
                })()}
              </div>

              {/* Relationship Statistics */}
              <div>
                <div style={{ 
                  fontWeight: '600', 
                  color: colors.text, 
                  marginBottom: '8px',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px'
                }}>
                  <span>🔗</span>
                  Relationship Types
                </div>
                {(() => {
                  const relationshipStats: Record<string, number> = {};
                  state.graph.relationships.forEach(rel => {
                    relationshipStats[rel.type] = (relationshipStats[rel.type] || 0) + 1;
                  });
                  return Object.entries(relationshipStats)
                    .sort(([,a], [,b]) => b - a)
                    .map(([type, count]) => (
                      <div key={type} style={{ 
                        display: 'flex', 
                        justifyContent: 'space-between',
                        color: colors.textSecondary,
                        marginBottom: '4px'
                      }}>
                        <span>{type}:</span>
                        <span style={{ fontWeight: '500' }}>{count}</span>
                      </div>
                    ));
                })()}
              </div>

              {/* File Statistics */}
              <div>
                <div style={{ 
                  fontWeight: '600', 
                  color: colors.text, 
                  marginBottom: '8px',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px'
                }}>
                  <span>📁</span>
                  File Info
                </div>
                <div style={{ 
                  display: 'flex', 
                  justifyContent: 'space-between',
                  color: colors.textSecondary,
                  marginBottom: '4px'
                }}>
                  <span>Total Files:</span>
                  <span style={{ fontWeight: '500' }}>{state.fileContents.size}</span>
                </div>
                <div style={{ 
                  display: 'flex', 
                  justifyContent: 'space-between',
                  color: colors.textSecondary,
                  marginBottom: '4px'
                }}>
                  <span>Source Files:</span>
                  <span style={{ fontWeight: '500' }}>
                    {Array.from(state.fileContents.keys()).filter(path => 
                      path.endsWith('.py') || path.endsWith('.js') || path.endsWith('.ts') || 
                      path.endsWith('.tsx') || path.endsWith('.jsx')
                    ).length}
                  </span>
                </div>
                <div style={{ 
                  display: 'flex', 
                  justifyContent: 'space-between',
                  color: colors.textSecondary,
                  marginBottom: '4px'
                }}>
                  <span>Repository:</span>
                  <span style={{ 
                    fontWeight: '500',
                    maxWidth: '120px',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap'
                  }}>
                    {state.githubUrl ? state.githubUrl.split('/').slice(-2).join('/') : 'ZIP Upload'}
                  </span>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Main Layout */}
        <div style={styles.mainLayout}>
          {/* Left Panel - Knowledge Graph */}
          <div style={styles.leftPanel}>
            <GraphExplorer
              graph={state.graph!}
              isLoading={state.isLoading}
              onNodeSelect={handleNodeSelect}
            />
          </div>

          {/* Right Panel - Chat and Source */}
          <div style={styles.rightPanel}>
            {/* Chat Section */}
            <div style={styles.chatSection}>
              {isApiKeyValid ? (
                <ChatInterface
                  graph={state.graph!}
                  fileContents={state.fileContents}
                  style={{ height: '100%' }}
                />
              ) : (
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  height: '100%',
                  flexDirection: 'column',
                  gap: '16px',
                  padding: '24px',
                  textAlign: 'center',
                  color: colors.textMuted
                }}>
                  <div style={{ fontSize: '48px', opacity: 0.3 }}>🔑</div>
                  <div>Configure your API key to use the chat interface</div>
                  <button
                    onClick={() => updateState({ showSettings: true })}
                    style={styles.secondaryButton}
                  >
                    Open Settings
                  </button>
                </div>
              )}
            </div>

            {/* Source Section */}
            <div style={styles.sourceSection}>
              <SourceViewer
                graph={state.graph!}
                selectedNodeId={state.selectedNodeId}
                fileContents={state.fileContents}
                style={{ height: '100%' }}
              />
            </div>
          </div>
        </div>
      </>
    );
  };

  return (
    <ErrorBoundary>
      <div style={styles.container}>
        <style>{`
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          
          #root {
            height: 100vh;
            width: 100vw;
          }
          
          input:focus, textarea:focus {
            border-color: ${colors.primary} !important;
            box-shadow: 0 0 0 3px ${colors.primary}20 !important;
          }
          
          button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          }
          
          button:active:not(:disabled) {
            transform: translateY(0);
          }
        `}</style>

        {state.showWelcome || !isGraphValid ? renderWelcomeScreen() : renderMainInterface()}

        {/* Settings Modal */}
        {state.showSettings && (
          <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'rgba(0,0,0,0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 2000
          }}>
            <div style={{
              backgroundColor: colors.surface,
              borderRadius: '16px',
              padding: '32px',
              maxWidth: '600px',
              width: '90%',
              maxHeight: '80vh',
              overflow: 'auto'
            }}>
              <h2 style={{ color: colors.text, marginBottom: '24px', fontSize: '24px', fontWeight: '700' }}>
                ⚙️ Settings
              </h2>
              
              {/* GitHub Token Section */}
              <div style={{
                padding: '20px',
                borderRadius: '12px',
                backgroundColor: colors.surfaceWarm,
                border: `1px solid ${colors.borderLight}`,
                marginBottom: '24px'
              }}>
                <h3 style={{ color: colors.text, marginBottom: '16px', fontSize: '18px', fontWeight: '600' }}>
                  🔑 GitHub Configuration
                </h3>
                
                <div style={styles.inputGroup}>
                  <label style={styles.label}>
                    GitHub Personal Access Token (Optional)
                  </label>
                  <input
                    type="password"
                    value={state.githubToken}
                    onChange={(e) => updateState({ githubToken: e.target.value })}
                    placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
                    style={styles.input}
                  />
                  <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                    Increases rate limit from 60 to 5,000 requests/hour. Generate at: 
                    <a href="https://github.com/settings/tokens" target="_blank" rel="noopener noreferrer" 
                       style={{ color: colors.primary, textDecoration: 'none', marginLeft: '4px' }}>
                      github.com/settings/tokens
                    </a>
                  </div>
                </div>
              </div>

              {/* LLM Configuration Section */}
              <div style={{
                padding: '20px',
                borderRadius: '12px',
                backgroundColor: colors.surfaceWarm,
                border: `1px solid ${colors.borderLight}`
              }}>
                <h3 style={{ color: colors.text, marginBottom: '16px', fontSize: '18px', fontWeight: '600' }}>
                  🤖 LLM Configuration
                </h3>
              
              {/* Provider Selection */}
              <div style={styles.inputGroup}>
                <label style={styles.label}>LLM Provider</label>
                <select
                  value={state.llmProvider}
                  onChange={(e) => updateState({ llmProvider: e.target.value as LLMProvider })}
                  style={{
                    ...styles.input,
                    cursor: 'pointer'
                  }}
                >
                  <option value="openai">OpenAI</option>
                  <option value="azure-openai">Azure OpenAI</option>
                  <option value="anthropic">Anthropic</option>
                  <option value="gemini">Google Gemini</option>
                </select>
              </div>

              {/* API Key */}
              <div style={styles.inputGroup}>
                <label style={styles.label}>
                  {state.llmProvider === 'azure-openai' ? 'Azure OpenAI API Key' : 
                   state.llmProvider === 'anthropic' ? 'Anthropic API Key' :
                   state.llmProvider === 'gemini' ? 'Google API Key' : 'OpenAI API Key'}
                </label>
                <input
                  type="password"
                  value={state.llmApiKey}
                  onChange={(e) => updateState({ llmApiKey: e.target.value })}
                  placeholder={
                    state.llmProvider === 'azure-openai' ? 'Your Azure OpenAI key...' :
                    state.llmProvider === 'anthropic' ? 'sk-ant-...' :
                    state.llmProvider === 'gemini' ? 'Your Google API key...' : 'sk-...'
                  }
                  style={styles.input}
                />
              </div>

              {/* Azure OpenAI Specific Fields */}
              {state.llmProvider === 'azure-openai' && (
                <>
                  <div style={styles.inputGroup}>
                    <label style={styles.label}>Azure OpenAI Endpoint</label>
                    <input
                      type="text"
                      value={state.azureOpenAIEndpoint}
                      onChange={(e) => updateState({ azureOpenAIEndpoint: e.target.value })}
                      placeholder="https://your-resource.openai.azure.com"
                      style={styles.input}
                    />
                    <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                      Your Azure OpenAI resource endpoint
                    </div>
                  </div>

                  <div style={styles.inputGroup}>
                    <label style={styles.label}>Deployment Name</label>
                    <input
                      type="text"
                      value={state.azureOpenAIDeploymentName}
                      onChange={(e) => updateState({ azureOpenAIDeploymentName: e.target.value })}
                      placeholder="gpt-4o-mini"
                      style={styles.input}
                    />
                    <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                      The deployment name you created in Azure OpenAI Studio
                    </div>
                  </div>

                  <div style={styles.inputGroup}>
                    <label style={styles.label}>API Version</label>
                    <input
                      type="text"
                      value={state.azureOpenAIApiVersion}
                      onChange={(e) => updateState({ azureOpenAIApiVersion: e.target.value })}
                      placeholder="2024-02-01"
                      style={styles.input}
                    />
                    <div style={{ fontSize: '12px', color: colors.textMuted, marginTop: '4px' }}>
                      Azure OpenAI API version (e.g., 2024-02-01, 2025-01-01-preview)
                    </div>
                  </div>
                </>
              )}

              {/* Configuration Status */}
              <div style={{
                padding: '16px',
                borderRadius: '8px',
                backgroundColor: isApiKeyValid ? '#F0F9F0' : '#FFF5F5',
                border: `1px solid ${isApiKeyValid ? '#C6F6C6' : '#FED7D7'}`,
                marginTop: '16px'
              }}>
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  fontSize: '14px',
                  fontWeight: '500',
                  color: isApiKeyValid ? '#2F855A' : '#C53030'
                }}>
                  <span>{isApiKeyValid ? '✅' : '❌'}</span>
                  {isApiKeyValid ? 'Configuration Valid' : 'Configuration Invalid'}
                </div>
                {!isApiKeyValid && (
                  <div style={{ fontSize: '12px', color: '#C53030', marginTop: '4px' }}>
                    {state.llmProvider === 'azure-openai' 
                      ? 'Please provide API key, endpoint, and deployment name'
                      : 'Please provide a valid API key'}
                  </div>
                )}
              </div>

              {/* Provider Information */}
              <div style={{
                padding: '16px',
                borderRadius: '8px',
                backgroundColor: colors.background,
                border: `1px solid ${colors.borderLight}`,
                marginTop: '16px'
              }}>
                <div style={{ fontSize: '14px', fontWeight: '600', color: colors.text, marginBottom: '8px' }}>
                  📋 Provider Information
                </div>
                <div style={{ fontSize: '12px', color: colors.textMuted, lineHeight: '1.5' }}>
                  {state.llmProvider === 'openai' && 'Direct OpenAI API. Get your API key from platform.openai.com'}
                  {state.llmProvider === 'azure-openai' && 'Azure OpenAI Service. Requires Azure subscription and deployed model.'}
                  {state.llmProvider === 'anthropic' && 'Anthropic Claude API. Get your API key from console.anthropic.com'}
                  {state.llmProvider === 'gemini' && 'Google Gemini API. Get your API key from aistudio.google.com'}
                </div>
              </div>
              </div>

              <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>
                <button
                  onClick={() => {
                    // Save settings to localStorage
                    if (state.githubToken) {
                      localStorage.setItem('github_token', state.githubToken);
                    } else {
                      localStorage.removeItem('github_token');
                    }
                    localStorage.setItem('llm_provider', state.llmProvider);
                    localStorage.setItem('llm_api_key', state.llmApiKey);
                    if (state.llmProvider === 'azure-openai') {
                      localStorage.setItem('azure_openai_endpoint', state.azureOpenAIEndpoint);
                      localStorage.setItem('azure_openai_deployment', state.azureOpenAIDeploymentName);
                      localStorage.setItem('azure_openai_api_version', state.azureOpenAIApiVersion);
                    }
                    updateState({ showSettings: false });
                  }}
                  style={styles.primaryButton}
                >
                  💾 Save Settings
                </button>
                <button
                  onClick={() => updateState({ showSettings: false })}
                  style={styles.secondaryButton}
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </ErrorBoundary>
  );
};

export default HomePage;

================
File: src/ui/pages/index.ts
================
export { default as HomePage } from './HomePage.tsx';

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: src/workers/ingestion.worker.ts
================
import * as Comlink from 'comlink';
import { GraphPipeline, type PipelineInput } from '../core/ingestion/pipeline.ts';
import type { KnowledgeGraph } from '../core/graph/types.ts';

export interface IngestionProgress {
  phase: 'structure' | 'parsing' | 'calls' | 'complete';
  message: string;
  progress: number;
  timestamp: number;
}

export interface IngestionResult {
  success: boolean;
  graph?: KnowledgeGraph;
  error?: string;
  stats?: {
    nodeStats: Record<string, number>;
    relationshipStats: Record<string, number>;
    callStats: { totalCalls: number; callTypes: Record<string, number> };
  };
  duration: number;
}

export class IngestionWorker {
  private pipeline: GraphPipeline;
  private progressCallback?: (progress: IngestionProgress) => void;

  constructor() {
    this.pipeline = new GraphPipeline();
  }

  public setProgressCallback(callback: (progress: IngestionProgress) => void): void {
    this.progressCallback = callback;
  }

  public async processRepository(input: PipelineInput): Promise<IngestionResult> {
    const startTime = Date.now();
    
    try {
      console.log('IngestionWorker: Starting processing with', input.filePaths.length, 'files');
      
      // Memory optimization: Create a copy of file contents and clear originals gradually
      const fileContentsMap = new Map(input.fileContents);
      
      // Initialize pipeline
      if (!this.pipeline) {
        this.pipeline = new GraphPipeline();
      }
      
      // Progress tracking
      let currentProgress = 0;
      const totalSteps = 3; // structure, parsing, calls
      
      const updateProgress = (phase: IngestionProgress['phase'], message: string, stepProgress: number) => {
        const overallProgress = (currentProgress / totalSteps) * 100 + (stepProgress / totalSteps);
        if (this.progressCallback) {
          this.progressCallback({
            phase,
            message,
            progress: Math.min(overallProgress, 100),
            timestamp: Date.now()
          });
        }
      };

      // Run the pipeline with memory optimization
      updateProgress('structure', 'Analyzing project structure...', 0);
      const graph = await this.pipeline.run({
        ...input,
        fileContents: fileContentsMap
      });
      
      // Clear file contents to free memory after processing
      fileContentsMap.clear();
      
      const duration = Date.now() - startTime;
      
      console.log('IngestionWorker: Processing completed successfully');
      console.log(`Graph contains ${graph.nodes.length} nodes and ${graph.relationships.length} relationships`);
      
      // Calculate statistics
      const nodeStats: Record<string, number> = {};
      const relationshipStats: Record<string, number> = {};
      
      graph.nodes.forEach(node => {
        nodeStats[node.label] = (nodeStats[node.label] || 0) + 1;
      });
      
      graph.relationships.forEach(rel => {
        relationshipStats[rel.type] = (relationshipStats[rel.type] || 0) + 1;
      });

      return {
        success: true,
        graph,
        stats: {
          nodeStats,
          relationshipStats,
          callStats: { totalCalls: 0, callTypes: {} }
        },
        duration
      };
    } catch (error) {
      console.error('IngestionWorker: Processing failed:', error);
      
      const duration = Date.now() - startTime;
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred during processing',
        duration
      };
    }
  }

  public async processFiles(
    projectName: string,
    files: { path: string; content: string }[]
  ): Promise<IngestionResult> {
    const fileContents = new Map<string, string>();
    const filePaths: string[] = [];
    
    for (const file of files) {
      filePaths.push(file.path);
      fileContents.set(file.path, file.content);
    }
    
    const input: PipelineInput = {
      projectRoot: '/',
      projectName,
      filePaths,
      fileContents
    };
    
    return this.processRepository(input);
  }

  public async validateRepository(input: PipelineInput): Promise<{ valid: boolean; errors: string[] }> {
    const errors: string[] = [];
    
    try {
      this.validateInput(input);
      
      // Additional validation checks
      if (input.filePaths.length === 0) {
        errors.push('No files provided for processing');
      }
      
      if (input.fileContents.size === 0) {
        errors.push('No file contents provided');
      }
      
      // Check for source files (Python, JavaScript, TypeScript)
      const sourceFiles = input.filePaths.filter(path => 
        path.endsWith('.py') || 
        path.endsWith('.js') || 
        path.endsWith('.jsx') || 
        path.endsWith('.ts') || 
        path.endsWith('.tsx')
      );
      if (sourceFiles.length === 0) {
        errors.push('No source files found in the repository (Python, JavaScript, or TypeScript)');
      }
      
      // Validate file contents exist
      for (const filePath of input.filePaths) {
        if (!input.fileContents.has(filePath)) {
          errors.push(`Missing content for file: ${filePath}`);
        }
      }
      
      return {
        valid: errors.length === 0,
        errors
      };
      
    } catch (error) {
      errors.push(error instanceof Error ? error.message : 'Validation failed');
      return {
        valid: false,
        errors
      };
    }
  }

  public getWorkerInfo(): { version: string; capabilities: string[] } {
    return {
      version: '1.0.0',
      capabilities: [
        'python-parsing',
        'javascript-parsing',
        'typescript-parsing',
        'tsx-parsing',
        'structure-analysis',
        'call-resolution',
        'ast-caching',
        'progress-reporting',
        'config-file-parsing',
        'import-resolution'
      ]
    };
  }

  private validateInput(input: PipelineInput): void {
    if (!input.projectName || input.projectName.trim().length === 0) {
      throw new Error('Project name is required');
    }
    
    if (!input.projectRoot || input.projectRoot.trim().length === 0) {
      throw new Error('Project root is required');
    }
    
    if (!Array.isArray(input.filePaths)) {
      throw new Error('File paths must be an array');
    }
    
    if (!(input.fileContents instanceof Map)) {
      throw new Error('File contents must be a Map');
    }
  }

  public terminate(): void {
    // Cleanup resources if needed
    console.log('Ingestion worker terminated');
  }
}

// Expose the worker class via Comlink
const worker = new IngestionWorker();
Comlink.expose(worker);

================
File: STRUCTURE_FIX_SUMMARY.md
================
# 🔧 GitNexus Structure Discovery Fix - Complete Architecture Overhaul

## 🚨 **Critical Flaw Identified and Fixed**

### **The Problem**
The original GitNexus architecture had a **fatal flaw** in repository structure discovery:

- **Flawed Logic**: `StructureProcessor` inferred directory existence from filtered file paths
- **Critical Bug**: Empty directories or directories containing only filtered-out files were **completely missing** from the knowledge graph
- **Result**: Incomplete and inaccurate codebase representation

### **Root Cause Analysis**
```
❌ OLD BROKEN FLOW:
GitHub/ZIP Service → Filter Files → Pass Filtered Paths → Infer Structure
                     ↑ FILTERING HERE BREAKS STRUCTURE DISCOVERY
```

**The Fundamental Issue**: Filtering happened **before** structure discovery, causing the `StructureProcessor` to never see paths for directories that contained only filtered-out files.

## 🏗️ **The New Robust Architecture**

### **Core Principle**
> **Discover Complete Structure First, Filter During Parsing**

```
✅ NEW ROBUST FLOW:
GitHub/ZIP Service → Discover ALL Paths → Build Complete Structure → Filter During Parsing
                     ↑ NO FILTERING YET    ↑ COMPLETE STRUCTURE   ↑ FILTERING HERE
```

### **Architectural Changes**

## **1. Data Acquisition Services (Complete Structure Discovery)**

### **GitHub Service (`src/services/github.ts`)**
- ✅ **New Method**: `getCompleteRepositoryStructure()` 
- ✅ **Returns**: `CompleteRepositoryStructure` with `allPaths` + `fileContents`
- ✅ **Behavior**: Discovers **every file and directory** in the repository
- ✅ **No Filtering**: Collects all content regardless of user filters

### **ZIP Service (`src/services/zip.ts`)**
- ✅ **New Method**: `extractCompleteStructure()`
- ✅ **Returns**: `CompleteZipStructure` with `allPaths` + `fileContents`  
- ✅ **Enhanced Logic**: Explicitly tracks directories and intermediate paths
- ✅ **Path Normalization**: Handles common top-level folder removal

## **2. Ingestion Service (Pipeline Orchestration)**

### **Updated Methods (`src/services/ingestion.service.ts`)**
- ✅ **`processGitHubRepo()`**: Uses complete structure discovery
- ✅ **`processZipFile()`**: Uses complete structure discovery
- ✅ **No Filtering**: Passes **all discovered paths** to pipeline
- ✅ **Clean Architecture**: Filtering responsibility moved to `ParsingProcessor`

## **3. Structure Processor (Direct Path Processing)**

### **Complete Rewrite (`src/core/ingestion/structure-processor.ts`)**
```typescript
// OLD: Infer structure from filtered file paths
const folderPaths = this.extractFolderPaths(filePaths); // ❌ BROKEN

// NEW: Process complete discovered structure directly  
const { directories, files } = this.categorizePaths(filePaths); // ✅ ROBUST
```

#### **Key Improvements**:
- ✅ **Direct Processing**: No inference, direct path categorization
- ✅ **Complete Structure**: Processes **all** discovered paths
- ✅ **Smart Categorization**: Distinguishes files from directories algorithmically
- ✅ **Intermediate Directories**: Automatically adds missing intermediate paths
- ✅ **Perfect Mirror**: KG structure exactly matches repository file system

## **4. Parsing Processor (Filtering During Parsing)**

### **New Filtering Logic (`src/core/ingestion/parsing-processor.ts`)**
```typescript
// NEW: Filtering happens here, during parsing
private applyFiltering(
  allPaths: string[], 
  fileContents: Map<string, string>, 
  options?: { directoryFilter?: string; fileExtensions?: string }
): string[]
```

#### **Filtering Strategy**:
- ✅ **Input**: Receives **all** paths from structure discovery
- ✅ **Apply Filters**: Directory and extension filters applied here
- ✅ **Parse Only Filtered**: Only processes files that pass filters
- ✅ **Structure Intact**: All directories remain in graph, regardless of filtering

## **5. Pipeline Integration**

### **Updated Pipeline (`src/core/ingestion/pipeline.ts`)**
- ✅ **4-Pass Architecture**: Maintains existing pass structure
- ✅ **Options Passing**: Filtering options passed to `ParsingProcessor`
- ✅ **Complete Structure**: `StructureProcessor` gets all paths
- ✅ **Filtered Parsing**: `ParsingProcessor` applies user filters

## 📊 **Before vs After Comparison**

| Aspect | ❌ **Before (Broken)** | ✅ **After (Robust)** |
|--------|------------------------|----------------------|
| **Structure Discovery** | Inferred from filtered files | Direct discovery of all paths |
| **Empty Directories** | Missing from KG | Present in KG |
| **Filtered Directories** | Missing if all files filtered | Present in KG |
| **Filtering Location** | Before structure discovery | During parsing phase |
| **KG Completeness** | Incomplete, inaccurate | Complete, accurate mirror |
| **Architecture** | Monolithic, coupled | Decoupled, robust |

## 🎯 **Results and Benefits**

### **Immediate Fixes**
1. **✅ Empty Directories**: Now appear in knowledge graph
2. **✅ Filtered Directories**: Directories with only filtered files now appear  
3. **✅ Complete Structure**: KG is a perfect mirror of repository structure
4. **✅ Accurate Representation**: No missing parts of codebase

### **Architectural Improvements**
1. **🔧 Separation of Concerns**: Structure discovery ≠ Content filtering
2. **🔧 Robust Design**: No inference, direct discovery
3. **🔧 Maintainable**: Clear responsibility boundaries
4. **🔧 Extensible**: Easy to add new file types or filtering logic

### **User Experience**
1. **📈 Accurate Graphs**: Users see complete repository structure
2. **📈 Better Navigation**: All directories visible for exploration  
3. **📈 Consistent Results**: Same structure regardless of filter settings
4. **📈 Trust**: KG accurately represents their codebase

## 🔍 **Technical Implementation Details**

### **Path Categorization Algorithm**
```typescript
// Smart algorithm to distinguish files from directories
const isDirectory = allPaths.some(otherPath => 
  otherPath !== path && otherPath.startsWith(path + '/')
);
```

### **Intermediate Directory Discovery**
```typescript
// Automatically discover missing intermediate directories
for (let i = 1; i < parts.length; i++) {
  const intermediatePath = parts.slice(0, i).join('/');
  if (intermediatePath && !pathSet.has(intermediatePath)) {
    allIntermediateDirs.add(intermediatePath);
  }
}
```

### **Filtering During Parsing**
```typescript
// Apply user filters only during parsing phase
if (options.directoryFilter?.trim()) {
  filesToProcess = filesToProcess.filter(path => 
    dirPatterns.some(pattern => path.toLowerCase().includes(pattern))
  );
}
```

## 🚀 **Deployment Status**

- ✅ **Build Status**: All components compile successfully
- ✅ **Integration**: Complete end-to-end pipeline updated
- ✅ **Testing Ready**: Architecture ready for validation
- ✅ **Backward Compatible**: Existing functionality preserved
- ✅ **Performance**: Optimized with batching and memory management

## 🎉 **Conclusion**

This architectural overhaul transforms GitNexus from a **flawed, incomplete** structure discovery system into a **robust, accurate** repository analysis tool. 

**The critical flaw is now fixed**: GitNexus will discover and represent the **complete** repository structure, ensuring users get an accurate and comprehensive knowledge graph of their codebase.

**Key Success Metric**: The knowledge graph structure is now a **perfect mirror** of the actual repository file system, regardless of user filtering preferences.

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

================
File: tsconfig.app.tsbuildinfo
================
{"root":["./src/app.tsx","./src/main.tsx","./src/vite-env.d.ts","./src/ai/cypher-generator.ts","./src/ai/index.ts","./src/ai/langchain-orchestrator.ts","./src/ai/llm-service.ts","./src/ai/orchestrator.ts","./src/core/graph/query-engine.ts","./src/core/graph/query.ts","./src/core/graph/trie.ts","./src/core/graph/types.ts","./src/core/ingestion/call-processor.ts","./src/core/ingestion/import-processor.ts","./src/core/ingestion/parsing-processor.ts","./src/core/ingestion/pipeline.ts","./src/core/ingestion/structure-processor.ts","./src/core/tree-sitter/parser-loader.ts","./src/lib/export.ts","./src/lib/polyfills.ts","./src/lib/preload.ts","./src/lib/utils.ts","./src/lib/workerutils.ts","./src/services/github.ts","./src/services/ingestion.service.ts","./src/services/zip.ts","./src/ui/index.ts","./src/ui/components/errorboundary.tsx","./src/ui/components/index.ts","./src/ui/components/chat/chatinterface.tsx","./src/ui/components/chat/codeassistant.tsx","./src/ui/components/chat/index.ts","./src/ui/components/graph/graphexplorer.tsx","./src/ui/components/graph/sourceviewer.tsx","./src/ui/components/graph/visualization.tsx","./src/ui/components/graph/index.ts","./src/ui/pages/homepage.tsx","./src/ui/pages/index.ts","./src/workers/ingestion.worker.ts"],"version":"5.8.3"}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

================
File: tsconfig.node.tsbuildinfo
================
{"root":["./vite.config.ts"],"version":"5.8.3"}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  worker: {
    format: 'es'
  },
  assetsInclude: ['**/*.wasm'],
  server: {
    fs: {
      allow: ['..']
    },
    headers: {
      'Cross-Origin-Embedder-Policy': 'require-corp',
      'Cross-Origin-Opener-Policy': 'same-origin'
    },
    hmr: {
      overlay: false
    }
  },
  build: {
    target: 'esnext',
    assetsInlineLimit: 0,
    commonjsOptions: {
      include: [/node_modules/],
      transformMixedEsModules: true,
      defaultIsModuleExports: true
    }
  },
  define: {
    global: 'globalThis',
  },
  resolve: {
    alias: {
      'node:async_hooks': path.resolve(__dirname, 'src/lib/polyfills.ts'),
      'async_hooks': path.resolve(__dirname, 'src/lib/polyfills.ts')
    }
  },
  optimizeDeps: {
    exclude: ['@langchain/langgraph'],
    include: [
      'camelcase', 
      'decamelize', 
      'ansi-styles',
      'chalk',
      'supports-color',
      'p-queue',
      'p-retry',
      'semver',
      'base64-js',
      'num-sort',
      'binary-search',
      'js-tiktoken',
      'uuid',
      'ms',
      'retry',
      'p-timeout',
      'p-finally',
      'eventemitter3',
      'web-tree-sitter',
      'comlink'
    ],
    force: true,
    holdUntilCrawlEnd: true
  }
})
